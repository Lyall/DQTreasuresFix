#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DarwinGame

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "DarwinGame_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Foliage_classes.hpp"
#include "Slate_structs.hpp"
#include "CriWareRuntime_structs.hpp"


namespace SDK
{

// Class DarwinGame.DarwinUserWidget
// 0x0258 (0x0490 - 0x0238)
class UDarwinUserWidget : public UUserWidget
{
public:
	uint8                                         Pad_238[0x88];                                     // 0x0238(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	EOpenState                                    OpenState;                                         // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EWidgetDefaultAnimation, class FName>    DefaultAnimationNames;                             // 0x02C8(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         DefaultZOrder;                                     // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultZOrderID;                                   // 0x031C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHandlingInput;                                  // 0x0324(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUI3D;                                           // 0x0325(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUse3DComponent;                                 // 0x0326(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_327[0x1];                                      // 0x0327(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocalZOrder;                                       // 0x0328(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HideCount;                                         // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KeyRepeatIntervalFirst;                            // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KeyRepeatIntervalAfterSecond;                      // 0x0334(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x158];                                    // 0x0338(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInputEventFunc(const class FString& EventName, int32 InPriority);
	void BeginUse();
	void Close();
	void CloseAnimationEnd();
	void CloseIfNotWillClose();
	void CloseImmediate();
	void EndUse();
	bool Input_Button_Down();
	bool Input_Button_Left();
	bool Input_Button_Right();
	bool Input_Button_Up();
	bool Input_Cancel();
	bool Input_Decide();
	bool Input_Down();
	bool Input_L();
	bool Input_Left();
	bool Input_Left_Analog_Down();
	bool Input_Left_Analog_Left();
	bool Input_Left_Analog_Right();
	bool Input_Left_Analog_Up();
	bool Input_Minus();
	bool Input_Mouse_Wheel_Down();
	bool Input_Mouse_Wheel_Up();
	bool Input_PC_R();
	bool Input_PC_T();
	bool Input_Plus();
	bool Input_R();
	bool Input_Right();
	bool Input_Right_Analog_Down();
	bool Input_Right_Analog_Left();
	bool Input_Right_Analog_Right();
	bool Input_Right_Analog_Up();
	bool Input_RMB();
	bool Input_Tab();
	bool Input_Up();
	bool Input_X();
	bool Input_Y();
	bool Input_ZL();
	bool Input_ZR();
	void InputEventFunc(float DeltaTime, bool GamePaused, const struct FKeyInput& KeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Reply);
	void InputName(class FName ID, class FName Name_0, const TDelegate<void(class FName EnteredName)>& EnteredNameEvent);
	bool IsRepeatPressedWIthSetting(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	bool IsUse();
	void OnCloseAnimationEnd();
	void OnOpenAnimationEnd();
	void open();
	void OpenAnimationEnd();
	void OpenIfNotWillOpen();
	void OpenImmediate();
	void PlayOneShot(float WaitTime);
	void PlayOneShotAnimation();
	void RemoveRegisteredInputEvent();
	void Resume();
	void ResumeAnimationEnd();
	void ResumeImmediate();
	void SetBrushFromButtonTexture(class UImage* TargetImage, EAxisMappingType Button);
	void SetHandlingInput(bool InIsHandlingInput);
	void SetHideCount(float Count);
	void SetProgressBar(class UProgressBar* Target, int32 Numerator, int32 Denominator);
	void Suspend();
	void SuspendAnimationEnd();
	void SuspendImmediate();
	void Update(float DeltaTime);
	void UpdateAtPostUpdateWork(float DeltaTime);

	bool CanAction(EWidgetAction Action) const;
	class UDarwinUserWidget* GetDarwinUserWidgetFromName(class FName InName) const;
	class UImage* GetImageFromName(class FName InName) const;
	EOpenState GetOpenState() const;
	class UTextBlock* GetTextBlockFromName(class FName InName) const;
	bool IsJustPressedWithLeftAnalog(EAxisMappingType Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinUserWidget">();
	}
	static class UDarwinUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinUserWidget>();
	}
};
static_assert(alignof(UDarwinUserWidget) == 0x000008, "Wrong alignment on UDarwinUserWidget");
static_assert(sizeof(UDarwinUserWidget) == 0x000490, "Wrong size on UDarwinUserWidget");
static_assert(offsetof(UDarwinUserWidget, OpenState) == 0x0002C0, "Member 'UDarwinUserWidget::OpenState' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, DefaultAnimationNames) == 0x0002C8, "Member 'UDarwinUserWidget::DefaultAnimationNames' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, DefaultZOrder) == 0x000318, "Member 'UDarwinUserWidget::DefaultZOrder' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, DefaultZOrderID) == 0x00031C, "Member 'UDarwinUserWidget::DefaultZOrderID' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, bIsHandlingInput) == 0x000324, "Member 'UDarwinUserWidget::bIsHandlingInput' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, bIsUI3D) == 0x000325, "Member 'UDarwinUserWidget::bIsUI3D' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, bIsUse3DComponent) == 0x000326, "Member 'UDarwinUserWidget::bIsUse3DComponent' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, LocalZOrder) == 0x000328, "Member 'UDarwinUserWidget::LocalZOrder' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, HideCount) == 0x00032C, "Member 'UDarwinUserWidget::HideCount' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, KeyRepeatIntervalFirst) == 0x000330, "Member 'UDarwinUserWidget::KeyRepeatIntervalFirst' has a wrong offset!");
static_assert(offsetof(UDarwinUserWidget, KeyRepeatIntervalAfterSecond) == 0x000334, "Member 'UDarwinUserWidget::KeyRepeatIntervalAfterSecond' has a wrong offset!");

// Class DarwinGame.UI3DBase
// 0x0120 (0x05B0 - 0x0490)
#pragma pack(push, 0x1)
class alignas(0x10) UUI3DBase : public UDarwinUserWidget
{
public:
	struct FVector                                DefaultOffsetPosition;                             // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseHideByObject;                                 // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               HideByTraceType;                                   // 0x04A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AA[0x2];                                      // 0x04AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ViewPortPos;                                       // 0x04AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x04B4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceOfInvisible;                               // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInScreenTop;                                    // 0x04C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultScreenTopPos;                               // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUpdateAnimIfOutWindow;                          // 0x04C8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x3];                                      // 0x04C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceOfMinSmall;                                // 0x04CC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceOfStartSmall;                              // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSmallScale;                                     // 0x04D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSmallScale;                                     // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DC[0xCC];                                     // 0x04DC(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAttachSocketName(class FName SocketName);
	void SetLocation(const struct FVector& InLocaion);
	void SetTargetActor(class AActor* InActor);
	void Update3DTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI3DBase">();
	}
	static class UUI3DBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI3DBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUI3DBase) == 0x000010, "Wrong alignment on UUI3DBase");
static_assert(sizeof(UUI3DBase) == 0x0005B0, "Wrong size on UUI3DBase");
static_assert(offsetof(UUI3DBase, DefaultOffsetPosition) == 0x000490, "Member 'UUI3DBase::DefaultOffsetPosition' has a wrong offset!");
static_assert(offsetof(UUI3DBase, TargetActor) == 0x0004A0, "Member 'UUI3DBase::TargetActor' has a wrong offset!");
static_assert(offsetof(UUI3DBase, IsUseHideByObject) == 0x0004A8, "Member 'UUI3DBase::IsUseHideByObject' has a wrong offset!");
static_assert(offsetof(UUI3DBase, HideByTraceType) == 0x0004A9, "Member 'UUI3DBase::HideByTraceType' has a wrong offset!");
static_assert(offsetof(UUI3DBase, ViewPortPos) == 0x0004AC, "Member 'UUI3DBase::ViewPortPos' has a wrong offset!");
static_assert(offsetof(UUI3DBase, AttachSocketName) == 0x0004B4, "Member 'UUI3DBase::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UUI3DBase, DistanceOfInvisible) == 0x0004BC, "Member 'UUI3DBase::DistanceOfInvisible' has a wrong offset!");
static_assert(offsetof(UUI3DBase, bIsInScreenTop) == 0x0004C0, "Member 'UUI3DBase::bIsInScreenTop' has a wrong offset!");
static_assert(offsetof(UUI3DBase, DefaultScreenTopPos) == 0x0004C4, "Member 'UUI3DBase::DefaultScreenTopPos' has a wrong offset!");
static_assert(offsetof(UUI3DBase, bIsUpdateAnimIfOutWindow) == 0x0004C8, "Member 'UUI3DBase::bIsUpdateAnimIfOutWindow' has a wrong offset!");
static_assert(offsetof(UUI3DBase, DistanceOfMinSmall) == 0x0004CC, "Member 'UUI3DBase::DistanceOfMinSmall' has a wrong offset!");
static_assert(offsetof(UUI3DBase, DistanceOfStartSmall) == 0x0004D0, "Member 'UUI3DBase::DistanceOfStartSmall' has a wrong offset!");
static_assert(offsetof(UUI3DBase, MaxSmallScale) == 0x0004D4, "Member 'UUI3DBase::MaxSmallScale' has a wrong offset!");
static_assert(offsetof(UUI3DBase, MinSmallScale) == 0x0004D8, "Member 'UUI3DBase::MinSmallScale' has a wrong offset!");

// Class DarwinGame.UIField_SkillChain_Word
// 0x0010 (0x05C0 - 0x05B0)
class UUIField_SkillChain_Word : public UUI3DBase
{
public:
	class UUISkillPop_00*                         DamagePop;                                         // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChainData(const int32& DamageNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_SkillChain_Word">();
	}
	static class UUIField_SkillChain_Word* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_SkillChain_Word>();
	}
};
static_assert(alignof(UUIField_SkillChain_Word) == 0x000010, "Wrong alignment on UUIField_SkillChain_Word");
static_assert(sizeof(UUIField_SkillChain_Word) == 0x0005C0, "Wrong size on UUIField_SkillChain_Word");
static_assert(offsetof(UUIField_SkillChain_Word, DamagePop) == 0x0005A8, "Member 'UUIField_SkillChain_Word::DamagePop' has a wrong offset!");

// Class DarwinGame.SaveGameBase
// 0x0000 (0x0030 - 0x0030)
class USaveGameBase : public USaveGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameBase">();
	}
	static class USaveGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameBase>();
	}
};
static_assert(alignof(USaveGameBase) == 0x000008, "Wrong alignment on USaveGameBase");
static_assert(sizeof(USaveGameBase) == 0x000030, "Wrong size on USaveGameBase");

// Class DarwinGame.AnimNotify_Visualization
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_Visualization final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Visualization">();
	}
	static class UAnimNotify_Visualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Visualization>();
	}
};
static_assert(alignof(UAnimNotify_Visualization) == 0x000008, "Wrong alignment on UAnimNotify_Visualization");
static_assert(sizeof(UAnimNotify_Visualization) == 0x000040, "Wrong size on UAnimNotify_Visualization");

// Class DarwinGame.AtomCueSheetManager
// 0x0040 (0x0070 - 0x0030)
class UAtomCueSheetManager : public UObject
{
public:
	class UDataTable*                             CueSheetList;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BaseEnvCueSheetList;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             VoiceJaCueSheetList;                               // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             VoiceEnCueSheetList;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DebugCueSheetList;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SheetNameListEnvSound;                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCueSheet*                     BaseEnvCueSheet;                                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomCueSheetManager">();
	}
	static class UAtomCueSheetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomCueSheetManager>();
	}
};
static_assert(alignof(UAtomCueSheetManager) == 0x000008, "Wrong alignment on UAtomCueSheetManager");
static_assert(sizeof(UAtomCueSheetManager) == 0x000070, "Wrong size on UAtomCueSheetManager");
static_assert(offsetof(UAtomCueSheetManager, CueSheetList) == 0x000030, "Member 'UAtomCueSheetManager::CueSheetList' has a wrong offset!");
static_assert(offsetof(UAtomCueSheetManager, BaseEnvCueSheetList) == 0x000038, "Member 'UAtomCueSheetManager::BaseEnvCueSheetList' has a wrong offset!");
static_assert(offsetof(UAtomCueSheetManager, VoiceJaCueSheetList) == 0x000040, "Member 'UAtomCueSheetManager::VoiceJaCueSheetList' has a wrong offset!");
static_assert(offsetof(UAtomCueSheetManager, VoiceEnCueSheetList) == 0x000048, "Member 'UAtomCueSheetManager::VoiceEnCueSheetList' has a wrong offset!");
static_assert(offsetof(UAtomCueSheetManager, DebugCueSheetList) == 0x000050, "Member 'UAtomCueSheetManager::DebugCueSheetList' has a wrong offset!");
static_assert(offsetof(UAtomCueSheetManager, SheetNameListEnvSound) == 0x000058, "Member 'UAtomCueSheetManager::SheetNameListEnvSound' has a wrong offset!");
static_assert(offsetof(UAtomCueSheetManager, BaseEnvCueSheet) == 0x000068, "Member 'UAtomCueSheetManager::BaseEnvCueSheet' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MonsterControllCamera
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_MonsterControllCamera final : public UAnimNotifyState
{
public:
	EMonsterCameraControllType                    mControllType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterControllCamera">();
	}
	static class UAnimNotifyState_MonsterControllCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterControllCamera>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterControllCamera) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterControllCamera");
static_assert(sizeof(UAnimNotifyState_MonsterControllCamera) == 0x000040, "Wrong size on UAnimNotifyState_MonsterControllCamera");
static_assert(offsetof(UAnimNotifyState_MonsterControllCamera, mControllType) == 0x000038, "Member 'UAnimNotifyState_MonsterControllCamera::mControllType' has a wrong offset!");

// Class DarwinGame.UIMenuBase
// 0x0030 (0x04C0 - 0x0490)
class UUIMenuBase : public UDarwinUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnChangeFocusStatus;                               // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEnableInputEventAtOpen;                         // 0x04B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsItemListUpdate;                                 // 0x04B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BA[0x6];                                      // 0x04BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemList(class UUIMenuItemBase* Item);
	bool ChangeFocusWithNavigation(EAxisMappingType Key, bool CheckSelfKeyInput);
	bool CheckSelectableFromKeyInput(EAxisMappingType Key, class UUIMenuBase* Menu);
	void ClearItemList();
	void CloseItemList();
	TArray<class UUIMenuItemBase*> GetItemList();
	void OnTriedToMoveBeyondTheEdgeFunc(EAxisMappingType Key);
	void OutFocusCurrentFocusItem();
	void RemoveIndexItemList(int32 Index_0);
	void SetFocusItem(class UUIMenuItemBase* Item);
	void SetFocusItemFromIndex(int32 ItemIndex);
	void SetItemList(const TArray<class UUIMenuItemBase*>& NewParam);
	void SetNavigationLinear(const TArray<class UUIMenuItemBase*>& NewParam, bool Loop, EAxisMappingType PrevKey, EAxisMappingType NextKey);
	void SetNavigationLinearLR(const TArray<class UUIMenuItemBase*>& NewParam, bool Loop);
	void SetNavigationLinearUpDown(const TArray<class UUIMenuItemBase*>& NewParam, bool Loop);

	class UUIMenuItemBase* GetFocusItem() const;
	int32 GetIndexAtFocusItem() const;
	bool HasFocusItem() const;
	int32 ItemListLastIndex() const;
	int32 ItemListLength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenuBase">();
	}
	static class UUIMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenuBase>();
	}
};
static_assert(alignof(UUIMenuBase) == 0x000008, "Wrong alignment on UUIMenuBase");
static_assert(sizeof(UUIMenuBase) == 0x0004C0, "Wrong size on UUIMenuBase");
static_assert(offsetof(UUIMenuBase, OnChangeFocusStatus) == 0x000490, "Member 'UUIMenuBase::OnChangeFocusStatus' has a wrong offset!");
static_assert(offsetof(UUIMenuBase, bIsEnableInputEventAtOpen) == 0x0004B8, "Member 'UUIMenuBase::bIsEnableInputEventAtOpen' has a wrong offset!");
static_assert(offsetof(UUIMenuBase, bIsItemListUpdate) == 0x0004B9, "Member 'UUIMenuBase::bIsItemListUpdate' has a wrong offset!");

// Class DarwinGame.UIScrollMenuBase
// 0x0110 (0x05D0 - 0x04C0)
class UUIScrollMenuBase : public UUIMenuBase
{
public:
	int32                                         CursorItemNum;                                     // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeItemNum;                                     // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterItemNum;                                      // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollSpeed;                                       // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLoop;                                       // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLineEnableLoop;                                   // 0x04D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D2[0x2];                                      // 0x04D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LineItemNum;                                       // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultSelectSound;                                // 0x04D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultSelectErrorSound;                           // 0x04E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListItemNum;                                       // 0x04F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListStartIndex;                                    // 0x04FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      PositionArray;                                     // 0x0500(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMenuItemBase*                        TopItem;                                           // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      ScaleArray;                                        // 0x0518(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDarwinUserWidget*                      ArrowWidget;                                       // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ScrollBarWidget;                                   // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ScrollBaseWidget;                                  // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bNext)>    LineMoveExceptioEventDispather;                    // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EScrollBarMoveType                            ScrollMoveType;                                    // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotSelectItemInListScroll;                        // 0x0551(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxisMappingType                              PrevItemKey;                                       // 0x0552(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxisMappingType                              NextItemKey;                                       // 0x0553(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxisMappingType                              PrevLineKey;                                       // 0x0554(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxisMappingType                              NextLineKey;                                       // 0x0555(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraceCursorArrow;                                 // 0x0556(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_557[0x1];                                      // 0x0557(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ArrowLoopAnimation;                                // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x70];                                     // 0x0560(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanPlaySelectSound();
	bool CanSelect();
	bool ChangePage(EAxisMappingType Key, bool CheckSelfKeyInput);
	void InitList(int32 InListNum);
	void InitScrollMenu(const TArray<class UUIScrollMenuItemBase*>& InItemList);
	bool IsScrolling();
	bool IsValidItem(class UUIScrollMenuItemBase* InItem);
	void ResetDispList(int32 InFocusIndex, bool IsSetFocus);
	void ResetDispListKeepFocus(bool IsSetFocus);
	void ResetDispListStartIndex(int32 InFocusIndex, int32 InListStartIndex, bool IsSetFocus);
	bool ScrollPage(EAxisMappingType Key, bool CheckSelfKeyInput);
	void SetFocusItemFromListIndex(int32 InIndex);
	void SetItemData(class UUIScrollMenuItemBase* InItem);
	void SetVisibleCursorArrow(bool IsVisible_0, EArrowWidgetVisibleType VisibleType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollMenuBase">();
	}
	static class UUIScrollMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollMenuBase>();
	}
};
static_assert(alignof(UUIScrollMenuBase) == 0x000008, "Wrong alignment on UUIScrollMenuBase");
static_assert(sizeof(UUIScrollMenuBase) == 0x0005D0, "Wrong size on UUIScrollMenuBase");
static_assert(offsetof(UUIScrollMenuBase, CursorItemNum) == 0x0004C0, "Member 'UUIScrollMenuBase::CursorItemNum' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, BeforeItemNum) == 0x0004C4, "Member 'UUIScrollMenuBase::BeforeItemNum' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, AfterItemNum) == 0x0004C8, "Member 'UUIScrollMenuBase::AfterItemNum' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ScrollSpeed) == 0x0004CC, "Member 'UUIScrollMenuBase::ScrollSpeed' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, bEnableLoop) == 0x0004D0, "Member 'UUIScrollMenuBase::bEnableLoop' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, bLineEnableLoop) == 0x0004D1, "Member 'UUIScrollMenuBase::bLineEnableLoop' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, LineItemNum) == 0x0004D4, "Member 'UUIScrollMenuBase::LineItemNum' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, DefaultSelectSound) == 0x0004D8, "Member 'UUIScrollMenuBase::DefaultSelectSound' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, DefaultSelectErrorSound) == 0x0004E8, "Member 'UUIScrollMenuBase::DefaultSelectErrorSound' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ListItemNum) == 0x0004F8, "Member 'UUIScrollMenuBase::ListItemNum' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ListStartIndex) == 0x0004FC, "Member 'UUIScrollMenuBase::ListStartIndex' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, PositionArray) == 0x000500, "Member 'UUIScrollMenuBase::PositionArray' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, TopItem) == 0x000510, "Member 'UUIScrollMenuBase::TopItem' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ScaleArray) == 0x000518, "Member 'UUIScrollMenuBase::ScaleArray' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ArrowWidget) == 0x000528, "Member 'UUIScrollMenuBase::ArrowWidget' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ScrollBarWidget) == 0x000530, "Member 'UUIScrollMenuBase::ScrollBarWidget' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ScrollBaseWidget) == 0x000538, "Member 'UUIScrollMenuBase::ScrollBaseWidget' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, LineMoveExceptioEventDispather) == 0x000540, "Member 'UUIScrollMenuBase::LineMoveExceptioEventDispather' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ScrollMoveType) == 0x000550, "Member 'UUIScrollMenuBase::ScrollMoveType' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, bNotSelectItemInListScroll) == 0x000551, "Member 'UUIScrollMenuBase::bNotSelectItemInListScroll' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, PrevItemKey) == 0x000552, "Member 'UUIScrollMenuBase::PrevItemKey' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, NextItemKey) == 0x000553, "Member 'UUIScrollMenuBase::NextItemKey' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, PrevLineKey) == 0x000554, "Member 'UUIScrollMenuBase::PrevLineKey' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, NextLineKey) == 0x000555, "Member 'UUIScrollMenuBase::NextLineKey' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, bTraceCursorArrow) == 0x000556, "Member 'UUIScrollMenuBase::bTraceCursorArrow' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuBase, ArrowLoopAnimation) == 0x000558, "Member 'UUIScrollMenuBase::ArrowLoopAnimation' has a wrong offset!");

// Class DarwinGame.UIRewardItemListBase
// 0x0028 (0x05F8 - 0x05D0)
class UUIRewardItemListBase : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x28];                                     // 0x05D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardItemListBase">();
	}
	static class UUIRewardItemListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardItemListBase>();
	}
};
static_assert(alignof(UUIRewardItemListBase) == 0x000008, "Wrong alignment on UUIRewardItemListBase");
static_assert(sizeof(UUIRewardItemListBase) == 0x0005F8, "Wrong size on UUIRewardItemListBase");

// Class DarwinGame.AbilityTask_PlayMontageAndWaitEvent
// 0x00C0 (0x0148 - 0x0088)
class UAbilityTask_PlayMontageAndWaitEvent final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnCompleted;                                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnBlendOut;                                        // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnInterrupted;                                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> OnCancelled;                                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)> EventReceived;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00E0(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x0104(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x37];                                     // 0x0111(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_PlayMontageAndWaitEvent* PlayMontageAndWaitEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_PlayMontageAndWaitEvent">();
	}
	static class UAbilityTask_PlayMontageAndWaitEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_PlayMontageAndWaitEvent>();
	}
};
static_assert(alignof(UAbilityTask_PlayMontageAndWaitEvent) == 0x000008, "Wrong alignment on UAbilityTask_PlayMontageAndWaitEvent");
static_assert(sizeof(UAbilityTask_PlayMontageAndWaitEvent) == 0x000148, "Wrong size on UAbilityTask_PlayMontageAndWaitEvent");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, OnCompleted) == 0x000088, "Member 'UAbilityTask_PlayMontageAndWaitEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, OnBlendOut) == 0x000098, "Member 'UAbilityTask_PlayMontageAndWaitEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, OnInterrupted) == 0x0000A8, "Member 'UAbilityTask_PlayMontageAndWaitEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, OnCancelled) == 0x0000B8, "Member 'UAbilityTask_PlayMontageAndWaitEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, EventReceived) == 0x0000C8, "Member 'UAbilityTask_PlayMontageAndWaitEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, MontageToPlay) == 0x0000D8, "Member 'UAbilityTask_PlayMontageAndWaitEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, EventTags) == 0x0000E0, "Member 'UAbilityTask_PlayMontageAndWaitEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, Rate) == 0x000100, "Member 'UAbilityTask_PlayMontageAndWaitEvent::Rate' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, StartSection) == 0x000104, "Member 'UAbilityTask_PlayMontageAndWaitEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, AnimRootMotionTranslationScale) == 0x00010C, "Member 'UAbilityTask_PlayMontageAndWaitEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitEvent, bStopWhenAbilityEnds) == 0x000110, "Member 'UAbilityTask_PlayMontageAndWaitEvent::bStopWhenAbilityEnds' has a wrong offset!");

// Class DarwinGame.AnimNotify_WarpToTarget
// 0x0020 (0x0060 - 0x0040)
class UAnimNotify_WarpToTarget final : public UAnimNotify
{
public:
	EWarpDir                                      mWarpDir;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mDistance;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mNavimeshSearchExtent;                             // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mDebugDrawNavimeshSearchExtent;                    // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIsEditUnwarpableWallHeight;                       // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mUnwarpableWallHeight;                             // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WarpToTarget">();
	}
	static class UAnimNotify_WarpToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WarpToTarget>();
	}
};
static_assert(alignof(UAnimNotify_WarpToTarget) == 0x000008, "Wrong alignment on UAnimNotify_WarpToTarget");
static_assert(sizeof(UAnimNotify_WarpToTarget) == 0x000060, "Wrong size on UAnimNotify_WarpToTarget");
static_assert(offsetof(UAnimNotify_WarpToTarget, mWarpDir) == 0x000040, "Member 'UAnimNotify_WarpToTarget::mWarpDir' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WarpToTarget, mDistance) == 0x000044, "Member 'UAnimNotify_WarpToTarget::mDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WarpToTarget, mNavimeshSearchExtent) == 0x000048, "Member 'UAnimNotify_WarpToTarget::mNavimeshSearchExtent' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WarpToTarget, mDebugDrawNavimeshSearchExtent) == 0x000054, "Member 'UAnimNotify_WarpToTarget::mDebugDrawNavimeshSearchExtent' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WarpToTarget, mIsEditUnwarpableWallHeight) == 0x000055, "Member 'UAnimNotify_WarpToTarget::mIsEditUnwarpableWallHeight' has a wrong offset!");
static_assert(offsetof(UAnimNotify_WarpToTarget, mUnwarpableWallHeight) == 0x000058, "Member 'UAnimNotify_WarpToTarget::mUnwarpableWallHeight' has a wrong offset!");

// Class DarwinGame.StateBase
// 0x0020 (0x00D8 - 0x00B8)
class UStateBase : public UActorComponent
{
public:
	int32                                         Priority;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGPACharacter*                          OwnerCharacter;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Button_A(bool bRelease);
	void Button_B(bool bRelease);
	void Button_Down(bool bRelease);
	void Button_L(bool bRelease);
	void Button_Left(bool bRelease);
	void Button_LT(bool bRelease);
	void Button_PC_R(bool bRelease);
	void Button_PC_T(bool bRelease);
	void Button_R(bool bRelease);
	void Button_Right(bool bRelease);
	void Button_RMB(bool bRelease);
	void Button_RT(bool bRelease);
	void Button_Up(bool bRelease);
	void Button_X(bool bRelease);
	void Button_Y(bool bRelease);
	void Cancel();
	void Enter();
	void Exit();
	void Move(const struct FVector& InputVector);
	void SpecialLeft(bool bRelease);
	void SpecialRight(bool bRelease);
	void TakeAction(const struct FGameplayTag& ActionTag, bool bRelease);
	void Thumb_Left(bool bRelease);
	void Update(float DeltaTime);

	float CalcAxisValue() const;
	struct FRotator GetInputRotation() const;
	struct FVector GetLastMovementInput() const;
	struct FRotator GetMoveRotation() const;
	void GetMoveValue(float* Axis, float* Direction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateBase">();
	}
	static class UStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateBase>();
	}
};
static_assert(alignof(UStateBase) == 0x000008, "Wrong alignment on UStateBase");
static_assert(sizeof(UStateBase) == 0x0000D8, "Wrong size on UStateBase");
static_assert(offsetof(UStateBase, Priority) == 0x0000B8, "Member 'UStateBase::Priority' has a wrong offset!");
static_assert(offsetof(UStateBase, OwnerCharacter) == 0x0000C0, "Member 'UStateBase::OwnerCharacter' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_SetLandSection
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_SetLandSection final : public UAnimNotifyState
{
public:
	class FName                                   mLandSection;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mResetLandSection;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SetLandSection">();
	}
	static class UAnimNotifyState_SetLandSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SetLandSection>();
	}
};
static_assert(alignof(UAnimNotifyState_SetLandSection) == 0x000008, "Wrong alignment on UAnimNotifyState_SetLandSection");
static_assert(sizeof(UAnimNotifyState_SetLandSection) == 0x000048, "Wrong size on UAnimNotifyState_SetLandSection");
static_assert(offsetof(UAnimNotifyState_SetLandSection, mLandSection) == 0x000038, "Member 'UAnimNotifyState_SetLandSection::mLandSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SetLandSection, mResetLandSection) == 0x000040, "Member 'UAnimNotifyState_SetLandSection::mResetLandSection' has a wrong offset!");

// Class DarwinGame.UIDungeon_Floor
// 0x0000 (0x0490 - 0x0490)
class UUIDungeon_Floor : public UDarwinUserWidget
{
public:
	void SetRoomNumber(int32 NewRoomNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDungeon_Floor">();
	}
	static class UUIDungeon_Floor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDungeon_Floor>();
	}
};
static_assert(alignof(UUIDungeon_Floor) == 0x000008, "Wrong alignment on UUIDungeon_Floor");
static_assert(sizeof(UUIDungeon_Floor) == 0x000490, "Wrong size on UUIDungeon_Floor");

// Class DarwinGame.AnimNotify_WarpToTargetLocation
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_WarpToTargetLocation final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WarpToTargetLocation">();
	}
	static class UAnimNotify_WarpToTargetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WarpToTargetLocation>();
	}
};
static_assert(alignof(UAnimNotify_WarpToTargetLocation) == 0x000008, "Wrong alignment on UAnimNotify_WarpToTargetLocation");
static_assert(sizeof(UAnimNotify_WarpToTargetLocation) == 0x000040, "Wrong size on UAnimNotify_WarpToTargetLocation");

// Class DarwinGame.UISentenceBase
// 0x0000 (0x0490 - 0x0490)
class UUISentenceBase : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISentenceBase">();
	}
	static class UUISentenceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISentenceBase>();
	}
};
static_assert(alignof(UUISentenceBase) == 0x000008, "Wrong alignment on UUISentenceBase");
static_assert(sizeof(UUISentenceBase) == 0x000490, "Wrong size on UUISentenceBase");

// Class DarwinGame.MoveStateBase
// 0x0098 (0x0170 - 0x00D8)
class UMoveStateBase : public UStateBase
{
public:
	uint8                                         Pad_D8[0x98];                                      // 0x00D8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckFrontWall(float RayLength, float Angle, float IncidentAngle, float Top, float Bottom);
	bool CheckWallHeight(float Top, float Bottom, float* Height);
	struct FVector GetGradientVector();
	void SetNextMoveStateTag(const struct FGameplayTag& Tag);

	struct FGameplayTag GetNextMoveStateTag() const;
	struct FHitResult GetWallSurface() const;
	bool IsWallSurfaceFound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveStateBase">();
	}
	static class UMoveStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveStateBase>();
	}
};
static_assert(alignof(UMoveStateBase) == 0x000008, "Wrong alignment on UMoveStateBase");
static_assert(sizeof(UMoveStateBase) == 0x000170, "Wrong size on UMoveStateBase");

// Class DarwinGame.AbnormalStateBase
// 0x0008 (0x0178 - 0x0170)
class UAbnormalStateBase final : public UMoveStateBase
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateBase">();
	}
	static class UAbnormalStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateBase>();
	}
};
static_assert(alignof(UAbnormalStateBase) == 0x000008, "Wrong alignment on UAbnormalStateBase");
static_assert(sizeof(UAbnormalStateBase) == 0x000178, "Wrong size on UAbnormalStateBase");

// Class DarwinGame.GameDataPlayer
// 0x01D0 (0x0200 - 0x0030)
class UGameDataPlayer final : public UObject
{
public:
	uint8                                         Pad_30[0x1D0];                                     // 0x0030(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddExp(const int32 Exp);
	void AddGold(int32 Gold);
	class UGameDataPlayer* Clone();
	void Overwrite(class UGameDataPlayer* game_data);
	void SetAttributeList(const TMap<class FName, int32>& list);
	void SetBP(int32 BP);
	void SetEquipmentCoins(const TArray<struct FST_CoinData>& EquipmentCoins);
	void SetFeatureBuffList(const TMap<class FName, struct FFeatureMapData>& list);
	void SetGold(int32 Gold);
	void SetHP(int32 HP);
	void SetMP(int32 MP);

	struct FST_Status GetAdvanceStatus() const;
	const TMap<class FName, int32> GetAttributeList() const;
	struct FST_Status GetBaseStatus() const;
	int32 GetBP() const;
	const TArray<struct FST_CoinData> GetEquipmentCoins() const;
	const TMap<class FName, struct FFeatureMapData> GetFeatureBuffList() const;
	int32 GetGold() const;
	int32 GetHP() const;
	int32 GetLevel() const;
	int32 GetMP() const;
	int32 GetRequiredExp(int32 Level) const;
	int32 GetRequiredExpToNextLevel() const;
	float GetRequiredExpToNextLevelPercent() const;
	struct FST_Status GetStatus() const;
	int32 GetTotalExp() const;
	bool IsKindKamyu() const;
	bool IsKindMaya() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataPlayer">();
	}
	static class UGameDataPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataPlayer>();
	}
};
static_assert(alignof(UGameDataPlayer) == 0x000008, "Wrong alignment on UGameDataPlayer");
static_assert(sizeof(UGameDataPlayer) == 0x000200, "Wrong size on UGameDataPlayer");

// Class DarwinGame.BaseAreaLevelUpDataAsset
// 0x00B0 (0x00E8 - 0x0038)
class UBaseAreaLevelUpDataAsset final : public UDataAsset
{
public:
	TMap<int32, struct FBaseAreaLevelUpGameFlagList> mGameFlagList;                                     // 0x0038(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FBaseAreaLevelUpEventData>      mEventDataList;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                mEventDataExclusiveList;                           // 0x0098(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaLevelUpDataAsset">();
	}
	static class UBaseAreaLevelUpDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAreaLevelUpDataAsset>();
	}
};
static_assert(alignof(UBaseAreaLevelUpDataAsset) == 0x000008, "Wrong alignment on UBaseAreaLevelUpDataAsset");
static_assert(sizeof(UBaseAreaLevelUpDataAsset) == 0x0000E8, "Wrong size on UBaseAreaLevelUpDataAsset");
static_assert(offsetof(UBaseAreaLevelUpDataAsset, mGameFlagList) == 0x000038, "Member 'UBaseAreaLevelUpDataAsset::mGameFlagList' has a wrong offset!");
static_assert(offsetof(UBaseAreaLevelUpDataAsset, mEventDataList) == 0x000088, "Member 'UBaseAreaLevelUpDataAsset::mEventDataList' has a wrong offset!");
static_assert(offsetof(UBaseAreaLevelUpDataAsset, mEventDataExclusiveList) == 0x000098, "Member 'UBaseAreaLevelUpDataAsset::mEventDataExclusiveList' has a wrong offset!");

// Class DarwinGame.AppGameModeBase
// 0x0000 (0x02C8 - 0x02C8)
class AAppGameModeBase : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppGameModeBase">();
	}
	static class AAppGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppGameModeBase>();
	}
};
static_assert(alignof(AAppGameModeBase) == 0x000008, "Wrong alignment on AAppGameModeBase");
static_assert(sizeof(AAppGameModeBase) == 0x0002C8, "Wrong size on AAppGameModeBase");

// Class DarwinGame.SoundTestGameMode
// 0x0000 (0x02C8 - 0x02C8)
class ASoundTestGameMode final : public AAppGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundTestGameMode">();
	}
	static class ASoundTestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundTestGameMode>();
	}
};
static_assert(alignof(ASoundTestGameMode) == 0x000008, "Wrong alignment on ASoundTestGameMode");
static_assert(sizeof(ASoundTestGameMode) == 0x0002C8, "Wrong size on ASoundTestGameMode");

// Class DarwinGame.AnimNotifyState_AddHateInRange
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_AddHateInRange final : public UAnimNotifyState
{
public:
	float                                         mHateRadius;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mHateValue;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AddHateInRange">();
	}
	static class UAnimNotifyState_AddHateInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AddHateInRange>();
	}
};
static_assert(alignof(UAnimNotifyState_AddHateInRange) == 0x000008, "Wrong alignment on UAnimNotifyState_AddHateInRange");
static_assert(sizeof(UAnimNotifyState_AddHateInRange) == 0x000040, "Wrong size on UAnimNotifyState_AddHateInRange");
static_assert(offsetof(UAnimNotifyState_AddHateInRange, mHateRadius) == 0x000038, "Member 'UAnimNotifyState_AddHateInRange::mHateRadius' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AddHateInRange, mHateValue) == 0x00003C, "Member 'UAnimNotifyState_AddHateInRange::mHateValue' has a wrong offset!");

// Class DarwinGame.AbyssRectTrigger
// 0x0008 (0x0230 - 0x0228)
class AAbyssRectTrigger final : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbyssRectTrigger">();
	}
	static class AAbyssRectTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAbyssRectTrigger>();
	}
};
static_assert(alignof(AAbyssRectTrigger) == 0x000008, "Wrong alignment on AAbyssRectTrigger");
static_assert(sizeof(AAbyssRectTrigger) == 0x000230, "Wrong size on AAbyssRectTrigger");
static_assert(offsetof(AAbyssRectTrigger, RootComp) == 0x000228, "Member 'AAbyssRectTrigger::RootComp' has a wrong offset!");

// Class DarwinGame.MonsterBattleAIMiscFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIMiscFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIMiscFunctionLibrary">();
	}
	static class UMonsterBattleAIMiscFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIMiscFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIMiscFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIMiscFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIMiscFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIMiscFunctionLibrary");

// Class DarwinGame.UIGlutGauge_01
// 0x0000 (0x0490 - 0x0490)
class UUIGlutGauge_01 final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlutGauge_01">();
	}
	static class UUIGlutGauge_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlutGauge_01>();
	}
};
static_assert(alignof(UUIGlutGauge_01) == 0x000008, "Wrong alignment on UUIGlutGauge_01");
static_assert(sizeof(UUIGlutGauge_01) == 0x000490, "Wrong size on UUIGlutGauge_01");

// Class DarwinGame.ActingArtifact
// 0x0050 (0x0278 - 0x0228)
class AActingArtifact : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComp;                                    // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            mDisplayEffect;                                    // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            mSevenStoneEffect;                                 // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            mLineEffect;                                       // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            mMillionArtifactMesh;                              // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            mThousandArtifactMesh;                             // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            mSevensStoneMesh;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            mReplicaMesh;                                      // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLanded;                                           // 0x0270(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLand();
	void StartFall();
	void StartSevenStoneAdjustLocation();
	void StartSevenStoneAdjustRotation();
	void StartSevenStoneEffectDirection();
	void StartSevenStoneLineDirection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActingArtifact">();
	}
	static class AActingArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActingArtifact>();
	}
};
static_assert(alignof(AActingArtifact) == 0x000008, "Wrong alignment on AActingArtifact");
static_assert(sizeof(AActingArtifact) == 0x000278, "Wrong size on AActingArtifact");
static_assert(offsetof(AActingArtifact, StaticMeshComp) == 0x000228, "Member 'AActingArtifact::StaticMeshComp' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mDisplayEffect) == 0x000238, "Member 'AActingArtifact::mDisplayEffect' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mSevenStoneEffect) == 0x000240, "Member 'AActingArtifact::mSevenStoneEffect' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mLineEffect) == 0x000248, "Member 'AActingArtifact::mLineEffect' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mMillionArtifactMesh) == 0x000250, "Member 'AActingArtifact::mMillionArtifactMesh' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mThousandArtifactMesh) == 0x000258, "Member 'AActingArtifact::mThousandArtifactMesh' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mSevensStoneMesh) == 0x000260, "Member 'AActingArtifact::mSevensStoneMesh' has a wrong offset!");
static_assert(offsetof(AActingArtifact, mReplicaMesh) == 0x000268, "Member 'AActingArtifact::mReplicaMesh' has a wrong offset!");
static_assert(offsetof(AActingArtifact, bLanded) == 0x000270, "Member 'AActingArtifact::bLanded' has a wrong offset!");

// Class DarwinGame.ActionAbilitySystemComponent
// 0x0000 (0x1300 - 0x1300)
class UActionAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	void AddOnlyGameplayTag(const struct FGameplayTag& Tag);
	bool HasTag(const struct FGameplayTag& Tag);
	void SetPauseAllActiveGameplayEffects(bool Pause);

	struct FGameplayTagContainer GetOwnedTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAbilitySystemComponent">();
	}
	static class UActionAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAbilitySystemComponent>();
	}
};
static_assert(alignof(UActionAbilitySystemComponent) == 0x000008, "Wrong alignment on UActionAbilitySystemComponent");
static_assert(sizeof(UActionAbilitySystemComponent) == 0x001300, "Wrong size on UActionAbilitySystemComponent");

// Class DarwinGame.UIGameOver_WinStatus
// 0x0028 (0x05F8 - 0x05D0)
class UUIGameOver_WinStatus final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UComputeTextBlock*>              DescTextBlocks;                                    // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGameOver_WinStatus">();
	}
	static class UUIGameOver_WinStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGameOver_WinStatus>();
	}
};
static_assert(alignof(UUIGameOver_WinStatus) == 0x000008, "Wrong alignment on UUIGameOver_WinStatus");
static_assert(sizeof(UUIGameOver_WinStatus) == 0x0005F8, "Wrong size on UUIGameOver_WinStatus");
static_assert(offsetof(UUIGameOver_WinStatus, DescTextBlocks) == 0x0005E8, "Member 'UUIGameOver_WinStatus::DescTextBlocks' has a wrong offset!");

// Class DarwinGame.ActionAssistFindWater
// 0x0008 (0x0230 - 0x0228)
class AActionAssistFindWater final : public AActor
{
public:
	class UBoxComponent*                          BoxComp;                                           // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAssistFindWater">();
	}
	static class AActionAssistFindWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionAssistFindWater>();
	}
};
static_assert(alignof(AActionAssistFindWater) == 0x000008, "Wrong alignment on AActionAssistFindWater");
static_assert(sizeof(AActionAssistFindWater) == 0x000230, "Wrong size on AActionAssistFindWater");
static_assert(offsetof(AActionAssistFindWater, BoxComp) == 0x000228, "Member 'AActionAssistFindWater::BoxComp' has a wrong offset!");

// Class DarwinGame.UIMenuItemBase
// 0x0060 (0x04F0 - 0x0490)
class UUIMenuItemBase : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x60];                                     // 0x0490(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Deselect();
	void Focus();
	void FocusImidiate();
	void GetCursorPosition(bool* HasCursor, struct FVector2D* Position);
	class UUIMenuItemBase* GetNavigationItem(EAxisMappingType Key);
	class UUIMenuItemBase* GetNavigationItemWithSelectable(EAxisMappingType Key);
	class UUIMenuItemBase* GetNavigationItemWithSelectableKeyRepead(EAxisMappingType Key);
	bool HasNavigationItem(EAxisMappingType Key);
	bool IsKeyEdge(EAxisMappingType Key);
	bool IsKeyRepeatSelectable(EAxisMappingType Key);
	bool IsSelectable();
	bool IsSelected();
	void OutFocus();
	void OutFocusImidiate();
	void RemoveNavigationItem(EAxisMappingType Key);
	void Select();
	void SetNavigationItem(EAxisMappingType Key, class UUIMenuItemBase* ToItem, bool KeyRepeatSelectable, bool KeyEdge);
	void SetNavigationItemLR(const struct FST_UIMenuNavigationItem& Left, const struct FST_UIMenuNavigationItem& Right);
	void SetSelectable(bool NewParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenuItemBase">();
	}
	static class UUIMenuItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenuItemBase>();
	}
};
static_assert(alignof(UUIMenuItemBase) == 0x000008, "Wrong alignment on UUIMenuItemBase");
static_assert(sizeof(UUIMenuItemBase) == 0x0004F0, "Wrong size on UUIMenuItemBase");

// Class DarwinGame.UIScrollMenuItemBase
// 0x0040 (0x0530 - 0x04F0)
class UUIScrollMenuItemBase : public UUIMenuItemBase
{
public:
	int32                                         ListIndex;                                         // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoving;                                           // 0x04F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaling;                                          // 0x04F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F6[0x2];                                      // 0x04F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TargetScale;                                       // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_500[0x30];                                     // 0x0500(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCanvasPanel* GetArrow();
	struct FVector2D GetPosition();
	struct FVector2D GetScale();
	void Move(const struct FVector2D& InTargetPosition, const struct FVector2D& InTargetScale, int32 InPosIndex);
	void PlayLoopAnimation();
	void SetFocusAnimation(class UWidgetAnimation* Focus_0, class UWidgetAnimation* OutFocus_0, class UWidgetAnimation* Loop);
	void SetFocusAnimationByName(class FName FocusName, class FName OutFocusName, class FName LoopName);
	void SetPosition(const struct FVector2D& InPosition);
	void SetScale(const struct FVector2D& InScale);
	void SetScrollItem(int32 Index_0, const struct FVector2D& InPosition, const struct FVector2D& InScale, int32 InPosIndex);
	void StartLoopAnimation();
	void StopLoopAnimation();
	void UpdatePosition(float InDeltaTime, float InScrollSpeed);
	void UpdateScale(float InDeltaTime, float InScalingSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollMenuItemBase">();
	}
	static class UUIScrollMenuItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollMenuItemBase>();
	}
};
static_assert(alignof(UUIScrollMenuItemBase) == 0x000008, "Wrong alignment on UUIScrollMenuItemBase");
static_assert(sizeof(UUIScrollMenuItemBase) == 0x000530, "Wrong size on UUIScrollMenuItemBase");
static_assert(offsetof(UUIScrollMenuItemBase, ListIndex) == 0x0004F0, "Member 'UUIScrollMenuItemBase::ListIndex' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuItemBase, bMoving) == 0x0004F4, "Member 'UUIScrollMenuItemBase::bMoving' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuItemBase, bScaling) == 0x0004F5, "Member 'UUIScrollMenuItemBase::bScaling' has a wrong offset!");
static_assert(offsetof(UUIScrollMenuItemBase, TargetScale) == 0x0004F8, "Member 'UUIScrollMenuItemBase::TargetScale' has a wrong offset!");

// Class DarwinGame.UICommonmenu_OptionChoiceBase_Base
// 0x0020 (0x0550 - 0x0530)
class UUICommonmenu_OptionChoiceBase_Base : public UUIScrollMenuItemBase
{
public:
	class FText                                   DefaultButtonText;                                 // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_OptionChoiceBase_Base">();
	}
	static class UUICommonmenu_OptionChoiceBase_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_OptionChoiceBase_Base>();
	}
};
static_assert(alignof(UUICommonmenu_OptionChoiceBase_Base) == 0x000008, "Wrong alignment on UUICommonmenu_OptionChoiceBase_Base");
static_assert(sizeof(UUICommonmenu_OptionChoiceBase_Base) == 0x000550, "Wrong size on UUICommonmenu_OptionChoiceBase_Base");
static_assert(offsetof(UUICommonmenu_OptionChoiceBase_Base, DefaultButtonText) == 0x000530, "Member 'UUICommonmenu_OptionChoiceBase_Base::DefaultButtonText' has a wrong offset!");

// Class DarwinGame.UICommonmenu_OptionChoiceBase_00
// 0x0008 (0x0558 - 0x0550)
class UUICommonmenu_OptionChoiceBase_00 : public UUICommonmenu_OptionChoiceBase_Base
{
public:
	bool                                          DefaultButtonValue;                                // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_OptionChoiceBase_00">();
	}
	static class UUICommonmenu_OptionChoiceBase_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_OptionChoiceBase_00>();
	}
};
static_assert(alignof(UUICommonmenu_OptionChoiceBase_00) == 0x000008, "Wrong alignment on UUICommonmenu_OptionChoiceBase_00");
static_assert(sizeof(UUICommonmenu_OptionChoiceBase_00) == 0x000558, "Wrong size on UUICommonmenu_OptionChoiceBase_00");
static_assert(offsetof(UUICommonmenu_OptionChoiceBase_00, DefaultButtonValue) == 0x000550, "Member 'UUICommonmenu_OptionChoiceBase_00::DefaultButtonValue' has a wrong offset!");

// Class DarwinGame.ActionAttributeSet
// 0x0218 (0x0250 - 0x0038)
class UActionAttributeSet final : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 HP;                                                // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MP;                                                // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FP;                                                // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FST_Status                             Status;                                            // 0x0068(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FST_Status                             AdvanceStatus;                                     // 0x0080(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FST_Status                             LastStatus;                                        // 0x0098(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFeatureEffectStatusResult             ConditionalFeatureStatus;                          // 0x00B0(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFeatureEffectStatusResult             FeatureStatus;                                     // 0x00E8(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFeatureEffectStatusResult             CoinStatus;                                        // 0x0120(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFoodEffectStatusResult                FoodStatus;                                        // 0x0158(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FST_Status                             AttributePercentage;                               // 0x0190(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Damage;                                            // 0x01A8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DamageAmount;                                      // 0x01B8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxDamageAmount;                                   // 0x01C8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Heal;                                              // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MPHeal;                                            // 0x01E8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Friendship;                                        // 0x01F8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Stun;                                              // 0x0208(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxStun;                                           // 0x0218(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StunTimes;                                         // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         GutsStockCount;                                    // 0x0238(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnChangeMPDelegate;                                // 0x023C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionAttributeSet">();
	}
	static class UActionAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionAttributeSet>();
	}
};
static_assert(alignof(UActionAttributeSet) == 0x000008, "Wrong alignment on UActionAttributeSet");
static_assert(sizeof(UActionAttributeSet) == 0x000250, "Wrong size on UActionAttributeSet");
static_assert(offsetof(UActionAttributeSet, HP) == 0x000038, "Member 'UActionAttributeSet::HP' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, MP) == 0x000048, "Member 'UActionAttributeSet::MP' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, FP) == 0x000058, "Member 'UActionAttributeSet::FP' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, Status) == 0x000068, "Member 'UActionAttributeSet::Status' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, AdvanceStatus) == 0x000080, "Member 'UActionAttributeSet::AdvanceStatus' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, LastStatus) == 0x000098, "Member 'UActionAttributeSet::LastStatus' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, ConditionalFeatureStatus) == 0x0000B0, "Member 'UActionAttributeSet::ConditionalFeatureStatus' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, FeatureStatus) == 0x0000E8, "Member 'UActionAttributeSet::FeatureStatus' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, CoinStatus) == 0x000120, "Member 'UActionAttributeSet::CoinStatus' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, FoodStatus) == 0x000158, "Member 'UActionAttributeSet::FoodStatus' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, AttributePercentage) == 0x000190, "Member 'UActionAttributeSet::AttributePercentage' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, Damage) == 0x0001A8, "Member 'UActionAttributeSet::Damage' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, DamageAmount) == 0x0001B8, "Member 'UActionAttributeSet::DamageAmount' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, MaxDamageAmount) == 0x0001C8, "Member 'UActionAttributeSet::MaxDamageAmount' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, Heal) == 0x0001D8, "Member 'UActionAttributeSet::Heal' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, MPHeal) == 0x0001E8, "Member 'UActionAttributeSet::MPHeal' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, Friendship) == 0x0001F8, "Member 'UActionAttributeSet::Friendship' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, Stun) == 0x000208, "Member 'UActionAttributeSet::Stun' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, MaxStun) == 0x000218, "Member 'UActionAttributeSet::MaxStun' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, StunTimes) == 0x000228, "Member 'UActionAttributeSet::StunTimes' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, GutsStockCount) == 0x000238, "Member 'UActionAttributeSet::GutsStockCount' has a wrong offset!");
static_assert(offsetof(UActionAttributeSet, OnChangeMPDelegate) == 0x00023C, "Member 'UActionAttributeSet::OnChangeMPDelegate' has a wrong offset!");

// Class DarwinGame.ActionComponent
// 0x0058 (0x0110 - 0x00B8)
class UActionComponent final : public UActorComponent
{
public:
	float                                         DistanceToParkourObj;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParkourObjHeight;                                  // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParkourObjDepth;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttackInfo                            CurrentAttackInfo;                                 // 0x00C8(0x0048)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	bool CanParkour(const ETraceTypeQuery TraceType, EDrawDebugTrace DrawDebugType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionComponent">();
	}
	static class UActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionComponent>();
	}
};
static_assert(alignof(UActionComponent) == 0x000008, "Wrong alignment on UActionComponent");
static_assert(sizeof(UActionComponent) == 0x000110, "Wrong size on UActionComponent");
static_assert(offsetof(UActionComponent, DistanceToParkourObj) == 0x0000B8, "Member 'UActionComponent::DistanceToParkourObj' has a wrong offset!");
static_assert(offsetof(UActionComponent, ParkourObjHeight) == 0x0000BC, "Member 'UActionComponent::ParkourObjHeight' has a wrong offset!");
static_assert(offsetof(UActionComponent, ParkourObjDepth) == 0x0000C0, "Member 'UActionComponent::ParkourObjDepth' has a wrong offset!");
static_assert(offsetof(UActionComponent, CurrentAttackInfo) == 0x0000C8, "Member 'UActionComponent::CurrentAttackInfo' has a wrong offset!");

// Class DarwinGame.SimpleDisplayCollisionObjectBase
// 0x0000 (0x0228 - 0x0228)
class ASimpleDisplayCollisionObjectBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleDisplayCollisionObjectBase">();
	}
	static class ASimpleDisplayCollisionObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleDisplayCollisionObjectBase>();
	}
};
static_assert(alignof(ASimpleDisplayCollisionObjectBase) == 0x000008, "Wrong alignment on ASimpleDisplayCollisionObjectBase");
static_assert(sizeof(ASimpleDisplayCollisionObjectBase) == 0x000228, "Wrong size on ASimpleDisplayCollisionObjectBase");

// Class DarwinGame.AnimNotifyState_TerraceWall
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_TerraceWall final : public UAnimNotifyState
{
public:
	int32                                         mWallNum;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TerraceWall">();
	}
	static class UAnimNotifyState_TerraceWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TerraceWall>();
	}
};
static_assert(alignof(UAnimNotifyState_TerraceWall) == 0x000008, "Wrong alignment on UAnimNotifyState_TerraceWall");
static_assert(sizeof(UAnimNotifyState_TerraceWall) == 0x000040, "Wrong size on UAnimNotifyState_TerraceWall");
static_assert(offsetof(UAnimNotifyState_TerraceWall, mWallNum) == 0x000038, "Member 'UAnimNotifyState_TerraceWall::mWallNum' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_Base
// 0x0040 (0x0610 - 0x05D0)
class UUIPartyMenu_PMR_Page_Base : public UUIScrollMenuBase
{
public:
	class FName                                   ScrollBarName;                                     // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScrollBaseName;                                    // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           PanelNames;                                        // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPageType                                     PageType;                                          // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FocusUnderType;                                    // 0x05F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SetForcus;                                         // 0x05FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FD[0x13];                                     // 0x05FD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_Base">();
	}
	static class UUIPartyMenu_PMR_Page_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_Base>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_Base) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_Base");
static_assert(sizeof(UUIPartyMenu_PMR_Page_Base) == 0x000610, "Wrong size on UUIPartyMenu_PMR_Page_Base");
static_assert(offsetof(UUIPartyMenu_PMR_Page_Base, ScrollBarName) == 0x0005D0, "Member 'UUIPartyMenu_PMR_Page_Base::ScrollBarName' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_Base, ScrollBaseName) == 0x0005D8, "Member 'UUIPartyMenu_PMR_Page_Base::ScrollBaseName' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_Base, PanelNames) == 0x0005E0, "Member 'UUIPartyMenu_PMR_Page_Base::PanelNames' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_Base, PageType) == 0x0005F0, "Member 'UUIPartyMenu_PMR_Page_Base::PageType' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_Base, FocusUnderType) == 0x0005F4, "Member 'UUIPartyMenu_PMR_Page_Base::FocusUnderType' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_Base, SetForcus) == 0x0005FC, "Member 'UUIPartyMenu_PMR_Page_Base::SetForcus' has a wrong offset!");

// Class DarwinGame.ActionCoolTimeFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UActionCoolTimeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionCoolTimeFunctionLibrary">();
	}
	static class UActionCoolTimeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionCoolTimeFunctionLibrary>();
	}
};
static_assert(alignof(UActionCoolTimeFunctionLibrary) == 0x000008, "Wrong alignment on UActionCoolTimeFunctionLibrary");
static_assert(sizeof(UActionCoolTimeFunctionLibrary) == 0x000030, "Wrong size on UActionCoolTimeFunctionLibrary");

// Class DarwinGame.ActionDataTable
// 0x0000 (0x0030 - 0x0030)
class UActionDataTable final : public UBlueprintFunctionLibrary
{
public:
	static bool BlowToAttackerDirection(class FName DetailID);
	static bool ConvertActionOverviewID(class FName ActionOverviewID, int32 ActionLevel, int32 CharacterLevel, class FName* outOverviewID);
	static class FName DecideDeriVateID(class FName ActionID);
	static void GetActionEffections(class FName DetailID, TArray<EObjectEffectionEnum>* Effections);
	static EActionTargetType GetActionTargetType(class FName DetailID);
	static void GetActPerformance(class FName OverviewID, struct FST_ActionPerformance* Performance);
	static void GetAttributes(class FName DetailID, TArray<struct FST_Attribute>* Attributes);
	static void GetBallisticPerformance(class FName DetailID, struct FST_BallisticPerformance* Performance);
	static float GetCastTime(class FName DetailID);
	static void GetChildActionPerformance(class FName DetailID, struct FST_ChildActionPerformance* Performance);
	static EActionClassType GetClassType(class FName DetailID);
	static EActionClassType GetClassTypeFromOverViewID(class FName OverviewID);
	static int32 GetCorrectValue(class FName DetailID);
	static void GetDamageData(class FName DetailID, bool IsEnemy, struct FST_AttackData* AttackData);
	static EActionEffectType GetEffectType(class FName DetailID);
	static float GetHitStopTime(class FName DetailID);
	static void GetLaserPerformance(class FName DetailID, struct FST_LaserPerformance* Performance);
	static void GetOverHeadFallPerformance(class FName OverviewID, struct FST_OverHeadFallPerformanceDefine* Performance);
	static class FName GetOverviewID(class FName DetailID);
	static EDamageReactionType GetReactionType(class FName DetailID);
	static float GetRequiredMP(class FName ActionOverviewID);
	static class FName GetResistanceID(class FName DetailID, EResistJudgeType Type, bool bIsEnemy);
	static void GetResistanceTypes(class FName DetailID, TArray<EResistanceType>* Types);
	static void GetShotgunActionPerformance(class FName DetailID, TArray<struct FST_ShotgunActionPerformance>* Performance);
	static void GetTargetArea(class FName OverviewID, struct FST_TargetArea* Performance);
	static bool IsDerivateOverviewID(class FName OverviewID);
	static bool IsEnableHitStop(class FName DetailID);
	static bool UseCurve(class FName OverviewID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionDataTable">();
	}
	static class UActionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionDataTable>();
	}
};
static_assert(alignof(UActionDataTable) == 0x000008, "Wrong alignment on UActionDataTable");
static_assert(sizeof(UActionDataTable) == 0x000030, "Wrong size on UActionDataTable");

// Class DarwinGame.GameDataShop
// 0x0068 (0x0098 - 0x0030)
class UGameDataShop final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBoughtItem(const class FName& ID);
	void AddId(const class FName& ID, bool IsNew);
	class UGameDataShop* Clone();
	void Overwrite(class UGameDataShop* game_data);
	void SetIsNewItem(const class FName& ID, bool IsNew);

	bool IsBoughtItem(const class FName& ID) const;
	bool IsContainId(const class FName& ID) const;
	bool IsNewItem(const class FName& ID) const;
	bool IsNewShopData(int32 ShopID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataShop">();
	}
	static class UGameDataShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataShop>();
	}
};
static_assert(alignof(UGameDataShop) == 0x000008, "Wrong alignment on UGameDataShop");
static_assert(sizeof(UGameDataShop) == 0x000098, "Wrong size on UGameDataShop");

// Class DarwinGame.QuestFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UQuestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddPlayerActionCount(const EQuestClearPlayerActionType Type);
	static void AddPlayerActionNum(const EQuestClearPlayerActionType Type, const int32 Num);
	static void ArrivalDestination(const class FName QuestID);
	static int32 CalcQuestCountRandom(const int32 Param);
	static bool CheckArtifactDetectNum(const struct FST_QuestListClear& ClearDat, const class FName QuestID, const class UGameDataQuest* GameDataQuest);
	static bool CheckArtifactDisplayNum(const struct FST_QuestListClear& ClearDat, const struct FOrderQuestData& OrderData);
	static bool CheckArtifactGetNum(const struct FST_QuestListClear& ClearDat, const class FName QuestID, const class UGameDataQuest* GameDataQuest);
	static bool CheckArtifactSum(const struct FST_QuestListClear& ClearDat, const class FName QuestID);
	static bool CheckClearTargetObjectDestroy(const int32& ClearNum);
	static bool CheckFriendMonsterNum(int32 friend_num);
	static bool CheckMonsterVisionNum(const struct FST_QuestListClear& ClearDat, const class FName QuestID);
	static bool CheckTeamRank(int32 team_rank);
	static void PlayQuestEvent(const class FName& quest_id);
	static void ResetArrivalDestination(const class FName RectID, const class FName QuestID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestFunctionLibrary">();
	}
	static class UQuestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestFunctionLibrary>();
	}
};
static_assert(alignof(UQuestFunctionLibrary) == 0x000008, "Wrong alignment on UQuestFunctionLibrary");
static_assert(sizeof(UQuestFunctionLibrary) == 0x000030, "Wrong size on UQuestFunctionLibrary");

// Class DarwinGame.ActionGameplayAbility
// 0x0018 (0x0420 - 0x0408)
class UActionGameplayAbility : public UGameplayAbility
{
public:
	class AGPACharacter*                          AvatarCharacter;                                   // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x4];                                      // 0x0410(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                mBaseLocation;                                     // 0x0414(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AdjustLocation();
	void AdjustState();
	void CalculateBaseLocation();
	void Cancel();
	struct FActionGameplayEffectContainerSpec CreateEffectContainerSpec(class FName actionDetailID);
	struct FActionGameplayEffectContainerSpec CreateEffectContainerSpecFromActionOverViewID(class FName ActionOverviewID);
	struct FActionGameplayEffectContainerSpec CreateEffectContainerSpecWithAttackResult(class FName actionDetailID, const struct FAttackHitResultStruct& AttackResult);
	void Debug_CheckPrintTask(bool OnBlend, bool OnIntercept, bool OnCancel);
	void Debug_SetNeedCallOnTaskFinish(bool Flag);
	void End();
	void EndMoveOnCurve();
	void JumpToSection(class FName SectionName);
	void OnCollisionHit();
	void SetNextSection(class FName SectionName);
	void StopEquipMotion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionGameplayAbility">();
	}
	static class UActionGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionGameplayAbility>();
	}
};
static_assert(alignof(UActionGameplayAbility) == 0x000008, "Wrong alignment on UActionGameplayAbility");
static_assert(sizeof(UActionGameplayAbility) == 0x000420, "Wrong size on UActionGameplayAbility");
static_assert(offsetof(UActionGameplayAbility, AvatarCharacter) == 0x000408, "Member 'UActionGameplayAbility::AvatarCharacter' has a wrong offset!");
static_assert(offsetof(UActionGameplayAbility, mBaseLocation) == 0x000414, "Member 'UActionGameplayAbility::mBaseLocation' has a wrong offset!");

// Class DarwinGame.MonsterSpawnedCallbackHolder
// 0x0010 (0x0238 - 0x0228)
class AMonsterSpawnedCallbackHolder final : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void countKillNumber(class AMonsterBase* Monster);
	int32 GetKillCount();
	void ResetKillCount();
	void SetKillCount(int32 Count);
	void SetTargetBattleID(class FName BattleID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterSpawnedCallbackHolder">();
	}
	static class AMonsterSpawnedCallbackHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterSpawnedCallbackHolder>();
	}
};
static_assert(alignof(AMonsterSpawnedCallbackHolder) == 0x000008, "Wrong alignment on AMonsterSpawnedCallbackHolder");
static_assert(sizeof(AMonsterSpawnedCallbackHolder) == 0x000238, "Wrong size on AMonsterSpawnedCallbackHolder");

// Class DarwinGame.UIGood_Heart
// 0x00C0 (0x0550 - 0x0490)
class alignas(0x10) UUIGood_Heart final : public UDarwinUserWidget
{
public:
	TArray<class UAutoTextBlock*>                 TextList;                                          // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     HeartTexList;                                      // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     HeartEffTexList;                                   // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     HeartBeatTexList;                                  // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeartIconImg;                                      // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeartEffImg;                                       // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeartBeatImg;                                      // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_GoodHeartInfo>              GoodInfoList;                                      // 0x04E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x58];                                     // 0x04F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_Heart">();
	}
	static class UUIGood_Heart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_Heart>();
	}
};
static_assert(alignof(UUIGood_Heart) == 0x000010, "Wrong alignment on UUIGood_Heart");
static_assert(sizeof(UUIGood_Heart) == 0x000550, "Wrong size on UUIGood_Heart");
static_assert(offsetof(UUIGood_Heart, TextList) == 0x000490, "Member 'UUIGood_Heart::TextList' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, HeartTexList) == 0x0004A0, "Member 'UUIGood_Heart::HeartTexList' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, HeartEffTexList) == 0x0004B0, "Member 'UUIGood_Heart::HeartEffTexList' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, HeartBeatTexList) == 0x0004C0, "Member 'UUIGood_Heart::HeartBeatTexList' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, HeartIconImg) == 0x0004D0, "Member 'UUIGood_Heart::HeartIconImg' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, HeartEffImg) == 0x0004D8, "Member 'UUIGood_Heart::HeartEffImg' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, HeartBeatImg) == 0x0004E0, "Member 'UUIGood_Heart::HeartBeatImg' has a wrong offset!");
static_assert(offsetof(UUIGood_Heart, GoodInfoList) == 0x0004E8, "Member 'UUIGood_Heart::GoodInfoList' has a wrong offset!");

// Class DarwinGame.ActionPoint
// 0x0028 (0x0250 - 0x0228)
class AActionPoint : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EActionPointType                              mIconType;                                         // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mGameFlag;                                         // 0x0234(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x14];                                     // 0x023C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class FName GetGameFlag() const;
	EActionPointType GetType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPoint">();
	}
	static class AActionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionPoint>();
	}
};
static_assert(alignof(AActionPoint) == 0x000008, "Wrong alignment on AActionPoint");
static_assert(sizeof(AActionPoint) == 0x000250, "Wrong size on AActionPoint");
static_assert(offsetof(AActionPoint, mIconType) == 0x000230, "Member 'AActionPoint::mIconType' has a wrong offset!");
static_assert(offsetof(AActionPoint, mGameFlag) == 0x000234, "Member 'AActionPoint::mGameFlag' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_Tips
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_Tips final : public UAnimNotifyState
{
public:
	class FName                                   mTipsID;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_Tips">();
	}
	static class UAnimNotifyState_Tips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_Tips>();
	}
};
static_assert(alignof(UAnimNotifyState_Tips) == 0x000008, "Wrong alignment on UAnimNotifyState_Tips");
static_assert(sizeof(UAnimNotifyState_Tips) == 0x000040, "Wrong size on UAnimNotifyState_Tips");
static_assert(offsetof(UAnimNotifyState_Tips, mTipsID) == 0x000038, "Member 'UAnimNotifyState_Tips::mTipsID' has a wrong offset!");

// Class DarwinGame.MonsNotifyStateBase
// 0x0008 (0x0038 - 0x0030)
class UMonsNotifyStateBase : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyStateBase">();
	}
	static class UMonsNotifyStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyStateBase>();
	}
};
static_assert(alignof(UMonsNotifyStateBase) == 0x000008, "Wrong alignment on UMonsNotifyStateBase");
static_assert(sizeof(UMonsNotifyStateBase) == 0x000038, "Wrong size on UMonsNotifyStateBase");

// Class DarwinGame.MonsNotifyState_MonsterTimeWait
// 0x0010 (0x0048 - 0x0038)
class UMonsNotifyState_MonsterTimeWait final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_MonsterTimeWait">();
	}
	static class UMonsNotifyState_MonsterTimeWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_MonsterTimeWait>();
	}
};
static_assert(alignof(UMonsNotifyState_MonsterTimeWait) == 0x000008, "Wrong alignment on UMonsNotifyState_MonsterTimeWait");
static_assert(sizeof(UMonsNotifyState_MonsterTimeWait) == 0x000048, "Wrong size on UMonsNotifyState_MonsterTimeWait");

// Class DarwinGame.PlayPlayerVoice
// 0x0008 (0x0048 - 0x0040)
class UPlayPlayerVoice final : public UAnimNotify
{
public:
	EVoiceTimingPC                                Voice;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayPlayerVoice">();
	}
	static class UPlayPlayerVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayPlayerVoice>();
	}
};
static_assert(alignof(UPlayPlayerVoice) == 0x000008, "Wrong alignment on UPlayPlayerVoice");
static_assert(sizeof(UPlayPlayerVoice) == 0x000048, "Wrong size on UPlayPlayerVoice");
static_assert(offsetof(UPlayPlayerVoice, Voice) == 0x000040, "Member 'UPlayPlayerVoice::Voice' has a wrong offset!");

// Class DarwinGame.FieldObjectActorTemplate
// 0x0010 (0x0238 - 0x0228)
class AFieldObjectActorTemplate : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mIsAllowParkour;                                   // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsAllowClimbing;                                  // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectActorTemplate">();
	}
	static class AFieldObjectActorTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldObjectActorTemplate>();
	}
};
static_assert(alignof(AFieldObjectActorTemplate) == 0x000008, "Wrong alignment on AFieldObjectActorTemplate");
static_assert(sizeof(AFieldObjectActorTemplate) == 0x000238, "Wrong size on AFieldObjectActorTemplate");
static_assert(offsetof(AFieldObjectActorTemplate, mIsAllowParkour) == 0x000230, "Member 'AFieldObjectActorTemplate::mIsAllowParkour' has a wrong offset!");
static_assert(offsetof(AFieldObjectActorTemplate, mIsAllowClimbing) == 0x000231, "Member 'AFieldObjectActorTemplate::mIsAllowClimbing' has a wrong offset!");

// Class DarwinGame.UIGlutGaugeBase
// 0x0028 (0x04B8 - 0x0490)
class UUIGlutGaugeBase : public UDarwinUserWidget
{
public:
	class UUIGlutGauge10XBase*                    Gauge1L;                                           // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGlutGauge10XBase*                    Gauge1C;                                           // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGlutGauge10XBase*                    Gauge1R;                                           // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGlutGauge10XBase*                    Gauge2L;                                           // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGlutGauge10XBase*                    Gauge2R;                                           // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlutGaugeBase">();
	}
	static class UUIGlutGaugeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlutGaugeBase>();
	}
};
static_assert(alignof(UUIGlutGaugeBase) == 0x000008, "Wrong alignment on UUIGlutGaugeBase");
static_assert(sizeof(UUIGlutGaugeBase) == 0x0004B8, "Wrong size on UUIGlutGaugeBase");
static_assert(offsetof(UUIGlutGaugeBase, Gauge1L) == 0x000490, "Member 'UUIGlutGaugeBase::Gauge1L' has a wrong offset!");
static_assert(offsetof(UUIGlutGaugeBase, Gauge1C) == 0x000498, "Member 'UUIGlutGaugeBase::Gauge1C' has a wrong offset!");
static_assert(offsetof(UUIGlutGaugeBase, Gauge1R) == 0x0004A0, "Member 'UUIGlutGaugeBase::Gauge1R' has a wrong offset!");
static_assert(offsetof(UUIGlutGaugeBase, Gauge2L) == 0x0004A8, "Member 'UUIGlutGaugeBase::Gauge2L' has a wrong offset!");
static_assert(offsetof(UUIGlutGaugeBase, Gauge2R) == 0x0004B0, "Member 'UUIGlutGaugeBase::Gauge2R' has a wrong offset!");

// Class DarwinGame.FieldObjectBase
// 0x0078 (0x02B0 - 0x0238)
class AFieldObjectBase : public AFieldObjectActorTemplate
{
public:
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AFieldComment*                          mFieldComment;                                     // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   mObjectId;                                         // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EObjectReactionType                           ReactionType;                                      // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261[0x4F];                                     // 0x0261(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoEventEndSubBP(const class FName& ID);
	void DoEventStartSubBP(const class FName& ID);
	void OnInitializeSub();
	void OnPauseSub();
	void OnReceiveEventSubBP(const struct FEventStruct& Info);
	void OnReceiveHitSubBP(EObjectEffectionEnum Type, class AActor* Inst);
	void OnResumeSub();
	void OnShowObject(bool IsShow);
	void Pause();
	void Resume();
	void SetActorHiddenInGameToAll(bool bNewHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectBase">();
	}
	static class AFieldObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldObjectBase>();
	}
};
static_assert(alignof(AFieldObjectBase) == 0x000008, "Wrong alignment on AFieldObjectBase");
static_assert(sizeof(AFieldObjectBase) == 0x0002B0, "Wrong size on AFieldObjectBase");
static_assert(offsetof(AFieldObjectBase, mFieldComment) == 0x000250, "Member 'AFieldObjectBase::mFieldComment' has a wrong offset!");
static_assert(offsetof(AFieldObjectBase, mObjectId) == 0x000258, "Member 'AFieldObjectBase::mObjectId' has a wrong offset!");
static_assert(offsetof(AFieldObjectBase, ReactionType) == 0x000260, "Member 'AFieldObjectBase::ReactionType' has a wrong offset!");

// Class DarwinGame.TrainBase
// 0x0070 (0x0320 - 0x02B0)
class ATrainBase : public AFieldObjectBase
{
public:
	bool                                          mIsDefaultRelease;                                 // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEffectBase>                mEngineEffectRes;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   mEngineEffectSocketName;                           // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   mEventID_A;                                        // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   mEventID_B;                                        // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mStepOpenFlag;                                     // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            mEngineEffect;                                     // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x38];                                     // 0x02E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToRail(const struct FVector& Location, const struct FVector& InboundVector);
	void m________________________2();
	void m________________________1();
	void m________________________0();
	void m_______________________();
	void SetRelease();
	void SetVisibleTrainRail();
	void TurnOnHeadLamp();

	struct FVector GetDoorLocation() const;
	struct FTransform GetStandPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainBase">();
	}
	static class ATrainBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainBase>();
	}
};
static_assert(alignof(ATrainBase) == 0x000008, "Wrong alignment on ATrainBase");
static_assert(sizeof(ATrainBase) == 0x000320, "Wrong size on ATrainBase");
static_assert(offsetof(ATrainBase, mIsDefaultRelease) == 0x0002B0, "Member 'ATrainBase::mIsDefaultRelease' has a wrong offset!");
static_assert(offsetof(ATrainBase, mEngineEffectRes) == 0x0002B8, "Member 'ATrainBase::mEngineEffectRes' has a wrong offset!");
static_assert(offsetof(ATrainBase, mEngineEffectSocketName) == 0x0002C0, "Member 'ATrainBase::mEngineEffectSocketName' has a wrong offset!");
static_assert(offsetof(ATrainBase, mEventID_A) == 0x0002C8, "Member 'ATrainBase::mEventID_A' has a wrong offset!");
static_assert(offsetof(ATrainBase, mEventID_B) == 0x0002D0, "Member 'ATrainBase::mEventID_B' has a wrong offset!");
static_assert(offsetof(ATrainBase, mStepOpenFlag) == 0x0002D8, "Member 'ATrainBase::mStepOpenFlag' has a wrong offset!");
static_assert(offsetof(ATrainBase, mEngineEffect) == 0x0002E0, "Member 'ATrainBase::mEngineEffect' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_TargetInRange
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_TargetInRange final : public UAnimNotifyState
{
public:
	float                                         mRange;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDurationTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TargetInRange">();
	}
	static class UAnimNotifyState_TargetInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TargetInRange>();
	}
};
static_assert(alignof(UAnimNotifyState_TargetInRange) == 0x000008, "Wrong alignment on UAnimNotifyState_TargetInRange");
static_assert(sizeof(UAnimNotifyState_TargetInRange) == 0x000048, "Wrong size on UAnimNotifyState_TargetInRange");
static_assert(offsetof(UAnimNotifyState_TargetInRange, mRange) == 0x000038, "Member 'UAnimNotifyState_TargetInRange::mRange' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TargetInRange, mDurationTime) == 0x00003C, "Member 'UAnimNotifyState_TargetInRange::mDurationTime' has a wrong offset!");

// Class DarwinGame.UIFreeScrollBase
// 0x0060 (0x04F0 - 0x0490)
class UUIFreeScrollBase : public UDarwinUserWidget
{
public:
	class FName                                   ScrollRootName;                                    // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaskAreaName;                                      // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScrollBarName;                                     // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScrollBaseName;                                    // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScrollSpeed;                                       // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                ScrollRoot;                                        // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MaskArea;                                          // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ScrollBarWidget;                                   // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ScrollBaseWidget;                                  // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFreeScrollBase">();
	}
	static class UUIFreeScrollBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFreeScrollBase>();
	}
};
static_assert(alignof(UUIFreeScrollBase) == 0x000008, "Wrong alignment on UUIFreeScrollBase");
static_assert(sizeof(UUIFreeScrollBase) == 0x0004F0, "Wrong size on UUIFreeScrollBase");
static_assert(offsetof(UUIFreeScrollBase, ScrollRootName) == 0x000490, "Member 'UUIFreeScrollBase::ScrollRootName' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, MaskAreaName) == 0x000498, "Member 'UUIFreeScrollBase::MaskAreaName' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, ScrollBarName) == 0x0004A0, "Member 'UUIFreeScrollBase::ScrollBarName' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, ScrollBaseName) == 0x0004A8, "Member 'UUIFreeScrollBase::ScrollBaseName' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, ScrollSpeed) == 0x0004B0, "Member 'UUIFreeScrollBase::ScrollSpeed' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, ScrollRoot) == 0x0004B8, "Member 'UUIFreeScrollBase::ScrollRoot' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, MaskArea) == 0x0004C0, "Member 'UUIFreeScrollBase::MaskArea' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, ScrollBarWidget) == 0x0004C8, "Member 'UUIFreeScrollBase::ScrollBarWidget' has a wrong offset!");
static_assert(offsetof(UUIFreeScrollBase, ScrollBaseWidget) == 0x0004D0, "Member 'UUIFreeScrollBase::ScrollBaseWidget' has a wrong offset!");

// Class DarwinGame.UIContentMenu_Page01
// 0x0010 (0x0500 - 0x04F0)
class UUIContentMenu_Page01 : public UUIFreeScrollBase
{
public:
	uint8                                         Pad_4F0[0x10];                                     // 0x04F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Page01">();
	}
	static class UUIContentMenu_Page01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Page01>();
	}
};
static_assert(alignof(UUIContentMenu_Page01) == 0x000008, "Wrong alignment on UUIContentMenu_Page01");
static_assert(sizeof(UUIContentMenu_Page01) == 0x000500, "Wrong size on UUIContentMenu_Page01");

// Class DarwinGame.ActionPointExamine
// 0x0010 (0x02C0 - 0x02B0)
class AActionPointExamine : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(EActionPointType Type, const class FName& gameFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPointExamine">();
	}
	static class AActionPointExamine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionPointExamine>();
	}
};
static_assert(alignof(AActionPointExamine) == 0x000008, "Wrong alignment on AActionPointExamine");
static_assert(sizeof(AActionPointExamine) == 0x0002C0, "Wrong size on AActionPointExamine");

// Class DarwinGame.ActionStateBase
// 0x0058 (0x0130 - 0x00D8)
class UActionStateBase : public UStateBase
{
public:
	struct FGameplayTagContainer                  CancelTags;                                        // 0x00D8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bExecuteWhenRigidTime;                             // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassInputToParallelState;                         // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x36];                                      // 0x00FA(0x0036)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enter_Abnormal();
	void Enter_Air();
	void Enter_Dive();
	void Enter_Ground();
	void Enter_Ride();
	void Enter_Water();
	void EnterWithResult(const struct FActionResult& InActionResult);
	const struct FActionResult GetActionResult();
	void Land();
	void OnLand();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateBase">();
	}
	static class UActionStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateBase>();
	}
};
static_assert(alignof(UActionStateBase) == 0x000008, "Wrong alignment on UActionStateBase");
static_assert(sizeof(UActionStateBase) == 0x000130, "Wrong size on UActionStateBase");
static_assert(offsetof(UActionStateBase, CancelTags) == 0x0000D8, "Member 'UActionStateBase::CancelTags' has a wrong offset!");
static_assert(offsetof(UActionStateBase, bExecuteWhenRigidTime) == 0x0000F8, "Member 'UActionStateBase::bExecuteWhenRigidTime' has a wrong offset!");
static_assert(offsetof(UActionStateBase, bPassInputToParallelState) == 0x0000F9, "Member 'UActionStateBase::bPassInputToParallelState' has a wrong offset!");

// Class DarwinGame.UIBoardmenu_WinItemUse
// 0x00E0 (0x06B0 - 0x05D0)
class UUIBoardmenu_WinItemUse final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIUseItemName*>                 UseItems;                                          // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0xC0];                                     // 0x05F0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_WinItemUse">();
	}
	static class UUIBoardmenu_WinItemUse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_WinItemUse>();
	}
};
static_assert(alignof(UUIBoardmenu_WinItemUse) == 0x000008, "Wrong alignment on UUIBoardmenu_WinItemUse");
static_assert(sizeof(UUIBoardmenu_WinItemUse) == 0x0006B0, "Wrong size on UUIBoardmenu_WinItemUse");
static_assert(offsetof(UUIBoardmenu_WinItemUse, UseItems) == 0x0005E0, "Member 'UUIBoardmenu_WinItemUse::UseItems' has a wrong offset!");

// Class DarwinGame.ActionTargetType
// 0x0000 (0x0030 - 0x0030)
class UActionTargetType : public UObject
{
public:
	void GetTargets(class AGPACharacter* TargetCharacter, class AActor* TargetActor, const struct FGameplayEventData& EventData, TArray<struct FHitResult>* OutHitResults, TArray<class AActor*>* OutActors) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionTargetType">();
	}
	static class UActionTargetType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionTargetType>();
	}
};
static_assert(alignof(UActionTargetType) == 0x000008, "Wrong alignment on UActionTargetType");
static_assert(sizeof(UActionTargetType) == 0x000030, "Wrong size on UActionTargetType");

// Class DarwinGame.ActionTargetType_UseOwner
// 0x0000 (0x0030 - 0x0030)
class UActionTargetType_UseOwner final : public UActionTargetType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionTargetType_UseOwner">();
	}
	static class UActionTargetType_UseOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionTargetType_UseOwner>();
	}
};
static_assert(alignof(UActionTargetType_UseOwner) == 0x000008, "Wrong alignment on UActionTargetType_UseOwner");
static_assert(sizeof(UActionTargetType_UseOwner) == 0x000030, "Wrong size on UActionTargetType_UseOwner");

// Class DarwinGame.GameDataAchievement
// 0x0010 (0x0040 - 0x0030)
class UGameDataAchievement final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataAchievement* Clone();
	void Overwrite(class UGameDataAchievement* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataAchievement">();
	}
	static class UGameDataAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataAchievement>();
	}
};
static_assert(alignof(UGameDataAchievement) == 0x000008, "Wrong alignment on UGameDataAchievement");
static_assert(sizeof(UGameDataAchievement) == 0x000040, "Wrong size on UGameDataAchievement");

// Class DarwinGame.AreaDataAsset
// 0x00A0 (0x00D8 - 0x0038)
class UAreaDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_AreaData>        list;                                              // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, TSubclassOf<class AEnvironmentEffectBase>> EnvEffectPairBPList;                               // 0x0088(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaDataAsset">();
	}
	static class UAreaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaDataAsset>();
	}
};
static_assert(alignof(UAreaDataAsset) == 0x000008, "Wrong alignment on UAreaDataAsset");
static_assert(sizeof(UAreaDataAsset) == 0x0000D8, "Wrong size on UAreaDataAsset");
static_assert(offsetof(UAreaDataAsset, list) == 0x000038, "Member 'UAreaDataAsset::list' has a wrong offset!");
static_assert(offsetof(UAreaDataAsset, EnvEffectPairBPList) == 0x000088, "Member 'UAreaDataAsset::EnvEffectPairBPList' has a wrong offset!");

// Class DarwinGame.TalkEventSystem
// 0x0138 (0x0168 - 0x0030)
class UTalkEventSystem : public UObject
{
public:
	class FName                                   PlayingEventID;                                    // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FST_EventTalkData                      EventTalkData;                                     // 0x0038(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	class FString                                 CurrentTextID;                                     // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 OldTextID;                                         // 0x0088(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NextTextID;                                        // 0x0098(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectIndex;                                       // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SelectCancel;                                      // 0x00A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentTalkerID;                                   // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 EventOwnerActor;                                   // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AGameCharacter*, bool>             ResetEmoteActorList;                               // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIEvent_FullScreenImage*               FullScreenImageWidget;                             // 0x0110(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGameCharacter*>                 ResetStampActorList;                               // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x40];                                     // 0x0128(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeNextText();
	void ClosePicture();
	void CloseTalkWindow();
	void EndTalkEvent();
	void GetTalkerActor(class AGPACharacter** Actor, bool* IsPlayer, class ANPCBase** NPCActor);
	bool IsCloseTalkWindow();
	bool IsOpenTalkWindow();
	void OnUtilityDelegateEvent(const class FString& CommandStr);
	void OpenTalkWindow(const class FString& TextID);
	void OpenTalkWindowForceText(const class FString& Text);
	void PutEmotionEffectOnTalker(EEmotionEffectID EmotionEffectID);
	void PutMotionOnTalker(ETextTalkEmotion EmotionID);
	void PutStampOnTalker(const EStampIconType StampID, const class FString& Option, const int32 LoopNum);
	void ResetActorEmote(const bool IsBodySkip);
	void ResetActorStamp();
	void SendSelectResult(int32 SendSelectIndex);
	void SetEventOwnerActor(class AActor* Actor);
	void SetTextWidgetData();
	void StartTalkEvent(const struct FST_EventData& EventData);

	bool IsSelectCancel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkEventSystem">();
	}
	static class UTalkEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTalkEventSystem>();
	}
};
static_assert(alignof(UTalkEventSystem) == 0x000008, "Wrong alignment on UTalkEventSystem");
static_assert(sizeof(UTalkEventSystem) == 0x000168, "Wrong size on UTalkEventSystem");
static_assert(offsetof(UTalkEventSystem, PlayingEventID) == 0x000030, "Member 'UTalkEventSystem::PlayingEventID' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, EventTalkData) == 0x000038, "Member 'UTalkEventSystem::EventTalkData' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, CurrentTextID) == 0x000078, "Member 'UTalkEventSystem::CurrentTextID' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, OldTextID) == 0x000088, "Member 'UTalkEventSystem::OldTextID' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, NextTextID) == 0x000098, "Member 'UTalkEventSystem::NextTextID' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, SelectIndex) == 0x0000A0, "Member 'UTalkEventSystem::SelectIndex' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, SelectCancel) == 0x0000A4, "Member 'UTalkEventSystem::SelectCancel' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, CurrentTalkerID) == 0x0000A8, "Member 'UTalkEventSystem::CurrentTalkerID' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, EventOwnerActor) == 0x0000B0, "Member 'UTalkEventSystem::EventOwnerActor' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, ResetEmoteActorList) == 0x0000B8, "Member 'UTalkEventSystem::ResetEmoteActorList' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, FullScreenImageWidget) == 0x000110, "Member 'UTalkEventSystem::FullScreenImageWidget' has a wrong offset!");
static_assert(offsetof(UTalkEventSystem, ResetStampActorList) == 0x000118, "Member 'UTalkEventSystem::ResetStampActorList' has a wrong offset!");

// Class DarwinGame.ActionTargetType_UseEventData
// 0x0000 (0x0030 - 0x0030)
class UActionTargetType_UseEventData final : public UActionTargetType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionTargetType_UseEventData">();
	}
	static class UActionTargetType_UseEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionTargetType_UseEventData>();
	}
};
static_assert(alignof(UActionTargetType_UseEventData) == 0x000008, "Wrong alignment on UActionTargetType_UseEventData");
static_assert(sizeof(UActionTargetType_UseEventData) == 0x000030, "Wrong size on UActionTargetType_UseEventData");

// Class DarwinGame.MagicBase
// 0x00C8 (0x02F0 - 0x0228)
class AMagicBase : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBattleSystemComponent*                 BattleSystem;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x20];                                     // 0x0238(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   actionDetailID;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActionGameplayEffectContainerSpec     EffectContainerSpec;                               // 0x0260(0x0038)(Edit, BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class USceneComponent*                        TargetComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x02A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShootAttackCollisionID;                            // 0x02AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRampageOnMagicAbility;                            // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B5[0x3B];                                     // 0x02B5(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckTerrainWithLineTrace(struct FHitResult* out_hit, const struct FVector& StartPos, const struct FVector& EndPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicBase">();
	}
	static class AMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagicBase>();
	}
};
static_assert(alignof(AMagicBase) == 0x000008, "Wrong alignment on AMagicBase");
static_assert(sizeof(AMagicBase) == 0x0002F0, "Wrong size on AMagicBase");
static_assert(offsetof(AMagicBase, BattleSystem) == 0x000230, "Member 'AMagicBase::BattleSystem' has a wrong offset!");
static_assert(offsetof(AMagicBase, actionDetailID) == 0x000258, "Member 'AMagicBase::actionDetailID' has a wrong offset!");
static_assert(offsetof(AMagicBase, EffectContainerSpec) == 0x000260, "Member 'AMagicBase::EffectContainerSpec' has a wrong offset!");
static_assert(offsetof(AMagicBase, TargetComponent) == 0x000298, "Member 'AMagicBase::TargetComponent' has a wrong offset!");
static_assert(offsetof(AMagicBase, TargetLocation) == 0x0002A0, "Member 'AMagicBase::TargetLocation' has a wrong offset!");
static_assert(offsetof(AMagicBase, ShootAttackCollisionID) == 0x0002AC, "Member 'AMagicBase::ShootAttackCollisionID' has a wrong offset!");
static_assert(offsetof(AMagicBase, bRampageOnMagicAbility) == 0x0002B4, "Member 'AMagicBase::bRampageOnMagicAbility' has a wrong offset!");

// Class DarwinGame.ActorDirectMagicBase
// 0x0068 (0x0358 - 0x02F0)
class AActorDirectMagicBase final : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicActorDirectType                         DirectType;                                        // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x5F];                                     // 0x02F9(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDirectMagicBase">();
	}
	static class AActorDirectMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorDirectMagicBase>();
	}
};
static_assert(alignof(AActorDirectMagicBase) == 0x000008, "Wrong alignment on AActorDirectMagicBase");
static_assert(sizeof(AActorDirectMagicBase) == 0x000358, "Wrong size on AActorDirectMagicBase");
static_assert(offsetof(AActorDirectMagicBase, collision) == 0x0002F0, "Member 'AActorDirectMagicBase::collision' has a wrong offset!");
static_assert(offsetof(AActorDirectMagicBase, DirectType) == 0x0002F8, "Member 'AActorDirectMagicBase::DirectType' has a wrong offset!");

// Class DarwinGame.SoundFadeComponentBase
// 0x0020 (0x0220 - 0x0200)
class USoundFadeComponentBase : public USceneComponent
{
public:
	uint8                                         Pad_200[0x20];                                     // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundFadeComponentBase">();
	}
	static class USoundFadeComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundFadeComponentBase>();
	}
};
static_assert(alignof(USoundFadeComponentBase) == 0x000010, "Wrong alignment on USoundFadeComponentBase");
static_assert(sizeof(USoundFadeComponentBase) == 0x000220, "Wrong size on USoundFadeComponentBase");

// Class DarwinGame.SideScrollTextBlock
// 0x0038 (0x0270 - 0x0238)
class USideScrollTextBlock : public UUserWidget
{
public:
	class UTextBlock*                             ScrollTextBlock;                                   // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIsActScroll;                                      // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIsStopAfterScroll;                                // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242[0x2];                                      // 0x0242(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mScrollSpeed;                                      // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mScrollStartSpan;                                  // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mScrollRestartSpan;                                // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mScrollEndAll;                                     // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIsNotExecNaitiveTickActScroll;                    // 0x0251(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252[0x1E];                                     // 0x0252(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SideScrollTextBlock">();
	}
	static class USideScrollTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<USideScrollTextBlock>();
	}
};
static_assert(alignof(USideScrollTextBlock) == 0x000008, "Wrong alignment on USideScrollTextBlock");
static_assert(sizeof(USideScrollTextBlock) == 0x000270, "Wrong size on USideScrollTextBlock");
static_assert(offsetof(USideScrollTextBlock, ScrollTextBlock) == 0x000238, "Member 'USideScrollTextBlock::ScrollTextBlock' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mIsActScroll) == 0x000240, "Member 'USideScrollTextBlock::mIsActScroll' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mIsStopAfterScroll) == 0x000241, "Member 'USideScrollTextBlock::mIsStopAfterScroll' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mScrollSpeed) == 0x000244, "Member 'USideScrollTextBlock::mScrollSpeed' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mScrollStartSpan) == 0x000248, "Member 'USideScrollTextBlock::mScrollStartSpan' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mScrollRestartSpan) == 0x00024C, "Member 'USideScrollTextBlock::mScrollRestartSpan' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mScrollEndAll) == 0x000250, "Member 'USideScrollTextBlock::mScrollEndAll' has a wrong offset!");
static_assert(offsetof(USideScrollTextBlock, mIsNotExecNaitiveTickActScroll) == 0x000251, "Member 'USideScrollTextBlock::mIsNotExecNaitiveTickActScroll' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ZoomUp
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_ZoomUp : public UAnimNotifyState
{
public:
	bool                                          mIsCheckShelter;                                   // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsCheckHight;                                     // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsPulloutFlag;                                    // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mCheckHightNG;                                     // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDestAngle() const;
	float GetDestLength() const;
	float GetDestYaw() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ZoomUp">();
	}
	static class UAnimNotifyState_ZoomUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ZoomUp>();
	}
};
static_assert(alignof(UAnimNotifyState_ZoomUp) == 0x000008, "Wrong alignment on UAnimNotifyState_ZoomUp");
static_assert(sizeof(UAnimNotifyState_ZoomUp) == 0x000040, "Wrong size on UAnimNotifyState_ZoomUp");
static_assert(offsetof(UAnimNotifyState_ZoomUp, mIsCheckShelter) == 0x000038, "Member 'UAnimNotifyState_ZoomUp::mIsCheckShelter' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ZoomUp, mIsCheckHight) == 0x000039, "Member 'UAnimNotifyState_ZoomUp::mIsCheckHight' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ZoomUp, mIsPulloutFlag) == 0x00003A, "Member 'UAnimNotifyState_ZoomUp::mIsPulloutFlag' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ZoomUp, mCheckHightNG) == 0x00003B, "Member 'UAnimNotifyState_ZoomUp::mCheckHightNG' has a wrong offset!");

// Class DarwinGame.UIBoardmenu_Total
// 0x0028 (0x04B8 - 0x0490)
class UUIBoardmenu_Total final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x28];                                     // 0x0490(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_Total">();
	}
	static class UUIBoardmenu_Total* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_Total>();
	}
};
static_assert(alignof(UUIBoardmenu_Total) == 0x000008, "Wrong alignment on UUIBoardmenu_Total");
static_assert(sizeof(UUIBoardmenu_Total) == 0x0004B8, "Wrong size on UUIBoardmenu_Total");

// Class DarwinGame.ACVolumeFadeComponent
// 0x0010 (0x0230 - 0x0220)
class UACVolumeFadeComponent final : public USoundFadeComponentBase
{
public:
	class UAtomComponent*                         TargetAtomComp;                                    // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESFadeOutEndState                             mFadeOutEndState;                                  // 0x0228(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ACVolumeFadeComponent">();
	}
	static class UACVolumeFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UACVolumeFadeComponent>();
	}
};
static_assert(alignof(UACVolumeFadeComponent) == 0x000010, "Wrong alignment on UACVolumeFadeComponent");
static_assert(sizeof(UACVolumeFadeComponent) == 0x000230, "Wrong size on UACVolumeFadeComponent");
static_assert(offsetof(UACVolumeFadeComponent, TargetAtomComp) == 0x000220, "Member 'UACVolumeFadeComponent::TargetAtomComp' has a wrong offset!");
static_assert(offsetof(UACVolumeFadeComponent, mFadeOutEndState) == 0x000228, "Member 'UACVolumeFadeComponent::mFadeOutEndState' has a wrong offset!");

// Class DarwinGame.AddOnContentMasterDataTable
// 0x0000 (0x0030 - 0x0030)
class UAddOnContentMasterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddOnContentMasterDataTable">();
	}
	static class UAddOnContentMasterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddOnContentMasterDataTable>();
	}
};
static_assert(alignof(UAddOnContentMasterDataTable) == 0x000008, "Wrong alignment on UAddOnContentMasterDataTable");
static_assert(sizeof(UAddOnContentMasterDataTable) == 0x000030, "Wrong size on UAddOnContentMasterDataTable");

// Class DarwinGame.UIButtonMapping
// 0x00B0 (0x05E0 - 0x0530)
class UUIButtonMapping : public UUIScrollMenuItemBase
{
public:
	class UTexture2D*                             DefaultIcon;                                       // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EButtonBaseMapping, class UTexture2D*>   ButtonBaseIcons;                                   // 0x0538(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UDataTable*                             ButtonIconDataTable;                               // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_590[0x50];                                     // 0x0590(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIButtonMapping">();
	}
	static class UUIButtonMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIButtonMapping>();
	}
};
static_assert(alignof(UUIButtonMapping) == 0x000008, "Wrong alignment on UUIButtonMapping");
static_assert(sizeof(UUIButtonMapping) == 0x0005E0, "Wrong size on UUIButtonMapping");
static_assert(offsetof(UUIButtonMapping, DefaultIcon) == 0x000530, "Member 'UUIButtonMapping::DefaultIcon' has a wrong offset!");
static_assert(offsetof(UUIButtonMapping, ButtonBaseIcons) == 0x000538, "Member 'UUIButtonMapping::ButtonBaseIcons' has a wrong offset!");
static_assert(offsetof(UUIButtonMapping, ButtonIconDataTable) == 0x000588, "Member 'UUIButtonMapping::ButtonIconDataTable' has a wrong offset!");

// Class DarwinGame.AddOnContentRewardGroupDataTable
// 0x0000 (0x0030 - 0x0030)
class UAddOnContentRewardGroupDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddOnContentRewardGroupDataTable">();
	}
	static class UAddOnContentRewardGroupDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddOnContentRewardGroupDataTable>();
	}
};
static_assert(alignof(UAddOnContentRewardGroupDataTable) == 0x000008, "Wrong alignment on UAddOnContentRewardGroupDataTable");
static_assert(sizeof(UAddOnContentRewardGroupDataTable) == 0x000030, "Wrong size on UAddOnContentRewardGroupDataTable");

// Class DarwinGame.DamageElementCapsuleComponent
// 0x0020 (0x0460 - 0x0440)
class UDamageElementCapsuleComponent : public UCapsuleComponent
{
public:
	struct FDamagePointParameter                  DamageParam;                                       // 0x0440(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bNeverTargeted;                                    // 0x0450(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCenter;                                           // 0x0451(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotPenetrate;                                     // 0x0452(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMustAimed;                                        // 0x0453(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreAimSelectableList;                          // 0x0454(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mAimWeight;                                        // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageElementCapsuleComponent">();
	}
	static class UDamageElementCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageElementCapsuleComponent>();
	}
};
static_assert(alignof(UDamageElementCapsuleComponent) == 0x000010, "Wrong alignment on UDamageElementCapsuleComponent");
static_assert(sizeof(UDamageElementCapsuleComponent) == 0x000460, "Wrong size on UDamageElementCapsuleComponent");
static_assert(offsetof(UDamageElementCapsuleComponent, DamageParam) == 0x000440, "Member 'UDamageElementCapsuleComponent::DamageParam' has a wrong offset!");
static_assert(offsetof(UDamageElementCapsuleComponent, bNeverTargeted) == 0x000450, "Member 'UDamageElementCapsuleComponent::bNeverTargeted' has a wrong offset!");
static_assert(offsetof(UDamageElementCapsuleComponent, bCenter) == 0x000451, "Member 'UDamageElementCapsuleComponent::bCenter' has a wrong offset!");
static_assert(offsetof(UDamageElementCapsuleComponent, bNotPenetrate) == 0x000452, "Member 'UDamageElementCapsuleComponent::bNotPenetrate' has a wrong offset!");
static_assert(offsetof(UDamageElementCapsuleComponent, bMustAimed) == 0x000453, "Member 'UDamageElementCapsuleComponent::bMustAimed' has a wrong offset!");
static_assert(offsetof(UDamageElementCapsuleComponent, bIgnoreAimSelectableList) == 0x000454, "Member 'UDamageElementCapsuleComponent::bIgnoreAimSelectableList' has a wrong offset!");
static_assert(offsetof(UDamageElementCapsuleComponent, mAimWeight) == 0x000458, "Member 'UDamageElementCapsuleComponent::mAimWeight' has a wrong offset!");

// Class DarwinGame.AreaFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UAreaFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetErosionCorrection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaFunctionLibrary">();
	}
	static class UAreaFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaFunctionLibrary>();
	}
};
static_assert(alignof(UAreaFunctionLibrary) == 0x000008, "Wrong alignment on UAreaFunctionLibrary");
static_assert(sizeof(UAreaFunctionLibrary) == 0x000030, "Wrong size on UAreaFunctionLibrary");

// Class DarwinGame.MonsterBattleAICheckFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAICheckFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAICheckFunctionLibrary">();
	}
	static class UMonsterBattleAICheckFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAICheckFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAICheckFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAICheckFunctionLibrary");
static_assert(sizeof(UMonsterBattleAICheckFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAICheckFunctionLibrary");

// Class DarwinGame.StationTank
// 0x0020 (0x02D0 - 0x02B0)
class AStationTank final : public AFieldObjectBase
{
public:
	class FName                                   mStationID;                                        // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AEffectBase>                mEffectRef;                                        // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mLocationName;                                     // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetReflectionRelease();
	void SetReflectionSeal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationTank">();
	}
	static class AStationTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStationTank>();
	}
};
static_assert(alignof(AStationTank) == 0x000008, "Wrong alignment on AStationTank");
static_assert(sizeof(AStationTank) == 0x0002D0, "Wrong size on AStationTank");
static_assert(offsetof(AStationTank, mStationID) == 0x0002B0, "Member 'AStationTank::mStationID' has a wrong offset!");
static_assert(offsetof(AStationTank, mEffectRef) == 0x0002B8, "Member 'AStationTank::mEffectRef' has a wrong offset!");
static_assert(offsetof(AStationTank, mLocationName) == 0x0002C0, "Member 'AStationTank::mLocationName' has a wrong offset!");

// Class DarwinGame.AimTargetComponent
// 0x0000 (0x0460 - 0x0460)
class UAimTargetComponent final : public UDamageElementCapsuleComponent
{
public:
	void SetAimEnabled(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimTargetComponent">();
	}
	static class UAimTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimTargetComponent>();
	}
};
static_assert(alignof(UAimTargetComponent) == 0x000010, "Wrong alignment on UAimTargetComponent");
static_assert(sizeof(UAimTargetComponent) == 0x000460, "Wrong size on UAimTargetComponent");

// Class DarwinGame.GameDataHistory
// 0x0288 (0x02B8 - 0x0030)
class UGameDataHistory final : public UObject
{
public:
	uint8                                         Pad_30[0x288];                                     // 0x0030(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttackCount(const class FName& ID);
	void AddDefeatedMonsterCount(const class FName& KindId, int32 Count);
	void AddFriendMonsterCount(const class FName& KindId, int32 Count);
	void AddItemBuyCount(const class FName& ItemId, int32 Count);
	void AddItemCollectionCount(const class FName& ItemId, EAreaType AreaType, int32 Count);
	void AddItemGetCount(const class FName& ItemId, int32 Count);
	void AddItemMakeCount(const class FName& ItemId, int32 Count);
	void AddItemSellCount(const class FName& ItemId, int32 Count);
	void AddItemUseToEnemyCount(const class FName& ItemId, const class FName& KindId, int32 Count);
	void AddItemUseToFriendCount(const class FName& ItemId, const class FName& KindId, int32 Count);
	void AddItemUseToMeCount(const class FName& ItemId, int32 Count);
	void AddKillMonsterCount(const class FName& KindId, int32 Count);
	void AddKillNightmareMonsterCount(const class FName& KindId, int32 Count);
	void AddPlayerActionCount(const class FName& ID);
	void AddPlayerActionNum(const class FName& ID, const int32 Num);
	void AddRivalTeamKillCount(ERivalTeamForce RivalTeam, int32 Num);
	void AddScoutMonsterCount(const class FName& KindId, int32 Count);
	void AddStealMonsterCount(const class FName& KindId, int32 Count);
	void ArrivalDestinationRect(const class FName& QuestID);
	class UGameDataHistory* Clone();
	void Overwrite(class UGameDataHistory* game_data);
	void ResetDestinationRect(const class FName& QuestID);

	const int32 GetAttackCount(const class FName& ID) const;
	int32 GetDefeatedMonsterCount(const class FName& KindId) const;
	TArray<class FName> GetDictMonsters() const;
	int32 GetFriendMonsterCount(const class FName& KindId) const;
	int32 GetFriendMonsterCountAll() const;
	TMap<class FName, int32> GetFriendMonsterCountMap() const;
	int32 GetItemBuyCount(const class FName& ItemId) const;
	TMap<class FName, int32> GetItemBuyCountMap() const;
	TMap<class FName, struct FItemCollection> GetItemCollectionCountMap() const;
	int32 GetItemGetCount(const class FName& ItemId) const;
	TMap<class FName, int32> GetItemGetCountMap() const;
	int32 GetItemMakeCount(const class FName& ItemId) const;
	TMap<class FName, int32> GetItemMakeCountMap() const;
	int32 GetItemSellCount(const class FName& ItemId) const;
	TMap<class FName, int32> GetItemSellCountMap() const;
	TArray<class FName> GetItemsGet() const;
	int32 GetItemUseToEnemyCount(const class FName& ItemId, const class FName& KindId) const;
	int32 GetItemUseToEnemyCountAllItem(const class FName& KindId) const;
	int32 GetItemUseToEnemyCountAllItemOfType(const class FName& KindId, EItemDataType Type) const;
	int32 GetItemUseToEnemyCountAllMonster(const class FName& ItemId) const;
	TMap<class FName, int32> GetItemUseToEnemyCountDetail(const class FName& ItemId) const;
	TMap<class FName, struct FItemUseToMonster> GetItemUseToEnemyCountMap() const;
	TMap<class FName, struct FItemUseToMonster> GetItemUseToFriendCountMap() const;
	int32 GetItemUseToMeCount(const class FName& ItemId) const;
	TMap<class FName, int32> GetItemUseToMeCountMap() const;
	int32 GetKilledMonsterCount(const class FName& KindId) const;
	int32 GetKilledMonsterCountAll() const;
	TMap<class FName, int32> GetKilledMonsterCountMap() const;
	int32 GetKilledNightmareMonsterCount(const class FName& KindId) const;
	int32 GetKilledNightmareMonsterCountAll() const;
	TMap<class FName, int32> GetKilledNightmareMonsterCountMap() const;
	const int32 GetPlayerActionCount(const class FName& ID) const;
	TArray<class FName> GetRegisteredKindIDList() const;
	int32 GetRivalTeamKillCount(ERivalTeamForce RivalTeam) const;
	TMap<ERivalTeamForce, int32> GetRivalTeamKillCountTMap() const;
	int32 GetScoutedMonsterCount(const class FName& KindId) const;
	int32 GetScoutedMonsterCountAll() const;
	TMap<class FName, int32> GetScoutedMonsterCountMap() const;
	int32 GetStealedMonsterCount(const class FName& KindId) const;
	int32 GetStealedMonsterCountAll() const;
	TMap<class FName, int32> GetStealedMonsterCountMap() const;
	bool IsBuyItem(const class FName& ItemId) const;
	bool IsDefeatedMonster(const class FName& KindId) const;
	bool IsDestinationRect(const class FName& QuestID) const;
	bool IsDictMonster(const class FName& KindId) const;
	bool IsFriendMonster(const class FName& KindId) const;
	bool IsGetItem(const class FName& ItemId) const;
	bool IsKilledMonster(const class FName& KindId) const;
	bool IsKilledNightmareMonster(const class FName& KindId) const;
	bool IsMakeItem(const class FName& ItemId) const;
	bool IsRegisterItem(const class FName& ItemId) const;
	bool IsRegisterMonster(const class FName& KindId) const;
	bool IsRegisterRivalTeam(ERivalTeamForce RivalTeam) const;
	bool IsScoutedMonster(const class FName& KindId) const;
	bool IsSellItem(const class FName& ItemId) const;
	bool IsStealedMonster(const class FName& KindId) const;
	bool IsUseItemToEnemy(const class FName& ItemId) const;
	bool IsUseItemToFriend(const class FName& ItemId) const;
	bool IsUseItemToMe(const class FName& ItemId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataHistory">();
	}
	static class UGameDataHistory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataHistory>();
	}
};
static_assert(alignof(UGameDataHistory) == 0x000008, "Wrong alignment on UGameDataHistory");
static_assert(sizeof(UGameDataHistory) == 0x0002B8, "Wrong size on UGameDataHistory");

// Class DarwinGame.AirShipBase
// 0x0008 (0x02B8 - 0x02B0)
class AAirShipBase final : public AFieldObjectBase
{
public:
	EAIR_SHIP_MODE                                mMode;                                             // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAIR_SHIP_GATE                                mGate;                                             // 0x02B1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCollisionEnable(bool enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirShipBase">();
	}
	static class AAirShipBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAirShipBase>();
	}
};
static_assert(alignof(AAirShipBase) == 0x000008, "Wrong alignment on AAirShipBase");
static_assert(sizeof(AAirShipBase) == 0x0002B8, "Wrong size on AAirShipBase");
static_assert(offsetof(AAirShipBase, mMode) == 0x0002B0, "Member 'AAirShipBase::mMode' has a wrong offset!");
static_assert(offsetof(AAirShipBase, mGate) == 0x0002B1, "Member 'AAirShipBase::mGate' has a wrong offset!");

// Class DarwinGame.SkillChainSystemComponent
// 0x0088 (0x0140 - 0x00B8)
class USkillChainSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASkillChainDirector*>            mDirectorList;                                     // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGPACharacter*                          mInvoker;                                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGPACharacter*                          mTarget;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x60];                                      // 0x00E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PauseChain();
	void ResumeChain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChainSystemComponent">();
	}
	static class USkillChainSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillChainSystemComponent>();
	}
};
static_assert(alignof(USkillChainSystemComponent) == 0x000008, "Wrong alignment on USkillChainSystemComponent");
static_assert(sizeof(USkillChainSystemComponent) == 0x000140, "Wrong size on USkillChainSystemComponent");
static_assert(offsetof(USkillChainSystemComponent, mDirectorList) == 0x0000C0, "Member 'USkillChainSystemComponent::mDirectorList' has a wrong offset!");
static_assert(offsetof(USkillChainSystemComponent, mInvoker) == 0x0000D0, "Member 'USkillChainSystemComponent::mInvoker' has a wrong offset!");
static_assert(offsetof(USkillChainSystemComponent, mTarget) == 0x0000D8, "Member 'USkillChainSystemComponent::mTarget' has a wrong offset!");

// Class DarwinGame.ApplyStatusRequirement
// 0x0000 (0x0030 - 0x0030)
class UApplyStatusRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplyStatusRequirement">();
	}
	static class UApplyStatusRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplyStatusRequirement>();
	}
};
static_assert(alignof(UApplyStatusRequirement) == 0x000008, "Wrong alignment on UApplyStatusRequirement");
static_assert(sizeof(UApplyStatusRequirement) == 0x000030, "Wrong size on UApplyStatusRequirement");

// Class DarwinGame.UIResidentWidgetBase
// 0x0000 (0x0490 - 0x0490)
class UUIResidentWidgetBase : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIResidentWidgetBase">();
	}
	static class UUIResidentWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIResidentWidgetBase>();
	}
};
static_assert(alignof(UUIResidentWidgetBase) == 0x000008, "Wrong alignment on UUIResidentWidgetBase");
static_assert(sizeof(UUIResidentWidgetBase) == 0x000490, "Wrong size on UUIResidentWidgetBase");

// Class DarwinGame.UIBrightness
// 0x0018 (0x04A8 - 0x0490)
class UUIBrightness : public UUIResidentWidgetBase
{
public:
	class UTexture2D*                             BrightnessImage;                                   // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DarknessImage;                                     // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image;                                             // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrightness">();
	}
	static class UUIBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrightness>();
	}
};
static_assert(alignof(UUIBrightness) == 0x000008, "Wrong alignment on UUIBrightness");
static_assert(sizeof(UUIBrightness) == 0x0004A8, "Wrong size on UUIBrightness");
static_assert(offsetof(UUIBrightness, BrightnessImage) == 0x000490, "Member 'UUIBrightness::BrightnessImage' has a wrong offset!");
static_assert(offsetof(UUIBrightness, DarknessImage) == 0x000498, "Member 'UUIBrightness::DarknessImage' has a wrong offset!");
static_assert(offsetof(UUIBrightness, Image) == 0x0004A0, "Member 'UUIBrightness::Image' has a wrong offset!");

// Class DarwinGame.AirStateBase
// 0x0010 (0x0180 - 0x0170)
class UAirStateBase : public UMoveStateBase
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVelocity(const struct FVector& Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateBase">();
	}
	static class UAirStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateBase>();
	}
};
static_assert(alignof(UAirStateBase) == 0x000008, "Wrong alignment on UAirStateBase");
static_assert(sizeof(UAirStateBase) == 0x000180, "Wrong size on UAirStateBase");

// Class DarwinGame.DarwinAbilitySystemGlobals
// 0x0000 (0x0268 - 0x0268)
class UDarwinAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinAbilitySystemGlobals">();
	}
	static class UDarwinAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinAbilitySystemGlobals>();
	}
};
static_assert(alignof(UDarwinAbilitySystemGlobals) == 0x000008, "Wrong alignment on UDarwinAbilitySystemGlobals");
static_assert(sizeof(UDarwinAbilitySystemGlobals) == 0x000268, "Wrong size on UDarwinAbilitySystemGlobals");

// Class DarwinGame.AirStateFly
// 0x0000 (0x0180 - 0x0180)
class UAirStateFly final : public UAirStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateFly">();
	}
	static class UAirStateFly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateFly>();
	}
};
static_assert(alignof(UAirStateFly) == 0x000008, "Wrong alignment on UAirStateFly");
static_assert(sizeof(UAirStateFly) == 0x000180, "Wrong size on UAirStateFly");

// Class DarwinGame.BelongingInterface
// 0x0000 (0x0030 - 0x0030)
class IBelongingInterface final : public IInterface
{
public:
	struct FGameplayTag GetBelonging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BelongingInterface">();
	}
	static class IBelongingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBelongingInterface>();
	}
};
static_assert(alignof(IBelongingInterface) == 0x000008, "Wrong alignment on IBelongingInterface");
static_assert(sizeof(IBelongingInterface) == 0x000030, "Wrong size on IBelongingInterface");

// Class DarwinGame.UILeftMenuBase
// 0x0080 (0x0650 - 0x05D0)
class UUILeftMenuBase : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultHeaderType;                                 // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_LeftMenuSetting>            DefaultSetting;                                    // 0x05F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_LeftMenuTypePartsData>      PartsData;                                         // 0x0600(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0x24];                                     // 0x0610(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsUseArrowWidget;                                  // 0x0634(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_635[0x3];                                      // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPartyMenu_BG*                        PartyMenu_BG;                                      // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILeftMenuUseBase*                     Parent;                                            // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenuBase">();
	}
	static class UUILeftMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenuBase>();
	}
};
static_assert(alignof(UUILeftMenuBase) == 0x000008, "Wrong alignment on UUILeftMenuBase");
static_assert(sizeof(UUILeftMenuBase) == 0x000650, "Wrong size on UUILeftMenuBase");
static_assert(offsetof(UUILeftMenuBase, DefaultHeaderType) == 0x0005E8, "Member 'UUILeftMenuBase::DefaultHeaderType' has a wrong offset!");
static_assert(offsetof(UUILeftMenuBase, DefaultSetting) == 0x0005F0, "Member 'UUILeftMenuBase::DefaultSetting' has a wrong offset!");
static_assert(offsetof(UUILeftMenuBase, PartsData) == 0x000600, "Member 'UUILeftMenuBase::PartsData' has a wrong offset!");
static_assert(offsetof(UUILeftMenuBase, IsUseArrowWidget) == 0x000634, "Member 'UUILeftMenuBase::IsUseArrowWidget' has a wrong offset!");
static_assert(offsetof(UUILeftMenuBase, PartyMenu_BG) == 0x000638, "Member 'UUILeftMenuBase::PartyMenu_BG' has a wrong offset!");
static_assert(offsetof(UUILeftMenuBase, Parent) == 0x000640, "Member 'UUILeftMenuBase::Parent' has a wrong offset!");

// Class DarwinGame.UILeftMenu_7
// 0x0030 (0x0680 - 0x0650)
class UUILeftMenu_7 : public UUILeftMenuBase
{
public:
	TArray<struct FST_LeftMenu_7_UpDownDelta>     UpDownDeltaArray;                                  // 0x0650(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_660[0x20];                                     // 0x0660(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_7">();
	}
	static class UUILeftMenu_7* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_7>();
	}
};
static_assert(alignof(UUILeftMenu_7) == 0x000008, "Wrong alignment on UUILeftMenu_7");
static_assert(sizeof(UUILeftMenu_7) == 0x000680, "Wrong size on UUILeftMenu_7");
static_assert(offsetof(UUILeftMenu_7, UpDownDeltaArray) == 0x000650, "Member 'UUILeftMenu_7::UpDownDeltaArray' has a wrong offset!");

// Class DarwinGame.UIDelivery_ItemPanel_Gold
// 0x0000 (0x0490 - 0x0490)
class UUIDelivery_ItemPanel_Gold final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_ItemPanel_Gold">();
	}
	static class UUIDelivery_ItemPanel_Gold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_ItemPanel_Gold>();
	}
};
static_assert(alignof(UUIDelivery_ItemPanel_Gold) == 0x000008, "Wrong alignment on UUIDelivery_ItemPanel_Gold");
static_assert(sizeof(UUIDelivery_ItemPanel_Gold) == 0x000490, "Wrong size on UUIDelivery_ItemPanel_Gold");

// Class DarwinGame.AirStateGlide
// 0x0078 (0x01F8 - 0x0180)
class UAirStateGlide final : public UAirStateBase
{
public:
	uint8                                         Pad_180[0x48];                                     // 0x0180(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEffectBase*>                    mTrailEffects;                                     // 0x01C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEffectBase*>                    mEletrialEffects;                                  // 0x01D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateGlide">();
	}
	static class UAirStateGlide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateGlide>();
	}
};
static_assert(alignof(UAirStateGlide) == 0x000008, "Wrong alignment on UAirStateGlide");
static_assert(sizeof(UAirStateGlide) == 0x0001F8, "Wrong size on UAirStateGlide");
static_assert(offsetof(UAirStateGlide, mTrailEffects) == 0x0001C8, "Member 'UAirStateGlide::mTrailEffects' has a wrong offset!");
static_assert(offsetof(UAirStateGlide, mEletrialEffects) == 0x0001D8, "Member 'UAirStateGlide::mEletrialEffects' has a wrong offset!");

// Class DarwinGame.AirStateJump
// 0x0010 (0x0190 - 0x0180)
class UAirStateJump : public UAirStateBase
{
public:
	struct FVector                                mJumpVelocity;                                     // 0x0180(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Jump();

	struct FVector CalculateJumpVelocity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateJump">();
	}
	static class UAirStateJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateJump>();
	}
};
static_assert(alignof(UAirStateJump) == 0x000008, "Wrong alignment on UAirStateJump");
static_assert(sizeof(UAirStateJump) == 0x000190, "Wrong size on UAirStateJump");
static_assert(offsetof(UAirStateJump, mJumpVelocity) == 0x000180, "Member 'UAirStateJump::mJumpVelocity' has a wrong offset!");

// Class DarwinGame.GiraNoLaserMagicBase
// 0x0070 (0x0360 - 0x02F0)
class AGiraNoLaserMagicBase final : public AMagicBase
{
public:
	uint8                                         Pad_2F0[0x70];                                     // 0x02F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GiraNoLaserMagicBase">();
	}
	static class AGiraNoLaserMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGiraNoLaserMagicBase>();
	}
};
static_assert(alignof(AGiraNoLaserMagicBase) == 0x000008, "Wrong alignment on AGiraNoLaserMagicBase");
static_assert(sizeof(AGiraNoLaserMagicBase) == 0x000360, "Wrong size on AGiraNoLaserMagicBase");

// Class DarwinGame.UIWinMenuCloseOnly
// 0x0020 (0x05F0 - 0x05D0)
class UUIWinMenuCloseOnly : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextDescription;                                   // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIIconChoice*                          Button;                                            // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenuCloseOnly">();
	}
	static class UUIWinMenuCloseOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenuCloseOnly>();
	}
};
static_assert(alignof(UUIWinMenuCloseOnly) == 0x000008, "Wrong alignment on UUIWinMenuCloseOnly");
static_assert(sizeof(UUIWinMenuCloseOnly) == 0x0005F0, "Wrong size on UUIWinMenuCloseOnly");
static_assert(offsetof(UUIWinMenuCloseOnly, TextDescription) == 0x0005E0, "Member 'UUIWinMenuCloseOnly::TextDescription' has a wrong offset!");
static_assert(offsetof(UUIWinMenuCloseOnly, Button) == 0x0005E8, "Member 'UUIWinMenuCloseOnly::Button' has a wrong offset!");

// Class DarwinGame.SceneCaptureBase
// 0x0130 (0x0370 - 0x0240)
class alignas(0x10) ASceneCaptureBase : public ASceneCapture2D
{
public:
	TSoftClassPtr<class UClass>                   PlayerClass;                                       // 0x0240(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGPACharacter*                          CharacterActor;                                    // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEstimateTreasureObjectBase*            EstimateArtifact;                                  // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATreasureFigureObject*                  ArtifactActor;                                     // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        MyArtifactObjectPath;                              // 0x0280(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESceneCaptureAdjust                           AdjustType;                                        // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutLineWidth;                                      // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEstimateBackPanel>         BackPanelRes;                                      // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEstimateBackPanel*                     BackPanel;                                         // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BasePosition;                                      // 0x02C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x44];                                     // 0x02D4(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           LightActorList;                                    // 0x0318(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         LightActors;                                       // 0x0328(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x38];                                     // 0x0338(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AGPACharacter* GetCharacterActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureBase">();
	}
	static class ASceneCaptureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneCaptureBase>();
	}
};
static_assert(alignof(ASceneCaptureBase) == 0x000010, "Wrong alignment on ASceneCaptureBase");
static_assert(sizeof(ASceneCaptureBase) == 0x000370, "Wrong size on ASceneCaptureBase");
static_assert(offsetof(ASceneCaptureBase, PlayerClass) == 0x000240, "Member 'ASceneCaptureBase::PlayerClass' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, CharacterActor) == 0x000268, "Member 'ASceneCaptureBase::CharacterActor' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, EstimateArtifact) == 0x000270, "Member 'ASceneCaptureBase::EstimateArtifact' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, ArtifactActor) == 0x000278, "Member 'ASceneCaptureBase::ArtifactActor' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, MyArtifactObjectPath) == 0x000280, "Member 'ASceneCaptureBase::MyArtifactObjectPath' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, AdjustType) == 0x000298, "Member 'ASceneCaptureBase::AdjustType' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, OutLineWidth) == 0x00029C, "Member 'ASceneCaptureBase::OutLineWidth' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, BackPanelRes) == 0x0002A0, "Member 'ASceneCaptureBase::BackPanelRes' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, BackPanel) == 0x0002A8, "Member 'ASceneCaptureBase::BackPanel' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, BasePosition) == 0x0002C8, "Member 'ASceneCaptureBase::BasePosition' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, LightActorList) == 0x000318, "Member 'ASceneCaptureBase::LightActorList' has a wrong offset!");
static_assert(offsetof(ASceneCaptureBase, LightActors) == 0x000328, "Member 'ASceneCaptureBase::LightActors' has a wrong offset!");

// Class DarwinGame.AirStateLand
// 0x0000 (0x0180 - 0x0180)
class UAirStateLand final : public UAirStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateLand">();
	}
	static class UAirStateLand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateLand>();
	}
};
static_assert(alignof(UAirStateLand) == 0x000008, "Wrong alignment on UAirStateLand");
static_assert(sizeof(UAirStateLand) == 0x000180, "Wrong size on UAirStateLand");

// Class DarwinGame.AirStateStartBeast
// 0x0010 (0x01A0 - 0x0190)
class UAirStateStartBeast : public UAirStateJump
{
public:
	float                                         JumpHeight;                                        // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateStartBeast">();
	}
	static class UAirStateStartBeast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateStartBeast>();
	}
};
static_assert(alignof(UAirStateStartBeast) == 0x000008, "Wrong alignment on UAirStateStartBeast");
static_assert(sizeof(UAirStateStartBeast) == 0x0001A0, "Wrong size on UAirStateStartBeast");
static_assert(offsetof(UAirStateStartBeast, JumpHeight) == 0x000190, "Member 'UAirStateStartBeast::JumpHeight' has a wrong offset!");
static_assert(offsetof(UAirStateStartBeast, GravityScale) == 0x000198, "Member 'UAirStateStartBeast::GravityScale' has a wrong offset!");

// Class DarwinGame.UIArtifact_Warehouse
// 0x0120 (0x06F0 - 0x05D0)
class alignas(0x10) UUIArtifact_Warehouse final : public UUIScrollMenuBase
{
public:
	class UTextBlock*                             ArtifactNumText;                                   // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AssetsText;                                        // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundImage;                                   // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UnderButtonDescription;                            // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIMy_Artifact_Panel*>           ArtifactPanelList;                                 // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_WarehouseBackGroundData>    BackGroundDatas;                                   // 0x0600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ERivalTeamForce, TSoftObjectPtr<class UTexture2D>> FlagTextureDataList;                               // 0x0610(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UUITreasureHouse_Table*                 TreasureHouse;                                     // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0x88];                                     // 0x0668(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPedestalIndex(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifact_Warehouse">();
	}
	static class UUIArtifact_Warehouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifact_Warehouse>();
	}
};
static_assert(alignof(UUIArtifact_Warehouse) == 0x000010, "Wrong alignment on UUIArtifact_Warehouse");
static_assert(sizeof(UUIArtifact_Warehouse) == 0x0006F0, "Wrong size on UUIArtifact_Warehouse");
static_assert(offsetof(UUIArtifact_Warehouse, ArtifactNumText) == 0x0005D0, "Member 'UUIArtifact_Warehouse::ArtifactNumText' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, AssetsText) == 0x0005D8, "Member 'UUIArtifact_Warehouse::AssetsText' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, BackgroundImage) == 0x0005E0, "Member 'UUIArtifact_Warehouse::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, UnderButtonDescription) == 0x0005E8, "Member 'UUIArtifact_Warehouse::UnderButtonDescription' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, ArtifactPanelList) == 0x0005F0, "Member 'UUIArtifact_Warehouse::ArtifactPanelList' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, BackGroundDatas) == 0x000600, "Member 'UUIArtifact_Warehouse::BackGroundDatas' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, FlagTextureDataList) == 0x000610, "Member 'UUIArtifact_Warehouse::FlagTextureDataList' has a wrong offset!");
static_assert(offsetof(UUIArtifact_Warehouse, TreasureHouse) == 0x000660, "Member 'UUIArtifact_Warehouse::TreasureHouse' has a wrong offset!");

// Class DarwinGame.BGMSoundMapDataAssetLibrary
// 0x0000 (0x0030 - 0x0030)
class UBGMSoundMapDataAssetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGMSoundMapDataAssetLibrary">();
	}
	static class UBGMSoundMapDataAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGMSoundMapDataAssetLibrary>();
	}
};
static_assert(alignof(UBGMSoundMapDataAssetLibrary) == 0x000008, "Wrong alignment on UBGMSoundMapDataAssetLibrary");
static_assert(sizeof(UBGMSoundMapDataAssetLibrary) == 0x000030, "Wrong size on UBGMSoundMapDataAssetLibrary");

// Class DarwinGame.AirStateStartDungeon
// 0x0068 (0x01F8 - 0x0190)
class UAirStateStartDungeon final : public UAirStateJump
{
public:
	float                                         JumpHeight;                                        // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravityScale;                                      // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x5C];                                     // 0x019C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateStartDungeon">();
	}
	static class UAirStateStartDungeon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateStartDungeon>();
	}
};
static_assert(alignof(UAirStateStartDungeon) == 0x000008, "Wrong alignment on UAirStateStartDungeon");
static_assert(sizeof(UAirStateStartDungeon) == 0x0001F8, "Wrong size on UAirStateStartDungeon");
static_assert(offsetof(UAirStateStartDungeon, JumpHeight) == 0x000190, "Member 'UAirStateStartDungeon::JumpHeight' has a wrong offset!");
static_assert(offsetof(UAirStateStartDungeon, GravityScale) == 0x000198, "Member 'UAirStateStartDungeon::GravityScale' has a wrong offset!");

// Class DarwinGame.IndoorTriggerBase
// 0x0008 (0x0230 - 0x0228)
class AIndoorTriggerBase : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndoorTriggerBase">();
	}
	static class AIndoorTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIndoorTriggerBase>();
	}
};
static_assert(alignof(AIndoorTriggerBase) == 0x000008, "Wrong alignment on AIndoorTriggerBase");
static_assert(sizeof(AIndoorTriggerBase) == 0x000230, "Wrong size on AIndoorTriggerBase");
static_assert(offsetof(AIndoorTriggerBase, RootComp) == 0x000228, "Member 'AIndoorTriggerBase::RootComp' has a wrong offset!");

// Class DarwinGame.IndoorTypeTrigger
// 0x0008 (0x0238 - 0x0230)
class AIndoorTypeTrigger final : public AIndoorTriggerBase
{
public:
	EIndoorType                                   IndoorType;                                        // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndoorTypeTrigger">();
	}
	static class AIndoorTypeTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIndoorTypeTrigger>();
	}
};
static_assert(alignof(AIndoorTypeTrigger) == 0x000008, "Wrong alignment on AIndoorTypeTrigger");
static_assert(sizeof(AIndoorTypeTrigger) == 0x000238, "Wrong size on AIndoorTypeTrigger");
static_assert(offsetof(AIndoorTypeTrigger, IndoorType) == 0x000230, "Member 'AIndoorTypeTrigger::IndoorType' has a wrong offset!");

// Class DarwinGame.UILeftMenu_4
// 0x0000 (0x0650 - 0x0650)
class UUILeftMenu_4 final : public UUILeftMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_4">();
	}
	static class UUILeftMenu_4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_4>();
	}
};
static_assert(alignof(UUILeftMenu_4) == 0x000008, "Wrong alignment on UUILeftMenu_4");
static_assert(sizeof(UUILeftMenu_4) == 0x000650, "Wrong size on UUILeftMenu_4");

// Class DarwinGame.AirStateStartLink
// 0x00B8 (0x0248 - 0x0190)
class UAirStateStartLink : public UAirStateJump
{
public:
	uint8                                         Pad_190[0xB0];                                     // 0x0190(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFalling;                                        // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsFalling() const;
	bool IsLinkSuccessed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirStateStartLink">();
	}
	static class UAirStateStartLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirStateStartLink>();
	}
};
static_assert(alignof(UAirStateStartLink) == 0x000008, "Wrong alignment on UAirStateStartLink");
static_assert(sizeof(UAirStateStartLink) == 0x000248, "Wrong size on UAirStateStartLink");
static_assert(offsetof(UAirStateStartLink, bIsFalling) == 0x000240, "Member 'UAirStateStartLink::bIsFalling' has a wrong offset!");

// Class DarwinGame.UIMenuStack
// 0x0018 (0x04A8 - 0x0490)
class UUIMenuStack : public UDarwinUserWidget
{
public:
	TArray<struct FST_MenuStack>                  MenuStack;                                         // 0x0490(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinUserWidget*                      NextMenuWidget;                                    // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenuStack">();
	}
	static class UUIMenuStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenuStack>();
	}
};
static_assert(alignof(UUIMenuStack) == 0x000008, "Wrong alignment on UUIMenuStack");
static_assert(sizeof(UUIMenuStack) == 0x0004A8, "Wrong size on UUIMenuStack");
static_assert(offsetof(UUIMenuStack, MenuStack) == 0x000490, "Member 'UUIMenuStack::MenuStack' has a wrong offset!");
static_assert(offsetof(UUIMenuStack, NextMenuWidget) == 0x0004A0, "Member 'UUIMenuStack::NextMenuWidget' has a wrong offset!");

// Class DarwinGame.UICaptureMenu_Root
// 0x0020 (0x04C8 - 0x04A8)
class UUICaptureMenu_Root : public UUIMenuStack
{
public:
	class UWidget*                                Blur;                                              // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Capture;                                           // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinFrameGrabber*                    FrameGrabber;                                      // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICaptureMenu_Root">();
	}
	static class UUICaptureMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICaptureMenu_Root>();
	}
};
static_assert(alignof(UUICaptureMenu_Root) == 0x000008, "Wrong alignment on UUICaptureMenu_Root");
static_assert(sizeof(UUICaptureMenu_Root) == 0x0004C8, "Wrong size on UUICaptureMenu_Root");
static_assert(offsetof(UUICaptureMenu_Root, Blur) == 0x0004A8, "Member 'UUICaptureMenu_Root::Blur' has a wrong offset!");
static_assert(offsetof(UUICaptureMenu_Root, Capture) == 0x0004B0, "Member 'UUICaptureMenu_Root::Capture' has a wrong offset!");
static_assert(offsetof(UUICaptureMenu_Root, FrameGrabber) == 0x0004B8, "Member 'UUICaptureMenu_Root::FrameGrabber' has a wrong offset!");

// Class DarwinGame.UIInitWidget_Root
// 0x0008 (0x04D0 - 0x04C8)
class UUIInitWidget_Root : public UUICaptureMenu_Root
{
public:
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInitWidget_Root">();
	}
	static class UUIInitWidget_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInitWidget_Root>();
	}
};
static_assert(alignof(UUIInitWidget_Root) == 0x000008, "Wrong alignment on UUIInitWidget_Root");
static_assert(sizeof(UUIInitWidget_Root) == 0x0004D0, "Wrong size on UUIInitWidget_Root");

// Class DarwinGame.UIDelivery_Item_00_Root
// 0x0030 (0x0500 - 0x04D0)
class UUIDelivery_Item_00_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x30];                                     // 0x04D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_Item_00_Root">();
	}
	static class UUIDelivery_Item_00_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_Item_00_Root>();
	}
};
static_assert(alignof(UUIDelivery_Item_00_Root) == 0x000008, "Wrong alignment on UUIDelivery_Item_00_Root");
static_assert(sizeof(UUIDelivery_Item_00_Root) == 0x000500, "Wrong size on UUIDelivery_Item_00_Root");

// Class DarwinGame.DarwinAbilitySystemBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDarwinAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FActionResult GetActionResult(const struct FGameplayCueParameters& Parameters);
	static struct FAttackHitResultStruct GetAttackResult(const struct FGameplayCueParameters& Parameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinAbilitySystemBlueprintLibrary">();
	}
	static class UDarwinAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UDarwinAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UDarwinAbilitySystemBlueprintLibrary");
static_assert(sizeof(UDarwinAbilitySystemBlueprintLibrary) == 0x000030, "Wrong size on UDarwinAbilitySystemBlueprintLibrary");

// Class DarwinGame.AliveRequirement
// 0x0000 (0x0030 - 0x0030)
class UAliveRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AliveRequirement">();
	}
	static class UAliveRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAliveRequirement>();
	}
};
static_assert(alignof(UAliveRequirement) == 0x000008, "Wrong alignment on UAliveRequirement");
static_assert(sizeof(UAliveRequirement) == 0x000030, "Wrong size on UAliveRequirement");

// Class DarwinGame.BehaviorDecision
// 0x0000 (0x0030 - 0x0030)
class UBehaviorDecision final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviorDecision">();
	}
	static class UBehaviorDecision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviorDecision>();
	}
};
static_assert(alignof(UBehaviorDecision) == 0x000008, "Wrong alignment on UBehaviorDecision");
static_assert(sizeof(UBehaviorDecision) == 0x000030, "Wrong size on UBehaviorDecision");

// Class DarwinGame.DarwinBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDarwinBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorIsCharacter(class AActor* Target);
	static bool ActorIsPlayer(class AActor* Target);
	static struct FActionGameplayEffectContainerSpec AddTargetsToEffectContainerSpec(const struct FActionGameplayEffectContainerSpec& ContainerSpec, const TArray<struct FHitResult>& HitResults, const TArray<class AActor*>& TargetActors);
	static void AddUIBrightness();
	static TArray<struct FActiveGameplayEffectHandle> ApplyExternalEffectContainerSpec(const struct FActionGameplayEffectContainerSpec& ContainerSpec);
	static struct FASyncLoadInfo ASyncLoadAsset(const struct FSoftObjectPath& targetsToStream);
	static struct FASyncLoadInfo ASyncLoadAssets(const TArray<struct FSoftObjectPath>& targetsToStream);
	static bool BoxOverlapActors(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool BoxOverlapActorsByProfile(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const class FName& ProfileName, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool BoxOverlapComponents(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool BoxOverlapComponentsByProfile(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const class FName& ProfileName, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool CapsuleOverlapActors(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool CapsuleOverlapActorsByProfile(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const class FName& ProfileName, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool CapsuleOverlapComponents(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool CapsuleOverlapComponentsByProfile(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const class FName& ProfileName, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static TArray<struct FHitResult> CheckCurrentFloor(class AActor* observe, float Height, float Radius, float ExtendScaleToUpward);
	static void DataTableRemoveAssetInfo(class UDataTable* DataTable);
	static void DisableFixedFrameRate();
	static bool DoesEffectContainerSpecHaveEffects(const struct FActionGameplayEffectContainerSpec& ContainerSpec);
	static bool DoesEffectContainerSpecHaveTargets(const struct FActionGameplayEffectContainerSpec& ContainerSpec);
	static bool DoesTagBelongToEnemy(const struct FGameplayTag& Belong);
	static bool DoesTargetBlongToAlly(class AActor* Target);
	static bool DoesTargetBlongToEnemy(class AActor* Target);
	static bool DoesTargetBlongToSameDepartment(class AActor* Source, class AActor* Target);
	static void EnableFixedFrameRate();
	static bool ExportCSVFromDataTable(const class UDataTable* DataTable, const class FString& FilePath);
	static void FindNPC(float FindDistance, float FindAngle, const TArray<EObjectTypeQuery>& ObjectTypes);
	static void ForceGarbageCollection(bool bFullPurge);
	static class UAnimationAsset* GetAnimationAsset(const struct FSoftObjectPath& SoftObjectPath);
	static float GetAverageFPS();
	static float GetAverageMS();
	static bool GetIntegerByName(class UObject* Target, class FName VarName, int32* OutInteger);
	static void GetLoadAsset(const struct FASyncLoadInfo& ASyncLoadInfo, class UObject** LoadAsset);
	static void GetLoadAssets(const struct FASyncLoadInfo& ASyncLoadInfo, TArray<class UObject*>* loadAssets);
	static float GetTargetFPS();
	static float GetTargetMS();
	static void InitializeResolution();
	static bool IsConfigFixedFrameRate();
	static bool IsExistAsset(const class FString& Path);
	static bool IsFinishedASyncLoad(const struct FASyncLoadInfo& ASyncLoadInfo);
	static bool IsHitLocationAtFeet(class AActor* observe, float Height, float Radius, const struct FHitResult& Hit);
	static bool IsObjectFaceToFace(const struct FRotator& A, const struct FRotator& B);
	static bool IsOnFloor(class AActor* observe, float Height, float Radius, float ExtendScaleToUpward);
	static struct FASyncLoadInfo ReleaseASyncLoad(const struct FASyncLoadInfo& inAsyncLoadInfo);
	static void SetFixedFrameRate(bool bUse, float FPS);
	static bool SetIntegerByName(class UObject* Target, class FName VarName, int32 NewValue, int32* OutInteger);
	static void SetMaxFPS();
	static class AActor* SpawnActor(const class UObject* Object, const struct FTransform& Transform);
	static void UnlockPCAchievement(EDarwinAchievementsID ID);
	static bool WhetherHitOnGround(class AActor* observe, float Height, float Radius, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinBlueprintLibrary">();
	}
	static class UDarwinBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinBlueprintLibrary>();
	}
};
static_assert(alignof(UDarwinBlueprintLibrary) == 0x000008, "Wrong alignment on UDarwinBlueprintLibrary");
static_assert(sizeof(UDarwinBlueprintLibrary) == 0x000030, "Wrong size on UDarwinBlueprintLibrary");

// Class DarwinGame.AnimAccessInterface
// 0x0000 (0x0030 - 0x0030)
class IAnimAccessInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimAccessInterface">();
	}
	static class IAnimAccessInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimAccessInterface>();
	}
};
static_assert(alignof(IAnimAccessInterface) == 0x000008, "Wrong alignment on IAnimAccessInterface");
static_assert(sizeof(IAnimAccessInterface) == 0x000030, "Wrong size on IAnimAccessInterface");

// Class DarwinGame.UILeftMenu_8
// 0x0048 (0x0698 - 0x0650)
class UUILeftMenu_8 : public UUILeftMenuBase
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      TitleTexList;                                      // 0x0650(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITopbar_10*                           Topbar;                                            // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FST_LeftMenu_8_UpDownDelta>     UpDownDeltaArray;                                  // 0x0668(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x20];                                     // 0x0678(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_8">();
	}
	static class UUILeftMenu_8* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_8>();
	}
};
static_assert(alignof(UUILeftMenu_8) == 0x000008, "Wrong alignment on UUILeftMenu_8");
static_assert(sizeof(UUILeftMenu_8) == 0x000698, "Wrong size on UUILeftMenu_8");
static_assert(offsetof(UUILeftMenu_8, TitleTexList) == 0x000650, "Member 'UUILeftMenu_8::TitleTexList' has a wrong offset!");
static_assert(offsetof(UUILeftMenu_8, Topbar) == 0x000660, "Member 'UUILeftMenu_8::Topbar' has a wrong offset!");
static_assert(offsetof(UUILeftMenu_8, UpDownDeltaArray) == 0x000668, "Member 'UUILeftMenu_8::UpDownDeltaArray' has a wrong offset!");

// Class DarwinGame.AnimNotify_AvoidanceCollisionSizeUpdate
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_AvoidanceCollisionSizeUpdate final : public UAnimNotify
{
public:
	ECollisionType                                mCollisionType;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpdateTiming                                 mUpdateTiming;                                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mRadius;                                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mHalfHeight;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_AvoidanceCollisionSizeUpdate">();
	}
	static class UAnimNotify_AvoidanceCollisionSizeUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_AvoidanceCollisionSizeUpdate>();
	}
};
static_assert(alignof(UAnimNotify_AvoidanceCollisionSizeUpdate) == 0x000008, "Wrong alignment on UAnimNotify_AvoidanceCollisionSizeUpdate");
static_assert(sizeof(UAnimNotify_AvoidanceCollisionSizeUpdate) == 0x000050, "Wrong size on UAnimNotify_AvoidanceCollisionSizeUpdate");
static_assert(offsetof(UAnimNotify_AvoidanceCollisionSizeUpdate, mCollisionType) == 0x000040, "Member 'UAnimNotify_AvoidanceCollisionSizeUpdate::mCollisionType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AvoidanceCollisionSizeUpdate, mUpdateTiming) == 0x000041, "Member 'UAnimNotify_AvoidanceCollisionSizeUpdate::mUpdateTiming' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AvoidanceCollisionSizeUpdate, mRadius) == 0x000044, "Member 'UAnimNotify_AvoidanceCollisionSizeUpdate::mRadius' has a wrong offset!");
static_assert(offsetof(UAnimNotify_AvoidanceCollisionSizeUpdate, mHalfHeight) == 0x000048, "Member 'UAnimNotify_AvoidanceCollisionSizeUpdate::mHalfHeight' has a wrong offset!");

// Class DarwinGame.GroundStateBase
// 0x0000 (0x0170 - 0x0170)
class UGroundStateBase : public UMoveStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateBase">();
	}
	static class UGroundStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateBase>();
	}
};
static_assert(alignof(UGroundStateBase) == 0x000008, "Wrong alignment on UGroundStateBase");
static_assert(sizeof(UGroundStateBase) == 0x000170, "Wrong size on UGroundStateBase");

// Class DarwinGame.GroundStateDespoil
// 0x0000 (0x0170 - 0x0170)
class UGroundStateDespoil : public UGroundStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateDespoil">();
	}
	static class UGroundStateDespoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateDespoil>();
	}
};
static_assert(alignof(UGroundStateDespoil) == 0x000008, "Wrong alignment on UGroundStateDespoil");
static_assert(sizeof(UGroundStateDespoil) == 0x000170, "Wrong size on UGroundStateDespoil");

// Class DarwinGame.UIBoardmenu_MonsterIconChoice
// 0x0050 (0x0580 - 0x0530)
class UUIBoardmenu_MonsterIconChoice final : public UUIScrollMenuItemBase
{
public:
	bool                                          IsEnableOpenAnim;                                  // 0x0530(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageCheck;                                        // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageNew;                                          // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageHeart;                                        // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageHeartEffect;                                  // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageCustom;                                       // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinUserWidget*                      Shutter;                                           // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinUserWidget*                      Wings;                                             // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBoardmenu_MonsterIcon*               MonsterIcon;                                       // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void IconIn();
	void ShutterOpen();
	void WingsOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_MonsterIconChoice">();
	}
	static class UUIBoardmenu_MonsterIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_MonsterIconChoice>();
	}
};
static_assert(alignof(UUIBoardmenu_MonsterIconChoice) == 0x000008, "Wrong alignment on UUIBoardmenu_MonsterIconChoice");
static_assert(sizeof(UUIBoardmenu_MonsterIconChoice) == 0x000580, "Wrong size on UUIBoardmenu_MonsterIconChoice");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, IsEnableOpenAnim) == 0x000530, "Member 'UUIBoardmenu_MonsterIconChoice::IsEnableOpenAnim' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, ImageCheck) == 0x000538, "Member 'UUIBoardmenu_MonsterIconChoice::ImageCheck' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, ImageNew) == 0x000540, "Member 'UUIBoardmenu_MonsterIconChoice::ImageNew' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, ImageHeart) == 0x000548, "Member 'UUIBoardmenu_MonsterIconChoice::ImageHeart' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, ImageHeartEffect) == 0x000550, "Member 'UUIBoardmenu_MonsterIconChoice::ImageHeartEffect' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, ImageCustom) == 0x000558, "Member 'UUIBoardmenu_MonsterIconChoice::ImageCustom' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, Frame) == 0x000560, "Member 'UUIBoardmenu_MonsterIconChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, Shutter) == 0x000568, "Member 'UUIBoardmenu_MonsterIconChoice::Shutter' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, Wings) == 0x000570, "Member 'UUIBoardmenu_MonsterIconChoice::Wings' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIconChoice, MonsterIcon) == 0x000578, "Member 'UUIBoardmenu_MonsterIconChoice::MonsterIcon' has a wrong offset!");

// Class DarwinGame.ArtifactPointBase
// 0x0010 (0x02C0 - 0x02B0)
class AArtifactPointBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactPointBase">();
	}
	static class AArtifactPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactPointBase>();
	}
};
static_assert(alignof(AArtifactPointBase) == 0x000008, "Wrong alignment on AArtifactPointBase");
static_assert(sizeof(AArtifactPointBase) == 0x0002C0, "Wrong size on AArtifactPointBase");

// Class DarwinGame.ArtifactPoint
// 0x0018 (0x02D8 - 0x02C0)
class AArtifactPoint : public AArtifactPointBase
{
public:
	class USphereComponent*                       mEffectCollision;                                  // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectReactionDefaultComponent*        ObjectReactionDefault;                             // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            mArtifactPointEffect;                              // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UPointEnvSound* GetSoundComponent();
	void OnBeginOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactPoint">();
	}
	static class AArtifactPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactPoint>();
	}
};
static_assert(alignof(AArtifactPoint) == 0x000008, "Wrong alignment on AArtifactPoint");
static_assert(sizeof(AArtifactPoint) == 0x0002D8, "Wrong size on AArtifactPoint");
static_assert(offsetof(AArtifactPoint, mEffectCollision) == 0x0002C0, "Member 'AArtifactPoint::mEffectCollision' has a wrong offset!");
static_assert(offsetof(AArtifactPoint, ObjectReactionDefault) == 0x0002C8, "Member 'AArtifactPoint::ObjectReactionDefault' has a wrong offset!");
static_assert(offsetof(AArtifactPoint, mArtifactPointEffect) == 0x0002D0, "Member 'AArtifactPoint::mArtifactPointEffect' has a wrong offset!");

// Class DarwinGame.AnimNotify_BossPossession
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_BossPossession final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_BossPossession">();
	}
	static class UAnimNotify_BossPossession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_BossPossession>();
	}
};
static_assert(alignof(UAnimNotify_BossPossession) == 0x000008, "Wrong alignment on UAnimNotify_BossPossession");
static_assert(sizeof(UAnimNotify_BossPossession) == 0x000040, "Wrong size on UAnimNotify_BossPossession");

// Class DarwinGame.AnimNotify_BossPossessionSwitch
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_BossPossessionSwitch final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_BossPossessionSwitch">();
	}
	static class UAnimNotify_BossPossessionSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_BossPossessionSwitch>();
	}
};
static_assert(alignof(UAnimNotify_BossPossessionSwitch) == 0x000008, "Wrong alignment on UAnimNotify_BossPossessionSwitch");
static_assert(sizeof(UAnimNotify_BossPossessionSwitch) == 0x000040, "Wrong size on UAnimNotify_BossPossessionSwitch");

// Class DarwinGame.UIArtifactList_Field
// 0x0028 (0x04B8 - 0x0490)
class UUIArtifactList_Field : public UDarwinUserWidget
{
public:
	TArray<class UUIArtifactList_ArtifactIcon*>   IconList;                                          // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PlayingAnimation;                                  // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         BlinkSound;                                        // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FrameIn();
	void FrameOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactList_Field">();
	}
	static class UUIArtifactList_Field* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactList_Field>();
	}
};
static_assert(alignof(UUIArtifactList_Field) == 0x000008, "Wrong alignment on UUIArtifactList_Field");
static_assert(sizeof(UUIArtifactList_Field) == 0x0004B8, "Wrong size on UUIArtifactList_Field");
static_assert(offsetof(UUIArtifactList_Field, IconList) == 0x000490, "Member 'UUIArtifactList_Field::IconList' has a wrong offset!");
static_assert(offsetof(UUIArtifactList_Field, PlayingAnimation) == 0x0004A0, "Member 'UUIArtifactList_Field::PlayingAnimation' has a wrong offset!");
static_assert(offsetof(UUIArtifactList_Field, BlinkSound) == 0x0004A8, "Member 'UUIArtifactList_Field::BlinkSound' has a wrong offset!");

// Class DarwinGame.SceneCaptureTwoCameraBase
// 0x0010 (0x0380 - 0x0370)
class ASceneCaptureTwoCameraBase : public ASceneCaptureBase
{
public:
	class USceneCaptureComponent2D*               SubCaptureComponent2D;                             // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureTwoCameraBase">();
	}
	static class ASceneCaptureTwoCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneCaptureTwoCameraBase>();
	}
};
static_assert(alignof(ASceneCaptureTwoCameraBase) == 0x000010, "Wrong alignment on ASceneCaptureTwoCameraBase");
static_assert(sizeof(ASceneCaptureTwoCameraBase) == 0x000380, "Wrong size on ASceneCaptureTwoCameraBase");
static_assert(offsetof(ASceneCaptureTwoCameraBase, SubCaptureComponent2D) == 0x000370, "Member 'ASceneCaptureTwoCameraBase::SubCaptureComponent2D' has a wrong offset!");

// Class DarwinGame.ArtifactGoodEventSceneCapture
// 0x0080 (0x0400 - 0x0380)
class AArtifactGoodEventSceneCapture final : public ASceneCaptureTwoCameraBase
{
public:
	TArray<TSubclassOf<class AEffectBase>>        HeartRankUpEffectBP;                               // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                HeartActionEffectBP;                               // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                HeartResultEffectBP;                               // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                NotHeartResultEffectBP;                            // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AEffectBase>>        HeartResultGoodEffectBP;                           // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AEffectBase*>                    HeartRankUpEffectList;                             // 0x03B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            HeartResultEffect;                                 // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            NotHeartResultEffect;                              // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEffectBase*>                    HeartResultGoodEffectList;                         // 0x03D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEffectBase*>                    HeartActionEffectList;                             // 0x03E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactGoodEventSceneCapture">();
	}
	static class AArtifactGoodEventSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactGoodEventSceneCapture>();
	}
};
static_assert(alignof(AArtifactGoodEventSceneCapture) == 0x000010, "Wrong alignment on AArtifactGoodEventSceneCapture");
static_assert(sizeof(AArtifactGoodEventSceneCapture) == 0x000400, "Wrong size on AArtifactGoodEventSceneCapture");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartRankUpEffectBP) == 0x000380, "Member 'AArtifactGoodEventSceneCapture::HeartRankUpEffectBP' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartActionEffectBP) == 0x000390, "Member 'AArtifactGoodEventSceneCapture::HeartActionEffectBP' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartResultEffectBP) == 0x000398, "Member 'AArtifactGoodEventSceneCapture::HeartResultEffectBP' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, NotHeartResultEffectBP) == 0x0003A0, "Member 'AArtifactGoodEventSceneCapture::NotHeartResultEffectBP' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartResultGoodEffectBP) == 0x0003A8, "Member 'AArtifactGoodEventSceneCapture::HeartResultGoodEffectBP' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartRankUpEffectList) == 0x0003B8, "Member 'AArtifactGoodEventSceneCapture::HeartRankUpEffectList' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartResultEffect) == 0x0003C8, "Member 'AArtifactGoodEventSceneCapture::HeartResultEffect' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, NotHeartResultEffect) == 0x0003D0, "Member 'AArtifactGoodEventSceneCapture::NotHeartResultEffect' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartResultGoodEffectList) == 0x0003D8, "Member 'AArtifactGoodEventSceneCapture::HeartResultGoodEffectList' has a wrong offset!");
static_assert(offsetof(AArtifactGoodEventSceneCapture, HeartActionEffectList) == 0x0003E8, "Member 'AArtifactGoodEventSceneCapture::HeartActionEffectList' has a wrong offset!");

// Class DarwinGame.UILeftMenu_3
// 0x0038 (0x0688 - 0x0650)
class UUILeftMenu_3 : public UUILeftMenuBase
{
public:
	TArray<struct FST_LeftMenu_3_UpDownDelta>     UpDownDeltaArray;                                  // 0x0650(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_660[0x20];                                     // 0x0660(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIUnder_Button*                        UnderButton;                                       // 0x0680(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_3">();
	}
	static class UUILeftMenu_3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_3>();
	}
};
static_assert(alignof(UUILeftMenu_3) == 0x000008, "Wrong alignment on UUILeftMenu_3");
static_assert(sizeof(UUILeftMenu_3) == 0x000688, "Wrong size on UUILeftMenu_3");
static_assert(offsetof(UUILeftMenu_3, UpDownDeltaArray) == 0x000650, "Member 'UUILeftMenu_3::UpDownDeltaArray' has a wrong offset!");
static_assert(offsetof(UUILeftMenu_3, UnderButton) == 0x000680, "Member 'UUILeftMenu_3::UnderButton' has a wrong offset!");

// Class DarwinGame.AnimNotify_FailTimer
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_FailTimer final : public UAnimNotify
{
public:
	float                                         mTime;                                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FailTimer">();
	}
	static class UAnimNotify_FailTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FailTimer>();
	}
};
static_assert(alignof(UAnimNotify_FailTimer) == 0x000008, "Wrong alignment on UAnimNotify_FailTimer");
static_assert(sizeof(UAnimNotify_FailTimer) == 0x000048, "Wrong size on UAnimNotify_FailTimer");
static_assert(offsetof(UAnimNotify_FailTimer, mTime) == 0x000040, "Member 'UAnimNotify_FailTimer::mTime' has a wrong offset!");

// Class DarwinGame.KeyStateUpdateComponent
// 0x0010 (0x0150 - 0x0140)
class UKeyStateUpdateComponent final : public UInputComponent
{
public:
	int32                                         KeyStateUpdatePriority;                            // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0xC];                                      // 0x0144(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyStateUpdateComponent">();
	}
	static class UKeyStateUpdateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyStateUpdateComponent>();
	}
};
static_assert(alignof(UKeyStateUpdateComponent) == 0x000008, "Wrong alignment on UKeyStateUpdateComponent");
static_assert(sizeof(UKeyStateUpdateComponent) == 0x000150, "Wrong size on UKeyStateUpdateComponent");
static_assert(offsetof(UKeyStateUpdateComponent, KeyStateUpdatePriority) == 0x000140, "Member 'UKeyStateUpdateComponent::KeyStateUpdatePriority' has a wrong offset!");

// Class DarwinGame.AnimNotify_GenerateMagicBullet
// 0x0020 (0x0060 - 0x0040)
class UAnimNotify_GenerateMagicBullet final : public UAnimNotify
{
public:
	TArray<ESocket>                               mSocketIDs;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           mActionDetailIDs;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GenerateMagicBullet">();
	}
	static class UAnimNotify_GenerateMagicBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GenerateMagicBullet>();
	}
};
static_assert(alignof(UAnimNotify_GenerateMagicBullet) == 0x000008, "Wrong alignment on UAnimNotify_GenerateMagicBullet");
static_assert(sizeof(UAnimNotify_GenerateMagicBullet) == 0x000060, "Wrong size on UAnimNotify_GenerateMagicBullet");
static_assert(offsetof(UAnimNotify_GenerateMagicBullet, mSocketIDs) == 0x000040, "Member 'UAnimNotify_GenerateMagicBullet::mSocketIDs' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GenerateMagicBullet, mActionDetailIDs) == 0x000050, "Member 'UAnimNotify_GenerateMagicBullet::mActionDetailIDs' has a wrong offset!");

// Class DarwinGame.UIDelivery_List_Text
// 0x0010 (0x0500 - 0x04F0)
class UUIDelivery_List_Text final : public UUIFreeScrollBase
{
public:
	TArray<class UUIDelivery_ItemPanel_Text*>     Panels;                                            // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_List_Text">();
	}
	static class UUIDelivery_List_Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_List_Text>();
	}
};
static_assert(alignof(UUIDelivery_List_Text) == 0x000008, "Wrong alignment on UUIDelivery_List_Text");
static_assert(sizeof(UUIDelivery_List_Text) == 0x000500, "Wrong size on UUIDelivery_List_Text");
static_assert(offsetof(UUIDelivery_List_Text, Panels) == 0x0004F0, "Member 'UUIDelivery_List_Text::Panels' has a wrong offset!");

// Class DarwinGame.ManagerBase
// 0x0008 (0x0038 - 0x0030)
class UManagerBase : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManagerBase">();
	}
	static class UManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManagerBase>();
	}
};
static_assert(alignof(UManagerBase) == 0x000008, "Wrong alignment on UManagerBase");
static_assert(sizeof(UManagerBase) == 0x000038, "Wrong size on UManagerBase");

// Class DarwinGame.DarwinAssetManager
// 0x0150 (0x0188 - 0x0038)
class UDarwinAssetManager : public UManagerBase
{
public:
	TMap<class FString, class UObject*>           mLoadedAssetList;                                  // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x100];                                     // 0x0088(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDarwinAssetManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinAssetManager">();
	}
	static class UDarwinAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinAssetManager>();
	}
};
static_assert(alignof(UDarwinAssetManager) == 0x000008, "Wrong alignment on UDarwinAssetManager");
static_assert(sizeof(UDarwinAssetManager) == 0x000188, "Wrong size on UDarwinAssetManager");
static_assert(offsetof(UDarwinAssetManager, mLoadedAssetList) == 0x000038, "Member 'UDarwinAssetManager::mLoadedAssetList' has a wrong offset!");

// Class DarwinGame.AnimNotify_GenerateShotgunAllBullets
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_GenerateShotgunAllBullets final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GenerateShotgunAllBullets">();
	}
	static class UAnimNotify_GenerateShotgunAllBullets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GenerateShotgunAllBullets>();
	}
};
static_assert(alignof(UAnimNotify_GenerateShotgunAllBullets) == 0x000008, "Wrong alignment on UAnimNotify_GenerateShotgunAllBullets");
static_assert(sizeof(UAnimNotify_GenerateShotgunAllBullets) == 0x000040, "Wrong size on UAnimNotify_GenerateShotgunAllBullets");

// Class DarwinGame.ArtifactDataTable
// 0x0000 (0x0030 - 0x0030)
class UArtifactDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactDataTable">();
	}
	static class UArtifactDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactDataTable>();
	}
};
static_assert(alignof(UArtifactDataTable) == 0x000008, "Wrong alignment on UArtifactDataTable");
static_assert(sizeof(UArtifactDataTable) == 0x000030, "Wrong size on UArtifactDataTable");

// Class DarwinGame.DarwinFrameCapture
// 0x0060 (0x0090 - 0x0030)
class UDarwinFrameCapture : public UObject
{
public:
	TArray<class UTextureRenderTarget2D*>         TextureTarget;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 CaptureBufferData;                                 // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x38];                                      // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinFrameCapture">();
	}
	static class UDarwinFrameCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinFrameCapture>();
	}
};
static_assert(alignof(UDarwinFrameCapture) == 0x000008, "Wrong alignment on UDarwinFrameCapture");
static_assert(sizeof(UDarwinFrameCapture) == 0x000090, "Wrong size on UDarwinFrameCapture");
static_assert(offsetof(UDarwinFrameCapture, TextureTarget) == 0x000030, "Member 'UDarwinFrameCapture::TextureTarget' has a wrong offset!");
static_assert(offsetof(UDarwinFrameCapture, CaptureBufferData) == 0x000048, "Member 'UDarwinFrameCapture::CaptureBufferData' has a wrong offset!");

// Class DarwinGame.AnimNotify_GenerateShotgunBullet
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_GenerateShotgunBullet final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GenerateShotgunBullet">();
	}
	static class UAnimNotify_GenerateShotgunBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GenerateShotgunBullet>();
	}
};
static_assert(alignof(UAnimNotify_GenerateShotgunBullet) == 0x000008, "Wrong alignment on UAnimNotify_GenerateShotgunBullet");
static_assert(sizeof(UAnimNotify_GenerateShotgunBullet) == 0x000040, "Wrong size on UAnimNotify_GenerateShotgunBullet");

// Class DarwinGame.ItemObjectBase
// 0x0040 (0x02F0 - 0x02B0)
class AItemObjectBase : public AFieldObjectBase
{
public:
	class USphereComponent*                       mRoot;                                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsShowUI;                                          // 0x02C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGettable;                                        // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPopObject;                                       // 0x02C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3[0x5];                                      // 0x02C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFieldItemGetInfo>              ItemGetInfo;                                       // 0x02C8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LooksItemID;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetStaticMeshComponentRelativeLocation();

	TArray<struct FFieldItemGetInfo> GetItemGetInfo() const;
	class USphereComponent* GetObjectRootComponent() const;
	class UStaticMesh* GetStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemObjectBase">();
	}
	static class AItemObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemObjectBase>();
	}
};
static_assert(alignof(AItemObjectBase) == 0x000008, "Wrong alignment on AItemObjectBase");
static_assert(sizeof(AItemObjectBase) == 0x0002F0, "Wrong size on AItemObjectBase");
static_assert(offsetof(AItemObjectBase, mRoot) == 0x0002B0, "Member 'AItemObjectBase::mRoot' has a wrong offset!");
static_assert(offsetof(AItemObjectBase, StaticMeshComponent) == 0x0002B8, "Member 'AItemObjectBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemObjectBase, IsShowUI) == 0x0002C0, "Member 'AItemObjectBase::IsShowUI' has a wrong offset!");
static_assert(offsetof(AItemObjectBase, IsGettable) == 0x0002C1, "Member 'AItemObjectBase::IsGettable' has a wrong offset!");
static_assert(offsetof(AItemObjectBase, IsPopObject) == 0x0002C2, "Member 'AItemObjectBase::IsPopObject' has a wrong offset!");
static_assert(offsetof(AItemObjectBase, ItemGetInfo) == 0x0002C8, "Member 'AItemObjectBase::ItemGetInfo' has a wrong offset!");
static_assert(offsetof(AItemObjectBase, LooksItemID) == 0x0002D8, "Member 'AItemObjectBase::LooksItemID' has a wrong offset!");

// Class DarwinGame.DropItemObject
// 0x0040 (0x0330 - 0x02F0)
class ADropItemObject : public AItemObjectBase
{
public:
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DropTimerHandle;                                   // 0x02F8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DropSoundID;                                       // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldBounce;                                      // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Bounciness;                                        // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Friction;                                          // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScale;                                      // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x18];                                     // 0x0318(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDrop(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors);
	void OnDropCheck();
	void OverlapWaterObject(class UPrimitiveComponent* collision);

	class UPrimitiveComponent* GetWaterOverlapCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropItemObject">();
	}
	static class ADropItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADropItemObject>();
	}
};
static_assert(alignof(ADropItemObject) == 0x000008, "Wrong alignment on ADropItemObject");
static_assert(sizeof(ADropItemObject) == 0x000330, "Wrong size on ADropItemObject");
static_assert(offsetof(ADropItemObject, ProjectileMovementComponent) == 0x0002F0, "Member 'ADropItemObject::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(ADropItemObject, DropTimerHandle) == 0x0002F8, "Member 'ADropItemObject::DropTimerHandle' has a wrong offset!");
static_assert(offsetof(ADropItemObject, DropSoundID) == 0x000300, "Member 'ADropItemObject::DropSoundID' has a wrong offset!");
static_assert(offsetof(ADropItemObject, ShouldBounce) == 0x000308, "Member 'ADropItemObject::ShouldBounce' has a wrong offset!");
static_assert(offsetof(ADropItemObject, Bounciness) == 0x00030C, "Member 'ADropItemObject::Bounciness' has a wrong offset!");
static_assert(offsetof(ADropItemObject, Friction) == 0x000310, "Member 'ADropItemObject::Friction' has a wrong offset!");
static_assert(offsetof(ADropItemObject, GravityScale) == 0x000314, "Member 'ADropItemObject::GravityScale' has a wrong offset!");

// Class DarwinGame.ArtifactObjectBase
// 0x0018 (0x0348 - 0x0330)
class AArtifactObjectBase : public ADropItemObject
{
public:
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactObjectBase">();
	}
	static class AArtifactObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactObjectBase>();
	}
};
static_assert(alignof(AArtifactObjectBase) == 0x000008, "Wrong alignment on AArtifactObjectBase");
static_assert(sizeof(AArtifactObjectBase) == 0x000348, "Wrong size on AArtifactObjectBase");

// Class DarwinGame.UIMainMenu
// 0x0078 (0x0648 - 0x05D0)
class UUIMainMenu : public UUIScrollMenuBase
{
public:
	TArray<struct FST_MainMenuCategory>           MainMenuCategoryList;                              // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   UniqueGoHomeTextFlag;                              // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x18];                                     // 0x05E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIMemberPanel*>                 MemberPanels;                                      // 0x0600(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUINowMoney*                            NowMoney;                                          // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         AtomComp;                                          // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x20];                                     // 0x0628(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainMenu">();
	}
	static class UUIMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainMenu>();
	}
};
static_assert(alignof(UUIMainMenu) == 0x000008, "Wrong alignment on UUIMainMenu");
static_assert(sizeof(UUIMainMenu) == 0x000648, "Wrong size on UUIMainMenu");
static_assert(offsetof(UUIMainMenu, MainMenuCategoryList) == 0x0005D0, "Member 'UUIMainMenu::MainMenuCategoryList' has a wrong offset!");
static_assert(offsetof(UUIMainMenu, UniqueGoHomeTextFlag) == 0x0005E0, "Member 'UUIMainMenu::UniqueGoHomeTextFlag' has a wrong offset!");
static_assert(offsetof(UUIMainMenu, MemberPanels) == 0x000600, "Member 'UUIMainMenu::MemberPanels' has a wrong offset!");
static_assert(offsetof(UUIMainMenu, NowMoney) == 0x000610, "Member 'UUIMainMenu::NowMoney' has a wrong offset!");
static_assert(offsetof(UUIMainMenu, AtomComp) == 0x000618, "Member 'UUIMainMenu::AtomComp' has a wrong offset!");
static_assert(offsetof(UUIMainMenu, UIUnderButton) == 0x000620, "Member 'UUIMainMenu::UIUnderButton' has a wrong offset!");

// Class DarwinGame.UIField_IconStamp
// 0x0070 (0x0620 - 0x05B0)
class UUIField_IconStamp : public UUI3DBase
{
public:
	uint8                                         Pad_5A8[0x20];                                     // 0x05A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             StampResourceTable;                                // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FrameResourceTable;                                // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TipsCountMax;                                      // 0x05D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIField_IconStamp_CompositeBase*       AnimFrame;                                         // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIField_StampIconBase*                 AnimStamp;                                         // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anim;                                              // 0x05F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x28];                                     // 0x05F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndStampAnimation();
	bool PlayStamp(float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool LoopStart);
	bool PlayStampByTime(float AnimTime);
	void SetDataFromType(const EStampIconType StampType, class AActor* Target, const EStampFrameType Frame, bool LoopStart);
	void StopStamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_IconStamp">();
	}
	static class UUIField_IconStamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_IconStamp>();
	}
};
static_assert(alignof(UUIField_IconStamp) == 0x000010, "Wrong alignment on UUIField_IconStamp");
static_assert(sizeof(UUIField_IconStamp) == 0x000620, "Wrong size on UUIField_IconStamp");
static_assert(offsetof(UUIField_IconStamp, StampResourceTable) == 0x0005C8, "Member 'UUIField_IconStamp::StampResourceTable' has a wrong offset!");
static_assert(offsetof(UUIField_IconStamp, FrameResourceTable) == 0x0005D0, "Member 'UUIField_IconStamp::FrameResourceTable' has a wrong offset!");
static_assert(offsetof(UUIField_IconStamp, TipsCountMax) == 0x0005D8, "Member 'UUIField_IconStamp::TipsCountMax' has a wrong offset!");
static_assert(offsetof(UUIField_IconStamp, AnimFrame) == 0x0005E0, "Member 'UUIField_IconStamp::AnimFrame' has a wrong offset!");
static_assert(offsetof(UUIField_IconStamp, AnimStamp) == 0x0005E8, "Member 'UUIField_IconStamp::AnimStamp' has a wrong offset!");
static_assert(offsetof(UUIField_IconStamp, Anim) == 0x0005F0, "Member 'UUIField_IconStamp::Anim' has a wrong offset!");

// Class DarwinGame.AnimNotify_Invisivle
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_Invisivle final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Invisivle">();
	}
	static class UAnimNotify_Invisivle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Invisivle>();
	}
};
static_assert(alignof(UAnimNotify_Invisivle) == 0x000008, "Wrong alignment on UAnimNotify_Invisivle");
static_assert(sizeof(UAnimNotify_Invisivle) == 0x000040, "Wrong size on UAnimNotify_Invisivle");

// Class DarwinGame.TerrainDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UTerrainDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrainDamageExecution">();
	}
	static class UTerrainDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrainDamageExecution>();
	}
};
static_assert(alignof(UTerrainDamageExecution) == 0x000008, "Wrong alignment on UTerrainDamageExecution");
static_assert(sizeof(UTerrainDamageExecution) == 0x000048, "Wrong size on UTerrainDamageExecution");

// Class DarwinGame.AnimNotify_MagicShot
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_MagicShot final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_MagicShot">();
	}
	static class UAnimNotify_MagicShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_MagicShot>();
	}
};
static_assert(alignof(UAnimNotify_MagicShot) == 0x000008, "Wrong alignment on UAnimNotify_MagicShot");
static_assert(sizeof(UAnimNotify_MagicShot) == 0x000040, "Wrong size on UAnimNotify_MagicShot");

// Class DarwinGame.GameCharacter
// 0x0200 (0x06C0 - 0x04C0)
class AGameCharacter : public ACharacter
{
public:
	TMap<int32, class UMaterialInterface*>        DefaultMaterialInstanceList;                       // 0x04B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x58];                                     // 0x0508(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OpenFukidashiIndex;                                // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_564[0x18];                                     // 0x0564(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             FinishAllEmoteCallback;                            // 0x057C(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x54];                                     // 0x058C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             EmoteSettingTable;                                 // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEmoteFaceComponent*                    EmoteFaceComponent;                                // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x88];                                     // 0x05F0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameCharacter*                         LookAtTargetActor;                                 // 0x0678(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_680[0x10];                                     // 0x0680(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StampWidgetIndex;                                  // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            EmotionEffect;                                     // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A0[0x20];                                     // 0x06A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEmotionEffect(const EEmotionEffectID ID, const EEffectSizeID Size, const struct FVector& Offset);
	void AddStamp(const EStampIconType Type, int32 LoopNum, const struct FVector& Offset);
	void AdjustActorUpVector();
	void AttachToSocket(class AActor* AttachActor, ESocket socket, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	void CancelEmote();
	void CancelEmoteBody();
	void CancelEmoteFacial();
	void ChangeDefaultMaterialInstance();
	void CloseFukidashi();
	class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent, bool bCopyPamameterFromOld);
	void DetachFromSocket(class AActor* DetachActor, EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule);
	void DisableLookAt();
	void DisableLookAtDirect();
	void EnableLookAtCharacter(class AGameCharacter* TargetCharacter);
	void EnableLookAtCharacterDirect(class AGameCharacter* TargetCharacter);
	void EnableLookAtLocation(const struct FVector& TargetLocation);
	void EnableLookAtLocationDirect(const struct FVector& TargetLocation);
	void EnableUIMode();
	void EndUpdateCollision();
	void GetAControllerTickable(bool* enable, class FString* Name_0);
	bool IsOverAbyssBorder();
	void NotifyHitAbyssTriggerObject();
	void OnAnimInstanceInitialized();
	void OnFinishBodyEmote();
	void OpenFukidashi(EFukidashiEnum FukidashiType, const class FString& CharacterName, const class FString& FukidashiText, const bool VisibleIcon, const bool AutoClose, const class FName TalkeID);
	void Pause();
	void PlayEmote(EEmoteType Type, const TArray<EEmoteMethod>& ignoreMethods, class UEmoteRuntimeOption* runtimeOpt, class UEmoteStampOverwriteOption* overwriteOpt, class UEmoteBodyMotionOverwriteOption* overwriteBodyOpt, class UEmoteFaceOverwriteOption* overwriteFaceOpt, class UEmoteBlinkOverwriteOption* overwriteBlinkOpt, class UEmoteVocalizeOverwriteOption* overwriteVocalizeOpt);
	void PlayEmoteBlink(class UEmoteRuntimeOption* runtimeOpt, class UEmoteBlinkOverwriteOption* overwriteOpt, bool bUseTotalEmote);
	void PlayEmoteBody(EEmoteType Type, class UEmoteRuntimeOption* runtimeOpt, class UEmoteBodyMotionOverwriteOption* overwriteOpt, bool bUseTotalEmote);
	void PlayEmoteBodyNextToLoopSection();
	void PlayEmoteFacial(EEmoteType Type, class UEmoteRuntimeOption* runtimeOpt, class UEmoteFaceOverwriteOption* overwriteOpt, bool bUseTotalEmote);
	void PlayEmoteSE(EEmoteType Type);
	void PlayEmoteStamp(EEmoteType Type, class UEmoteRuntimeOption* runtimeOpt, class UEmoteStampOverwriteOption* overwriteOpt, bool bUseTotalEmote);
	void PlayEmoteVocalize(class UEmoteRuntimeOption* runtimeOpt, class UEmoteVocalizeOverwriteOption* overwriteVocalizeOpt, bool bUseTotalEmote);
	void RemoveDefaultMaterial(int32 ElementIndex);
	void RemoveDefaultMaterialByName(const class FName& MaterialSlotName);
	void RemoveEmotionEffect();
	void RemoveStamp();
	void Resume();
	void SetDefaultMaterial(int32 ElementIndex, class UMaterialInterface* Material);
	void SetDefaultMaterialByName(const class FName& MaterialSlotName, class UMaterialInterface* Material);
	void SetEmoteFacialAnim(class UAnimSequence* FacialAnim);
	void SetEnableAController(bool enable);
	void SetEnableApplyEmoteFace(bool enable);
	void SetLookAtParamHead(const float AnglearVelocity, const float ClampVertical, const float ClampHorizontal);
	void SetLookAtParamSpine(const float AnglearVelocity, const float ClampVertical, const float ClampHorizontal);
	void StopEmote();
	void StopEmoteBlink();
	void StopEmoteBody();
	void StopEmoteFacial();
	void StopEmoteSE();
	void StopEmoteStamp();
	void StopEmoteVocalize();

	bool GetIsPause() const;
	const class FName GetSocketName(ESocket socket) const;
	struct FTransform GetSocketTransform(ESocket socket, ERelativeTransformSpace TransformSpace) const;
	bool HasEmoteEndMotion(const EEmoteType Type) const;
	bool IsOpenFukidashi() const;
	bool IsPlayEmote() const;
	bool IsUpdateCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameCharacter">();
	}
	static class AGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameCharacter>();
	}
};
static_assert(alignof(AGameCharacter) == 0x000010, "Wrong alignment on AGameCharacter");
static_assert(sizeof(AGameCharacter) == 0x0006C0, "Wrong size on AGameCharacter");
static_assert(offsetof(AGameCharacter, DefaultMaterialInstanceList) == 0x0004B8, "Member 'AGameCharacter::DefaultMaterialInstanceList' has a wrong offset!");
static_assert(offsetof(AGameCharacter, OpenFukidashiIndex) == 0x000560, "Member 'AGameCharacter::OpenFukidashiIndex' has a wrong offset!");
static_assert(offsetof(AGameCharacter, FinishAllEmoteCallback) == 0x00057C, "Member 'AGameCharacter::FinishAllEmoteCallback' has a wrong offset!");
static_assert(offsetof(AGameCharacter, EmoteSettingTable) == 0x0005E0, "Member 'AGameCharacter::EmoteSettingTable' has a wrong offset!");
static_assert(offsetof(AGameCharacter, EmoteFaceComponent) == 0x0005E8, "Member 'AGameCharacter::EmoteFaceComponent' has a wrong offset!");
static_assert(offsetof(AGameCharacter, LookAtTargetActor) == 0x000678, "Member 'AGameCharacter::LookAtTargetActor' has a wrong offset!");
static_assert(offsetof(AGameCharacter, StampWidgetIndex) == 0x000690, "Member 'AGameCharacter::StampWidgetIndex' has a wrong offset!");
static_assert(offsetof(AGameCharacter, EmotionEffect) == 0x000698, "Member 'AGameCharacter::EmotionEffect' has a wrong offset!");

// Class DarwinGame.GPACharacter
// 0x0520 (0x0BE0 - 0x06C0)
class AGPACharacter : public AGameCharacter
{
public:
	uint8                                         Pad_6C0[0x128];                                    // 0x06C0(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             BattleMotionList;                                  // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TouchAttackCollisionList;                          // 0x07F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CharacterID;                                       // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BelongType;                                        // 0x0800(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_804[0xC];                                      // 0x0804(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCueSheet*                     UseCueSheet;                                       // 0x0810(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BelongingTag;                                      // 0x0818(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RunninngActionOverViewID;                          // 0x0820(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FParkour                               ParkourData;                                       // 0x0828(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_854[0x4];                                      // 0x0854(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_BattleMotionData                   BattleMotionData;                                  // 0x0858(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FST_AttackData                         AttackData;                                        // 0x08D8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 AnimNotifyID;                                      // 0x0900(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TemporarilyActionDetailID;                         // 0x0910(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReadyWeapon;                                       // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOfGazePoint;                                 // 0x0920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_924[0x4];                                      // 0x0924(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UActionAttributeSet*                    AttributeSet;                                      // 0x0928(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStateComponent*                        StateSystem;                                       // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbilityInitialized;                               // 0x0938(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_939[0x7];                                      // 0x0939(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActionAbilitySystemComponent*          AbilitySystem;                                     // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UActionGameplayAbility>> AbilityList;                                       // 0x0948(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageCollisionComponent*              DamageCollision;                                   // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleSystemComponent*                 BattleSystem;                                      // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimeScaleComponent*                    TimeScaleSystem;                                   // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_970[0x58];                                     // 0x0970(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttachedEffect                        mHeadEffect;                                       // 0x09C8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttachedEffect                        mBodyEffect;                                       // 0x09D8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAttachedEffect>                mOneShotBodyEffectList;                            // 0x09E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F8[0x8];                                      // 0x09F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttributeMaterialType, class UMaterialInstance*> mAttributeMaterialList;                            // 0x0A00(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A50[0x8];                                      // 0x0A50(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDitheringComponent*                    Dithering;                                         // 0x0A58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A60[0x8];                                      // 0x0A60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EResistanceType, int32>                  ResistMap;                                         // 0x0A68(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            ChargeBreakHandle;                                 // 0x0AB8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC0[0x50];                                     // 0x0AC0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            mFootTerrainEffect;                                // 0x0B10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B18[0xB0];                                     // 0x0B18(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGeneratedFromUI;                                  // 0x0BC8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC9[0x17];                                     // 0x0BC9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActivateAbilities(const struct FGameplayTagContainer& AbilityTags, bool bAllowRemoteActivation);
	void ApplyForce(const EForceType Type, const struct FVector& Force);
	void ApplySubFoodEffectGameplayEffectData(int32 FoodHandle, int32 UnitId);
	float CalcFallingAltitude();
	void CalculateAttributeStatus();
	void CalculateConditionalFeatureStatus();
	void CancelAbilities(const struct FGameplayTagContainer& AbilityTags);
	bool CanUseMP(const float Value);
	void ChangeBelong(int32 Type);
	void ChangeToCurrentStateMoveMode();
	void ClearRunninngActionOverViewID();
	void ClearTemporarilyHoldActionDetailID();
	void Dodge(bool StickTilted);
	void EndAbilities(const struct FGameplayTagContainer& AbilityTags);
	void EndRigidTime();
	bool EqualBelong(int32 Type);
	void EventSetEnableAController(bool enable);
	void ExpendMP(const float Value);
	bool FindBattleMotionData(class FName MotionID);
	void GetActiveAbilitiesWithTags(const struct FGameplayTagContainer& GameplayTagContainer, TArray<class UActionGameplayAbility*>* ActiveAbilities);
	class AEffectBase* GetBodyEffect();
	const struct FST_TempCharaDataForDamageCalc GetData();
	class AEffectBase* GetHeadEffect();
	float GetStun();
	void Initialize(class FName ID);
	void InitStatus();
	bool IsUsingAbility(const struct FGameplayTagContainer& GameplayTagContainer);
	bool JudgeMagicRampage(class FName actionDetailID);
	void KnockBack(const struct FVector& Direct, float Power);
	void KnockBackAction(const struct FActionResult& ActionResult);
	void OnDamaged(const struct FGameplayEffectContextHandle& Handle, float DamageAmount, class AGPACharacter* InstigatorCharacter);
	void OnDead(class AGPACharacter* InstigatorCharacter);
	void OnGuard(const struct FGameplayEffectContextHandle& Handle, EGuardType Type, class AGPACharacter* InstigatorCharacter);
	void OnGuts(float DamageAmount);
	void OnHealed(const struct FGameplayEffectContextHandle& Handle, float HealAmount, class AGPACharacter* InstigatorCharacter);
	void OnLand();
	void OnMPHealed(const struct FGameplayEffectContextHandle& Handle, float HealAmount, class AGPACharacter* InstigatorCharacter);
	void OnSetHiddenByDithering(bool Hidden);
	void ReleaseForce(const EForceType Type);
	void ResetMaxFlySpeed();
	void ResetMaxMoveSpeed();
	void ResetMaxWalkSpeed();
	void RotateToTarget(int32 RotateRate);
	void RotateToTargetWithAllParams(class USceneComponent* Target, const struct FVector& Offset, int32 RotateRate);
	void RotateToTargetWithOffset(const struct FVector& Offset, int32 RotateRate);
	void SetCurrentDamageReactionType(EDamageReactionType Type);
	void SetHP(float Value);
	void SetInDodge(bool InDodge);
	void SetLinkTarget(class AGPACharacter* Target);
	void SetMP(float Value);
	void SetPauseAllAttributeEffect(bool Pause_0);
	void SetRootMotionScale(float Scale);
	void SetRunningLinkID(const class FName LinkID);
	void SetRunninngActionOverViewID(const class FName& ID);
	void SetTemporarilyActionDetailID(const class FName& actionDetailID);
	void SetVisible(bool Visibility);
	void SetVisibleOnlyBodyAndEquipments(bool Visibility);
	void StartRigidTime();
	void SyncWithLoadedData();
	bool UseMP(float Value);

	void GetAttributeList(TMap<class FName, int32>* AttributeList) const;
	int32 GetCharacterLevel() const;
	class USwitchCollisionMovementComponent* GetDarwinCharacterMovement() const;
	class UDitheringComponent* GetDitheringComponent() const;
	EEffectSizeID GetEffectSize() const;
	float GetFallingAltitude() const;
	void GetFeatures(TArray<struct FFeaturePossessionInfo>* Features) const;
	float GetHP() const;
	class AGPACharacter* GetLinkTarget() const;
	float GetMaxHP() const;
	float GetMaxMP() const;
	float GetMP() const;
	const class FName GetOriginKindID() const;
	int32 GetResistLevel(EResistanceType ResistType) const;
	float GetRootMotionScale() const;
	class FName GetRunningLinkID() const;
	const class FName GetRunninngActionOverViewID() const;
	struct FST_Status GetStatus() const;
	class USceneComponent* GetTargetComponent() const;
	const class FName GetTemporarilyActionDetailID() const;
	bool IsMPEmpty() const;
	bool IsRunninngAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GPACharacter">();
	}
	static class AGPACharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGPACharacter>();
	}
};
static_assert(alignof(AGPACharacter) == 0x000010, "Wrong alignment on AGPACharacter");
static_assert(sizeof(AGPACharacter) == 0x000BE0, "Wrong size on AGPACharacter");
static_assert(offsetof(AGPACharacter, BattleMotionList) == 0x0007E8, "Member 'AGPACharacter::BattleMotionList' has a wrong offset!");
static_assert(offsetof(AGPACharacter, TouchAttackCollisionList) == 0x0007F0, "Member 'AGPACharacter::TouchAttackCollisionList' has a wrong offset!");
static_assert(offsetof(AGPACharacter, CharacterID) == 0x0007F8, "Member 'AGPACharacter::CharacterID' has a wrong offset!");
static_assert(offsetof(AGPACharacter, BelongType) == 0x000800, "Member 'AGPACharacter::BelongType' has a wrong offset!");
static_assert(offsetof(AGPACharacter, UseCueSheet) == 0x000810, "Member 'AGPACharacter::UseCueSheet' has a wrong offset!");
static_assert(offsetof(AGPACharacter, BelongingTag) == 0x000818, "Member 'AGPACharacter::BelongingTag' has a wrong offset!");
static_assert(offsetof(AGPACharacter, RunninngActionOverViewID) == 0x000820, "Member 'AGPACharacter::RunninngActionOverViewID' has a wrong offset!");
static_assert(offsetof(AGPACharacter, ParkourData) == 0x000828, "Member 'AGPACharacter::ParkourData' has a wrong offset!");
static_assert(offsetof(AGPACharacter, BattleMotionData) == 0x000858, "Member 'AGPACharacter::BattleMotionData' has a wrong offset!");
static_assert(offsetof(AGPACharacter, AttackData) == 0x0008D8, "Member 'AGPACharacter::AttackData' has a wrong offset!");
static_assert(offsetof(AGPACharacter, AnimNotifyID) == 0x000900, "Member 'AGPACharacter::AnimNotifyID' has a wrong offset!");
static_assert(offsetof(AGPACharacter, TemporarilyActionDetailID) == 0x000910, "Member 'AGPACharacter::TemporarilyActionDetailID' has a wrong offset!");
static_assert(offsetof(AGPACharacter, ReadyWeapon) == 0x000918, "Member 'AGPACharacter::ReadyWeapon' has a wrong offset!");
static_assert(offsetof(AGPACharacter, HeightOfGazePoint) == 0x000920, "Member 'AGPACharacter::HeightOfGazePoint' has a wrong offset!");
static_assert(offsetof(AGPACharacter, AttributeSet) == 0x000928, "Member 'AGPACharacter::AttributeSet' has a wrong offset!");
static_assert(offsetof(AGPACharacter, StateSystem) == 0x000930, "Member 'AGPACharacter::StateSystem' has a wrong offset!");
static_assert(offsetof(AGPACharacter, bAbilityInitialized) == 0x000938, "Member 'AGPACharacter::bAbilityInitialized' has a wrong offset!");
static_assert(offsetof(AGPACharacter, AbilitySystem) == 0x000940, "Member 'AGPACharacter::AbilitySystem' has a wrong offset!");
static_assert(offsetof(AGPACharacter, AbilityList) == 0x000948, "Member 'AGPACharacter::AbilityList' has a wrong offset!");
static_assert(offsetof(AGPACharacter, DamageCollision) == 0x000958, "Member 'AGPACharacter::DamageCollision' has a wrong offset!");
static_assert(offsetof(AGPACharacter, BattleSystem) == 0x000960, "Member 'AGPACharacter::BattleSystem' has a wrong offset!");
static_assert(offsetof(AGPACharacter, TimeScaleSystem) == 0x000968, "Member 'AGPACharacter::TimeScaleSystem' has a wrong offset!");
static_assert(offsetof(AGPACharacter, mHeadEffect) == 0x0009C8, "Member 'AGPACharacter::mHeadEffect' has a wrong offset!");
static_assert(offsetof(AGPACharacter, mBodyEffect) == 0x0009D8, "Member 'AGPACharacter::mBodyEffect' has a wrong offset!");
static_assert(offsetof(AGPACharacter, mOneShotBodyEffectList) == 0x0009E8, "Member 'AGPACharacter::mOneShotBodyEffectList' has a wrong offset!");
static_assert(offsetof(AGPACharacter, mAttributeMaterialList) == 0x000A00, "Member 'AGPACharacter::mAttributeMaterialList' has a wrong offset!");
static_assert(offsetof(AGPACharacter, Dithering) == 0x000A58, "Member 'AGPACharacter::Dithering' has a wrong offset!");
static_assert(offsetof(AGPACharacter, ResistMap) == 0x000A68, "Member 'AGPACharacter::ResistMap' has a wrong offset!");
static_assert(offsetof(AGPACharacter, ChargeBreakHandle) == 0x000AB8, "Member 'AGPACharacter::ChargeBreakHandle' has a wrong offset!");
static_assert(offsetof(AGPACharacter, mFootTerrainEffect) == 0x000B10, "Member 'AGPACharacter::mFootTerrainEffect' has a wrong offset!");
static_assert(offsetof(AGPACharacter, bGeneratedFromUI) == 0x000BC8, "Member 'AGPACharacter::bGeneratedFromUI' has a wrong offset!");

// Class DarwinGame.MonsterBase
// 0x08F0 (0x14D0 - 0x0BE0)
class AMonsterBase : public AGPACharacter
{
public:
	uint8                                         Pad_BE0[0x10];                                     // 0x0BE0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      mAccessCollision;                                  // 0x0BF0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF8[0x70];                                     // 0x0BF8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mSpawnPointID;                                     // 0x0C68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mMonsterKindID;                                    // 0x0C70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mMonsterParameterID;                               // 0x0C78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C80[0x8];                                      // 0x0C80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsterEcologicalAI*                   mEcologicalAI;                                     // 0x0C88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBasicTimer*>                    mTimer;                                            // 0x0C90(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA0[0x18];                                     // 0x0CA0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionComponent*                 mAIPerceptionComponent;                            // 0x0CB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC0[0x38];                                     // 0x0CC0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMagickShot;                                      // 0x0CF8(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<ESocket>& Sockets, const TArray<class FName>& ActionDetailIDs)> OnGenerateMagicBullet;                             // 0x0D08(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGenerateShotgunBullet;                           // 0x0D18(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGenerateShotgunAllBullets;                       // 0x0D28(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTaskFinish;                                      // 0x0D38(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EMonsterCombatState                           CombatState;                                       // 0x0D48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D49[0x3];                                      // 0x0D49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mAnimSection;                                      // 0x0D4C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mLandSection;                                      // 0x0D54(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5C[0x24];                                     // 0x0D5C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsNotifyState_MonsterRotateInsightTarget* mMonsNotifyState_MonsterRotateInsightTarget;       // 0x0D80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_MonsterTimeCheckAttack* mMonsNotifyState_MonsterTimeCheckAttack;           // 0x0D88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_MonsterTimeWait*       mMonsNotifyState_MonsterTimeWait;                  // 0x0D90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_MonsterCheckFloorChangeSection* mMonsNotifyState_MonsterCheckFloorChangeSection;   // 0x0D98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_RotateToTargetWithLocationOffset* mMonsNotifyState_RotateToTargetWithLocationOffset; // 0x0DA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_TargetInRangeFin*      mMonsNotifyState_TargetInRangeFin;                 // 0x0DA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_IgnoreCollision*       mMonsNotifyState_IgnoreCollision;                  // 0x0DB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB8[0xF0];                                     // 0x0DB8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mImpactWeight;                                     // 0x0EA8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mReversalTime;                                     // 0x0EAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FST_MonsterAvoidanceInfo>       mAvoidanceBodyInfoList;                            // 0x0EB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC0[0x8];                                      // 0x0EC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                mDamageCollisionInfoList;                          // 0x0EC8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED8[0x100];                                    // 0x0ED8(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            mEmotionEffect;                                    // 0x0FD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FE0[0x290];                                    // 0x0FE0(0x0290)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsterBattleAIBase*                   mBattleAIBase;                                     // 0x1270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1278[0xC8];                                    // 0x1278(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTargetArrowComponent*                  mTargetArrowComponent;                             // 0x1340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1348[0x20];                                    // 0x1348(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsterRingComponent*                  mMonsterRingComponent;                             // 0x1368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1370[0x50];                                    // 0x1370(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         SpecialAbilityLevelSequence;                       // 0x13C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C8[0x108];                                   // 0x13C8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AvoidMonster(class AActor* Other);
	void CancelBehaviorAndWait(class AGPACharacter* Target);
	bool CanExetuteMonsterTask();
	void ChangeBehavior(bool change);
	bool CheckRemakeAttackLocationData();
	void CloseSubjugetionMessage();
	int32 CountEcologicalMotionWithConsecutiveNumber(EMonsterEcologicalMotion ID, int32 Max);
	void CountUpRandomWalkFailedCount();
	struct FActiveGameplayEffectHandle GetAbnormalEffectHandel();
	float GetAcceptableRadius();
	class FName GetAnimSection();
	class UAreaOfEffectControlComponent* GetAreaOfEffectComponent();
	class UMonsterBattleAIBase* GetBattleAIBase();
	bool GetBattleOnDead();
	bool GetBattleStartWaiting();
	bool GetCausedDamage();
	EMonsterCombatState GetCombatState();
	bool GetEcologicalMotionData(struct FST_EcologicalMotionData* Out, EMonsterEcologicalMotion ID);
	bool GetEcologicalMotionDataWithNumber(struct FST_EcologicalMotionData* Out, EMonsterEcologicalMotion ID, int32 No);
	class FName GetLandSection();
	class UMonsterRingComponent* GetMonsterRingComponent();
	bool GetMoveAnimation();
	bool GetOuterRequestLeave();
	EEnemySpawnGeneratorType GetParentGeneratorType();
	float GetReversalTime();
	class ULevelSequence* GetSpecialAbilityLevelSequence();
	bool GetSuperArmor();
	bool HasChangedBehavior();
	bool HasRequestChangeBehavior();
	bool IsChargeBreaking();
	bool IsHiding();
	bool IsStun();
	bool NeedFixedJump();
	void NextBehaviorWithContext(class AGPACharacter* Target, const struct FBehaviorContext& Context);
	void PushBackAvoidanceBodys();
	void RemoveAttackLocationSelf();
	void RequestChangeBehavior(bool change);
	void RequestLeave();
	void ResetBehavior(class AGPACharacter* Target);
	void ResetBehaviorWithContext(class AGPACharacter* Target, const struct FBehaviorContext& Context);
	void ResetRandomWalkFailedCount();
	void RotateToSelectTarget(int32 RotateRate);
	void SetAbnormalEffectHandle(const struct FActiveGameplayEffectHandle& meffect);
	void SetAcceptableRadius(float Radius);
	void SetAnimSection(class FName Section);
	void SetBattleOnDead(bool flg);
	void SetBattleStartWaiting(bool flg);
	void SetBehavior(EMonsterBehavior Behavior);
	void SetBoolOnBlackboard(class FName Key, bool Value);
	void SetCausedDamage(bool flg);
	void SetChargeBreaking(bool flg);
	void SetCombatState(EMonsterCombatState State);
	void SetDamageCollisionEnable(bool isEnable);
	void SetEcologicalState(EEcologicalState ID);
	void SetFloatOnBlackboard(class FName Key, float Value);
	void SetHidingDamage(bool flg);
	void SetIntOnBlackboard(class FName Key, int32 Value);
	void SetLandSection(class FName Section);
	void SetMagicChantingTimer(class AEffectBase* chantingEffect, const float chantingTimer);
	void SetMonsterStatus(EMonsterStatus Status, bool SetFlag);
	void SetMoveAnimation(bool Animation);
	void SetOuterRequestLeave(bool flg);
	void SetPlayingDeadEd(bool flg);
	void SetPlayingHideEd(bool flg);
	void SetStateComplete(bool Complete);
	void SetSuperArmor(bool change);
	void SetTargetDropItemOnBlackboard(class FName Key, class ADropItemObject* Actor);
	void SetTerritoryMaxRadius(float Radius);
	void SetTerritoryMinRadius(float Radius);
	void SetThoughtType(EMonsterThoughtType Type);
	void SetTurn(float Angle, bool isLeft);
	void SetVectorOnBlackboard(class FName Key, const struct FVector& Location);
	void ShowSubjugationMessage();
	void StackBossFinishSequence();
	void StartActionCoolTime();
	void StartDamageGetUp();
	void StartEcoActCoolTime(class FName ID, float Time);
	void TaskFinishBroadcast(bool IsCallBroadcast);
	void TaskFinishClear();
	void UpdateActionCoolTime(float DeltaTime);
	void UpdateEachs();
	void UpdateEcoActCoolTime(float DeltaTime);
	bool ValidEcologicalMotion(EMonsterEcologicalMotion ID);
	bool ValidEcologicalMotions(const TArray<EMonsterEcologicalMotion>& IDs);
	bool ValidEcologicalMotionWithNumber(EMonsterEcologicalMotion ID, int32 No);
	bool ValidTurn();

	float GetActionCycle() const;
	EMonsterBehavior GetBehavior() const;
	bool GetBoolOnBlackboard(class FName Key) const;
	EEcologicalState GetEcologicalState() const;
	EFieldLinkType GetFieldLinkType() const;
	float GetFloatOnBlackboard(class FName Key) const;
	int32 GetIntOnBlackboard(class FName Key) const;
	bool GetIsBoss() const;
	bool GetIsKeepInvisible() const;
	bool GetIsNormalBoss() const;
	const class FName GetKindIDName() const;
	class AMonsterAIController* GetMonsterAIController() const;
	bool GetMonsterStatus(EMonsterStatus Status) const;
	EMonsterType GetParamMonsterType() const;
	int32 GetPartyIndex() const;
	struct FRotator GetRotatorOnBlackboard(class FName Key) const;
	bool GetStateComplete() const;
	class ADropItemObject* GetTargetDropItemOnBlackboard(class FName Key) const;
	class AGPACharacter* GetTargetOnBlackboard(class FName Key) const;
	float GetTerritoryMaxRadius() const;
	float GetTerritoryMinRadius() const;
	EMonsterThoughtType GetThoughtType() const;
	struct FVector GetVectorOnBlackboard(class FName Key) const;
	bool IsEnemyMonster() const;
	bool IsFlyType() const;
	bool IsFriendMonster() const;
	bool IsHidingDamage() const;
	bool IsHighAltitude() const;
	bool IsPlayingDeadEd() const;
	bool IsPlayingHideEd() const;
	bool IsTargeted() const;
	bool IsTurn(float Angle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBase">();
	}
	static class AMonsterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterBase>();
	}
};
static_assert(alignof(AMonsterBase) == 0x000010, "Wrong alignment on AMonsterBase");
static_assert(sizeof(AMonsterBase) == 0x0014D0, "Wrong size on AMonsterBase");
static_assert(offsetof(AMonsterBase, mAccessCollision) == 0x000BF0, "Member 'AMonsterBase::mAccessCollision' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mSpawnPointID) == 0x000C68, "Member 'AMonsterBase::mSpawnPointID' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsterKindID) == 0x000C70, "Member 'AMonsterBase::mMonsterKindID' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsterParameterID) == 0x000C78, "Member 'AMonsterBase::mMonsterParameterID' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mEcologicalAI) == 0x000C88, "Member 'AMonsterBase::mEcologicalAI' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mTimer) == 0x000C90, "Member 'AMonsterBase::mTimer' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mAIPerceptionComponent) == 0x000CB8, "Member 'AMonsterBase::mAIPerceptionComponent' has a wrong offset!");
static_assert(offsetof(AMonsterBase, OnMagickShot) == 0x000CF8, "Member 'AMonsterBase::OnMagickShot' has a wrong offset!");
static_assert(offsetof(AMonsterBase, OnGenerateMagicBullet) == 0x000D08, "Member 'AMonsterBase::OnGenerateMagicBullet' has a wrong offset!");
static_assert(offsetof(AMonsterBase, OnGenerateShotgunBullet) == 0x000D18, "Member 'AMonsterBase::OnGenerateShotgunBullet' has a wrong offset!");
static_assert(offsetof(AMonsterBase, OnGenerateShotgunAllBullets) == 0x000D28, "Member 'AMonsterBase::OnGenerateShotgunAllBullets' has a wrong offset!");
static_assert(offsetof(AMonsterBase, OnTaskFinish) == 0x000D38, "Member 'AMonsterBase::OnTaskFinish' has a wrong offset!");
static_assert(offsetof(AMonsterBase, CombatState) == 0x000D48, "Member 'AMonsterBase::CombatState' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mAnimSection) == 0x000D4C, "Member 'AMonsterBase::mAnimSection' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mLandSection) == 0x000D54, "Member 'AMonsterBase::mLandSection' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_MonsterRotateInsightTarget) == 0x000D80, "Member 'AMonsterBase::mMonsNotifyState_MonsterRotateInsightTarget' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_MonsterTimeCheckAttack) == 0x000D88, "Member 'AMonsterBase::mMonsNotifyState_MonsterTimeCheckAttack' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_MonsterTimeWait) == 0x000D90, "Member 'AMonsterBase::mMonsNotifyState_MonsterTimeWait' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_MonsterCheckFloorChangeSection) == 0x000D98, "Member 'AMonsterBase::mMonsNotifyState_MonsterCheckFloorChangeSection' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_RotateToTargetWithLocationOffset) == 0x000DA0, "Member 'AMonsterBase::mMonsNotifyState_RotateToTargetWithLocationOffset' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_TargetInRangeFin) == 0x000DA8, "Member 'AMonsterBase::mMonsNotifyState_TargetInRangeFin' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsNotifyState_IgnoreCollision) == 0x000DB0, "Member 'AMonsterBase::mMonsNotifyState_IgnoreCollision' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mImpactWeight) == 0x000EA8, "Member 'AMonsterBase::mImpactWeight' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mReversalTime) == 0x000EAC, "Member 'AMonsterBase::mReversalTime' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mAvoidanceBodyInfoList) == 0x000EB0, "Member 'AMonsterBase::mAvoidanceBodyInfoList' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mDamageCollisionInfoList) == 0x000EC8, "Member 'AMonsterBase::mDamageCollisionInfoList' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mEmotionEffect) == 0x000FD8, "Member 'AMonsterBase::mEmotionEffect' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mBattleAIBase) == 0x001270, "Member 'AMonsterBase::mBattleAIBase' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mTargetArrowComponent) == 0x001340, "Member 'AMonsterBase::mTargetArrowComponent' has a wrong offset!");
static_assert(offsetof(AMonsterBase, mMonsterRingComponent) == 0x001368, "Member 'AMonsterBase::mMonsterRingComponent' has a wrong offset!");
static_assert(offsetof(AMonsterBase, SpecialAbilityLevelSequence) == 0x0013C0, "Member 'AMonsterBase::SpecialAbilityLevelSequence' has a wrong offset!");

// Class DarwinGame.Monster
// 0x01E0 (0x16B0 - 0x14D0)
class AMonster : public AMonsterBase
{
public:
	float                                         mDiveCapsuleSize;                                  // 0x14D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D4[0xC];                                     // 0x14D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AGPACharacter* LinkTarget, ELinkType Type, int32 Index)> OnLinkActionFinish;                                // 0x14E0(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F0[0x58];                                    // 0x14F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorDecision*                      mBehaviorDecision;                                 // 0x1548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1550[0x18];                                    // 0x1550(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsterBattleAI*                       mBattleAI;                                         // 0x1568(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMonsterRivalteamNonBattleAI*           mRivalNonBattleAI;                                 // 0x1570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMonsterRivalteamStealArtifactAI*       mRivalStealArtifactAI;                             // 0x1578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMonsterTableComponent*                 MonsterTableComponent;                             // 0x1580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1588[0x90];                                    // 0x1588(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AActingArtifact*                        mHaveArtifact;                                     // 0x1618(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1620[0x8];                                     // 0x1620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActingArtifact*                        mStealArtifact;                                    // 0x1628(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ADropItemObject*>                mIgnoreStealArtifactList;                          // 0x1630(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1640[0x58];                                    // 0x1640(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDitheringSyncControlConnect*           DitheringConnectForFieldLink;                      // 0x1698(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16A0[0x10];                                    // 0x16A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachHaveArtifactOnHead();
	void BattleAIActionDecision();
	void BehaviorDecision();
	void BindOnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void CancelLink();
	void ClearHaveArtifact();
	void DetachHaveArtifactOnHead();
	void DispatchMonsterGetUp();
	void DropHaveArtifact();
	void EndCounterAttackFromFootpad();
	void EndGetUp();
	class UMonsterBattleAI* GetBattleAI();
	bool GetCamEnd();
	EMonsterCameraControllType GetCameraControll();
	EMonsterCameraType GetCameraType();
	class UMonsterEcologicalAI* GetEcologicalAI();
	bool GetIsCounterAttack();
	bool GetIsGetUp();
	EMonsterPhase GetMonsterPhase();
	class UMonsterRivalteamNonBattleAI* GetRivalTeamNonBattleAI();
	class UMonsterRivalteamStealArtifactAI* GetRivalTeamStealArtifactAI();
	void HiddenDeadIcon(bool IsHidden);
	void OnFinishAllEmote();
	void OnFinishPlayOneShotArtifactNotifyStamp();
	void PickUpArtifact();
	void RemoveAttackLocationUser();
	void RequestLeaveDispatchMonster();
	void SetCamEnd(bool flg);
	void SetCameraControll(EMonsterCameraControllType Type);
	void SetCameraType(EMonsterCameraType Type);
	void SetEyesSocket(class FName Name_0);
	void SetIsCounterAttack(bool IsCounterAttack);
	void SetMonsterPhase(EMonsterPhase phase);
	void SetRivalTeamDialogID(int32 ID);
	bool StartLink(const struct FVector& Location, const struct FRotator& Rotation);
	bool StartLinkDefault(const struct FVector& Location, const struct FRotator& Rotation);
	bool StartLinkDive(const struct FVector& Location, const struct FRotator& Rotation);
	void StopMove();
	void WaitLink();
	void WithdrawalFootpad();

	class UMonsterTableComponent* GetMonsterTableComponent() const;
	int32 GetRivalTeamDialogID() const;
	int32 GetStealArtifactID() const;
	bool HasStealArtifact() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Monster">();
	}
	static class AMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonster>();
	}
};
static_assert(alignof(AMonster) == 0x000010, "Wrong alignment on AMonster");
static_assert(sizeof(AMonster) == 0x0016B0, "Wrong size on AMonster");
static_assert(offsetof(AMonster, mDiveCapsuleSize) == 0x0014D0, "Member 'AMonster::mDiveCapsuleSize' has a wrong offset!");
static_assert(offsetof(AMonster, OnLinkActionFinish) == 0x0014E0, "Member 'AMonster::OnLinkActionFinish' has a wrong offset!");
static_assert(offsetof(AMonster, mBehaviorDecision) == 0x001548, "Member 'AMonster::mBehaviorDecision' has a wrong offset!");
static_assert(offsetof(AMonster, mBattleAI) == 0x001568, "Member 'AMonster::mBattleAI' has a wrong offset!");
static_assert(offsetof(AMonster, mRivalNonBattleAI) == 0x001570, "Member 'AMonster::mRivalNonBattleAI' has a wrong offset!");
static_assert(offsetof(AMonster, mRivalStealArtifactAI) == 0x001578, "Member 'AMonster::mRivalStealArtifactAI' has a wrong offset!");
static_assert(offsetof(AMonster, MonsterTableComponent) == 0x001580, "Member 'AMonster::MonsterTableComponent' has a wrong offset!");
static_assert(offsetof(AMonster, mHaveArtifact) == 0x001618, "Member 'AMonster::mHaveArtifact' has a wrong offset!");
static_assert(offsetof(AMonster, mStealArtifact) == 0x001628, "Member 'AMonster::mStealArtifact' has a wrong offset!");
static_assert(offsetof(AMonster, mIgnoreStealArtifactList) == 0x001630, "Member 'AMonster::mIgnoreStealArtifactList' has a wrong offset!");
static_assert(offsetof(AMonster, DitheringConnectForFieldLink) == 0x001698, "Member 'AMonster::DitheringConnectForFieldLink' has a wrong offset!");

// Class DarwinGame.M040
// 0x0000 (0x16B0 - 0x16B0)
class AM040 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M040">();
	}
	static class AM040* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM040>();
	}
};
static_assert(alignof(AM040) == 0x000010, "Wrong alignment on AM040");
static_assert(sizeof(AM040) == 0x0016B0, "Wrong size on AM040");

// Class DarwinGame.AttackCollisionInterface
// 0x0000 (0x0030 - 0x0030)
class IAttackCollisionInterface final : public IInterface
{
public:
	bool IsMagicRampage();
	bool IsOffsetable();
	void Pause();
	void PostDamage();
	void PostHit();
	void Resume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackCollisionInterface">();
	}
	static class IAttackCollisionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAttackCollisionInterface>();
	}
};
static_assert(alignof(IAttackCollisionInterface) == 0x000008, "Wrong alignment on IAttackCollisionInterface");
static_assert(sizeof(IAttackCollisionInterface) == 0x000030, "Wrong size on IAttackCollisionInterface");

// Class DarwinGame.AnimNotify_PickUpArtifact
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_PickUpArtifact final : public UAnimNotify
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PickUpArtifact() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PickUpArtifact">();
	}
	static class UAnimNotify_PickUpArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PickUpArtifact>();
	}
};
static_assert(alignof(UAnimNotify_PickUpArtifact) == 0x000008, "Wrong alignment on UAnimNotify_PickUpArtifact");
static_assert(sizeof(UAnimNotify_PickUpArtifact) == 0x000048, "Wrong size on UAnimNotify_PickUpArtifact");

// Class DarwinGame.AnimNotify_PlayCollectingSE
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_PlayCollectingSE final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayCollectingSE">();
	}
	static class UAnimNotify_PlayCollectingSE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayCollectingSE>();
	}
};
static_assert(alignof(UAnimNotify_PlayCollectingSE) == 0x000008, "Wrong alignment on UAnimNotify_PlayCollectingSE");
static_assert(sizeof(UAnimNotify_PlayCollectingSE) == 0x000040, "Wrong size on UAnimNotify_PlayCollectingSE");

// Class DarwinGame.LiftObjectBase
// 0x0040 (0x02F0 - 0x02B0)
class ALiftObjectBase final : public AFieldObjectBase
{
public:
	TArray<class FName>                           mCloseDoorEventIDList;                             // 0x02B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           mRestoreStateEventIDList;                          // 0x02C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mFastTravelId;                                     // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsActive;                                         // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsOpenRightDoor;                                  // 0x02D9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsOpenLeftDoor;                                   // 0x02DA(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DB[0x15];                                     // 0x02DB(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseLeftDoorSkip();
	void CloseRightDoorSkip();
	void OpenLeftDoorSkip();
	void OpenRightDoorSkip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LiftObjectBase">();
	}
	static class ALiftObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALiftObjectBase>();
	}
};
static_assert(alignof(ALiftObjectBase) == 0x000008, "Wrong alignment on ALiftObjectBase");
static_assert(sizeof(ALiftObjectBase) == 0x0002F0, "Wrong size on ALiftObjectBase");
static_assert(offsetof(ALiftObjectBase, mCloseDoorEventIDList) == 0x0002B0, "Member 'ALiftObjectBase::mCloseDoorEventIDList' has a wrong offset!");
static_assert(offsetof(ALiftObjectBase, mRestoreStateEventIDList) == 0x0002C0, "Member 'ALiftObjectBase::mRestoreStateEventIDList' has a wrong offset!");
static_assert(offsetof(ALiftObjectBase, mFastTravelId) == 0x0002D0, "Member 'ALiftObjectBase::mFastTravelId' has a wrong offset!");
static_assert(offsetof(ALiftObjectBase, mIsActive) == 0x0002D8, "Member 'ALiftObjectBase::mIsActive' has a wrong offset!");
static_assert(offsetof(ALiftObjectBase, mIsOpenRightDoor) == 0x0002D9, "Member 'ALiftObjectBase::mIsOpenRightDoor' has a wrong offset!");
static_assert(offsetof(ALiftObjectBase, mIsOpenLeftDoor) == 0x0002DA, "Member 'ALiftObjectBase::mIsOpenLeftDoor' has a wrong offset!");

// Class DarwinGame.UILoadIconChoice
// 0x0010 (0x0540 - 0x0530)
class UUILoadIconChoice : public UUIScrollMenuItemBase
{
public:
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUILoadIcon*                            LoadIcon;                                          // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadIconChoice">();
	}
	static class UUILoadIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoadIconChoice>();
	}
};
static_assert(alignof(UUILoadIconChoice) == 0x000008, "Wrong alignment on UUILoadIconChoice");
static_assert(sizeof(UUILoadIconChoice) == 0x000540, "Wrong size on UUILoadIconChoice");
static_assert(offsetof(UUILoadIconChoice, Frame) == 0x000530, "Member 'UUILoadIconChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUILoadIconChoice, LoadIcon) == 0x000538, "Member 'UUILoadIconChoice::LoadIcon' has a wrong offset!");

// Class DarwinGame.AnimNotify_PlayEffectAppliedRate
// 0x0000 (0x0090 - 0x0090)
class UAnimNotify_PlayEffectAppliedRate final : public UAnimNotify_PlayParticleEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayEffectAppliedRate">();
	}
	static class UAnimNotify_PlayEffectAppliedRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayEffectAppliedRate>();
	}
};
static_assert(alignof(UAnimNotify_PlayEffectAppliedRate) == 0x000010, "Wrong alignment on UAnimNotify_PlayEffectAppliedRate");
static_assert(sizeof(UAnimNotify_PlayEffectAppliedRate) == 0x000090, "Wrong size on UAnimNotify_PlayEffectAppliedRate");

// Class DarwinGame.UIField_IconLockon
// 0x0000 (0x05B0 - 0x05B0)
class UUIField_IconLockon : public UUI3DBase
{
public:
	class UWidgetAnimation*                       NowAnim;                                           // 0x05A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void LockOff();
	void LockOn();
	void SetLockOnState(bool IsLockOn);
	void SetMarkerVisibility(bool Condition);
	void SetTarget(class USceneComponent* SceneComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_IconLockon">();
	}
	static class UUIField_IconLockon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_IconLockon>();
	}
};
static_assert(alignof(UUIField_IconLockon) == 0x000010, "Wrong alignment on UUIField_IconLockon");
static_assert(sizeof(UUIField_IconLockon) == 0x0005B0, "Wrong size on UUIField_IconLockon");
static_assert(offsetof(UUIField_IconLockon, NowAnim) == 0x0005A8, "Member 'UUIField_IconLockon::NowAnim' has a wrong offset!");

// Class DarwinGame.DarwinFlagDefinitionDataTable
// 0x0000 (0x0030 - 0x0030)
class UDarwinFlagDefinitionDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinFlagDefinitionDataTable">();
	}
	static class UDarwinFlagDefinitionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinFlagDefinitionDataTable>();
	}
};
static_assert(alignof(UDarwinFlagDefinitionDataTable) == 0x000008, "Wrong alignment on UDarwinFlagDefinitionDataTable");
static_assert(sizeof(UDarwinFlagDefinitionDataTable) == 0x000030, "Wrong size on UDarwinFlagDefinitionDataTable");

// Class DarwinGame.AnimNotify_PlayFootEffect
// 0x0020 (0x0060 - 0x0040)
class UAnimNotify_PlayFootEffect final : public UAnimNotify
{
public:
	struct FFootEffectRequest                     Request;                                           // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayFootEffect">();
	}
	static class UAnimNotify_PlayFootEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayFootEffect>();
	}
};
static_assert(alignof(UAnimNotify_PlayFootEffect) == 0x000008, "Wrong alignment on UAnimNotify_PlayFootEffect");
static_assert(sizeof(UAnimNotify_PlayFootEffect) == 0x000060, "Wrong size on UAnimNotify_PlayFootEffect");
static_assert(offsetof(UAnimNotify_PlayFootEffect, Request) == 0x000040, "Member 'UAnimNotify_PlayFootEffect::Request' has a wrong offset!");

// Class DarwinGame.DarwinSaveGame
// 0x0010 (0x0040 - 0x0030)
class UDarwinSaveGame final : public USaveGameBase
{
public:
	class FString                                 GameData;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinSaveGame">();
	}
	static class UDarwinSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinSaveGame>();
	}
};
static_assert(alignof(UDarwinSaveGame) == 0x000008, "Wrong alignment on UDarwinSaveGame");
static_assert(sizeof(UDarwinSaveGame) == 0x000040, "Wrong size on UDarwinSaveGame");
static_assert(offsetof(UDarwinSaveGame, GameData) == 0x000030, "Member 'UDarwinSaveGame::GameData' has a wrong offset!");

// Class DarwinGame.AnimNotify_PlaySkillEffect
// 0x0010 (0x00A0 - 0x0090)
class UAnimNotify_PlaySkillEffect final : public UAnimNotify_PlayParticleEffect
{
public:
	bool                                          IsExplosionOfSpecialAbility;                       // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlaySkillEffect">();
	}
	static class UAnimNotify_PlaySkillEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlaySkillEffect>();
	}
};
static_assert(alignof(UAnimNotify_PlaySkillEffect) == 0x000010, "Wrong alignment on UAnimNotify_PlaySkillEffect");
static_assert(sizeof(UAnimNotify_PlaySkillEffect) == 0x0000A0, "Wrong size on UAnimNotify_PlaySkillEffect");
static_assert(offsetof(UAnimNotify_PlaySkillEffect, IsExplosionOfSpecialAbility) == 0x000090, "Member 'UAnimNotify_PlaySkillEffect::IsExplosionOfSpecialAbility' has a wrong offset!");

// Class DarwinGame.PushWaveDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UPushWaveDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushWaveDamageExecution">();
	}
	static class UPushWaveDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushWaveDamageExecution>();
	}
};
static_assert(alignof(UPushWaveDamageExecution) == 0x000008, "Wrong alignment on UPushWaveDamageExecution");
static_assert(sizeof(UPushWaveDamageExecution) == 0x000048, "Wrong size on UPushWaveDamageExecution");

// Class DarwinGame.AttackCollisionBase
// 0x0058 (0x0280 - 0x0228)
class AAttackCollisionBase : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(struct FAttackCollisionEventInfo& Info, class FName damageCollisionId, bool doDamage)> OnExecuteOverlapEvent;                             // 0x0238(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         UniqueId;                                          // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttackElementBaseComponent*            element;                                           // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x28];                                     // 0x0258(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlap(const struct FOverlapEventInfo& Info, class FName ElementID);
	void OnComponentExecuteOverlapEvent(struct FAttackCollisionEventInfo* Info, class FName damageCollisionId, bool doDamage);
	void Release();
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackCollisionBase">();
	}
	static class AAttackCollisionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttackCollisionBase>();
	}
};
static_assert(alignof(AAttackCollisionBase) == 0x000008, "Wrong alignment on AAttackCollisionBase");
static_assert(sizeof(AAttackCollisionBase) == 0x000280, "Wrong size on AAttackCollisionBase");
static_assert(offsetof(AAttackCollisionBase, OnExecuteOverlapEvent) == 0x000238, "Member 'AAttackCollisionBase::OnExecuteOverlapEvent' has a wrong offset!");
static_assert(offsetof(AAttackCollisionBase, UniqueId) == 0x000248, "Member 'AAttackCollisionBase::UniqueId' has a wrong offset!");
static_assert(offsetof(AAttackCollisionBase, element) == 0x000250, "Member 'AAttackCollisionBase::element' has a wrong offset!");

// Class DarwinGame.UIField_StampIconBase
// 0x0060 (0x0610 - 0x05B0)
class UUIField_StampIconBase : public UUI3DBase
{
public:
	uint8                                         Pad_5A8[0x18];                                     // 0x05A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       OpenAnim;                                          // 0x05C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x05C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x40];                                     // 0x05D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_StampIconBase">();
	}
	static class UUIField_StampIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_StampIconBase>();
	}
};
static_assert(alignof(UUIField_StampIconBase) == 0x000010, "Wrong alignment on UUIField_StampIconBase");
static_assert(sizeof(UUIField_StampIconBase) == 0x000610, "Wrong size on UUIField_StampIconBase");
static_assert(offsetof(UUIField_StampIconBase, OpenAnim) == 0x0005C0, "Member 'UUIField_StampIconBase::OpenAnim' has a wrong offset!");
static_assert(offsetof(UUIField_StampIconBase, WaitAnim) == 0x0005C8, "Member 'UUIField_StampIconBase::WaitAnim' has a wrong offset!");

// Class DarwinGame.AnimNotify_PopDialogue
// 0x0010 (0x0050 - 0x0040)
class UAnimNotify_PopDialogue final : public UAnimNotify
{
public:
	float                                         mPopTime;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIsFirstRival;                                     // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         mDelayMessage;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDialogTimingType                             DialogTiming;                                      // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PopDialogue">();
	}
	static class UAnimNotify_PopDialogue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PopDialogue>();
	}
};
static_assert(alignof(UAnimNotify_PopDialogue) == 0x000008, "Wrong alignment on UAnimNotify_PopDialogue");
static_assert(sizeof(UAnimNotify_PopDialogue) == 0x000050, "Wrong size on UAnimNotify_PopDialogue");
static_assert(offsetof(UAnimNotify_PopDialogue, mPopTime) == 0x000040, "Member 'UAnimNotify_PopDialogue::mPopTime' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PopDialogue, mIsFirstRival) == 0x000044, "Member 'UAnimNotify_PopDialogue::mIsFirstRival' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PopDialogue, mDelayMessage) == 0x000048, "Member 'UAnimNotify_PopDialogue::mDelayMessage' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PopDialogue, DialogTiming) == 0x00004C, "Member 'UAnimNotify_PopDialogue::DialogTiming' has a wrong offset!");

// Class DarwinGame.DarwinSceneCaptureImage
// 0x0070 (0x0288 - 0x0218)
class UDarwinSceneCaptureImage : public UImage
{
public:
	TArray<struct FST_SceneCapture2DLight>        DirectionalLights;                                 // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SceneCapture;                                      // 0x0228(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget_High;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x0260(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASceneCaptureBase*                      SceneCaptureActor;                                 // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADirectionalLight*>              LightActors;                                       // 0x0278(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinSceneCaptureImage">();
	}
	static class UDarwinSceneCaptureImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinSceneCaptureImage>();
	}
};
static_assert(alignof(UDarwinSceneCaptureImage) == 0x000008, "Wrong alignment on UDarwinSceneCaptureImage");
static_assert(sizeof(UDarwinSceneCaptureImage) == 0x000288, "Wrong size on UDarwinSceneCaptureImage");
static_assert(offsetof(UDarwinSceneCaptureImage, DirectionalLights) == 0x000218, "Member 'UDarwinSceneCaptureImage::DirectionalLights' has a wrong offset!");
static_assert(offsetof(UDarwinSceneCaptureImage, SceneCapture) == 0x000228, "Member 'UDarwinSceneCaptureImage::SceneCapture' has a wrong offset!");
static_assert(offsetof(UDarwinSceneCaptureImage, RenderTarget) == 0x000250, "Member 'UDarwinSceneCaptureImage::RenderTarget' has a wrong offset!");
static_assert(offsetof(UDarwinSceneCaptureImage, RenderTarget_High) == 0x000258, "Member 'UDarwinSceneCaptureImage::RenderTarget_High' has a wrong offset!");
static_assert(offsetof(UDarwinSceneCaptureImage, Offset) == 0x000260, "Member 'UDarwinSceneCaptureImage::Offset' has a wrong offset!");
static_assert(offsetof(UDarwinSceneCaptureImage, SceneCaptureActor) == 0x000270, "Member 'UDarwinSceneCaptureImage::SceneCaptureActor' has a wrong offset!");
static_assert(offsetof(UDarwinSceneCaptureImage, LightActors) == 0x000278, "Member 'UDarwinSceneCaptureImage::LightActors' has a wrong offset!");

// Class DarwinGame.DarwinArtifactCaptureImage
// 0x0018 (0x02A0 - 0x0288)
class UDarwinArtifactCaptureImage : public UDarwinSceneCaptureImage
{
public:
	class UMaterial*                              DefaultMaterial;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              SilhouetteMaterial;                                // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              ReplicaMaterial;                                   // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinArtifactCaptureImage">();
	}
	static class UDarwinArtifactCaptureImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinArtifactCaptureImage>();
	}
};
static_assert(alignof(UDarwinArtifactCaptureImage) == 0x000008, "Wrong alignment on UDarwinArtifactCaptureImage");
static_assert(sizeof(UDarwinArtifactCaptureImage) == 0x0002A0, "Wrong size on UDarwinArtifactCaptureImage");
static_assert(offsetof(UDarwinArtifactCaptureImage, DefaultMaterial) == 0x000288, "Member 'UDarwinArtifactCaptureImage::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(UDarwinArtifactCaptureImage, SilhouetteMaterial) == 0x000290, "Member 'UDarwinArtifactCaptureImage::SilhouetteMaterial' has a wrong offset!");
static_assert(offsetof(UDarwinArtifactCaptureImage, ReplicaMaterial) == 0x000298, "Member 'UDarwinArtifactCaptureImage::ReplicaMaterial' has a wrong offset!");

// Class DarwinGame.DarwinArtifactTwoCaptureImage
// 0x0010 (0x02B0 - 0x02A0)
class UDarwinArtifactTwoCaptureImage final : public UDarwinArtifactCaptureImage
{
public:
	class UTextureRenderTarget2D*                 FinalColorRenderTarget;                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 FinalColorRenderTarget_High;                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinArtifactTwoCaptureImage">();
	}
	static class UDarwinArtifactTwoCaptureImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinArtifactTwoCaptureImage>();
	}
};
static_assert(alignof(UDarwinArtifactTwoCaptureImage) == 0x000008, "Wrong alignment on UDarwinArtifactTwoCaptureImage");
static_assert(sizeof(UDarwinArtifactTwoCaptureImage) == 0x0002B0, "Wrong size on UDarwinArtifactTwoCaptureImage");
static_assert(offsetof(UDarwinArtifactTwoCaptureImage, FinalColorRenderTarget) == 0x0002A0, "Member 'UDarwinArtifactTwoCaptureImage::FinalColorRenderTarget' has a wrong offset!");
static_assert(offsetof(UDarwinArtifactTwoCaptureImage, FinalColorRenderTarget_High) == 0x0002A8, "Member 'UDarwinArtifactTwoCaptureImage::FinalColorRenderTarget_High' has a wrong offset!");

// Class DarwinGame.UIMainMenu_Button
// 0x0038 (0x0568 - 0x0530)
class UUIMainMenu_Button : public UUIScrollMenuItemBase
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MaxTextColor;                                      // 0x0538(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MaxTextOutlineColor;                               // 0x0548(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             OnTexture;                                         // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             OffTexture;                                        // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainMenu_Button">();
	}
	static class UUIMainMenu_Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainMenu_Button>();
	}
};
static_assert(alignof(UUIMainMenu_Button) == 0x000008, "Wrong alignment on UUIMainMenu_Button");
static_assert(sizeof(UUIMainMenu_Button) == 0x000568, "Wrong size on UUIMainMenu_Button");
static_assert(offsetof(UUIMainMenu_Button, ImageIcon) == 0x000530, "Member 'UUIMainMenu_Button::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUIMainMenu_Button, MaxTextColor) == 0x000538, "Member 'UUIMainMenu_Button::MaxTextColor' has a wrong offset!");
static_assert(offsetof(UUIMainMenu_Button, MaxTextOutlineColor) == 0x000548, "Member 'UUIMainMenu_Button::MaxTextOutlineColor' has a wrong offset!");
static_assert(offsetof(UUIMainMenu_Button, OnTexture) == 0x000558, "Member 'UUIMainMenu_Button::OnTexture' has a wrong offset!");
static_assert(offsetof(UUIMainMenu_Button, OffTexture) == 0x000560, "Member 'UUIMainMenu_Button::OffTexture' has a wrong offset!");

// Class DarwinGame.AnimNotify_PossessedSequenceEnd
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_PossessedSequenceEnd final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PossessedSequenceEnd">();
	}
	static class UAnimNotify_PossessedSequenceEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PossessedSequenceEnd>();
	}
};
static_assert(alignof(UAnimNotify_PossessedSequenceEnd) == 0x000008, "Wrong alignment on UAnimNotify_PossessedSequenceEnd");
static_assert(sizeof(UAnimNotify_PossessedSequenceEnd) == 0x000040, "Wrong size on UAnimNotify_PossessedSequenceEnd");

// Class DarwinGame.ProjectileMagicBase
// 0x0020 (0x0310 - 0x02F0)
class AProjectileMagicBase : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           MagicMovement;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHit;                                            // 0x0300(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0xF];                                      // 0x0301(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReturnBulletEffect();
	void SpawnBulletEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileMagicBase">();
	}
	static class AProjectileMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectileMagicBase>();
	}
};
static_assert(alignof(AProjectileMagicBase) == 0x000008, "Wrong alignment on AProjectileMagicBase");
static_assert(sizeof(AProjectileMagicBase) == 0x000310, "Wrong size on AProjectileMagicBase");
static_assert(offsetof(AProjectileMagicBase, collision) == 0x0002F0, "Member 'AProjectileMagicBase::collision' has a wrong offset!");
static_assert(offsetof(AProjectileMagicBase, MagicMovement) == 0x0002F8, "Member 'AProjectileMagicBase::MagicMovement' has a wrong offset!");
static_assert(offsetof(AProjectileMagicBase, bIsHit) == 0x000300, "Member 'AProjectileMagicBase::bIsHit' has a wrong offset!");

// Class DarwinGame.MissileMagicBase
// 0x0050 (0x0360 - 0x0310)
class AMissileMagicBase final : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit();
	void OnLaunch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissileMagicBase">();
	}
	static class AMissileMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissileMagicBase>();
	}
};
static_assert(alignof(AMissileMagicBase) == 0x000008, "Wrong alignment on AMissileMagicBase");
static_assert(sizeof(AMissileMagicBase) == 0x000360, "Wrong size on AMissileMagicBase");

// Class DarwinGame.AnimNotify_ProvocationStart
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ProvocationStart final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ProvocationStart">();
	}
	static class UAnimNotify_ProvocationStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ProvocationStart>();
	}
};
static_assert(alignof(UAnimNotify_ProvocationStart) == 0x000008, "Wrong alignment on UAnimNotify_ProvocationStart");
static_assert(sizeof(UAnimNotify_ProvocationStart) == 0x000040, "Wrong size on UAnimNotify_ProvocationStart");

// Class DarwinGame.AnimNotify_ShowCompass
// 0x0008 (0x0048 - 0x0040)
class UAnimNotify_ShowCompass final : public UAnimNotify
{
public:
	float                                         ScalingTime;                                       // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ShowCompass">();
	}
	static class UAnimNotify_ShowCompass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ShowCompass>();
	}
};
static_assert(alignof(UAnimNotify_ShowCompass) == 0x000008, "Wrong alignment on UAnimNotify_ShowCompass");
static_assert(sizeof(UAnimNotify_ShowCompass) == 0x000048, "Wrong size on UAnimNotify_ShowCompass");
static_assert(offsetof(UAnimNotify_ShowCompass, ScalingTime) == 0x000040, "Member 'UAnimNotify_ShowCompass::ScalingTime' has a wrong offset!");

// Class DarwinGame.AttackLocationManager
// 0x0010 (0x0040 - 0x0030)
class UAttackLocationManager final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackLocationManager">();
	}
	static class UAttackLocationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackLocationManager>();
	}
};
static_assert(alignof(UAttackLocationManager) == 0x000008, "Wrong alignment on UAttackLocationManager");
static_assert(sizeof(UAttackLocationManager) == 0x000040, "Wrong size on UAttackLocationManager");

// Class DarwinGame.TreasureFigureBase
// 0x0068 (0x0318 - 0x02B0)
class ATreasureFigureBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x68];                                     // 0x02B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableUIMode(EFigureType Type, bool pedestal, bool Crystal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureFigureBase">();
	}
	static class ATreasureFigureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureFigureBase>();
	}
};
static_assert(alignof(ATreasureFigureBase) == 0x000008, "Wrong alignment on ATreasureFigureBase");
static_assert(sizeof(ATreasureFigureBase) == 0x000318, "Wrong size on ATreasureFigureBase");

// Class DarwinGame.TreasureFigureObject
// 0x0000 (0x0318 - 0x0318)
class ATreasureFigureObject final : public ATreasureFigureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureFigureObject">();
	}
	static class ATreasureFigureObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureFigureObject>();
	}
};
static_assert(alignof(ATreasureFigureObject) == 0x000008, "Wrong alignment on ATreasureFigureObject");
static_assert(sizeof(ATreasureFigureObject) == 0x000318, "Wrong size on ATreasureFigureObject");

// Class DarwinGame.UILoadIcon
// 0x0018 (0x04A8 - 0x0490)
class UUILoadIcon : public UDarwinUserWidget
{
public:
	class UImage*                                 CaptureImage;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUILoadFacePanel*>               LoadFacePanelList;                                 // 0x0498(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadIcon">();
	}
	static class UUILoadIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoadIcon>();
	}
};
static_assert(alignof(UUILoadIcon) == 0x000008, "Wrong alignment on UUILoadIcon");
static_assert(sizeof(UUILoadIcon) == 0x0004A8, "Wrong size on UUILoadIcon");
static_assert(offsetof(UUILoadIcon, CaptureImage) == 0x000490, "Member 'UUILoadIcon::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUILoadIcon, LoadFacePanelList) == 0x000498, "Member 'UUILoadIcon::LoadFacePanelList' has a wrong offset!");

// Class DarwinGame.AnimNotify_ShowReplicaStamp
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_ShowReplicaStamp final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_ShowReplicaStamp">();
	}
	static class UAnimNotify_ShowReplicaStamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_ShowReplicaStamp>();
	}
};
static_assert(alignof(UAnimNotify_ShowReplicaStamp) == 0x000008, "Wrong alignment on UAnimNotify_ShowReplicaStamp");
static_assert(sizeof(UAnimNotify_ShowReplicaStamp) == 0x000040, "Wrong size on UAnimNotify_ShowReplicaStamp");

// Class DarwinGame.GameFieldGameMode
// 0x0000 (0x02C8 - 0x02C8)
class AGameFieldGameMode : public AAppGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFieldGameMode">();
	}
	static class AGameFieldGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameFieldGameMode>();
	}
};
static_assert(alignof(AGameFieldGameMode) == 0x000008, "Wrong alignment on AGameFieldGameMode");
static_assert(sizeof(AGameFieldGameMode) == 0x0002C8, "Wrong size on AGameFieldGameMode");

// Class DarwinGame.AnimNotify_Unrivaled
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_Unrivaled final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Unrivaled">();
	}
	static class UAnimNotify_Unrivaled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Unrivaled>();
	}
};
static_assert(alignof(UAnimNotify_Unrivaled) == 0x000008, "Wrong alignment on UAnimNotify_Unrivaled");
static_assert(sizeof(UAnimNotify_Unrivaled) == 0x000040, "Wrong size on UAnimNotify_Unrivaled");

// Class DarwinGame.AnimNotifyState_AdjustJump
// 0x0028 (0x0060 - 0x0038)
class UAnimNotifyState_AdjustJump final : public UAnimNotifyState
{
public:
	EAdjustJumpType                               mJumpType;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mReferenceValue;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mMinMovement;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mMaxMovement;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mSetAttackAreaLocation;                            // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mAttackAreaLocationAdjustValue;                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mLoopEndTimer;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AdjustJump">();
	}
	static class UAnimNotifyState_AdjustJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AdjustJump>();
	}
};
static_assert(alignof(UAnimNotifyState_AdjustJump) == 0x000008, "Wrong alignment on UAnimNotifyState_AdjustJump");
static_assert(sizeof(UAnimNotifyState_AdjustJump) == 0x000060, "Wrong size on UAnimNotifyState_AdjustJump");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mJumpType) == 0x000038, "Member 'UAnimNotifyState_AdjustJump::mJumpType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mReferenceValue) == 0x00003C, "Member 'UAnimNotifyState_AdjustJump::mReferenceValue' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mMinMovement) == 0x000040, "Member 'UAnimNotifyState_AdjustJump::mMinMovement' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mMaxMovement) == 0x000044, "Member 'UAnimNotifyState_AdjustJump::mMaxMovement' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mSetAttackAreaLocation) == 0x000048, "Member 'UAnimNotifyState_AdjustJump::mSetAttackAreaLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mAttackAreaLocationAdjustValue) == 0x00004C, "Member 'UAnimNotifyState_AdjustJump::mAttackAreaLocationAdjustValue' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_AdjustJump, mLoopEndTimer) == 0x000050, "Member 'UAnimNotifyState_AdjustJump::mLoopEndTimer' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_SwitchDamageCollision
// 0x0020 (0x0058 - 0x0038)
class UAnimNotifyState_SwitchDamageCollision final : public UAnimNotifyState
{
public:
	TArray<class FName>                           HideCollisionName;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ShowCollisionName;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SwitchDamageCollision">();
	}
	static class UAnimNotifyState_SwitchDamageCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SwitchDamageCollision>();
	}
};
static_assert(alignof(UAnimNotifyState_SwitchDamageCollision) == 0x000008, "Wrong alignment on UAnimNotifyState_SwitchDamageCollision");
static_assert(sizeof(UAnimNotifyState_SwitchDamageCollision) == 0x000058, "Wrong size on UAnimNotifyState_SwitchDamageCollision");
static_assert(offsetof(UAnimNotifyState_SwitchDamageCollision, HideCollisionName) == 0x000038, "Member 'UAnimNotifyState_SwitchDamageCollision::HideCollisionName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SwitchDamageCollision, ShowCollisionName) == 0x000048, "Member 'UAnimNotifyState_SwitchDamageCollision::ShowCollisionName' has a wrong offset!");

// Class DarwinGame.SkillChainDirector
// 0x0068 (0x0290 - 0x0228)
class ASkillChainDirector final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActionAbilitySystemComponent*          AbilitySystem;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGPACharacter*                          mDamagedCharacter;                                 // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x38];                                     // 0x0240(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            mPredictiveEffect;                                 // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            mLastAttackEffect;                                 // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChainDirector">();
	}
	static class ASkillChainDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkillChainDirector>();
	}
};
static_assert(alignof(ASkillChainDirector) == 0x000008, "Wrong alignment on ASkillChainDirector");
static_assert(sizeof(ASkillChainDirector) == 0x000290, "Wrong size on ASkillChainDirector");
static_assert(offsetof(ASkillChainDirector, AbilitySystem) == 0x000230, "Member 'ASkillChainDirector::AbilitySystem' has a wrong offset!");
static_assert(offsetof(ASkillChainDirector, mDamagedCharacter) == 0x000238, "Member 'ASkillChainDirector::mDamagedCharacter' has a wrong offset!");
static_assert(offsetof(ASkillChainDirector, mPredictiveEffect) == 0x000278, "Member 'ASkillChainDirector::mPredictiveEffect' has a wrong offset!");
static_assert(offsetof(ASkillChainDirector, mLastAttackEffect) == 0x000280, "Member 'ASkillChainDirector::mLastAttackEffect' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ApplyMaterialParameterBase
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_ApplyMaterialParameterBase : public UAnimNotifyState
{
public:
	float                                         BlendTotalDuration;                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTime;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ApplyMaterialParameterBase">();
	}
	static class UAnimNotifyState_ApplyMaterialParameterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ApplyMaterialParameterBase>();
	}
};
static_assert(alignof(UAnimNotifyState_ApplyMaterialParameterBase) == 0x000008, "Wrong alignment on UAnimNotifyState_ApplyMaterialParameterBase");
static_assert(sizeof(UAnimNotifyState_ApplyMaterialParameterBase) == 0x000040, "Wrong size on UAnimNotifyState_ApplyMaterialParameterBase");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterBase, BlendTotalDuration) == 0x000038, "Member 'UAnimNotifyState_ApplyMaterialParameterBase::BlendTotalDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterBase, CurrentTime) == 0x00003C, "Member 'UAnimNotifyState_ApplyMaterialParameterBase::CurrentTime' has a wrong offset!");

// Class DarwinGame.GameDataBonfireLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataBonfireLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataBonfireLibrary">();
	}
	static class UGameDataBonfireLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataBonfireLibrary>();
	}
};
static_assert(alignof(UGameDataBonfireLibrary) == 0x000008, "Wrong alignment on UGameDataBonfireLibrary");
static_assert(sizeof(UGameDataBonfireLibrary) == 0x000030, "Wrong size on UGameDataBonfireLibrary");

// Class DarwinGame.AnimNotifyState_ApplyMaterialParameterFloatCurve
// 0x0028 (0x0068 - 0x0040)
class UAnimNotifyState_ApplyMaterialParameterFloatCurve final : public UAnimNotifyState_ApplyMaterialParameterBase
{
public:
	struct FAnimNotifyMaterialParameterFloatInfo  MaterialParameter;                                 // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ApplyMaterialParameterFloatCurve">();
	}
	static class UAnimNotifyState_ApplyMaterialParameterFloatCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ApplyMaterialParameterFloatCurve>();
	}
};
static_assert(alignof(UAnimNotifyState_ApplyMaterialParameterFloatCurve) == 0x000008, "Wrong alignment on UAnimNotifyState_ApplyMaterialParameterFloatCurve");
static_assert(sizeof(UAnimNotifyState_ApplyMaterialParameterFloatCurve) == 0x000068, "Wrong size on UAnimNotifyState_ApplyMaterialParameterFloatCurve");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterFloatCurve, MaterialParameter) == 0x000040, "Member 'UAnimNotifyState_ApplyMaterialParameterFloatCurve::MaterialParameter' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_QuicksandWait
// 0x0020 (0x0058 - 0x0038)
class UAnimNotifyState_QuicksandWait final : public UAnimNotifyState
{
public:
	float                                         mRange;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDurationTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mFailSection;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_QuicksandWait">();
	}
	static class UAnimNotifyState_QuicksandWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_QuicksandWait>();
	}
};
static_assert(alignof(UAnimNotifyState_QuicksandWait) == 0x000008, "Wrong alignment on UAnimNotifyState_QuicksandWait");
static_assert(sizeof(UAnimNotifyState_QuicksandWait) == 0x000058, "Wrong size on UAnimNotifyState_QuicksandWait");
static_assert(offsetof(UAnimNotifyState_QuicksandWait, mRange) == 0x000038, "Member 'UAnimNotifyState_QuicksandWait::mRange' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_QuicksandWait, mDurationTime) == 0x00003C, "Member 'UAnimNotifyState_QuicksandWait::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_QuicksandWait, mFailSection) == 0x000040, "Member 'UAnimNotifyState_QuicksandWait::mFailSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_QuicksandWait, mSuccessSection) == 0x000048, "Member 'UAnimNotifyState_QuicksandWait::mSuccessSection' has a wrong offset!");

// Class DarwinGame.UIDispatch_TeamStatusBase
// 0x0028 (0x0518 - 0x04F0)
class UUIDispatch_TeamStatusBase : public UUIFreeScrollBase
{
public:
	int32                                         ScrollItemMax;                                     // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x24];                                     // 0x04F4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_TeamStatusBase">();
	}
	static class UUIDispatch_TeamStatusBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_TeamStatusBase>();
	}
};
static_assert(alignof(UUIDispatch_TeamStatusBase) == 0x000008, "Wrong alignment on UUIDispatch_TeamStatusBase");
static_assert(sizeof(UUIDispatch_TeamStatusBase) == 0x000518, "Wrong size on UUIDispatch_TeamStatusBase");
static_assert(offsetof(UUIDispatch_TeamStatusBase, ScrollItemMax) == 0x0004F0, "Member 'UUIDispatch_TeamStatusBase::ScrollItemMax' has a wrong offset!");

// Class DarwinGame.UIDispatch_TeamStatus
// 0x0020 (0x0538 - 0x0518)
class UUIDispatch_TeamStatus : public UUIDispatch_TeamStatusBase
{
public:
	uint8                                         Pad_518[0x20];                                     // 0x0518(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_TeamStatus">();
	}
	static class UUIDispatch_TeamStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_TeamStatus>();
	}
};
static_assert(alignof(UUIDispatch_TeamStatus) == 0x000008, "Wrong alignment on UUIDispatch_TeamStatus");
static_assert(sizeof(UUIDispatch_TeamStatus) == 0x000538, "Wrong size on UUIDispatch_TeamStatus");

// Class DarwinGame.AnimNotifyState_ApplyMaterialParameterLinearColorCurve
// 0x0048 (0x0088 - 0x0040)
class UAnimNotifyState_ApplyMaterialParameterLinearColorCurve final : public UAnimNotifyState_ApplyMaterialParameterBase
{
public:
	struct FAnimNotifyMaterialParameterLinearColorInfo MaterialParameter;                                 // 0x0040(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ApplyMaterialParameterLinearColorCurve">();
	}
	static class UAnimNotifyState_ApplyMaterialParameterLinearColorCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ApplyMaterialParameterLinearColorCurve>();
	}
};
static_assert(alignof(UAnimNotifyState_ApplyMaterialParameterLinearColorCurve) == 0x000008, "Wrong alignment on UAnimNotifyState_ApplyMaterialParameterLinearColorCurve");
static_assert(sizeof(UAnimNotifyState_ApplyMaterialParameterLinearColorCurve) == 0x000088, "Wrong size on UAnimNotifyState_ApplyMaterialParameterLinearColorCurve");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterLinearColorCurve, MaterialParameter) == 0x000040, "Member 'UAnimNotifyState_ApplyMaterialParameterLinearColorCurve::MaterialParameter' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ApplyMaterialParameterMockTest
// 0x0030 (0x0070 - 0x0040)
class UAnimNotifyState_ApplyMaterialParameterMockTest final : public UAnimNotifyState_ApplyMaterialParameterBase
{
public:
	TArray<struct FAnimNotifyMaterialParameterFloatInfo> MaterialParameterFloatList;                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimNotifyMaterialParameterVectorInfo> MaterialParameterVectorList;                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimNotifyMaterialParameterLinearColorInfo> MaterialParameterColorList;                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ApplyMaterialParameterMockTest">();
	}
	static class UAnimNotifyState_ApplyMaterialParameterMockTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ApplyMaterialParameterMockTest>();
	}
};
static_assert(alignof(UAnimNotifyState_ApplyMaterialParameterMockTest) == 0x000008, "Wrong alignment on UAnimNotifyState_ApplyMaterialParameterMockTest");
static_assert(sizeof(UAnimNotifyState_ApplyMaterialParameterMockTest) == 0x000070, "Wrong size on UAnimNotifyState_ApplyMaterialParameterMockTest");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterMockTest, MaterialParameterFloatList) == 0x000040, "Member 'UAnimNotifyState_ApplyMaterialParameterMockTest::MaterialParameterFloatList' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterMockTest, MaterialParameterVectorList) == 0x000050, "Member 'UAnimNotifyState_ApplyMaterialParameterMockTest::MaterialParameterVectorList' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterMockTest, MaterialParameterColorList) == 0x000060, "Member 'UAnimNotifyState_ApplyMaterialParameterMockTest::MaterialParameterColorList' has a wrong offset!");

// Class DarwinGame.TrialDirectorMessageGameMode
// 0x0000 (0x02C8 - 0x02C8)
class ATrialDirectorMessageGameMode final : public AAppGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrialDirectorMessageGameMode">();
	}
	static class ATrialDirectorMessageGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrialDirectorMessageGameMode>();
	}
};
static_assert(alignof(ATrialDirectorMessageGameMode) == 0x000008, "Wrong alignment on ATrialDirectorMessageGameMode");
static_assert(sizeof(ATrialDirectorMessageGameMode) == 0x0002C8, "Wrong size on ATrialDirectorMessageGameMode");

// Class DarwinGame.BaseAreaBattleFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UBaseAreaBattleFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsBaseAreaBattleEvent();
	static bool IsOccurringBaseAreaBattle(bool isCheckEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaBattleFunctionLibrary">();
	}
	static class UBaseAreaBattleFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAreaBattleFunctionLibrary>();
	}
};
static_assert(alignof(UBaseAreaBattleFunctionLibrary) == 0x000008, "Wrong alignment on UBaseAreaBattleFunctionLibrary");
static_assert(sizeof(UBaseAreaBattleFunctionLibrary) == 0x000030, "Wrong size on UBaseAreaBattleFunctionLibrary");

// Class DarwinGame.UIEstimate_BonusDialogItemBase
// 0x0010 (0x04A0 - 0x0490)
class UUIEstimate_BonusDialogItemBase : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_BonusDialogItemBase">();
	}
	static class UUIEstimate_BonusDialogItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_BonusDialogItemBase>();
	}
};
static_assert(alignof(UUIEstimate_BonusDialogItemBase) == 0x000008, "Wrong alignment on UUIEstimate_BonusDialogItemBase");
static_assert(sizeof(UUIEstimate_BonusDialogItemBase) == 0x0004A0, "Wrong size on UUIEstimate_BonusDialogItemBase");

// Class DarwinGame.UIEstimate_HaveArtifact
// 0x00B8 (0x0558 - 0x04A0)
class UUIEstimate_HaveArtifact final : public UUIEstimate_BonusDialogItemBase
{
public:
	TMap<EArtifactIconType, class UTexture2D*>    IconImageList;                                     // 0x04A0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<int32, class UTexture2D*>                NumImageList;                                      // 0x04F0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	class UImage*                                 IconImage;                                         // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Num1Image;                                         // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Num2Image;                                         // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_HaveArtifact">();
	}
	static class UUIEstimate_HaveArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_HaveArtifact>();
	}
};
static_assert(alignof(UUIEstimate_HaveArtifact) == 0x000008, "Wrong alignment on UUIEstimate_HaveArtifact");
static_assert(sizeof(UUIEstimate_HaveArtifact) == 0x000558, "Wrong size on UUIEstimate_HaveArtifact");
static_assert(offsetof(UUIEstimate_HaveArtifact, IconImageList) == 0x0004A0, "Member 'UUIEstimate_HaveArtifact::IconImageList' has a wrong offset!");
static_assert(offsetof(UUIEstimate_HaveArtifact, NumImageList) == 0x0004F0, "Member 'UUIEstimate_HaveArtifact::NumImageList' has a wrong offset!");
static_assert(offsetof(UUIEstimate_HaveArtifact, IconImage) == 0x000540, "Member 'UUIEstimate_HaveArtifact::IconImage' has a wrong offset!");
static_assert(offsetof(UUIEstimate_HaveArtifact, Num1Image) == 0x000548, "Member 'UUIEstimate_HaveArtifact::Num1Image' has a wrong offset!");
static_assert(offsetof(UUIEstimate_HaveArtifact, Num2Image) == 0x000550, "Member 'UUIEstimate_HaveArtifact::Num2Image' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ApplyMaterialParameterVectorCurve
// 0x0040 (0x0080 - 0x0040)
class UAnimNotifyState_ApplyMaterialParameterVectorCurve final : public UAnimNotifyState_ApplyMaterialParameterBase
{
public:
	struct FAnimNotifyMaterialParameterVectorInfo MaterialParameter;                                 // 0x0040(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ApplyMaterialParameterVectorCurve">();
	}
	static class UAnimNotifyState_ApplyMaterialParameterVectorCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ApplyMaterialParameterVectorCurve>();
	}
};
static_assert(alignof(UAnimNotifyState_ApplyMaterialParameterVectorCurve) == 0x000008, "Wrong alignment on UAnimNotifyState_ApplyMaterialParameterVectorCurve");
static_assert(sizeof(UAnimNotifyState_ApplyMaterialParameterVectorCurve) == 0x000080, "Wrong size on UAnimNotifyState_ApplyMaterialParameterVectorCurve");
static_assert(offsetof(UAnimNotifyState_ApplyMaterialParameterVectorCurve, MaterialParameter) == 0x000040, "Member 'UAnimNotifyState_ApplyMaterialParameterVectorCurve::MaterialParameter' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossActorVisible
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossActorVisible final : public UAnimNotifyState
{
public:
	bool                                          mVisibility;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossActorVisible">();
	}
	static class UAnimNotifyState_BossActorVisible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossActorVisible>();
	}
};
static_assert(alignof(UAnimNotifyState_BossActorVisible) == 0x000008, "Wrong alignment on UAnimNotifyState_BossActorVisible");
static_assert(sizeof(UAnimNotifyState_BossActorVisible) == 0x000040, "Wrong size on UAnimNotifyState_BossActorVisible");
static_assert(offsetof(UAnimNotifyState_BossActorVisible, mVisibility) == 0x000038, "Member 'UAnimNotifyState_BossActorVisible::mVisibility' has a wrong offset!");

// Class DarwinGame.LaserMagicBase
// 0x0100 (0x03F0 - 0x02F0)
class ALaserMagicBase final : public AMagicBase
{
public:
	uint8                                         Pad_2F0[0x100];                                    // 0x02F0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LaserMagicBase">();
	}
	static class ALaserMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALaserMagicBase>();
	}
};
static_assert(alignof(ALaserMagicBase) == 0x000008, "Wrong alignment on ALaserMagicBase");
static_assert(sizeof(ALaserMagicBase) == 0x0003F0, "Wrong size on ALaserMagicBase");

// Class DarwinGame.DoorObjectBase
// 0x0020 (0x02D0 - 0x02B0)
class ADoorObjectBase : public AFieldObjectBase
{
public:
	bool                                          mIsOpen;                                           // 0x02B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NotAccessFlagName;                                 // 0x02B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoCloseLength;                                   // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoCloseDoor(class AActor* TargetActor);
	void PlayClose();
	void PlayOpen(const struct FVector& Vector);
	void SetClose();
	void SetOpen(const struct FVector& Vector);

	class USkeletalMeshComponent* GetObjectDoorComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorObjectBase">();
	}
	static class ADoorObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorObjectBase>();
	}
};
static_assert(alignof(ADoorObjectBase) == 0x000008, "Wrong alignment on ADoorObjectBase");
static_assert(sizeof(ADoorObjectBase) == 0x0002D0, "Wrong size on ADoorObjectBase");
static_assert(offsetof(ADoorObjectBase, mIsOpen) == 0x0002B0, "Member 'ADoorObjectBase::mIsOpen' has a wrong offset!");
static_assert(offsetof(ADoorObjectBase, NotAccessFlagName) == 0x0002B4, "Member 'ADoorObjectBase::NotAccessFlagName' has a wrong offset!");
static_assert(offsetof(ADoorObjectBase, AutoCloseLength) == 0x0002BC, "Member 'ADoorObjectBase::AutoCloseLength' has a wrong offset!");

// Class DarwinGame.BasicDoor
// 0x0000 (0x02D0 - 0x02D0)
class ABasicDoor final : public ADoorObjectBase
{
public:
	void ReceivePlayClose();
	void ReceivePlayOpen(const struct FVector& Vector);
	void ReceiveSetClose();
	void ReceiveSetOpen(const struct FVector& Vector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasicDoor">();
	}
	static class ABasicDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasicDoor>();
	}
};
static_assert(alignof(ABasicDoor) == 0x000008, "Wrong alignment on ABasicDoor");
static_assert(sizeof(ABasicDoor) == 0x0002D0, "Wrong size on ABasicDoor");

// Class DarwinGame.StationDataTable
// 0x0000 (0x0030 - 0x0030)
class UStationDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationDataTable">();
	}
	static class UStationDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationDataTable>();
	}
};
static_assert(alignof(UStationDataTable) == 0x000008, "Wrong alignment on UStationDataTable");
static_assert(sizeof(UStationDataTable) == 0x000030, "Wrong size on UStationDataTable");

// Class DarwinGame.AnimNotifyState_BossBarrierVisible
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossBarrierVisible final : public UAnimNotifyState
{
public:
	EMonsterBossBarrierStep                       mBarrierStep;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossBarrierVisible">();
	}
	static class UAnimNotifyState_BossBarrierVisible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossBarrierVisible>();
	}
};
static_assert(alignof(UAnimNotifyState_BossBarrierVisible) == 0x000008, "Wrong alignment on UAnimNotifyState_BossBarrierVisible");
static_assert(sizeof(UAnimNotifyState_BossBarrierVisible) == 0x000040, "Wrong size on UAnimNotifyState_BossBarrierVisible");
static_assert(offsetof(UAnimNotifyState_BossBarrierVisible, mBarrierStep) == 0x000038, "Member 'UAnimNotifyState_BossBarrierVisible::mBarrierStep' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossBoost
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossBoost final : public UAnimNotifyState
{
public:
	EMonsterBossBodyType                          BossBodyType;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossBoost">();
	}
	static class UAnimNotifyState_BossBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossBoost>();
	}
};
static_assert(alignof(UAnimNotifyState_BossBoost) == 0x000008, "Wrong alignment on UAnimNotifyState_BossBoost");
static_assert(sizeof(UAnimNotifyState_BossBoost) == 0x000040, "Wrong size on UAnimNotifyState_BossBoost");
static_assert(offsetof(UAnimNotifyState_BossBoost, BossBodyType) == 0x000038, "Member 'UAnimNotifyState_BossBoost::BossBodyType' has a wrong offset!");

// Class DarwinGame.FlagBase
// 0x0008 (0x02B8 - 0x02B0)
class AFlagBase : public AFieldObjectBase
{
public:
	class UFlagMaterialDataAsset*                 mFlagMaterialData;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagBase">();
	}
	static class AFlagBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlagBase>();
	}
};
static_assert(alignof(AFlagBase) == 0x000008, "Wrong alignment on AFlagBase");
static_assert(sizeof(AFlagBase) == 0x0002B8, "Wrong size on AFlagBase");
static_assert(offsetof(AFlagBase, mFlagMaterialData) == 0x0002B0, "Member 'AFlagBase::mFlagMaterialData' has a wrong offset!");

// Class DarwinGame.SoundManager
// 0x0230 (0x0268 - 0x0038)
class USoundManager : public UManagerBase
{
public:
	TSoftClassPtr<class UClass>                   mSoundManagerActor;                                // 0x0038(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mAtomCueSheetManager;                              // 0x0060(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mSoundVolumeManager;                               // 0x0088(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mVoiceManager;                                     // 0x00B0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mPointEnvSoundController;                          // 0x00D8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mBaseSoundController;                              // 0x0100(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mSoundPoolManager;                                 // 0x0128(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mMeController;                                     // 0x0150(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TouchSound;                                        // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ObjectSound;                                       // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             EffectSound;                                       // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemSound;                                         // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuCS;                             // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuSIE;                            // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuIE;                             // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuFukidashi;                      // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuCSEn;                           // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuSIEEn;                          // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuIEEn;                           // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TextSoundListSerifuFukidashiEn;                    // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FootSoundCueListNPC;                               // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             EventSoundList;                                    // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         mDecideSeComp;                                     // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         mCancelSeComp;                                     // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         mSelectSeComp;                                     // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         mTextSoundComp;                                    // 0x0210(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAtomComponent*>                 LoopSoundList;                                     // 0x0218(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASoundManagerActor*                     mSoundManagerActor_0;                              // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomCueSheetManager*                   mAtomCueSheetManager_0;                            // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundVolumeManager*                    mSoundVolumeManager_0;                             // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoiceManager*                          mVoiceManager_0;                                   // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointEnvSoundController*               mPointEnvSoundController_0;                        // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseSoundController*                   mBaseSoundController_0;                            // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundPoolManager*                      mSoundPoolManager_0;                               // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeController*                          mMeController_0;                                   // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class USoundManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManager">();
	}
	static class USoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundManager>();
	}
};
static_assert(alignof(USoundManager) == 0x000008, "Wrong alignment on USoundManager");
static_assert(sizeof(USoundManager) == 0x000268, "Wrong size on USoundManager");
static_assert(offsetof(USoundManager, mSoundManagerActor) == 0x000038, "Member 'USoundManager::mSoundManagerActor' has a wrong offset!");
static_assert(offsetof(USoundManager, mAtomCueSheetManager) == 0x000060, "Member 'USoundManager::mAtomCueSheetManager' has a wrong offset!");
static_assert(offsetof(USoundManager, mSoundVolumeManager) == 0x000088, "Member 'USoundManager::mSoundVolumeManager' has a wrong offset!");
static_assert(offsetof(USoundManager, mVoiceManager) == 0x0000B0, "Member 'USoundManager::mVoiceManager' has a wrong offset!");
static_assert(offsetof(USoundManager, mPointEnvSoundController) == 0x0000D8, "Member 'USoundManager::mPointEnvSoundController' has a wrong offset!");
static_assert(offsetof(USoundManager, mBaseSoundController) == 0x000100, "Member 'USoundManager::mBaseSoundController' has a wrong offset!");
static_assert(offsetof(USoundManager, mSoundPoolManager) == 0x000128, "Member 'USoundManager::mSoundPoolManager' has a wrong offset!");
static_assert(offsetof(USoundManager, mMeController) == 0x000150, "Member 'USoundManager::mMeController' has a wrong offset!");
static_assert(offsetof(USoundManager, TouchSound) == 0x000178, "Member 'USoundManager::TouchSound' has a wrong offset!");
static_assert(offsetof(USoundManager, ObjectSound) == 0x000180, "Member 'USoundManager::ObjectSound' has a wrong offset!");
static_assert(offsetof(USoundManager, EffectSound) == 0x000188, "Member 'USoundManager::EffectSound' has a wrong offset!");
static_assert(offsetof(USoundManager, ItemSound) == 0x000190, "Member 'USoundManager::ItemSound' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuCS) == 0x000198, "Member 'USoundManager::TextSoundListSerifuCS' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuSIE) == 0x0001A0, "Member 'USoundManager::TextSoundListSerifuSIE' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuIE) == 0x0001A8, "Member 'USoundManager::TextSoundListSerifuIE' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuFukidashi) == 0x0001B0, "Member 'USoundManager::TextSoundListSerifuFukidashi' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuCSEn) == 0x0001B8, "Member 'USoundManager::TextSoundListSerifuCSEn' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuSIEEn) == 0x0001C0, "Member 'USoundManager::TextSoundListSerifuSIEEn' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuIEEn) == 0x0001C8, "Member 'USoundManager::TextSoundListSerifuIEEn' has a wrong offset!");
static_assert(offsetof(USoundManager, TextSoundListSerifuFukidashiEn) == 0x0001D0, "Member 'USoundManager::TextSoundListSerifuFukidashiEn' has a wrong offset!");
static_assert(offsetof(USoundManager, FootSoundCueListNPC) == 0x0001D8, "Member 'USoundManager::FootSoundCueListNPC' has a wrong offset!");
static_assert(offsetof(USoundManager, EventSoundList) == 0x0001E0, "Member 'USoundManager::EventSoundList' has a wrong offset!");
static_assert(offsetof(USoundManager, mDecideSeComp) == 0x0001F8, "Member 'USoundManager::mDecideSeComp' has a wrong offset!");
static_assert(offsetof(USoundManager, mCancelSeComp) == 0x000200, "Member 'USoundManager::mCancelSeComp' has a wrong offset!");
static_assert(offsetof(USoundManager, mSelectSeComp) == 0x000208, "Member 'USoundManager::mSelectSeComp' has a wrong offset!");
static_assert(offsetof(USoundManager, mTextSoundComp) == 0x000210, "Member 'USoundManager::mTextSoundComp' has a wrong offset!");
static_assert(offsetof(USoundManager, LoopSoundList) == 0x000218, "Member 'USoundManager::LoopSoundList' has a wrong offset!");
static_assert(offsetof(USoundManager, mSoundManagerActor_0) == 0x000228, "Member 'USoundManager::mSoundManagerActor_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mAtomCueSheetManager_0) == 0x000230, "Member 'USoundManager::mAtomCueSheetManager_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mSoundVolumeManager_0) == 0x000238, "Member 'USoundManager::mSoundVolumeManager_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mVoiceManager_0) == 0x000240, "Member 'USoundManager::mVoiceManager_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mPointEnvSoundController_0) == 0x000248, "Member 'USoundManager::mPointEnvSoundController_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mBaseSoundController_0) == 0x000250, "Member 'USoundManager::mBaseSoundController_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mSoundPoolManager_0) == 0x000258, "Member 'USoundManager::mSoundPoolManager_0' has a wrong offset!");
static_assert(offsetof(USoundManager, mMeController_0) == 0x000260, "Member 'USoundManager::mMeController_0' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossBoostingCheck
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_BossBoostingCheck final : public UAnimNotifyState
{
public:
	float                                         mRadiusStep;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mRadiusMax;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mRadiusMin;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossBoostingCheck">();
	}
	static class UAnimNotifyState_BossBoostingCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossBoostingCheck>();
	}
};
static_assert(alignof(UAnimNotifyState_BossBoostingCheck) == 0x000008, "Wrong alignment on UAnimNotifyState_BossBoostingCheck");
static_assert(sizeof(UAnimNotifyState_BossBoostingCheck) == 0x000048, "Wrong size on UAnimNotifyState_BossBoostingCheck");
static_assert(offsetof(UAnimNotifyState_BossBoostingCheck, mRadiusStep) == 0x000038, "Member 'UAnimNotifyState_BossBoostingCheck::mRadiusStep' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossBoostingCheck, mRadiusMax) == 0x00003C, "Member 'UAnimNotifyState_BossBoostingCheck::mRadiusMax' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossBoostingCheck, mRadiusMin) == 0x000040, "Member 'UAnimNotifyState_BossBoostingCheck::mRadiusMin' has a wrong offset!");

// Class DarwinGame.GameDataDictLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataDictLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDictLibrary">();
	}
	static class UGameDataDictLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDictLibrary>();
	}
};
static_assert(alignof(UGameDataDictLibrary) == 0x000008, "Wrong alignment on UGameDataDictLibrary");
static_assert(sizeof(UGameDataDictLibrary) == 0x000030, "Wrong size on UGameDataDictLibrary");

// Class DarwinGame.AnimNotifyState_BossCombatDuring
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_BossCombatDuring final : public UAnimNotifyState
{
public:
	bool                                          mOffAtEnd;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossCombatDuring                      mCombatDuring;                                     // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterCombatState                           mCombatState;                                      // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mSkipSection;                                      // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossCombatDuring">();
	}
	static class UAnimNotifyState_BossCombatDuring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossCombatDuring>();
	}
};
static_assert(alignof(UAnimNotifyState_BossCombatDuring) == 0x000008, "Wrong alignment on UAnimNotifyState_BossCombatDuring");
static_assert(sizeof(UAnimNotifyState_BossCombatDuring) == 0x000048, "Wrong size on UAnimNotifyState_BossCombatDuring");
static_assert(offsetof(UAnimNotifyState_BossCombatDuring, mOffAtEnd) == 0x000038, "Member 'UAnimNotifyState_BossCombatDuring::mOffAtEnd' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossCombatDuring, mCombatDuring) == 0x000039, "Member 'UAnimNotifyState_BossCombatDuring::mCombatDuring' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossCombatDuring, mCombatState) == 0x00003A, "Member 'UAnimNotifyState_BossCombatDuring::mCombatState' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossCombatDuring, mSkipSection) == 0x00003C, "Member 'UAnimNotifyState_BossCombatDuring::mSkipSection' has a wrong offset!");

// Class DarwinGame.BaseAreaBattleDataAsset
// 0x00C8 (0x0100 - 0x0038)
class UBaseAreaBattleDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FBaseAreaBattleEventPreset> mEventPreset;                                      // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FBaseAreaBattleResultEvent             mBattleResultEvent;                                // 0x0088(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBaseAreaBattleResultEvent             mBattleResultSystemMessage;                        // 0x0098(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBaseAreaBattleConfig                  mConfig;                                           // 0x00A8(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBaseAreaBattleWaitTime                mWaitConfig;                                       // 0x00C4(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBaseAreaBattleMonsterLocation         mMonsterLocationInfo;                              // 0x00D8(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaBattleDataAsset">();
	}
	static class UBaseAreaBattleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAreaBattleDataAsset>();
	}
};
static_assert(alignof(UBaseAreaBattleDataAsset) == 0x000008, "Wrong alignment on UBaseAreaBattleDataAsset");
static_assert(sizeof(UBaseAreaBattleDataAsset) == 0x000100, "Wrong size on UBaseAreaBattleDataAsset");
static_assert(offsetof(UBaseAreaBattleDataAsset, mEventPreset) == 0x000038, "Member 'UBaseAreaBattleDataAsset::mEventPreset' has a wrong offset!");
static_assert(offsetof(UBaseAreaBattleDataAsset, mBattleResultEvent) == 0x000088, "Member 'UBaseAreaBattleDataAsset::mBattleResultEvent' has a wrong offset!");
static_assert(offsetof(UBaseAreaBattleDataAsset, mBattleResultSystemMessage) == 0x000098, "Member 'UBaseAreaBattleDataAsset::mBattleResultSystemMessage' has a wrong offset!");
static_assert(offsetof(UBaseAreaBattleDataAsset, mConfig) == 0x0000A8, "Member 'UBaseAreaBattleDataAsset::mConfig' has a wrong offset!");
static_assert(offsetof(UBaseAreaBattleDataAsset, mWaitConfig) == 0x0000C4, "Member 'UBaseAreaBattleDataAsset::mWaitConfig' has a wrong offset!");
static_assert(offsetof(UBaseAreaBattleDataAsset, mMonsterLocationInfo) == 0x0000D8, "Member 'UBaseAreaBattleDataAsset::mMonsterLocationInfo' has a wrong offset!");

// Class DarwinGame.UIEstimate_Effect
// 0x0028 (0x04B8 - 0x0490)
class UUIEstimate_Effect final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FlashAnim;                                         // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndFlash();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_Effect">();
	}
	static class UUIEstimate_Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_Effect>();
	}
};
static_assert(alignof(UUIEstimate_Effect) == 0x000008, "Wrong alignment on UUIEstimate_Effect");
static_assert(sizeof(UUIEstimate_Effect) == 0x0004B8, "Wrong size on UUIEstimate_Effect");
static_assert(offsetof(UUIEstimate_Effect, FlashAnim) == 0x0004A0, "Member 'UUIEstimate_Effect::FlashAnim' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossCombatState
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossCombatState final : public UAnimNotifyState
{
public:
	EMonsterCombatState                           mCombatState;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossCombatState">();
	}
	static class UAnimNotifyState_BossCombatState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossCombatState>();
	}
};
static_assert(alignof(UAnimNotifyState_BossCombatState) == 0x000008, "Wrong alignment on UAnimNotifyState_BossCombatState");
static_assert(sizeof(UAnimNotifyState_BossCombatState) == 0x000040, "Wrong size on UAnimNotifyState_BossCombatState");
static_assert(offsetof(UAnimNotifyState_BossCombatState, mCombatState) == 0x000038, "Member 'UAnimNotifyState_BossCombatState::mCombatState' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossControllCamera
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossControllCamera final : public UAnimNotifyState
{
public:
	EMonsterBossCameraControllType                mControllType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossControllCamera">();
	}
	static class UAnimNotifyState_BossControllCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossControllCamera>();
	}
};
static_assert(alignof(UAnimNotifyState_BossControllCamera) == 0x000008, "Wrong alignment on UAnimNotifyState_BossControllCamera");
static_assert(sizeof(UAnimNotifyState_BossControllCamera) == 0x000040, "Wrong size on UAnimNotifyState_BossControllCamera");
static_assert(offsetof(UAnimNotifyState_BossControllCamera, mControllType) == 0x000038, "Member 'UAnimNotifyState_BossControllCamera::mControllType' has a wrong offset!");

// Class DarwinGame.UIAlertBase
// 0x0188 (0x0618 - 0x0490)
class UUIAlertBase : public UDarwinUserWidget
{
public:
	float                                         WarningTime;                                       // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CueName;                                           // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EUICautionRank, class UTexture2D*>       AlertMaterialTexture;                              // 0x04A8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EUICautionRank, class UTexture2D*>       Alert00Texture;                                    // 0x04F8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EUICautionRank, class UTexture2D*>       Alert01Texture;                                    // 0x0548(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x18];                                     // 0x0598(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       AlertAnim;                                         // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 MaterialImage;                                     // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                Alert00;                                           // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                Alert01;                                           // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_UIAlertPlayAnimData>        PlayAnimData;                                      // 0x05E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x18];                                     // 0x05F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         AlertSound;                                        // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAlertBase">();
	}
	static class UUIAlertBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAlertBase>();
	}
};
static_assert(alignof(UUIAlertBase) == 0x000008, "Wrong alignment on UUIAlertBase");
static_assert(sizeof(UUIAlertBase) == 0x000618, "Wrong size on UUIAlertBase");
static_assert(offsetof(UUIAlertBase, WarningTime) == 0x000490, "Member 'UUIAlertBase::WarningTime' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, CueName) == 0x000498, "Member 'UUIAlertBase::CueName' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, AlertMaterialTexture) == 0x0004A8, "Member 'UUIAlertBase::AlertMaterialTexture' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, Alert00Texture) == 0x0004F8, "Member 'UUIAlertBase::Alert00Texture' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, Alert01Texture) == 0x000548, "Member 'UUIAlertBase::Alert01Texture' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, AlertAnim) == 0x0005B0, "Member 'UUIAlertBase::AlertAnim' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, MaterialImage) == 0x0005C8, "Member 'UUIAlertBase::MaterialImage' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, Alert00) == 0x0005D0, "Member 'UUIAlertBase::Alert00' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, Alert01) == 0x0005D8, "Member 'UUIAlertBase::Alert01' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, PlayAnimData) == 0x0005E8, "Member 'UUIAlertBase::PlayAnimData' has a wrong offset!");
static_assert(offsetof(UUIAlertBase, AlertSound) == 0x000610, "Member 'UUIAlertBase::AlertSound' has a wrong offset!");

// Class DarwinGame.BaseSoundController
// 0x01E0 (0x0210 - 0x0030)
class alignas(0x10) UBaseSoundController : public UObject
{
public:
	class UDataTable*                             AreaBgmInfo;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RevengeBattleBgmInfo;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AreaSoundInfo;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             WeatherSound;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BGMInfo;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeZoneEnvParamter                   TZEnvCueNameList;                                  // 0x0058(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           TZEnvIgnoreAreaList;                               // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentAreaSoundName;                              // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          LastBgm;                                           // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentBaseEnvListID;                              // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          CurrentBaseEnv;                                    // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnvironmentType                              CurrentEnvType;                                    // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          CurrentWeatherEnv;                                 // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAtomComponent*>                 BSCompList;                                        // 0x0110(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         TimeZoneEnvComp;                                   // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0xE8];                                     // 0x0128(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSoundController">();
	}
	static class UBaseSoundController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSoundController>();
	}
};
static_assert(alignof(UBaseSoundController) == 0x000010, "Wrong alignment on UBaseSoundController");
static_assert(sizeof(UBaseSoundController) == 0x000210, "Wrong size on UBaseSoundController");
static_assert(offsetof(UBaseSoundController, AreaBgmInfo) == 0x000030, "Member 'UBaseSoundController::AreaBgmInfo' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, RevengeBattleBgmInfo) == 0x000038, "Member 'UBaseSoundController::RevengeBattleBgmInfo' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, AreaSoundInfo) == 0x000040, "Member 'UBaseSoundController::AreaSoundInfo' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, WeatherSound) == 0x000048, "Member 'UBaseSoundController::WeatherSound' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, BGMInfo) == 0x000050, "Member 'UBaseSoundController::BGMInfo' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, TZEnvCueNameList) == 0x000058, "Member 'UBaseSoundController::TZEnvCueNameList' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, TZEnvIgnoreAreaList) == 0x0000C0, "Member 'UBaseSoundController::TZEnvIgnoreAreaList' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, CurrentAreaSoundName) == 0x0000D4, "Member 'UBaseSoundController::CurrentAreaSoundName' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, LastBgm) == 0x0000E0, "Member 'UBaseSoundController::LastBgm' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, CurrentBaseEnvListID) == 0x0000E8, "Member 'UBaseSoundController::CurrentBaseEnvListID' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, CurrentBaseEnv) == 0x0000F0, "Member 'UBaseSoundController::CurrentBaseEnv' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, CurrentEnvType) == 0x0000F8, "Member 'UBaseSoundController::CurrentEnvType' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, CurrentWeatherEnv) == 0x000100, "Member 'UBaseSoundController::CurrentWeatherEnv' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, BSCompList) == 0x000110, "Member 'UBaseSoundController::BSCompList' has a wrong offset!");
static_assert(offsetof(UBaseSoundController, TimeZoneEnvComp) == 0x000120, "Member 'UBaseSoundController::TimeZoneEnvComp' has a wrong offset!");

// Class DarwinGame.UICorrection_01
// 0x0038 (0x04C8 - 0x0490)
class UUICorrection_01 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBonus_Points_01*                     Bonus;                                             // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBonus_Points_02*                     Price;                                             // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBonus_Points_02*                     TotalPrice;                                        // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         LoopSe;                                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         PriceCountSe;                                      // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SlideInEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICorrection_01">();
	}
	static class UUICorrection_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICorrection_01>();
	}
};
static_assert(alignof(UUICorrection_01) == 0x000008, "Wrong alignment on UUICorrection_01");
static_assert(sizeof(UUICorrection_01) == 0x0004C8, "Wrong size on UUICorrection_01");
static_assert(offsetof(UUICorrection_01, Bonus) == 0x0004A0, "Member 'UUICorrection_01::Bonus' has a wrong offset!");
static_assert(offsetof(UUICorrection_01, Price) == 0x0004A8, "Member 'UUICorrection_01::Price' has a wrong offset!");
static_assert(offsetof(UUICorrection_01, TotalPrice) == 0x0004B0, "Member 'UUICorrection_01::TotalPrice' has a wrong offset!");
static_assert(offsetof(UUICorrection_01, LoopSe) == 0x0004B8, "Member 'UUICorrection_01::LoopSe' has a wrong offset!");
static_assert(offsetof(UUICorrection_01, PriceCountSe) == 0x0004C0, "Member 'UUICorrection_01::PriceCountSe' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossEffectVisible
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossEffectVisible final : public UAnimNotifyState
{
public:
	EMonsterLastBossEffect                        mLastBossEffect;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossEffectVisible">();
	}
	static class UAnimNotifyState_BossEffectVisible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossEffectVisible>();
	}
};
static_assert(alignof(UAnimNotifyState_BossEffectVisible) == 0x000008, "Wrong alignment on UAnimNotifyState_BossEffectVisible");
static_assert(sizeof(UAnimNotifyState_BossEffectVisible) == 0x000040, "Wrong size on UAnimNotifyState_BossEffectVisible");
static_assert(offsetof(UAnimNotifyState_BossEffectVisible, mLastBossEffect) == 0x000038, "Member 'UAnimNotifyState_BossEffectVisible::mLastBossEffect' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossExposeWeaknesses
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossExposeWeaknesses final : public UAnimNotifyState
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossExposeWeaknesses">();
	}
	static class UAnimNotifyState_BossExposeWeaknesses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossExposeWeaknesses>();
	}
};
static_assert(alignof(UAnimNotifyState_BossExposeWeaknesses) == 0x000008, "Wrong alignment on UAnimNotifyState_BossExposeWeaknesses");
static_assert(sizeof(UAnimNotifyState_BossExposeWeaknesses) == 0x000040, "Wrong size on UAnimNotifyState_BossExposeWeaknesses");

// Class DarwinGame.GameDataTips
// 0x0068 (0x0098 - 0x0030)
class UGameDataTips final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOpenTips(const class FName& TipsID);
	void AddPopupTips(const class FName& TipsID);
	class UGameDataTips* Clone();
	void Overwrite(class UGameDataTips* game_data);
	void ShowTips(const class FName& TipsID);

	bool IsOpenTips(const class FName& TipsID) const;
	bool IsOpenTipsNew(const class FName& TipsID) const;
	bool IsPopupedTips(const class FName& TipsID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataTips">();
	}
	static class UGameDataTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataTips>();
	}
};
static_assert(alignof(UGameDataTips) == 0x000008, "Wrong alignment on UGameDataTips");
static_assert(sizeof(UGameDataTips) == 0x000098, "Wrong size on UGameDataTips");

// Class DarwinGame.BattleInformation
// 0x0028 (0x0058 - 0x0030)
class UBattleInformation final : public UObject
{
public:
	TArray<class AGPACharacter*>                  mAttackTargetList;                                 // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGPACharacter*                          mOwner;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttackLocationManager*                 mAttackLocationManager;                            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddAttackTarget(class AGPACharacter* Monster);
	class AGPACharacter* GetAttackTarget();
	void SetOwner(class AGPACharacter* Owner, EMonsterRegisterType registerType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleInformation">();
	}
	static class UBattleInformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleInformation>();
	}
};
static_assert(alignof(UBattleInformation) == 0x000008, "Wrong alignment on UBattleInformation");
static_assert(sizeof(UBattleInformation) == 0x000058, "Wrong size on UBattleInformation");
static_assert(offsetof(UBattleInformation, mAttackTargetList) == 0x000030, "Member 'UBattleInformation::mAttackTargetList' has a wrong offset!");
static_assert(offsetof(UBattleInformation, mOwner) == 0x000040, "Member 'UBattleInformation::mOwner' has a wrong offset!");
static_assert(offsetof(UBattleInformation, mAttackLocationManager) == 0x000050, "Member 'UBattleInformation::mAttackLocationManager' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossGimmickBreak
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossGimmickBreak final : public UAnimNotifyState
{
public:
	bool                                          mGimmickBreak;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossGimmickBreak">();
	}
	static class UAnimNotifyState_BossGimmickBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossGimmickBreak>();
	}
};
static_assert(alignof(UAnimNotifyState_BossGimmickBreak) == 0x000008, "Wrong alignment on UAnimNotifyState_BossGimmickBreak");
static_assert(sizeof(UAnimNotifyState_BossGimmickBreak) == 0x000040, "Wrong size on UAnimNotifyState_BossGimmickBreak");
static_assert(offsetof(UAnimNotifyState_BossGimmickBreak, mGimmickBreak) == 0x000038, "Member 'UAnimNotifyState_BossGimmickBreak::mGimmickBreak' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossPauseInCamWork
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossPauseInCamWork final : public UAnimNotifyState
{
public:
	bool                                          mPause;                                            // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mLogic;                                            // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mEnd;                                              // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossPauseInCamWork">();
	}
	static class UAnimNotifyState_BossPauseInCamWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossPauseInCamWork>();
	}
};
static_assert(alignof(UAnimNotifyState_BossPauseInCamWork) == 0x000008, "Wrong alignment on UAnimNotifyState_BossPauseInCamWork");
static_assert(sizeof(UAnimNotifyState_BossPauseInCamWork) == 0x000040, "Wrong size on UAnimNotifyState_BossPauseInCamWork");
static_assert(offsetof(UAnimNotifyState_BossPauseInCamWork, mPause) == 0x000038, "Member 'UAnimNotifyState_BossPauseInCamWork::mPause' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPauseInCamWork, mLogic) == 0x000039, "Member 'UAnimNotifyState_BossPauseInCamWork::mLogic' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPauseInCamWork, mEnd) == 0x00003A, "Member 'UAnimNotifyState_BossPauseInCamWork::mEnd' has a wrong offset!");

// Class DarwinGame.BattleBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UBattleBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float CalculateActionCastTime(class FName actionDetailID, const struct FST_TempCharaDataForDamageCalc& Source);
	static float CalculateBreathDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static float CalculateDamageCorrectValue(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static float CalculateDamageCorrectValueWithountActionCorrect(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static float CalculateDamageRevision(const struct FST_AttackData& AttackData, const struct FST_TempCharaDataForDamageCalc& Source);
	static int32 CalculateDropMoney(const class FName& MonsterParamID, const int32 Level);
	static class FName CalculateDropRate(class FName MonsterParamID, class AGPACharacter* InstigatorCharacter);
	static float CalculateEffectTime(class FName ID, int32 Level, const struct FST_TempCharaDataForDamageCalc& Source);
	static float CalculateMagicalBulletDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static float CalculateMagicalDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target, bool Rampage);
	static float CalculateMPCost(class AGPACharacter* Instigator, const class FName& ActionOverviewID);
	static float CalculatePhysicalBulletDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static float CalculatePhysicalDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target, const struct FAttackHitResultStruct& AttackResult, bool IsCritical);
	static float CalculateSkillChainTime(const struct FST_TempCharaDataForDamageCalc& Source);
	static float CalculateSkillDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static float CalculateTakenDamageRevision(const struct FST_AttackData& AttackData, const struct FST_TempCharaDataForDamageCalc& Target);
	static bool GainExp(const int32 Exp);
	static struct FVector GetBlownVelocity(const struct FActionResult& ActionResult, class AGPACharacter* Target, bool bToBack);
	static bool IsTargetOfAction(class FName actionDetailID, class AActor* Source, class AActor* Target);
	static bool IsTargetOfActionAlly(class FName actionDetailID);
	static bool JudgeWhetherAttackIsBlow(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static bool JudgeWhetherAttackIsRampage(const struct FST_AttackData& AttackData, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target);
	static EGuardType JudgeWhetherEvasion(class FName actionDetailID, class AGPACharacter* Source, class AGPACharacter* Target);
	static bool LotteryGetUp(class AGPACharacter* Instigator, class AGPACharacter* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleBlueprintFunctionLibrary">();
	}
	static class UBattleBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UBattleBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UBattleBlueprintFunctionLibrary");
static_assert(sizeof(UBattleBlueprintFunctionLibrary) == 0x000030, "Wrong size on UBattleBlueprintFunctionLibrary");

// Class DarwinGame.SoundVolumeManager
// 0x0138 (0x0168 - 0x0030)
class USoundVolumeManager : public UObject
{
public:
	class UDataTable*                             CSGroupSettingList;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mCSVolumeFadeComponent;                            // 0x0038(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mACVolumeFadeComponent;                            // 0x0060(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVolumeScaleParamter                   VolumeScaleGeneral;                                // 0x0088(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVolumeScaleParamter                   VolumeScaleNX;                                     // 0x00A8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         SpawnSoundVolume;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccompanyingVolumeRate;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCSVolumeFadeComponent*                 CSVolumeFadeComponent;                             // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UACVolumeFadeComponent*                 ACVolumeFadeComponent;                             // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoundVolumeParamter                   BgmVolumeParam;                                    // 0x00E0(0x0010)(NativeAccessSpecifierPrivate)
	struct FSoundVolumeParamter                   SeVolumeParam;                                     // 0x00F0(0x0010)(NativeAccessSpecifierPrivate)
	struct FSoundVolumeParamter                   VoiceVolumeParam;                                  // 0x0100(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundFadeComponentBase*>        FadeList;                                          // 0x0120(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<bool>                                  DuckingSoundUIAllList;                             // 0x0130(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<bool>                                  DuckingSoundUIList;                                // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<bool>                                  DuckingBgmUIList;                                  // 0x0150(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundVolumeManager">();
	}
	static class USoundVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundVolumeManager>();
	}
};
static_assert(alignof(USoundVolumeManager) == 0x000008, "Wrong alignment on USoundVolumeManager");
static_assert(sizeof(USoundVolumeManager) == 0x000168, "Wrong size on USoundVolumeManager");
static_assert(offsetof(USoundVolumeManager, CSGroupSettingList) == 0x000030, "Member 'USoundVolumeManager::CSGroupSettingList' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, mCSVolumeFadeComponent) == 0x000038, "Member 'USoundVolumeManager::mCSVolumeFadeComponent' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, mACVolumeFadeComponent) == 0x000060, "Member 'USoundVolumeManager::mACVolumeFadeComponent' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, VolumeScaleGeneral) == 0x000088, "Member 'USoundVolumeManager::VolumeScaleGeneral' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, VolumeScaleNX) == 0x0000A8, "Member 'USoundVolumeManager::VolumeScaleNX' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, SpawnSoundVolume) == 0x0000C8, "Member 'USoundVolumeManager::SpawnSoundVolume' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, AccompanyingVolumeRate) == 0x0000CC, "Member 'USoundVolumeManager::AccompanyingVolumeRate' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, CSVolumeFadeComponent) == 0x0000D0, "Member 'USoundVolumeManager::CSVolumeFadeComponent' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, ACVolumeFadeComponent) == 0x0000D8, "Member 'USoundVolumeManager::ACVolumeFadeComponent' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, BgmVolumeParam) == 0x0000E0, "Member 'USoundVolumeManager::BgmVolumeParam' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, SeVolumeParam) == 0x0000F0, "Member 'USoundVolumeManager::SeVolumeParam' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, VoiceVolumeParam) == 0x000100, "Member 'USoundVolumeManager::VoiceVolumeParam' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, FadeList) == 0x000120, "Member 'USoundVolumeManager::FadeList' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, DuckingSoundUIAllList) == 0x000130, "Member 'USoundVolumeManager::DuckingSoundUIAllList' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, DuckingSoundUIList) == 0x000140, "Member 'USoundVolumeManager::DuckingSoundUIList' has a wrong offset!");
static_assert(offsetof(USoundVolumeManager, DuckingBgmUIList) == 0x000150, "Member 'USoundVolumeManager::DuckingBgmUIList' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossPossessed
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossPossessed final : public UAnimNotifyState
{
public:
	class FName                                   mSectionName;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossPossessed">();
	}
	static class UAnimNotifyState_BossPossessed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossPossessed>();
	}
};
static_assert(alignof(UAnimNotifyState_BossPossessed) == 0x000008, "Wrong alignment on UAnimNotifyState_BossPossessed");
static_assert(sizeof(UAnimNotifyState_BossPossessed) == 0x000040, "Wrong size on UAnimNotifyState_BossPossessed");
static_assert(offsetof(UAnimNotifyState_BossPossessed, mSectionName) == 0x000038, "Member 'UAnimNotifyState_BossPossessed::mSectionName' has a wrong offset!");

// Class DarwinGame.GameDataFixTreasureBoxLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataFixTreasureBoxLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFixTreasureBoxLibrary">();
	}
	static class UGameDataFixTreasureBoxLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFixTreasureBoxLibrary>();
	}
};
static_assert(alignof(UGameDataFixTreasureBoxLibrary) == 0x000008, "Wrong alignment on UGameDataFixTreasureBoxLibrary");
static_assert(sizeof(UGameDataFixTreasureBoxLibrary) == 0x000030, "Wrong size on UGameDataFixTreasureBoxLibrary");

// Class DarwinGame.AnimNotifyState_BossPossessFlying
// 0x0020 (0x0058 - 0x0038)
class UAnimNotifyState_BossPossessFlying final : public UAnimNotifyState
{
public:
	float                                         mRange;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mExitUi;                                           // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mFlyingTime;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mMaxSpeed;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mMinSpeed;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSectionName;                                      // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossPossessFlying">();
	}
	static class UAnimNotifyState_BossPossessFlying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossPossessFlying>();
	}
};
static_assert(alignof(UAnimNotifyState_BossPossessFlying) == 0x000008, "Wrong alignment on UAnimNotifyState_BossPossessFlying");
static_assert(sizeof(UAnimNotifyState_BossPossessFlying) == 0x000058, "Wrong size on UAnimNotifyState_BossPossessFlying");
static_assert(offsetof(UAnimNotifyState_BossPossessFlying, mRange) == 0x000038, "Member 'UAnimNotifyState_BossPossessFlying::mRange' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPossessFlying, mExitUi) == 0x00003C, "Member 'UAnimNotifyState_BossPossessFlying::mExitUi' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPossessFlying, mFlyingTime) == 0x000040, "Member 'UAnimNotifyState_BossPossessFlying::mFlyingTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPossessFlying, mMaxSpeed) == 0x000044, "Member 'UAnimNotifyState_BossPossessFlying::mMaxSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPossessFlying, mMinSpeed) == 0x000048, "Member 'UAnimNotifyState_BossPossessFlying::mMinSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossPossessFlying, mSectionName) == 0x00004C, "Member 'UAnimNotifyState_BossPossessFlying::mSectionName' has a wrong offset!");

// Class DarwinGame.TreasureMapObjectBase
// 0x0010 (0x0340 - 0x0330)
class ATreasureMapObjectBase : public ADropItemObject
{
public:
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const class FName Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureMapObjectBase">();
	}
	static class ATreasureMapObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureMapObjectBase>();
	}
};
static_assert(alignof(ATreasureMapObjectBase) == 0x000008, "Wrong alignment on ATreasureMapObjectBase");
static_assert(sizeof(ATreasureMapObjectBase) == 0x000340, "Wrong size on ATreasureMapObjectBase");

// Class DarwinGame.MyTeamFlagBase
// 0x0008 (0x02C0 - 0x02B8)
class AMyTeamFlagBase : public AFlagBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTeamFlagBase">();
	}
	static class AMyTeamFlagBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyTeamFlagBase>();
	}
};
static_assert(alignof(AMyTeamFlagBase) == 0x000008, "Wrong alignment on AMyTeamFlagBase");
static_assert(sizeof(AMyTeamFlagBase) == 0x0002C0, "Wrong size on AMyTeamFlagBase");

// Class DarwinGame.BaseAreaMyTeamFlag
// 0x0028 (0x02E8 - 0x02C0)
class ABaseAreaMyTeamFlag final : public AMyTeamFlagBase
{
public:
	class FName                                   mFastTravelIdToBattleArea;                         // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mConfirmTextID;                                    // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mVsGalesTextID;                                    // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaMyTeamFlag">();
	}
	static class ABaseAreaMyTeamFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseAreaMyTeamFlag>();
	}
};
static_assert(alignof(ABaseAreaMyTeamFlag) == 0x000008, "Wrong alignment on ABaseAreaMyTeamFlag");
static_assert(sizeof(ABaseAreaMyTeamFlag) == 0x0002E8, "Wrong size on ABaseAreaMyTeamFlag");
static_assert(offsetof(ABaseAreaMyTeamFlag, mFastTravelIdToBattleArea) == 0x0002C0, "Member 'ABaseAreaMyTeamFlag::mFastTravelIdToBattleArea' has a wrong offset!");
static_assert(offsetof(ABaseAreaMyTeamFlag, mConfirmTextID) == 0x0002C8, "Member 'ABaseAreaMyTeamFlag::mConfirmTextID' has a wrong offset!");
static_assert(offsetof(ABaseAreaMyTeamFlag, mVsGalesTextID) == 0x0002D0, "Member 'ABaseAreaMyTeamFlag::mVsGalesTextID' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_Base
// 0x0000 (0x0530 - 0x0530)
class UUIPartyMenu_PM_Panel_Base : public UUIScrollMenuItemBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_Base">();
	}
	static class UUIPartyMenu_PM_Panel_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_Base>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_Base) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_Base");
static_assert(sizeof(UUIPartyMenu_PM_Panel_Base) == 0x000530, "Wrong size on UUIPartyMenu_PM_Panel_Base");

// Class DarwinGame.UIContentMenu_Panel_02
// 0x0000 (0x0530 - 0x0530)
class UUIContentMenu_Panel_02 : public UUIPartyMenu_PM_Panel_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Panel_02">();
	}
	static class UUIContentMenu_Panel_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Panel_02>();
	}
};
static_assert(alignof(UUIContentMenu_Panel_02) == 0x000008, "Wrong alignment on UUIContentMenu_Panel_02");
static_assert(sizeof(UUIContentMenu_Panel_02) == 0x000530, "Wrong size on UUIContentMenu_Panel_02");

// Class DarwinGame.AnimNotifyState_BossRedeyeVisible
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossRedeyeVisible final : public UAnimNotifyState
{
public:
	EMonsterBossRedeyeStep                        mRedeyeStep;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossRedeyeVisible">();
	}
	static class UAnimNotifyState_BossRedeyeVisible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossRedeyeVisible>();
	}
};
static_assert(alignof(UAnimNotifyState_BossRedeyeVisible) == 0x000008, "Wrong alignment on UAnimNotifyState_BossRedeyeVisible");
static_assert(sizeof(UAnimNotifyState_BossRedeyeVisible) == 0x000040, "Wrong size on UAnimNotifyState_BossRedeyeVisible");
static_assert(offsetof(UAnimNotifyState_BossRedeyeVisible, mRedeyeStep) == 0x000038, "Member 'UAnimNotifyState_BossRedeyeVisible::mRedeyeStep' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossRetarget
// 0x0028 (0x0060 - 0x0038)
class UAnimNotifyState_BossRetarget final : public UAnimNotifyState
{
public:
	float                                         mAttackTargetDistance;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossTargetType                        mNearTargetLocationType;                           // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mNearSection;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossTargetType                        mFarTargetLocationType;                            // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mFarSection;                                       // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossTransitionType                    mTransitionType;                                   // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0xB];                                       // 0x0055(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossRetarget">();
	}
	static class UAnimNotifyState_BossRetarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossRetarget>();
	}
};
static_assert(alignof(UAnimNotifyState_BossRetarget) == 0x000008, "Wrong alignment on UAnimNotifyState_BossRetarget");
static_assert(sizeof(UAnimNotifyState_BossRetarget) == 0x000060, "Wrong size on UAnimNotifyState_BossRetarget");
static_assert(offsetof(UAnimNotifyState_BossRetarget, mAttackTargetDistance) == 0x000038, "Member 'UAnimNotifyState_BossRetarget::mAttackTargetDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRetarget, mNearTargetLocationType) == 0x00003C, "Member 'UAnimNotifyState_BossRetarget::mNearTargetLocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRetarget, mNearSection) == 0x000040, "Member 'UAnimNotifyState_BossRetarget::mNearSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRetarget, mFarTargetLocationType) == 0x000048, "Member 'UAnimNotifyState_BossRetarget::mFarTargetLocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRetarget, mFarSection) == 0x00004C, "Member 'UAnimNotifyState_BossRetarget::mFarSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRetarget, mTransitionType) == 0x000054, "Member 'UAnimNotifyState_BossRetarget::mTransitionType' has a wrong offset!");

// Class DarwinGame.BattleDirector
// 0x0008 (0x0038 - 0x0030)
class UBattleDirector final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDirector">();
	}
	static class UBattleDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDirector>();
	}
};
static_assert(alignof(UBattleDirector) == 0x000008, "Wrong alignment on UBattleDirector");
static_assert(sizeof(UBattleDirector) == 0x000038, "Wrong size on UBattleDirector");

// Class DarwinGame.UICursor_PartymenuBase
// 0x00B8 (0x05E8 - 0x0530)
class UUICursor_PartymenuBase : public UUIScrollMenuItemBase
{
public:
	float                                         DefaultPanelWidth;                                 // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultTextOffsetY;                                // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LevelNumberText;                                   // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x50];                                     // 0x0540(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextName;                                          // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           arrow;                                             // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageCustom;                                       // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_CursorPartyMoveAnimation>   MoveAnimations;                                    // 0x05B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x28];                                     // 0x05C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_PartymenuBase">();
	}
	static class UUICursor_PartymenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_PartymenuBase>();
	}
};
static_assert(alignof(UUICursor_PartymenuBase) == 0x000008, "Wrong alignment on UUICursor_PartymenuBase");
static_assert(sizeof(UUICursor_PartymenuBase) == 0x0005E8, "Wrong size on UUICursor_PartymenuBase");
static_assert(offsetof(UUICursor_PartymenuBase, DefaultPanelWidth) == 0x000530, "Member 'UUICursor_PartymenuBase::DefaultPanelWidth' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuBase, DefaultTextOffsetY) == 0x000534, "Member 'UUICursor_PartymenuBase::DefaultTextOffsetY' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuBase, LevelNumberText) == 0x000538, "Member 'UUICursor_PartymenuBase::LevelNumberText' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuBase, TextName) == 0x000590, "Member 'UUICursor_PartymenuBase::TextName' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuBase, arrow) == 0x000598, "Member 'UUICursor_PartymenuBase::arrow' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuBase, ImageCustom) == 0x0005A0, "Member 'UUICursor_PartymenuBase::ImageCustom' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuBase, MoveAnimations) == 0x0005B0, "Member 'UUICursor_PartymenuBase::MoveAnimations' has a wrong offset!");

// Class DarwinGame.UICursor_Partymenu_06
// 0x0000 (0x05E8 - 0x05E8)
class UUICursor_Partymenu_06 : public UUICursor_PartymenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_06">();
	}
	static class UUICursor_Partymenu_06* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_06>();
	}
};
static_assert(alignof(UUICursor_Partymenu_06) == 0x000008, "Wrong alignment on UUICursor_Partymenu_06");
static_assert(sizeof(UUICursor_Partymenu_06) == 0x0005E8, "Wrong size on UUICursor_Partymenu_06");

// Class DarwinGame.AnimNotifyState_BossRotateInsightTarget
// 0x0028 (0x0060 - 0x0038)
class UAnimNotifyState_BossRotateInsightTarget final : public UAnimNotifyState
{
public:
	float                                         mReversalTime;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDurationTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mInsightAngle;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mChase;                                            // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mFailSection;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossRotateInsightTarget">();
	}
	static class UAnimNotifyState_BossRotateInsightTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossRotateInsightTarget>();
	}
};
static_assert(alignof(UAnimNotifyState_BossRotateInsightTarget) == 0x000008, "Wrong alignment on UAnimNotifyState_BossRotateInsightTarget");
static_assert(sizeof(UAnimNotifyState_BossRotateInsightTarget) == 0x000060, "Wrong size on UAnimNotifyState_BossRotateInsightTarget");
static_assert(offsetof(UAnimNotifyState_BossRotateInsightTarget, mReversalTime) == 0x000038, "Member 'UAnimNotifyState_BossRotateInsightTarget::mReversalTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRotateInsightTarget, mDurationTime) == 0x00003C, "Member 'UAnimNotifyState_BossRotateInsightTarget::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRotateInsightTarget, mInsightAngle) == 0x000040, "Member 'UAnimNotifyState_BossRotateInsightTarget::mInsightAngle' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRotateInsightTarget, mChase) == 0x000044, "Member 'UAnimNotifyState_BossRotateInsightTarget::mChase' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRotateInsightTarget, mFailSection) == 0x000048, "Member 'UAnimNotifyState_BossRotateInsightTarget::mFailSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossRotateInsightTarget, mSuccessSection) == 0x000050, "Member 'UAnimNotifyState_BossRotateInsightTarget::mSuccessSection' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossSelfhalm
// 0x0018 (0x0050 - 0x0038)
class UAnimNotifyState_BossSelfhalm final : public UAnimNotifyState
{
public:
	bool                                          mSubtractionType;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mPauseAutoRecover;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mSubtractionChargeAll;                             // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mSubtractionHPAll;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mSubtractionCharge;                                // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mSubtractionHP;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossSelfhalm">();
	}
	static class UAnimNotifyState_BossSelfhalm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossSelfhalm>();
	}
};
static_assert(alignof(UAnimNotifyState_BossSelfhalm) == 0x000008, "Wrong alignment on UAnimNotifyState_BossSelfhalm");
static_assert(sizeof(UAnimNotifyState_BossSelfhalm) == 0x000050, "Wrong size on UAnimNotifyState_BossSelfhalm");
static_assert(offsetof(UAnimNotifyState_BossSelfhalm, mSubtractionType) == 0x000038, "Member 'UAnimNotifyState_BossSelfhalm::mSubtractionType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossSelfhalm, mPauseAutoRecover) == 0x000039, "Member 'UAnimNotifyState_BossSelfhalm::mPauseAutoRecover' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossSelfhalm, mSubtractionChargeAll) == 0x00003C, "Member 'UAnimNotifyState_BossSelfhalm::mSubtractionChargeAll' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossSelfhalm, mSubtractionHPAll) == 0x000040, "Member 'UAnimNotifyState_BossSelfhalm::mSubtractionHPAll' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossSelfhalm, mSubtractionCharge) == 0x000044, "Member 'UAnimNotifyState_BossSelfhalm::mSubtractionCharge' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossSelfhalm, mSubtractionHP) == 0x000048, "Member 'UAnimNotifyState_BossSelfhalm::mSubtractionHP' has a wrong offset!");

// Class DarwinGame.GameScriptBase
// 0x0100 (0x0328 - 0x0228)
class AGameScriptBase : public AActor
{
public:
	class UDataTable*                             DT_GameScript;                                     // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EventTriggerrPtr;                                  // 0x0230(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Debug_ForcePlayGameScript;                         // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEventTrigger>              EventTriggerClass;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EEpisodeType, struct FST_EpisodeSpawnInfo> EpisodeSpawnList;                                  // 0x0268(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FST_FlagSpawnInfo>   FlagSpawnList;                                     // 0x02B8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           SpawnFlagNameList;                                 // 0x0308(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameScriptBase">();
	}
	static class AGameScriptBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameScriptBase>();
	}
};
static_assert(alignof(AGameScriptBase) == 0x000008, "Wrong alignment on AGameScriptBase");
static_assert(sizeof(AGameScriptBase) == 0x000328, "Wrong size on AGameScriptBase");
static_assert(offsetof(AGameScriptBase, DT_GameScript) == 0x000228, "Member 'AGameScriptBase::DT_GameScript' has a wrong offset!");
static_assert(offsetof(AGameScriptBase, EventTriggerrPtr) == 0x000230, "Member 'AGameScriptBase::EventTriggerrPtr' has a wrong offset!");
static_assert(offsetof(AGameScriptBase, Debug_ForcePlayGameScript) == 0x000258, "Member 'AGameScriptBase::Debug_ForcePlayGameScript' has a wrong offset!");
static_assert(offsetof(AGameScriptBase, EventTriggerClass) == 0x000260, "Member 'AGameScriptBase::EventTriggerClass' has a wrong offset!");
static_assert(offsetof(AGameScriptBase, EpisodeSpawnList) == 0x000268, "Member 'AGameScriptBase::EpisodeSpawnList' has a wrong offset!");
static_assert(offsetof(AGameScriptBase, FlagSpawnList) == 0x0002B8, "Member 'AGameScriptBase::FlagSpawnList' has a wrong offset!");
static_assert(offsetof(AGameScriptBase, SpawnFlagNameList) == 0x000308, "Member 'AGameScriptBase::SpawnFlagNameList' has a wrong offset!");

// Class DarwinGame.UIArtifactGetSystem
// 0x0010 (0x0040 - 0x0030)
class UUIArtifactGetSystem : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactGetSystem">();
	}
	static class UUIArtifactGetSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactGetSystem>();
	}
};
static_assert(alignof(UUIArtifactGetSystem) == 0x000008, "Wrong alignment on UUIArtifactGetSystem");
static_assert(sizeof(UUIArtifactGetSystem) == 0x000040, "Wrong size on UUIArtifactGetSystem");

// Class DarwinGame.BGMRegionActor
// 0x0000 (0x0228 - 0x0228)
class ABGMRegionActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGMRegionActor">();
	}
	static class ABGMRegionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGMRegionActor>();
	}
};
static_assert(alignof(ABGMRegionActor) == 0x000008, "Wrong alignment on ABGMRegionActor");
static_assert(sizeof(ABGMRegionActor) == 0x000228, "Wrong size on ABGMRegionActor");

// Class DarwinGame.AnimNotifyState_BossStartCamera
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_BossStartCamera final : public UAnimNotifyState
{
public:
	EMonsterBossCameraType                        mCameraType;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mEndCamera;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossStartCamera">();
	}
	static class UAnimNotifyState_BossStartCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossStartCamera>();
	}
};
static_assert(alignof(UAnimNotifyState_BossStartCamera) == 0x000008, "Wrong alignment on UAnimNotifyState_BossStartCamera");
static_assert(sizeof(UAnimNotifyState_BossStartCamera) == 0x000040, "Wrong size on UAnimNotifyState_BossStartCamera");
static_assert(offsetof(UAnimNotifyState_BossStartCamera, mCameraType) == 0x000038, "Member 'UAnimNotifyState_BossStartCamera::mCameraType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossStartCamera, mEndCamera) == 0x000039, "Member 'UAnimNotifyState_BossStartCamera::mEndCamera' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossStatueDeadWait
// 0x0018 (0x0050 - 0x0038)
class UAnimNotifyState_BossStatueDeadWait final : public UAnimNotifyState
{
public:
	class FName                                   mSectionNoneStatue;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSectionStatueDead;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mPhaseChange;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossStatueDeadWait">();
	}
	static class UAnimNotifyState_BossStatueDeadWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossStatueDeadWait>();
	}
};
static_assert(alignof(UAnimNotifyState_BossStatueDeadWait) == 0x000008, "Wrong alignment on UAnimNotifyState_BossStatueDeadWait");
static_assert(sizeof(UAnimNotifyState_BossStatueDeadWait) == 0x000050, "Wrong size on UAnimNotifyState_BossStatueDeadWait");
static_assert(offsetof(UAnimNotifyState_BossStatueDeadWait, mSectionNoneStatue) == 0x000038, "Member 'UAnimNotifyState_BossStatueDeadWait::mSectionNoneStatue' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossStatueDeadWait, mSectionStatueDead) == 0x000040, "Member 'UAnimNotifyState_BossStatueDeadWait::mSectionStatueDead' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossStatueDeadWait, mPhaseChange) == 0x000048, "Member 'UAnimNotifyState_BossStatueDeadWait::mPhaseChange' has a wrong offset!");

// Class DarwinGame.UITabLRBase
// 0x0030 (0x04C0 - 0x0490)
class UUITabLRBase : public UDarwinUserWidget
{
public:
	TArray<class UUITabLRItemBase*>               TabArray;                                          // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITabLRItemBase*                       CurrentTab;                                        // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITabLRBase">();
	}
	static class UUITabLRBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITabLRBase>();
	}
};
static_assert(alignof(UUITabLRBase) == 0x000008, "Wrong alignment on UUITabLRBase");
static_assert(sizeof(UUITabLRBase) == 0x0004C0, "Wrong size on UUITabLRBase");
static_assert(offsetof(UUITabLRBase, TabArray) == 0x000490, "Member 'UUITabLRBase::TabArray' has a wrong offset!");
static_assert(offsetof(UUITabLRBase, CurrentTab) == 0x0004B8, "Member 'UUITabLRBase::CurrentTab' has a wrong offset!");

// Class DarwinGame.LinkMenuBase
// 0x0068 (0x0198 - 0x0130)
class ULinkMenuBase : public UActionStateBase
{
public:
	uint8                                         Pad_130[0xC];                                      // 0x0130(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         mCurrentIndex;                                     // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           mLinkIDList;                                       // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_LinkData>                   mLinkDataList;                                     // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<bool>                                  mExecutableFlagList;                               // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 mActiveIndices;                                    // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecuteLinkAction(int32 Index_0);
	bool IsExecutable(int32 Index_0);
	void StartReacstTimer();

	class UUIField_IconLink* GetLinkWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinkMenuBase">();
	}
	static class ULinkMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULinkMenuBase>();
	}
};
static_assert(alignof(ULinkMenuBase) == 0x000008, "Wrong alignment on ULinkMenuBase");
static_assert(sizeof(ULinkMenuBase) == 0x000198, "Wrong size on ULinkMenuBase");
static_assert(offsetof(ULinkMenuBase, mCurrentIndex) == 0x00013C, "Member 'ULinkMenuBase::mCurrentIndex' has a wrong offset!");
static_assert(offsetof(ULinkMenuBase, mLinkIDList) == 0x000140, "Member 'ULinkMenuBase::mLinkIDList' has a wrong offset!");
static_assert(offsetof(ULinkMenuBase, mLinkDataList) == 0x000150, "Member 'ULinkMenuBase::mLinkDataList' has a wrong offset!");
static_assert(offsetof(ULinkMenuBase, mExecutableFlagList) == 0x000160, "Member 'ULinkMenuBase::mExecutableFlagList' has a wrong offset!");
static_assert(offsetof(ULinkMenuBase, mActiveIndices) == 0x000170, "Member 'ULinkMenuBase::mActiveIndices' has a wrong offset!");

// Class DarwinGame.BattleLinkMenu
// 0x0000 (0x0198 - 0x0198)
class UBattleLinkMenu final : public ULinkMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleLinkMenu">();
	}
	static class UBattleLinkMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleLinkMenu>();
	}
};
static_assert(alignof(UBattleLinkMenu) == 0x000008, "Wrong alignment on UBattleLinkMenu");
static_assert(sizeof(UBattleLinkMenu) == 0x000198, "Wrong size on UBattleLinkMenu");

// Class DarwinGame.AnimNotifyState_BossStatueDestroy
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_BossStatueDestroy final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossStatueDestroy">();
	}
	static class UAnimNotifyState_BossStatueDestroy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossStatueDestroy>();
	}
};
static_assert(alignof(UAnimNotifyState_BossStatueDestroy) == 0x000008, "Wrong alignment on UAnimNotifyState_BossStatueDestroy");
static_assert(sizeof(UAnimNotifyState_BossStatueDestroy) == 0x000038, "Wrong size on UAnimNotifyState_BossStatueDestroy");

// Class DarwinGame.HomingMagiceBase
// 0x0010 (0x0320 - 0x0310)
class AHomingMagiceBase : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomingMagiceBase">();
	}
	static class AHomingMagiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHomingMagiceBase>();
	}
};
static_assert(alignof(AHomingMagiceBase) == 0x000008, "Wrong alignment on AHomingMagiceBase");
static_assert(sizeof(AHomingMagiceBase) == 0x000320, "Wrong size on AHomingMagiceBase");

// Class DarwinGame.HomingSolidBase
// 0x0008 (0x0328 - 0x0320)
class AHomingSolidBase final : public AHomingMagiceBase
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomingSolidBase">();
	}
	static class AHomingSolidBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHomingSolidBase>();
	}
};
static_assert(alignof(AHomingSolidBase) == 0x000008, "Wrong alignment on AHomingSolidBase");
static_assert(sizeof(AHomingSolidBase) == 0x000328, "Wrong size on AHomingSolidBase");
static_assert(offsetof(AHomingSolidBase, Mesh) == 0x000320, "Member 'AHomingSolidBase::Mesh' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_BossTargetInRange
// 0x0048 (0x0080 - 0x0038)
class UAnimNotifyState_BossTargetInRange final : public UAnimNotifyState
{
public:
	EMonsterBossJudgementLocationType             mTarget1;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mRange;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossJudgementRangeType                mJudgementType1;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossJudgementLocationType             mTarget2;                                          // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossJudgementConditionType            mConditionType;                                    // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mRange2;                                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossJudgementRangeType                mJudgementType2;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mDurationTime;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection2;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mLeftRight;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mLeftSuccessSection;                               // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mRightSuccessSection;                              // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mTimeOutSection;                                   // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossTargetInRange">();
	}
	static class UAnimNotifyState_BossTargetInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossTargetInRange>();
	}
};
static_assert(alignof(UAnimNotifyState_BossTargetInRange) == 0x000008, "Wrong alignment on UAnimNotifyState_BossTargetInRange");
static_assert(sizeof(UAnimNotifyState_BossTargetInRange) == 0x000080, "Wrong size on UAnimNotifyState_BossTargetInRange");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mTarget1) == 0x000038, "Member 'UAnimNotifyState_BossTargetInRange::mTarget1' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mRange) == 0x00003C, "Member 'UAnimNotifyState_BossTargetInRange::mRange' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mJudgementType1) == 0x000040, "Member 'UAnimNotifyState_BossTargetInRange::mJudgementType1' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mTarget2) == 0x000041, "Member 'UAnimNotifyState_BossTargetInRange::mTarget2' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mConditionType) == 0x000042, "Member 'UAnimNotifyState_BossTargetInRange::mConditionType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mRange2) == 0x000044, "Member 'UAnimNotifyState_BossTargetInRange::mRange2' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mJudgementType2) == 0x000048, "Member 'UAnimNotifyState_BossTargetInRange::mJudgementType2' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mDurationTime) == 0x00004C, "Member 'UAnimNotifyState_BossTargetInRange::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mSuccessSection) == 0x000050, "Member 'UAnimNotifyState_BossTargetInRange::mSuccessSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mSuccessSection2) == 0x000058, "Member 'UAnimNotifyState_BossTargetInRange::mSuccessSection2' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mLeftRight) == 0x000060, "Member 'UAnimNotifyState_BossTargetInRange::mLeftRight' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mLeftSuccessSection) == 0x000064, "Member 'UAnimNotifyState_BossTargetInRange::mLeftSuccessSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mRightSuccessSection) == 0x00006C, "Member 'UAnimNotifyState_BossTargetInRange::mRightSuccessSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossTargetInRange, mTimeOutSection) == 0x000074, "Member 'UAnimNotifyState_BossTargetInRange::mTimeOutSection' has a wrong offset!");

// Class DarwinGame.UILeftMenu_9
// 0x0000 (0x0650 - 0x0650)
class UUILeftMenu_9 : public UUILeftMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_9">();
	}
	static class UUILeftMenu_9* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_9>();
	}
};
static_assert(alignof(UUILeftMenu_9) == 0x000008, "Wrong alignment on UUILeftMenu_9");
static_assert(sizeof(UUILeftMenu_9) == 0x000650, "Wrong size on UUILeftMenu_9");

// Class DarwinGame.DamageExecutionBase
// 0x0000 (0x0048 - 0x0048)
class UDamageExecutionBase : public UGameplayEffectExecutionCalculation
{
public:
	void CalculateDamage(const struct FGameplayEffectContextHandle& ContextHandle, class AGPACharacter* Source, class AGPACharacter* Target, float* Damage, float* Stun) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageExecutionBase">();
	}
	static class UDamageExecutionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageExecutionBase>();
	}
};
static_assert(alignof(UDamageExecutionBase) == 0x000008, "Wrong alignment on UDamageExecutionBase");
static_assert(sizeof(UDamageExecutionBase) == 0x000048, "Wrong size on UDamageExecutionBase");

// Class DarwinGame.BattleDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UBattleDamageExecution final : public UDamageExecutionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDamageExecution">();
	}
	static class UBattleDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDamageExecution>();
	}
};
static_assert(alignof(UBattleDamageExecution) == 0x000008, "Wrong alignment on UBattleDamageExecution");
static_assert(sizeof(UBattleDamageExecution) == 0x000048, "Wrong size on UBattleDamageExecution");

// Class DarwinGame.UICursor_Partymenu_04
// 0x0000 (0x05E8 - 0x05E8)
class UUICursor_Partymenu_04 final : public UUICursor_PartymenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_04">();
	}
	static class UUICursor_Partymenu_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_04>();
	}
};
static_assert(alignof(UUICursor_Partymenu_04) == 0x000008, "Wrong alignment on UUICursor_Partymenu_04");
static_assert(sizeof(UUICursor_Partymenu_04) == 0x0005E8, "Wrong size on UUICursor_Partymenu_04");

// Class DarwinGame.AnimNotifyState_BossUIRestart
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_BossUIRestart final : public UAnimNotifyState
{
public:
	float                                         mChangeTime;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mWaitChildBoss;                                    // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mSectionName;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BossUIRestart">();
	}
	static class UAnimNotifyState_BossUIRestart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BossUIRestart>();
	}
};
static_assert(alignof(UAnimNotifyState_BossUIRestart) == 0x000008, "Wrong alignment on UAnimNotifyState_BossUIRestart");
static_assert(sizeof(UAnimNotifyState_BossUIRestart) == 0x000048, "Wrong size on UAnimNotifyState_BossUIRestart");
static_assert(offsetof(UAnimNotifyState_BossUIRestart, mChangeTime) == 0x000038, "Member 'UAnimNotifyState_BossUIRestart::mChangeTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossUIRestart, mWaitChildBoss) == 0x00003C, "Member 'UAnimNotifyState_BossUIRestart::mWaitChildBoss' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BossUIRestart, mSectionName) == 0x000040, "Member 'UAnimNotifyState_BossUIRestart::mSectionName' has a wrong offset!");

// Class DarwinGame.StalkerBattleIdDataTable
// 0x0000 (0x0030 - 0x0030)
class UStalkerBattleIdDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkerBattleIdDataTable">();
	}
	static class UStalkerBattleIdDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkerBattleIdDataTable>();
	}
};
static_assert(alignof(UStalkerBattleIdDataTable) == 0x000008, "Wrong alignment on UStalkerBattleIdDataTable");
static_assert(sizeof(UStalkerBattleIdDataTable) == 0x000030, "Wrong size on UStalkerBattleIdDataTable");

// Class DarwinGame.AnimNotifyState_ChangeEcologicalState
// 0x0018 (0x0050 - 0x0038)
class UAnimNotifyState_ChangeEcologicalState final : public UAnimNotifyState
{
public:
	float                                         ChangeTime;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChangePercentage;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEcologicalState                              InitEcologicalState;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEcologicalState                              ChangedEcologicalState;                            // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ChangeEcologicalState">();
	}
	static class UAnimNotifyState_ChangeEcologicalState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ChangeEcologicalState>();
	}
};
static_assert(alignof(UAnimNotifyState_ChangeEcologicalState) == 0x000008, "Wrong alignment on UAnimNotifyState_ChangeEcologicalState");
static_assert(sizeof(UAnimNotifyState_ChangeEcologicalState) == 0x000050, "Wrong size on UAnimNotifyState_ChangeEcologicalState");
static_assert(offsetof(UAnimNotifyState_ChangeEcologicalState, ChangeTime) == 0x000038, "Member 'UAnimNotifyState_ChangeEcologicalState::ChangeTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ChangeEcologicalState, ChangePercentage) == 0x00003C, "Member 'UAnimNotifyState_ChangeEcologicalState::ChangePercentage' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ChangeEcologicalState, InitEcologicalState) == 0x000040, "Member 'UAnimNotifyState_ChangeEcologicalState::InitEcologicalState' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ChangeEcologicalState, ChangedEcologicalState) == 0x000041, "Member 'UAnimNotifyState_ChangeEcologicalState::ChangedEcologicalState' has a wrong offset!");

// Class DarwinGame.UICoinMenu
// 0x00D0 (0x0560 - 0x0490)
class UUICoinMenu : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           TabNames;                                          // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICoinMenu_Coin_Stock*                 UICoinStock;                                       // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICoinMenu_CoinPlate_Set*              UICoinPlateSet;                                    // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHeader_01*                           UIHeader;                                          // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x20];                                     // 0x04D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPartyMenu_PMR_Page_12*               Page12;                                            // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_02*               Page02;                                            // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_02*               CoinDetail;                                        // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITopbar_01*                           Topbar;                                            // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_Base*             CurrentPage;                                       // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIPartyMenu_PMR_Page_Base*>     PageArray;                                         // 0x0518(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x38];                                     // 0x0528(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Refresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu">();
	}
	static class UUICoinMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu>();
	}
};
static_assert(alignof(UUICoinMenu) == 0x000008, "Wrong alignment on UUICoinMenu");
static_assert(sizeof(UUICoinMenu) == 0x000560, "Wrong size on UUICoinMenu");
static_assert(offsetof(UUICoinMenu, TabNames) == 0x0004A0, "Member 'UUICoinMenu::TabNames' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, UICoinStock) == 0x0004B0, "Member 'UUICoinMenu::UICoinStock' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, UICoinPlateSet) == 0x0004B8, "Member 'UUICoinMenu::UICoinPlateSet' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, UIUnderButton) == 0x0004C0, "Member 'UUICoinMenu::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, UIHeader) == 0x0004C8, "Member 'UUICoinMenu::UIHeader' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, Page12) == 0x0004F0, "Member 'UUICoinMenu::Page12' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, Page02) == 0x0004F8, "Member 'UUICoinMenu::Page02' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, CoinDetail) == 0x000500, "Member 'UUICoinMenu::CoinDetail' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, Topbar) == 0x000508, "Member 'UUICoinMenu::Topbar' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, CurrentPage) == 0x000510, "Member 'UUICoinMenu::CurrentPage' has a wrong offset!");
static_assert(offsetof(UUICoinMenu, PageArray) == 0x000518, "Member 'UUICoinMenu::PageArray' has a wrong offset!");

// Class DarwinGame.EmoteBodyMotionOverwriteOption
// 0x0010 (0x0040 - 0x0030)
class UEmoteBodyMotionOverwriteOption final : public UObject
{
public:
	struct FEmoteBodyMotionSetting                OverwriteParam;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteBodyMotionOverwriteOption">();
	}
	static class UEmoteBodyMotionOverwriteOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteBodyMotionOverwriteOption>();
	}
};
static_assert(alignof(UEmoteBodyMotionOverwriteOption) == 0x000008, "Wrong alignment on UEmoteBodyMotionOverwriteOption");
static_assert(sizeof(UEmoteBodyMotionOverwriteOption) == 0x000040, "Wrong size on UEmoteBodyMotionOverwriteOption");
static_assert(offsetof(UEmoteBodyMotionOverwriteOption, OverwriteParam) == 0x000030, "Member 'UEmoteBodyMotionOverwriteOption::OverwriteParam' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ChargeBehavior
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_ChargeBehavior final : public UAnimNotifyState
{
public:
	bool                                          mVisibility;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ChargeBehavior">();
	}
	static class UAnimNotifyState_ChargeBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ChargeBehavior>();
	}
};
static_assert(alignof(UAnimNotifyState_ChargeBehavior) == 0x000008, "Wrong alignment on UAnimNotifyState_ChargeBehavior");
static_assert(sizeof(UAnimNotifyState_ChargeBehavior) == 0x000040, "Wrong size on UAnimNotifyState_ChargeBehavior");
static_assert(offsetof(UAnimNotifyState_ChargeBehavior, mVisibility) == 0x000038, "Member 'UAnimNotifyState_ChargeBehavior::mVisibility' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ChargeBreakingTime
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_ChargeBreakingTime final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ChargeBreakingTime">();
	}
	static class UAnimNotifyState_ChargeBreakingTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ChargeBreakingTime>();
	}
};
static_assert(alignof(UAnimNotifyState_ChargeBreakingTime) == 0x000008, "Wrong alignment on UAnimNotifyState_ChargeBreakingTime");
static_assert(sizeof(UAnimNotifyState_ChargeBreakingTime) == 0x000038, "Wrong size on UAnimNotifyState_ChargeBreakingTime");

// Class DarwinGame.EventDataBase
// 0x0050 (0x0080 - 0x0030)
class UEventDataBase : public UObject
{
public:
	TMap<EEventDataTableType, class UDataTable*>  EventDataTableList;                                // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool CanForcedBattleEvent(const class FName& EventID);
	class FName ConvertItemIdToTreasureAreaId(const class FName& ItemId);
	int32 ConvertItemIdToTresureId(const class FName& ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventDataBase">();
	}
	static class UEventDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventDataBase>();
	}
};
static_assert(alignof(UEventDataBase) == 0x000008, "Wrong alignment on UEventDataBase");
static_assert(sizeof(UEventDataBase) == 0x000080, "Wrong size on UEventDataBase");
static_assert(offsetof(UEventDataBase, EventDataTableList) == 0x000030, "Member 'UEventDataBase::EventDataTableList' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ComboInputTime
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_ComboInputTime : public UAnimNotifyState
{
public:
	void OnComboInputBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ComboInputTime">();
	}
	static class UAnimNotifyState_ComboInputTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ComboInputTime>();
	}
};
static_assert(alignof(UAnimNotifyState_ComboInputTime) == 0x000008, "Wrong alignment on UAnimNotifyState_ComboInputTime");
static_assert(sizeof(UAnimNotifyState_ComboInputTime) == 0x000038, "Wrong size on UAnimNotifyState_ComboInputTime");

// Class DarwinGame.AnimNotifyState_DisableFootIK
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_DisableFootIK final : public UAnimNotifyState
{
public:
	bool                                          bChangeImmediateBegin;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeImmediateEnd;                               // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableFootIK">();
	}
	static class UAnimNotifyState_DisableFootIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableFootIK>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableFootIK) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableFootIK");
static_assert(sizeof(UAnimNotifyState_DisableFootIK) == 0x000040, "Wrong size on UAnimNotifyState_DisableFootIK");
static_assert(offsetof(UAnimNotifyState_DisableFootIK, bChangeImmediateBegin) == 0x000038, "Member 'UAnimNotifyState_DisableFootIK::bChangeImmediateBegin' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_DisableFootIK, bChangeImmediateEnd) == 0x000039, "Member 'UAnimNotifyState_DisableFootIK::bChangeImmediateEnd' has a wrong offset!");

// Class DarwinGame.TipsOpener
// 0x00A8 (0x00D8 - 0x0030)
class UTipsOpener : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OpenScheduleManualTipsIDs;                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           OpenScheduleNewItemGetTipsIDs;                     // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOpenTips;                                       // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDelay;                                          // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPause;                                          // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTimerHandle>        DelayedTipsTimerHandleList;                        // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOpenScheduleManualTipsList(const class FName& TipsID);
	void AddOpenScheduleNewItemGetTipsList(const class FName& ItemId);
	void ClearDelayedTipsSchedule();
	void OpenDelayedTips(const class FName TipsID);
	void OpenTips();
	void OpenTipsSpecifyOnly(const class FName& TipsID);
	void RequestOpenDelayedTips(const class FName& TipsID, float DelayTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TipsOpener">();
	}
	static class UTipsOpener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTipsOpener>();
	}
};
static_assert(alignof(UTipsOpener) == 0x000008, "Wrong alignment on UTipsOpener");
static_assert(sizeof(UTipsOpener) == 0x0000D8, "Wrong size on UTipsOpener");
static_assert(offsetof(UTipsOpener, OpenScheduleManualTipsIDs) == 0x000040, "Member 'UTipsOpener::OpenScheduleManualTipsIDs' has a wrong offset!");
static_assert(offsetof(UTipsOpener, OpenScheduleNewItemGetTipsIDs) == 0x000050, "Member 'UTipsOpener::OpenScheduleNewItemGetTipsIDs' has a wrong offset!");
static_assert(offsetof(UTipsOpener, bIsOpenTips) == 0x000060, "Member 'UTipsOpener::bIsOpenTips' has a wrong offset!");
static_assert(offsetof(UTipsOpener, bIsDelay) == 0x000061, "Member 'UTipsOpener::bIsDelay' has a wrong offset!");
static_assert(offsetof(UTipsOpener, bIsPause) == 0x000062, "Member 'UTipsOpener::bIsPause' has a wrong offset!");
static_assert(offsetof(UTipsOpener, DelayedTipsTimerHandleList) == 0x000068, "Member 'UTipsOpener::DelayedTipsTimerHandleList' has a wrong offset!");

// Class DarwinGame.UICoinStatusArrow
// 0x0028 (0x04B8 - 0x0490)
class UUICoinStatusArrow : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x28];                                     // 0x0490(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitWidget(class UImage* iconImg, class UTextBlock* upValue, class UWidgetAnimation* statusUp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinStatusArrow">();
	}
	static class UUICoinStatusArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinStatusArrow>();
	}
};
static_assert(alignof(UUICoinStatusArrow) == 0x000008, "Wrong alignment on UUICoinStatusArrow");
static_assert(sizeof(UUICoinStatusArrow) == 0x0004B8, "Wrong size on UUICoinStatusArrow");

// Class DarwinGame.DespoilAction
// 0x0080 (0x01B0 - 0x0130)
class UDespoilAction : public UActionStateBase
{
public:
	float                                         mDashDistance;                                     // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mDashSpeed;                                        // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mMiniGameStartDistance;                            // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x1C];                                     // 0x013C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      mRangeTimeList;                                    // 0x0158(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DespoilAction">();
	}
	static class UDespoilAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDespoilAction>();
	}
};
static_assert(alignof(UDespoilAction) == 0x000008, "Wrong alignment on UDespoilAction");
static_assert(sizeof(UDespoilAction) == 0x0001B0, "Wrong size on UDespoilAction");
static_assert(offsetof(UDespoilAction, mDashDistance) == 0x000130, "Member 'UDespoilAction::mDashDistance' has a wrong offset!");
static_assert(offsetof(UDespoilAction, mDashSpeed) == 0x000134, "Member 'UDespoilAction::mDashSpeed' has a wrong offset!");
static_assert(offsetof(UDespoilAction, mMiniGameStartDistance) == 0x000138, "Member 'UDespoilAction::mMiniGameStartDistance' has a wrong offset!");
static_assert(offsetof(UDespoilAction, mRangeTimeList) == 0x000158, "Member 'UDespoilAction::mRangeTimeList' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState">();
	}
	static class UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState>();
	}
};
static_assert(alignof(UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState) == 0x000008, "Wrong alignment on UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState");
static_assert(sizeof(UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState) == 0x000038, "Wrong size on UAnimNotifyState_EnableAirStateFlyCheckLandingChangeLandState");

// Class DarwinGame.AnimNotifyState_EnablePlayingHideEdFlag
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_EnablePlayingHideEdFlag final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EnablePlayingHideEdFlag">();
	}
	static class UAnimNotifyState_EnablePlayingHideEdFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EnablePlayingHideEdFlag>();
	}
};
static_assert(alignof(UAnimNotifyState_EnablePlayingHideEdFlag) == 0x000008, "Wrong alignment on UAnimNotifyState_EnablePlayingHideEdFlag");
static_assert(sizeof(UAnimNotifyState_EnablePlayingHideEdFlag) == 0x000038, "Wrong size on UAnimNotifyState_EnablePlayingHideEdFlag");

// Class DarwinGame.TextWidgetData
// 0x0070 (0x00A0 - 0x0030)
class UTextWidgetData : public UObject
{
public:
	TDelegate<void(const class FString& Text)>    OnTextUtilityEventDispather;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetText(const class FString& inString, bool isSystemMessage, int32 defaultCursol, int32 cancelPos, int32 Price, bool forceRuby);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextWidgetData">();
	}
	static class UTextWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextWidgetData>();
	}
};
static_assert(alignof(UTextWidgetData) == 0x000008, "Wrong alignment on UTextWidgetData");
static_assert(sizeof(UTextWidgetData) == 0x0000A0, "Wrong size on UTextWidgetData");
static_assert(offsetof(UTextWidgetData, OnTextUtilityEventDispather) == 0x000030, "Member 'UTextWidgetData::OnTextUtilityEventDispather' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ExpandBoundingBox
// 0x0028 (0x0060 - 0x0038)
class UAnimNotifyState_ExpandBoundingBox final : public UAnimNotifyState
{
public:
	class UCurveFloat*                            ParameterCurve;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendTotalDuration;                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTime;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OriginalScale;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentValue;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bChangeAnimTickOption;                             // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVisibilityBasedAnimTickOption                ChangeAnimTickOption;                              // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ExpandBoundingBox">();
	}
	static class UAnimNotifyState_ExpandBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ExpandBoundingBox>();
	}
};
static_assert(alignof(UAnimNotifyState_ExpandBoundingBox) == 0x000008, "Wrong alignment on UAnimNotifyState_ExpandBoundingBox");
static_assert(sizeof(UAnimNotifyState_ExpandBoundingBox) == 0x000060, "Wrong size on UAnimNotifyState_ExpandBoundingBox");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, ParameterCurve) == 0x000038, "Member 'UAnimNotifyState_ExpandBoundingBox::ParameterCurve' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, BlendTotalDuration) == 0x000040, "Member 'UAnimNotifyState_ExpandBoundingBox::BlendTotalDuration' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, CurrentTime) == 0x000044, "Member 'UAnimNotifyState_ExpandBoundingBox::CurrentTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, OriginalScale) == 0x000048, "Member 'UAnimNotifyState_ExpandBoundingBox::OriginalScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, CurrentValue) == 0x00004C, "Member 'UAnimNotifyState_ExpandBoundingBox::CurrentValue' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, bChangeAnimTickOption) == 0x000058, "Member 'UAnimNotifyState_ExpandBoundingBox::bChangeAnimTickOption' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_ExpandBoundingBox, ChangeAnimTickOption) == 0x000059, "Member 'UAnimNotifyState_ExpandBoundingBox::ChangeAnimTickOption' has a wrong offset!");

// Class DarwinGame.EnvironmentObject
// 0x07A8 (0x09D0 - 0x0228)
class alignas(0x10) AEnvironmentObject : public AActor
{
public:
	class UPostProcessComponent*                  m_PostProcessComp;                                 // 0x0228(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkyLightComponent*                     m_SkyLight;                                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionalLightComponent*             m_DirectionalLight;                                // 0x0238(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExponentialHeightFogComponent*         m_ExponentialHeightFog;                            // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           m_SkyMPC;                                          // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               m_SkySphereDMI;                                    // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               m_SkyCloudDMI;                                     // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            m_SunColorCurve;                                   // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           m_SunRotationCurve;                                // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           m_DirectionalLightRotationCurve;                   // 0x0270(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x330];                                    // 0x0278(0x0330)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThunderWeight;                                     // 0x05A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderLifeMax;                                    // 0x05AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderLifeMin;                                    // 0x05B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUpdateThunderEvent;                              // 0x05B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDisplayedThunder;                                // 0x05B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B6[0x2];                                      // 0x05B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThunderFinishTime;                                 // 0x05B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUseInitEnvironmentID;                            // 0x05BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUseEvent;                                        // 0x05BD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BE[0x2];                                      // 0x05BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         mEventTimeHour;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mEventTimeMinute;                                  // 0x05C4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InitEnvironmentID;                                 // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeightedBlendables                    InitPostProcessMaterials;                          // 0x05D0(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x380];                                    // 0x05E0(0x0380)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           NextCubemap;                                       // 0x0960(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x48];                                     // 0x0968(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class AEnvironmentEffectBase*                 EnvEffect;                                         // 0x09B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEnvironmentEffectBase*                 PrevEnvEffect;                                     // 0x09B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C0[0x10];                                     // 0x09C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBigStarEmissive();
	EEnvironmentType GetEnvironmentType();
	float GetFogDensity();
	float GetSmallStarEmissive();
	float GetSmallStarReduce();
	float GetStarOverallEmissive();
	void Initialize(const class FName& EnvID);
	void PreInitialize(class UPostProcessComponent* PostProcessComponent, class UStaticMeshComponent* SkySphere, class UStaticMeshComponent* SkyCloud, class USkyLightComponent* SkyLight, class UDirectionalLightComponent* DirectionalLight, class UExponentialHeightFogComponent* ExponentialHeightFog, class UMaterialParameterCollection* SkyMPC, class UCurveFloat* SunColorCurve, class UCurveVector* SunRotationCurve, class UCurveVector* DirectionalLightRotationCurve);
	void RefreshSettings();
	void SetBigStarEmissive(float Param);
	void SetFogDensity(float Density);
	void SetPostProcessWeight(EEnvironmentPostProcessType Type, float Weight);
	void SetSmallStarEmissive(float Param);
	void SetSmallStarReduce(float Param);
	void SetStarOverallEmissive(float Param);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentObject">();
	}
	static class AEnvironmentObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentObject>();
	}
};
static_assert(alignof(AEnvironmentObject) == 0x000010, "Wrong alignment on AEnvironmentObject");
static_assert(sizeof(AEnvironmentObject) == 0x0009D0, "Wrong size on AEnvironmentObject");
static_assert(offsetof(AEnvironmentObject, m_PostProcessComp) == 0x000228, "Member 'AEnvironmentObject::m_PostProcessComp' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_SkyLight) == 0x000230, "Member 'AEnvironmentObject::m_SkyLight' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_DirectionalLight) == 0x000238, "Member 'AEnvironmentObject::m_DirectionalLight' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_ExponentialHeightFog) == 0x000240, "Member 'AEnvironmentObject::m_ExponentialHeightFog' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_SkyMPC) == 0x000248, "Member 'AEnvironmentObject::m_SkyMPC' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_SkySphereDMI) == 0x000250, "Member 'AEnvironmentObject::m_SkySphereDMI' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_SkyCloudDMI) == 0x000258, "Member 'AEnvironmentObject::m_SkyCloudDMI' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_SunColorCurve) == 0x000260, "Member 'AEnvironmentObject::m_SunColorCurve' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_SunRotationCurve) == 0x000268, "Member 'AEnvironmentObject::m_SunRotationCurve' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, m_DirectionalLightRotationCurve) == 0x000270, "Member 'AEnvironmentObject::m_DirectionalLightRotationCurve' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, ThunderWeight) == 0x0005A8, "Member 'AEnvironmentObject::ThunderWeight' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, ThunderLifeMax) == 0x0005AC, "Member 'AEnvironmentObject::ThunderLifeMax' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, ThunderLifeMin) == 0x0005B0, "Member 'AEnvironmentObject::ThunderLifeMin' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, IsUpdateThunderEvent) == 0x0005B4, "Member 'AEnvironmentObject::IsUpdateThunderEvent' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, IsDisplayedThunder) == 0x0005B5, "Member 'AEnvironmentObject::IsDisplayedThunder' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, ThunderFinishTime) == 0x0005B8, "Member 'AEnvironmentObject::ThunderFinishTime' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, IsUseInitEnvironmentID) == 0x0005BC, "Member 'AEnvironmentObject::IsUseInitEnvironmentID' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, IsUseEvent) == 0x0005BD, "Member 'AEnvironmentObject::IsUseEvent' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, mEventTimeHour) == 0x0005C0, "Member 'AEnvironmentObject::mEventTimeHour' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, mEventTimeMinute) == 0x0005C4, "Member 'AEnvironmentObject::mEventTimeMinute' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, InitEnvironmentID) == 0x0005C8, "Member 'AEnvironmentObject::InitEnvironmentID' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, InitPostProcessMaterials) == 0x0005D0, "Member 'AEnvironmentObject::InitPostProcessMaterials' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, NextCubemap) == 0x000960, "Member 'AEnvironmentObject::NextCubemap' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, EnvEffect) == 0x0009B0, "Member 'AEnvironmentObject::EnvEffect' has a wrong offset!");
static_assert(offsetof(AEnvironmentObject, PrevEnvEffect) == 0x0009B8, "Member 'AEnvironmentObject::PrevEnvEffect' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_FailToAttack
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_FailToAttack final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_FailToAttack">();
	}
	static class UAnimNotifyState_FailToAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_FailToAttack>();
	}
};
static_assert(alignof(UAnimNotifyState_FailToAttack) == 0x000008, "Wrong alignment on UAnimNotifyState_FailToAttack");
static_assert(sizeof(UAnimNotifyState_FailToAttack) == 0x000038, "Wrong size on UAnimNotifyState_FailToAttack");

// Class DarwinGame.UIDispatch_List
// 0x0030 (0x0600 - 0x05D0)
class UUIDispatch_List : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x30];                                     // 0x05D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_List">();
	}
	static class UUIDispatch_List* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_List>();
	}
};
static_assert(alignof(UUIDispatch_List) == 0x000008, "Wrong alignment on UUIDispatch_List");
static_assert(sizeof(UUIDispatch_List) == 0x000600, "Wrong size on UUIDispatch_List");

// Class DarwinGame.EnemySpawnGeneratorBase
// 0x00F0 (0x01A8 - 0x00B8)
class UEnemySpawnGeneratorBase : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mGeneratorID;                                      // 0x00BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FlagPopID;                                         // 0x00C4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FlagDefeatedID;                                    // 0x00CC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UpperLimit;                                        // 0x00D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LowerLimit;                                        // 0x00D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TimeID;                                            // 0x00DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_EncountMonsterParam>        Monsters;                                          // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnemySpawnSetType                            SetType;                                           // 0x00F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnemySpawnGeneratorType                      GenType;                                           // 0x00F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChildGeneratorNum;                                 // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChildGeneratorMonsterNum;                          // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChildGeneratorRadius;                              // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChildGeneratorMonsterDistance;                     // 0x0100(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawnPriority;                                     // 0x0104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          mIsHighAltitude;                                   // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x34];                                     // 0x0109(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mIsStopSpawn;                                      // 0x013D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          mStartUpPawn;                                      // 0x013E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13F[0x9];                                      // 0x013F(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          mSpawnBox;                                         // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      mSpawnCylinder;                                    // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       mIgnoreSphere;                                     // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrowComponent*                        mForwardArrow;                                     // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x18];                                     // 0x0190(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBoxVisible(bool flg);
	void SetEnableSpawnCheck(const bool flg);
	void SetGeneratorID(const class FName ID);
	void SetIgnoreAreaCheck(const bool flg);
	void SetOverlapCheck(const bool flg);
	void SetStopSpawn(bool flg);

	float GetChildGeneratorRadius() const;
	const class FName GetGeneratorID() const;
	bool HasActiveGenerator() const;
	bool IsBoxVisible() const;
	bool IsEnableSpawnCheck() const;
	bool IsIgnoreAreaCheck() const;
	bool IsOverlapCheck() const;
	bool IsStopSpawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorBase">();
	}
	static class UEnemySpawnGeneratorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorBase>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorBase) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorBase");
static_assert(sizeof(UEnemySpawnGeneratorBase) == 0x0001A8, "Wrong size on UEnemySpawnGeneratorBase");
static_assert(offsetof(UEnemySpawnGeneratorBase, mGeneratorID) == 0x0000BC, "Member 'UEnemySpawnGeneratorBase::mGeneratorID' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, FlagPopID) == 0x0000C4, "Member 'UEnemySpawnGeneratorBase::FlagPopID' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, FlagDefeatedID) == 0x0000CC, "Member 'UEnemySpawnGeneratorBase::FlagDefeatedID' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, UpperLimit) == 0x0000D4, "Member 'UEnemySpawnGeneratorBase::UpperLimit' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, LowerLimit) == 0x0000D8, "Member 'UEnemySpawnGeneratorBase::LowerLimit' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, TimeID) == 0x0000DC, "Member 'UEnemySpawnGeneratorBase::TimeID' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, Monsters) == 0x0000E0, "Member 'UEnemySpawnGeneratorBase::Monsters' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, SetType) == 0x0000F0, "Member 'UEnemySpawnGeneratorBase::SetType' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, GenType) == 0x0000F1, "Member 'UEnemySpawnGeneratorBase::GenType' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, ChildGeneratorNum) == 0x0000F4, "Member 'UEnemySpawnGeneratorBase::ChildGeneratorNum' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, ChildGeneratorMonsterNum) == 0x0000F8, "Member 'UEnemySpawnGeneratorBase::ChildGeneratorMonsterNum' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, ChildGeneratorRadius) == 0x0000FC, "Member 'UEnemySpawnGeneratorBase::ChildGeneratorRadius' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, ChildGeneratorMonsterDistance) == 0x000100, "Member 'UEnemySpawnGeneratorBase::ChildGeneratorMonsterDistance' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, SpawnPriority) == 0x000104, "Member 'UEnemySpawnGeneratorBase::SpawnPriority' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mIsHighAltitude) == 0x000108, "Member 'UEnemySpawnGeneratorBase::mIsHighAltitude' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mIsStopSpawn) == 0x00013D, "Member 'UEnemySpawnGeneratorBase::mIsStopSpawn' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mStartUpPawn) == 0x00013E, "Member 'UEnemySpawnGeneratorBase::mStartUpPawn' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mSpawnBox) == 0x000148, "Member 'UEnemySpawnGeneratorBase::mSpawnBox' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mSpawnCylinder) == 0x000150, "Member 'UEnemySpawnGeneratorBase::mSpawnCylinder' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mIgnoreSphere) == 0x000170, "Member 'UEnemySpawnGeneratorBase::mIgnoreSphere' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorBase, mForwardArrow) == 0x000188, "Member 'UEnemySpawnGeneratorBase::mForwardArrow' has a wrong offset!");

// Class DarwinGame.EnemySpawnGeneratorDirect
// 0x0000 (0x01A8 - 0x01A8)
class UEnemySpawnGeneratorDirect : public UEnemySpawnGeneratorBase
{
public:
	void SetForwardArrow(class UArrowComponent* arrow);
	void SetIgnoreSphere(class USphereComponent* Sphere);
	void SetSpawnBox(class UBoxComponent* Box);
	void SetSpawnCylinder(class UCapsuleComponent* Cylinder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorDirect">();
	}
	static class UEnemySpawnGeneratorDirect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorDirect>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorDirect) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorDirect");
static_assert(sizeof(UEnemySpawnGeneratorDirect) == 0x0001A8, "Wrong size on UEnemySpawnGeneratorDirect");

// Class DarwinGame.EnemySpawnGeneratorAsset
// 0x0000 (0x01A8 - 0x01A8)
class UEnemySpawnGeneratorAsset final : public UEnemySpawnGeneratorDirect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorAsset">();
	}
	static class UEnemySpawnGeneratorAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorAsset>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorAsset) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorAsset");
static_assert(sizeof(UEnemySpawnGeneratorAsset) == 0x0001A8, "Wrong size on UEnemySpawnGeneratorAsset");

// Class DarwinGame.AnimNotifyState_GetArtifactCameraShake
// 0x0018 (0x0050 - 0x0038)
class UAnimNotifyState_GetArtifactCameraShake final : public UAnimNotifyState
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShake>               CameraShakeClass;                                  // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GetArtifactCameraShake">();
	}
	static class UAnimNotifyState_GetArtifactCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GetArtifactCameraShake>();
	}
};
static_assert(alignof(UAnimNotifyState_GetArtifactCameraShake) == 0x000008, "Wrong alignment on UAnimNotifyState_GetArtifactCameraShake");
static_assert(sizeof(UAnimNotifyState_GetArtifactCameraShake) == 0x000050, "Wrong size on UAnimNotifyState_GetArtifactCameraShake");
static_assert(offsetof(UAnimNotifyState_GetArtifactCameraShake, CameraShakeClass) == 0x000040, "Member 'UAnimNotifyState_GetArtifactCameraShake::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactCameraShake, ShakeScale) == 0x000048, "Member 'UAnimNotifyState_GetArtifactCameraShake::ShakeScale' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_GetArtifactZoom
// 0x0038 (0x0070 - 0x0038)
class UAnimNotifyState_GetArtifactZoom final : public UAnimNotifyState
{
public:
	float                                         PitchAngle;                                        // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle;                                          // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAngle;                                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoomLength;                                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchAngle_SevenStone;                             // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawAngle_SevenStone;                               // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAngle_SevenStone;                              // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoomLength_SevenStone;                             // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed_SevenStone;                            // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraOffset;                                      // 0x0064(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GetArtifactZoom">();
	}
	static class UAnimNotifyState_GetArtifactZoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GetArtifactZoom>();
	}
};
static_assert(alignof(UAnimNotifyState_GetArtifactZoom) == 0x000008, "Wrong alignment on UAnimNotifyState_GetArtifactZoom");
static_assert(sizeof(UAnimNotifyState_GetArtifactZoom) == 0x000070, "Wrong size on UAnimNotifyState_GetArtifactZoom");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, PitchAngle) == 0x000038, "Member 'UAnimNotifyState_GetArtifactZoom::PitchAngle' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, YawAngle) == 0x00003C, "Member 'UAnimNotifyState_GetArtifactZoom::YawAngle' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, RollAngle) == 0x000040, "Member 'UAnimNotifyState_GetArtifactZoom::RollAngle' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, BoomLength) == 0x000044, "Member 'UAnimNotifyState_GetArtifactZoom::BoomLength' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, InterpSpeed) == 0x000048, "Member 'UAnimNotifyState_GetArtifactZoom::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, PitchAngle_SevenStone) == 0x000050, "Member 'UAnimNotifyState_GetArtifactZoom::PitchAngle_SevenStone' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, YawAngle_SevenStone) == 0x000054, "Member 'UAnimNotifyState_GetArtifactZoom::YawAngle_SevenStone' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, RollAngle_SevenStone) == 0x000058, "Member 'UAnimNotifyState_GetArtifactZoom::RollAngle_SevenStone' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, BoomLength_SevenStone) == 0x00005C, "Member 'UAnimNotifyState_GetArtifactZoom::BoomLength_SevenStone' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, InterpSpeed_SevenStone) == 0x000060, "Member 'UAnimNotifyState_GetArtifactZoom::InterpSpeed_SevenStone' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GetArtifactZoom, CameraOffset) == 0x000064, "Member 'UAnimNotifyState_GetArtifactZoom::CameraOffset' has a wrong offset!");

// Class DarwinGame.EventStateBase
// 0x0000 (0x00D8 - 0x00D8)
class UEventStateBase : public UStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventStateBase">();
	}
	static class UEventStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventStateBase>();
	}
};
static_assert(alignof(UEventStateBase) == 0x000008, "Wrong alignment on UEventStateBase");
static_assert(sizeof(UEventStateBase) == 0x0000D8, "Wrong size on UEventStateBase");

// Class DarwinGame.AnimNotifyState_GuideSysLog
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_GuideSysLog final : public UAnimNotifyState
{
public:
	class FName                                   mMessageID;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mCollided;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mUnCollided;                                       // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GuideSysLog">();
	}
	static class UAnimNotifyState_GuideSysLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GuideSysLog>();
	}
};
static_assert(alignof(UAnimNotifyState_GuideSysLog) == 0x000008, "Wrong alignment on UAnimNotifyState_GuideSysLog");
static_assert(sizeof(UAnimNotifyState_GuideSysLog) == 0x000048, "Wrong size on UAnimNotifyState_GuideSysLog");
static_assert(offsetof(UAnimNotifyState_GuideSysLog, mMessageID) == 0x000038, "Member 'UAnimNotifyState_GuideSysLog::mMessageID' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GuideSysLog, mCollided) == 0x000040, "Member 'UAnimNotifyState_GuideSysLog::mCollided' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GuideSysLog, mUnCollided) == 0x000041, "Member 'UAnimNotifyState_GuideSysLog::mUnCollided' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_IgnoreCollision
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_IgnoreCollision final : public UAnimNotifyState
{
public:
	bool                                          mDisableCollision;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mHiddenTime;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mDisableHiddenTimer;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mKeepHidden;                                       // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIgnorePushBack;                                   // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_IgnoreCollision">();
	}
	static class UAnimNotifyState_IgnoreCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_IgnoreCollision>();
	}
};
static_assert(alignof(UAnimNotifyState_IgnoreCollision) == 0x000008, "Wrong alignment on UAnimNotifyState_IgnoreCollision");
static_assert(sizeof(UAnimNotifyState_IgnoreCollision) == 0x000048, "Wrong size on UAnimNotifyState_IgnoreCollision");
static_assert(offsetof(UAnimNotifyState_IgnoreCollision, mDisableCollision) == 0x000038, "Member 'UAnimNotifyState_IgnoreCollision::mDisableCollision' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IgnoreCollision, mHiddenTime) == 0x00003C, "Member 'UAnimNotifyState_IgnoreCollision::mHiddenTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IgnoreCollision, mDisableHiddenTimer) == 0x000040, "Member 'UAnimNotifyState_IgnoreCollision::mDisableHiddenTimer' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IgnoreCollision, mKeepHidden) == 0x000041, "Member 'UAnimNotifyState_IgnoreCollision::mKeepHidden' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IgnoreCollision, mIgnorePushBack) == 0x000042, "Member 'UAnimNotifyState_IgnoreCollision::mIgnorePushBack' has a wrong offset!");

// Class DarwinGame.ArtifactFigureDataAsset
// 0x0050 (0x0088 - 0x0038)
class UArtifactFigureDataAsset final : public UDataAsset
{
public:
	TMap<int32, struct FTreasureFigureData>       DataList;                                          // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactFigureDataAsset">();
	}
	static class UArtifactFigureDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactFigureDataAsset>();
	}
};
static_assert(alignof(UArtifactFigureDataAsset) == 0x000008, "Wrong alignment on UArtifactFigureDataAsset");
static_assert(sizeof(UArtifactFigureDataAsset) == 0x000088, "Wrong size on UArtifactFigureDataAsset");
static_assert(offsetof(UArtifactFigureDataAsset, DataList) == 0x000038, "Member 'UArtifactFigureDataAsset::DataList' has a wrong offset!");

// Class DarwinGame.UICommonmenu_ItemIconBase
// 0x0028 (0x04B8 - 0x0490)
class UUICommonmenu_ItemIconBase : public UDarwinUserWidget
{
public:
	class UTexture2D*                             Frame_Bronze;                                      // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Frame_Silver;                                      // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Frame_Gold;                                        // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Frame_Rainbow;                                     // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImgIconItem;                                       // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_ItemIconBase">();
	}
	static class UUICommonmenu_ItemIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_ItemIconBase>();
	}
};
static_assert(alignof(UUICommonmenu_ItemIconBase) == 0x000008, "Wrong alignment on UUICommonmenu_ItemIconBase");
static_assert(sizeof(UUICommonmenu_ItemIconBase) == 0x0004B8, "Wrong size on UUICommonmenu_ItemIconBase");
static_assert(offsetof(UUICommonmenu_ItemIconBase, Frame_Bronze) == 0x000490, "Member 'UUICommonmenu_ItemIconBase::Frame_Bronze' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemIconBase, Frame_Silver) == 0x000498, "Member 'UUICommonmenu_ItemIconBase::Frame_Silver' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemIconBase, Frame_Gold) == 0x0004A0, "Member 'UUICommonmenu_ItemIconBase::Frame_Gold' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemIconBase, Frame_Rainbow) == 0x0004A8, "Member 'UUICommonmenu_ItemIconBase::Frame_Rainbow' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemIconBase, ImgIconItem) == 0x0004B0, "Member 'UUICommonmenu_ItemIconBase::ImgIconItem' has a wrong offset!");

// Class DarwinGame.UICommonmenu_ItemIcon
// 0x0000 (0x04B8 - 0x04B8)
class UUICommonmenu_ItemIcon : public UUICommonmenu_ItemIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_ItemIcon">();
	}
	static class UUICommonmenu_ItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_ItemIcon>();
	}
};
static_assert(alignof(UUICommonmenu_ItemIcon) == 0x000008, "Wrong alignment on UUICommonmenu_ItemIcon");
static_assert(sizeof(UUICommonmenu_ItemIcon) == 0x0004B8, "Wrong size on UUICommonmenu_ItemIcon");

// Class DarwinGame.EnvironmentSettingsLibrary
// 0x0000 (0x0030 - 0x0030)
class UEnvironmentSettingsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentSettingsLibrary">();
	}
	static class UEnvironmentSettingsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentSettingsLibrary>();
	}
};
static_assert(alignof(UEnvironmentSettingsLibrary) == 0x000008, "Wrong alignment on UEnvironmentSettingsLibrary");
static_assert(sizeof(UEnvironmentSettingsLibrary) == 0x000030, "Wrong size on UEnvironmentSettingsLibrary");

// Class DarwinGame.AnimNotifyState_InfiltrationMove
// 0x0028 (0x0060 - 0x0038)
class UAnimNotifyState_InfiltrationMove final : public UAnimNotifyState
{
public:
	float                                         mMinSpeed;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mMaxSpeed;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mMoveSpeedScale;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x1C];                                      // 0x0044(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_InfiltrationMove">();
	}
	static class UAnimNotifyState_InfiltrationMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_InfiltrationMove>();
	}
};
static_assert(alignof(UAnimNotifyState_InfiltrationMove) == 0x000008, "Wrong alignment on UAnimNotifyState_InfiltrationMove");
static_assert(sizeof(UAnimNotifyState_InfiltrationMove) == 0x000060, "Wrong size on UAnimNotifyState_InfiltrationMove");
static_assert(offsetof(UAnimNotifyState_InfiltrationMove, mMinSpeed) == 0x000038, "Member 'UAnimNotifyState_InfiltrationMove::mMinSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_InfiltrationMove, mMaxSpeed) == 0x00003C, "Member 'UAnimNotifyState_InfiltrationMove::mMaxSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_InfiltrationMove, mMoveSpeedScale) == 0x000040, "Member 'UAnimNotifyState_InfiltrationMove::mMoveSpeedScale' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_InfiltrationStart
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_InfiltrationStart final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_InfiltrationStart">();
	}
	static class UAnimNotifyState_InfiltrationStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_InfiltrationStart>();
	}
};
static_assert(alignof(UAnimNotifyState_InfiltrationStart) == 0x000008, "Wrong alignment on UAnimNotifyState_InfiltrationStart");
static_assert(sizeof(UAnimNotifyState_InfiltrationStart) == 0x000038, "Wrong size on UAnimNotifyState_InfiltrationStart");

// Class DarwinGame.FieldObjectComponentBase
// 0x0000 (0x00B8 - 0x00B8)
class UFieldObjectComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectComponentBase">();
	}
	static class UFieldObjectComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldObjectComponentBase>();
	}
};
static_assert(alignof(UFieldObjectComponentBase) == 0x000008, "Wrong alignment on UFieldObjectComponentBase");
static_assert(sizeof(UFieldObjectComponentBase) == 0x0000B8, "Wrong size on UFieldObjectComponentBase");

// Class DarwinGame.ToggleVisibilityComponent
// 0x0020 (0x00D8 - 0x00B8)
class UToggleVisibilityComponent final : public UFieldObjectComponentBase
{
public:
	struct FST_FieldObjectHiddenInfo              HiddenInfo;                                        // 0x00B8(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToggleVisibilityComponent">();
	}
	static class UToggleVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToggleVisibilityComponent>();
	}
};
static_assert(alignof(UToggleVisibilityComponent) == 0x000008, "Wrong alignment on UToggleVisibilityComponent");
static_assert(sizeof(UToggleVisibilityComponent) == 0x0000D8, "Wrong size on UToggleVisibilityComponent");
static_assert(offsetof(UToggleVisibilityComponent, HiddenInfo) == 0x0000B8, "Member 'UToggleVisibilityComponent::HiddenInfo' has a wrong offset!");

// Class DarwinGame.FlexibleDoor
// 0x0008 (0x02D8 - 0x02D0)
class AFlexibleDoor final : public ADoorObjectBase
{
public:
	struct FDoorUtil                              mDoorUtil;                                         // 0x02D0(0x0003)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D3[0x5];                                      // 0x02D3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool FrontCheck(class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlexibleDoor">();
	}
	static class AFlexibleDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlexibleDoor>();
	}
};
static_assert(alignof(AFlexibleDoor) == 0x000008, "Wrong alignment on AFlexibleDoor");
static_assert(sizeof(AFlexibleDoor) == 0x0002D8, "Wrong size on AFlexibleDoor");
static_assert(offsetof(AFlexibleDoor, mDoorUtil) == 0x0002D0, "Member 'AFlexibleDoor::mDoorUtil' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MonsterCheckFloorChangeSection
// 0x0030 (0x0068 - 0x0038)
class UAnimNotifyState_MonsterCheckFloorChangeSection final : public UAnimNotifyState
{
public:
	ECheckFloorDirection                          mDirection;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                mHalfSize;                                         // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mStartDistance;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDistance;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mForwardOffset;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mHeightOffset;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSection;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mIsDebugDraw;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterCheckFloorChangeSection">();
	}
	static class UAnimNotifyState_MonsterCheckFloorChangeSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterCheckFloorChangeSection>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterCheckFloorChangeSection) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterCheckFloorChangeSection");
static_assert(sizeof(UAnimNotifyState_MonsterCheckFloorChangeSection) == 0x000068, "Wrong size on UAnimNotifyState_MonsterCheckFloorChangeSection");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mDirection) == 0x000038, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mDirection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mHalfSize) == 0x00003C, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mHalfSize' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mStartDistance) == 0x000048, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mStartDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mDistance) == 0x00004C, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mForwardOffset) == 0x000050, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mForwardOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mHeightOffset) == 0x000054, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mHeightOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mSection) == 0x000058, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterCheckFloorChangeSection, mIsDebugDraw) == 0x000060, "Member 'UAnimNotifyState_MonsterCheckFloorChangeSection::mIsDebugDraw' has a wrong offset!");

// Class DarwinGame.UIDispatch_Result
// 0x0050 (0x0648 - 0x05F8)
class UUIDispatch_Result final : public UUIRewardItemListBase
{
public:
	uint8                                         Pad_5F8[0x50];                                     // 0x05F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Result">();
	}
	static class UUIDispatch_Result* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Result>();
	}
};
static_assert(alignof(UUIDispatch_Result) == 0x000008, "Wrong alignment on UUIDispatch_Result");
static_assert(sizeof(UUIDispatch_Result) == 0x000648, "Wrong size on UUIDispatch_Result");

// Class DarwinGame.EnvironmentEffectBase
// 0x0010 (0x0238 - 0x0228)
class AEnvironmentEffectBase : public AActor
{
public:
	class FName                                   EffectId;                                          // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentEffectBase">();
	}
	static class AEnvironmentEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentEffectBase>();
	}
};
static_assert(alignof(AEnvironmentEffectBase) == 0x000008, "Wrong alignment on AEnvironmentEffectBase");
static_assert(sizeof(AEnvironmentEffectBase) == 0x000238, "Wrong size on AEnvironmentEffectBase");
static_assert(offsetof(AEnvironmentEffectBase, EffectId) == 0x000228, "Member 'AEnvironmentEffectBase::EffectId' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MonsterRotateInsightTarget
// 0x0028 (0x0060 - 0x0038)
class UAnimNotifyState_MonsterRotateInsightTarget final : public UAnimNotifyState
{
public:
	float                                         mReversalTime;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDurationTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mInsightAngle;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mChase;                                            // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mFailSection;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterRotateInsightTarget">();
	}
	static class UAnimNotifyState_MonsterRotateInsightTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterRotateInsightTarget>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterRotateInsightTarget) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterRotateInsightTarget");
static_assert(sizeof(UAnimNotifyState_MonsterRotateInsightTarget) == 0x000060, "Wrong size on UAnimNotifyState_MonsterRotateInsightTarget");
static_assert(offsetof(UAnimNotifyState_MonsterRotateInsightTarget, mReversalTime) == 0x000038, "Member 'UAnimNotifyState_MonsterRotateInsightTarget::mReversalTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterRotateInsightTarget, mDurationTime) == 0x00003C, "Member 'UAnimNotifyState_MonsterRotateInsightTarget::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterRotateInsightTarget, mInsightAngle) == 0x000040, "Member 'UAnimNotifyState_MonsterRotateInsightTarget::mInsightAngle' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterRotateInsightTarget, mChase) == 0x000044, "Member 'UAnimNotifyState_MonsterRotateInsightTarget::mChase' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterRotateInsightTarget, mFailSection) == 0x000048, "Member 'UAnimNotifyState_MonsterRotateInsightTarget::mFailSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterRotateInsightTarget, mSuccessSection) == 0x000050, "Member 'UAnimNotifyState_MonsterRotateInsightTarget::mSuccessSection' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MonsterStackTime
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_MonsterStackTime final : public UAnimNotifyState
{
public:
	float                                         mStackTimer;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterStackTime">();
	}
	static class UAnimNotifyState_MonsterStackTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterStackTime>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterStackTime) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterStackTime");
static_assert(sizeof(UAnimNotifyState_MonsterStackTime) == 0x000040, "Wrong size on UAnimNotifyState_MonsterStackTime");
static_assert(offsetof(UAnimNotifyState_MonsterStackTime, mStackTimer) == 0x000038, "Member 'UAnimNotifyState_MonsterStackTime::mStackTimer' has a wrong offset!");

// Class DarwinGame.EffectControlComponent
// 0x0020 (0x00D8 - 0x00B8)
class UEffectControlComponent final : public UFieldObjectComponentBase
{
public:
	TArray<class FName>                           mTargetTagList;                                    // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectControlComponent">();
	}
	static class UEffectControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectControlComponent>();
	}
};
static_assert(alignof(UEffectControlComponent) == 0x000008, "Wrong alignment on UEffectControlComponent");
static_assert(sizeof(UEffectControlComponent) == 0x0000D8, "Wrong size on UEffectControlComponent");
static_assert(offsetof(UEffectControlComponent, mTargetTagList) == 0x0000B8, "Member 'UEffectControlComponent::mTargetTagList' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MonsterStartCamera
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_MonsterStartCamera final : public UAnimNotifyState
{
public:
	EMonsterCameraType                            mCameraType;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mEndCamera;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterStartCamera">();
	}
	static class UAnimNotifyState_MonsterStartCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterStartCamera>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterStartCamera) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterStartCamera");
static_assert(sizeof(UAnimNotifyState_MonsterStartCamera) == 0x000040, "Wrong size on UAnimNotifyState_MonsterStartCamera");
static_assert(offsetof(UAnimNotifyState_MonsterStartCamera, mCameraType) == 0x000038, "Member 'UAnimNotifyState_MonsterStartCamera::mCameraType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterStartCamera, mEndCamera) == 0x000039, "Member 'UAnimNotifyState_MonsterStartCamera::mEndCamera' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MonsterTimeCheckAttack
// 0x0038 (0x0070 - 0x0038)
class UAnimNotifyState_MonsterTimeCheckAttack final : public UAnimNotifyState
{
public:
	float                                         mDurationTime;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_MonsterCollisionSectionName> mCollisionSet;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mWeightRatio;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mFailSection;                                      // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection;                                   // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mTimeOutSection;                                   // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterTimeCheckAttack">();
	}
	static class UAnimNotifyState_MonsterTimeCheckAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterTimeCheckAttack>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterTimeCheckAttack) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterTimeCheckAttack");
static_assert(sizeof(UAnimNotifyState_MonsterTimeCheckAttack) == 0x000070, "Wrong size on UAnimNotifyState_MonsterTimeCheckAttack");
static_assert(offsetof(UAnimNotifyState_MonsterTimeCheckAttack, mDurationTime) == 0x000038, "Member 'UAnimNotifyState_MonsterTimeCheckAttack::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterTimeCheckAttack, mCollisionSet) == 0x000040, "Member 'UAnimNotifyState_MonsterTimeCheckAttack::mCollisionSet' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterTimeCheckAttack, mWeightRatio) == 0x000050, "Member 'UAnimNotifyState_MonsterTimeCheckAttack::mWeightRatio' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterTimeCheckAttack, mFailSection) == 0x000054, "Member 'UAnimNotifyState_MonsterTimeCheckAttack::mFailSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterTimeCheckAttack, mSuccessSection) == 0x00005C, "Member 'UAnimNotifyState_MonsterTimeCheckAttack::mSuccessSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterTimeCheckAttack, mTimeOutSection) == 0x000064, "Member 'UAnimNotifyState_MonsterTimeCheckAttack::mTimeOutSection' has a wrong offset!");

// Class DarwinGame.DarwinAnimInstanceBase
// 0x0000 (0x0270 - 0x0270)
#pragma pack(push, 0x1)
class alignas(0x10) UDarwinAnimInstanceBase : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinAnimInstanceBase">();
	}
	static class UDarwinAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinAnimInstanceBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDarwinAnimInstanceBase) == 0x000010, "Wrong alignment on UDarwinAnimInstanceBase");
static_assert(sizeof(UDarwinAnimInstanceBase) == 0x000270, "Wrong size on UDarwinAnimInstanceBase");

// Class DarwinGame.ModeAnimInstance
// 0x0000 (0x0270 - 0x0270)
class UModeAnimInstance : public UDarwinAnimInstanceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModeAnimInstance">();
	}
	static class UModeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModeAnimInstance>();
	}
};
static_assert(alignof(UModeAnimInstance) == 0x000010, "Wrong alignment on UModeAnimInstance");
static_assert(sizeof(UModeAnimInstance) == 0x000270, "Wrong size on UModeAnimInstance");

// Class DarwinGame.SimpleOpenAnimInstance
// 0x0000 (0x0270 - 0x0270)
class USimpleOpenAnimInstance : public UModeAnimInstance
{
public:
	void PlayClose();
	void PlayOpen();
	void SetClose();
	void SetOpen();

	bool IsCloseAndPlayAnimation() const;
	bool IsCloseAndSkipAnimation() const;
	bool IsOpenAndPlayAnimation() const;
	bool IsOpenAndSkipAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleOpenAnimInstance">();
	}
	static class USimpleOpenAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleOpenAnimInstance>();
	}
};
static_assert(alignof(USimpleOpenAnimInstance) == 0x000010, "Wrong alignment on USimpleOpenAnimInstance");
static_assert(sizeof(USimpleOpenAnimInstance) == 0x000270, "Wrong size on USimpleOpenAnimInstance");

// Class DarwinGame.UIComplete
// 0x0100 (0x0590 - 0x0490)
class alignas(0x10) UUIComplete final : public UDarwinUserWidget
{
public:
	TArray<struct FST_CompFontInfo>               CompFontInfoList;                                  // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_ArtifactCompInfo>           ArtifactCompInfoList;                              // 0x04A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 CompImg;                                           // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 CompAddImg;                                        // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 CompAddImg2;                                       // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       CompAnim;                                          // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AllCompAnim;                                       // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       CompOutAnim;                                       // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       BkWaitAnim;                                        // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       BkWaitAnim02;                                      // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      HubEff02;                                          // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      HubEff03;                                          // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x90];                                     // 0x0500(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCompAnimCallback();
	void EndCompOutAnimCallback();
	void PlayCompMe();
	void StartCompAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIComplete">();
	}
	static class UUIComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIComplete>();
	}
};
static_assert(alignof(UUIComplete) == 0x000010, "Wrong alignment on UUIComplete");
static_assert(sizeof(UUIComplete) == 0x000590, "Wrong size on UUIComplete");
static_assert(offsetof(UUIComplete, CompFontInfoList) == 0x000490, "Member 'UUIComplete::CompFontInfoList' has a wrong offset!");
static_assert(offsetof(UUIComplete, ArtifactCompInfoList) == 0x0004A0, "Member 'UUIComplete::ArtifactCompInfoList' has a wrong offset!");
static_assert(offsetof(UUIComplete, CompImg) == 0x0004B0, "Member 'UUIComplete::CompImg' has a wrong offset!");
static_assert(offsetof(UUIComplete, CompAddImg) == 0x0004B8, "Member 'UUIComplete::CompAddImg' has a wrong offset!");
static_assert(offsetof(UUIComplete, CompAddImg2) == 0x0004C0, "Member 'UUIComplete::CompAddImg2' has a wrong offset!");
static_assert(offsetof(UUIComplete, CompAnim) == 0x0004C8, "Member 'UUIComplete::CompAnim' has a wrong offset!");
static_assert(offsetof(UUIComplete, AllCompAnim) == 0x0004D0, "Member 'UUIComplete::AllCompAnim' has a wrong offset!");
static_assert(offsetof(UUIComplete, CompOutAnim) == 0x0004D8, "Member 'UUIComplete::CompOutAnim' has a wrong offset!");
static_assert(offsetof(UUIComplete, BkWaitAnim) == 0x0004E0, "Member 'UUIComplete::BkWaitAnim' has a wrong offset!");
static_assert(offsetof(UUIComplete, BkWaitAnim02) == 0x0004E8, "Member 'UUIComplete::BkWaitAnim02' has a wrong offset!");
static_assert(offsetof(UUIComplete, HubEff02) == 0x0004F0, "Member 'UUIComplete::HubEff02' has a wrong offset!");
static_assert(offsetof(UUIComplete, HubEff03) == 0x0004F8, "Member 'UUIComplete::HubEff03' has a wrong offset!");

// Class DarwinGame.EstimateBackPanel
// 0x0000 (0x0238 - 0x0238)
class AEstimateBackPanel final : public AStaticMeshActor
{
public:
	void SetPanelMaterial(class UTexture2D* Texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateBackPanel">();
	}
	static class AEstimateBackPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimateBackPanel>();
	}
};
static_assert(alignof(AEstimateBackPanel) == 0x000008, "Wrong alignment on AEstimateBackPanel");
static_assert(sizeof(AEstimateBackPanel) == 0x000238, "Wrong size on AEstimateBackPanel");

// Class DarwinGame.AnimNotifyState_MonsterTimeWait
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_MonsterTimeWait final : public UAnimNotifyState
{
public:
	float                                         mDurationTime;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSection;                                          // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MonsterTimeWait">();
	}
	static class UAnimNotifyState_MonsterTimeWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MonsterTimeWait>();
	}
};
static_assert(alignof(UAnimNotifyState_MonsterTimeWait) == 0x000008, "Wrong alignment on UAnimNotifyState_MonsterTimeWait");
static_assert(sizeof(UAnimNotifyState_MonsterTimeWait) == 0x000048, "Wrong size on UAnimNotifyState_MonsterTimeWait");
static_assert(offsetof(UAnimNotifyState_MonsterTimeWait, mDurationTime) == 0x000038, "Member 'UAnimNotifyState_MonsterTimeWait::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_MonsterTimeWait, mSection) == 0x00003C, "Member 'UAnimNotifyState_MonsterTimeWait::mSection' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_MoveUpDown
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_MoveUpDown final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MoveUpDown">();
	}
	static class UAnimNotifyState_MoveUpDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MoveUpDown>();
	}
};
static_assert(alignof(UAnimNotifyState_MoveUpDown) == 0x000008, "Wrong alignment on UAnimNotifyState_MoveUpDown");
static_assert(sizeof(UAnimNotifyState_MoveUpDown) == 0x000038, "Wrong size on UAnimNotifyState_MoveUpDown");

// Class DarwinGame.ShopSortFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UShopSortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopSortFunctionLibrary">();
	}
	static class UShopSortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopSortFunctionLibrary>();
	}
};
static_assert(alignof(UShopSortFunctionLibrary) == 0x000008, "Wrong alignment on UShopSortFunctionLibrary");
static_assert(sizeof(UShopSortFunctionLibrary) == 0x000030, "Wrong size on UShopSortFunctionLibrary");

// Class DarwinGame.FootEffectSystemComponent
// 0x01F0 (0x02A8 - 0x00B8)
class UFootEffectSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA4];                                      // 0x00B8(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFootEffectFloor                       FootFloor;                                         // 0x015C(0x008C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AEffectBase*                            SwimEffect;                                        // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorTraceHeight;                                  // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorTraceStartOffset;                             // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootPrintDecalSize;                                // 0x01F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFootprintDataAsset*                    FootprintData;                                     // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootPrintFadeTriggerDistance;                      // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFootEffectRequest                     AutoIdleRequest;                                   // 0x0218(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<ESocket>                               AutoIdleRequestTargetSockets;                      // 0x0238(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedThresholdForAutoIdle;                         // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMiddleWaterFootEffect                 MiddleWaterParam;                                  // 0x024C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<ESocket, class UDecalComponent*>         LastFootPrints;                                    // 0x0258(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void PlayFootEffect(const struct FFootEffectRequest& Request);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootEffectSystemComponent">();
	}
	static class UFootEffectSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootEffectSystemComponent>();
	}
};
static_assert(alignof(UFootEffectSystemComponent) == 0x000008, "Wrong alignment on UFootEffectSystemComponent");
static_assert(sizeof(UFootEffectSystemComponent) == 0x0002A8, "Wrong size on UFootEffectSystemComponent");
static_assert(offsetof(UFootEffectSystemComponent, FootFloor) == 0x00015C, "Member 'UFootEffectSystemComponent::FootFloor' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, SwimEffect) == 0x0001E8, "Member 'UFootEffectSystemComponent::SwimEffect' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, FloorTraceHeight) == 0x0001F0, "Member 'UFootEffectSystemComponent::FloorTraceHeight' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, FloorTraceStartOffset) == 0x0001F4, "Member 'UFootEffectSystemComponent::FloorTraceStartOffset' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, FootPrintDecalSize) == 0x0001F8, "Member 'UFootEffectSystemComponent::FootPrintDecalSize' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, FootprintData) == 0x000208, "Member 'UFootEffectSystemComponent::FootprintData' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, FootPrintFadeTriggerDistance) == 0x000210, "Member 'UFootEffectSystemComponent::FootPrintFadeTriggerDistance' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, AutoIdleRequest) == 0x000218, "Member 'UFootEffectSystemComponent::AutoIdleRequest' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, AutoIdleRequestTargetSockets) == 0x000238, "Member 'UFootEffectSystemComponent::AutoIdleRequestTargetSockets' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, SpeedThresholdForAutoIdle) == 0x000248, "Member 'UFootEffectSystemComponent::SpeedThresholdForAutoIdle' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, MiddleWaterParam) == 0x00024C, "Member 'UFootEffectSystemComponent::MiddleWaterParam' has a wrong offset!");
static_assert(offsetof(UFootEffectSystemComponent, LastFootPrints) == 0x000258, "Member 'UFootEffectSystemComponent::LastFootPrints' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_PlayTrail
// 0x0030 (0x0068 - 0x0038)
class UAnimNotifyState_PlayTrail final : public UAnimNotifyState
{
public:
	class FName                                   EffectId;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstSocket;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocket;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               ScaleMode;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x17];                                      // 0x0051(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_PlayTrail">();
	}
	static class UAnimNotifyState_PlayTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_PlayTrail>();
	}
};
static_assert(alignof(UAnimNotifyState_PlayTrail) == 0x000008, "Wrong alignment on UAnimNotifyState_PlayTrail");
static_assert(sizeof(UAnimNotifyState_PlayTrail) == 0x000068, "Wrong size on UAnimNotifyState_PlayTrail");
static_assert(offsetof(UAnimNotifyState_PlayTrail, EffectId) == 0x000038, "Member 'UAnimNotifyState_PlayTrail::EffectId' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlayTrail, FirstSocket) == 0x000040, "Member 'UAnimNotifyState_PlayTrail::FirstSocket' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlayTrail, SecondSocket) == 0x000048, "Member 'UAnimNotifyState_PlayTrail::SecondSocket' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlayTrail, ScaleMode) == 0x000050, "Member 'UAnimNotifyState_PlayTrail::ScaleMode' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_RotateToTargetWithLocationOffset
// 0x0068 (0x00A0 - 0x0038)
class UAnimNotifyState_RotateToTargetWithLocationOffset final : public UAnimNotifyState
{
public:
	ELocationOffsetDir                            mDir;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mDistance;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDistanceFuzzy;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRate;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mHiddenTime;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mRadius;                                           // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mNaviCheckRange;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mGoalSection;                                      // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mTimeUpSection;                                    // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mFailSection;                                      // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x34];                                      // 0x006C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RotateToTargetWithLocationOffset">();
	}
	static class UAnimNotifyState_RotateToTargetWithLocationOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RotateToTargetWithLocationOffset>();
	}
};
static_assert(alignof(UAnimNotifyState_RotateToTargetWithLocationOffset) == 0x000008, "Wrong alignment on UAnimNotifyState_RotateToTargetWithLocationOffset");
static_assert(sizeof(UAnimNotifyState_RotateToTargetWithLocationOffset) == 0x0000A0, "Wrong size on UAnimNotifyState_RotateToTargetWithLocationOffset");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mDir) == 0x000038, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mDir' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mDistance) == 0x00003C, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mDistance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mDistanceFuzzy) == 0x000040, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mDistanceFuzzy' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, RotateRate) == 0x000044, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::RotateRate' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mHiddenTime) == 0x000048, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mHiddenTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mRadius) == 0x00004C, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mRadius' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mNaviCheckRange) == 0x000050, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mNaviCheckRange' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mGoalSection) == 0x000054, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mGoalSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mTimeUpSection) == 0x00005C, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mTimeUpSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RotateToTargetWithLocationOffset, mFailSection) == 0x000064, "Member 'UAnimNotifyState_RotateToTargetWithLocationOffset::mFailSection' has a wrong offset!");

// Class DarwinGame.EmoteRuntimeOption
// 0x0018 (0x0048 - 0x0030)
class UEmoteRuntimeOption final : public UObject
{
public:
	bool                                          bStopAI;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StampPositionOffeset;                              // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmotePlayTime;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteRuntimeOption">();
	}
	static class UEmoteRuntimeOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteRuntimeOption>();
	}
};
static_assert(alignof(UEmoteRuntimeOption) == 0x000008, "Wrong alignment on UEmoteRuntimeOption");
static_assert(sizeof(UEmoteRuntimeOption) == 0x000048, "Wrong size on UEmoteRuntimeOption");
static_assert(offsetof(UEmoteRuntimeOption, bStopAI) == 0x000030, "Member 'UEmoteRuntimeOption::bStopAI' has a wrong offset!");
static_assert(offsetof(UEmoteRuntimeOption, StampPositionOffeset) == 0x000034, "Member 'UEmoteRuntimeOption::StampPositionOffeset' has a wrong offset!");
static_assert(offsetof(UEmoteRuntimeOption, EmotePlayTime) == 0x000040, "Member 'UEmoteRuntimeOption::EmotePlayTime' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_ShowSkillNameUI
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyState_ShowSkillNameUI final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_ShowSkillNameUI">();
	}
	static class UAnimNotifyState_ShowSkillNameUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_ShowSkillNameUI>();
	}
};
static_assert(alignof(UAnimNotifyState_ShowSkillNameUI) == 0x000008, "Wrong alignment on UAnimNotifyState_ShowSkillNameUI");
static_assert(sizeof(UAnimNotifyState_ShowSkillNameUI) == 0x000038, "Wrong size on UAnimNotifyState_ShowSkillNameUI");

// Class DarwinGame.AnimNotifyState_SuckInTarget
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_SuckInTarget final : public UAnimNotifyState
{
public:
	float                                         mDrawRadius;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDrawPower;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mSuckInHeight;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mOnlyOnGround;                                     // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SuckInTarget">();
	}
	static class UAnimNotifyState_SuckInTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SuckInTarget>();
	}
};
static_assert(alignof(UAnimNotifyState_SuckInTarget) == 0x000008, "Wrong alignment on UAnimNotifyState_SuckInTarget");
static_assert(sizeof(UAnimNotifyState_SuckInTarget) == 0x000048, "Wrong size on UAnimNotifyState_SuckInTarget");
static_assert(offsetof(UAnimNotifyState_SuckInTarget, mDrawRadius) == 0x000038, "Member 'UAnimNotifyState_SuckInTarget::mDrawRadius' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SuckInTarget, mDrawPower) == 0x00003C, "Member 'UAnimNotifyState_SuckInTarget::mDrawPower' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SuckInTarget, mSuckInHeight) == 0x000040, "Member 'UAnimNotifyState_SuckInTarget::mSuckInHeight' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SuckInTarget, mOnlyOnGround) == 0x000044, "Member 'UAnimNotifyState_SuckInTarget::mOnlyOnGround' has a wrong offset!");

// Class DarwinGame.SoftMonsterDataTable
// 0x0000 (0x0030 - 0x0030)
class USoftMonsterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftMonsterDataTable">();
	}
	static class USoftMonsterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftMonsterDataTable>();
	}
};
static_assert(alignof(USoftMonsterDataTable) == 0x000008, "Wrong alignment on USoftMonsterDataTable");
static_assert(sizeof(USoftMonsterDataTable) == 0x000030, "Wrong size on USoftMonsterDataTable");

// Class DarwinGame.UILeftMenuUseBase
// 0x0040 (0x04D0 - 0x0490)
class UUILeftMenuUseBase : public UDarwinUserWidget
{
public:
	class UUILeftMenuBase*                        LeftMenu;                                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x20];                                     // 0x0498(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDarwinUserWidget*>              UnionChildOpenList;                                // 0x04B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenuUseBase">();
	}
	static class UUILeftMenuUseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenuUseBase>();
	}
};
static_assert(alignof(UUILeftMenuUseBase) == 0x000008, "Wrong alignment on UUILeftMenuUseBase");
static_assert(sizeof(UUILeftMenuUseBase) == 0x0004D0, "Wrong size on UUILeftMenuUseBase");
static_assert(offsetof(UUILeftMenuUseBase, LeftMenu) == 0x000490, "Member 'UUILeftMenuUseBase::LeftMenu' has a wrong offset!");
static_assert(offsetof(UUILeftMenuUseBase, UnionChildOpenList) == 0x0004B8, "Member 'UUILeftMenuUseBase::UnionChildOpenList' has a wrong offset!");

// Class DarwinGame.FieldEventComponentBase
// 0x0010 (0x00C8 - 0x00B8)
class UFieldEventComponentBase : public UFieldObjectComponentBase
{
public:
	class FString                                 EventID;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldEventComponentBase">();
	}
	static class UFieldEventComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldEventComponentBase>();
	}
};
static_assert(alignof(UFieldEventComponentBase) == 0x000008, "Wrong alignment on UFieldEventComponentBase");
static_assert(sizeof(UFieldEventComponentBase) == 0x0000C8, "Wrong size on UFieldEventComponentBase");
static_assert(offsetof(UFieldEventComponentBase, EventID) == 0x0000B8, "Member 'UFieldEventComponentBase::EventID' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_SuperArmor
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_SuperArmor final : public UAnimNotifyState
{
public:
	TArray<struct FGameplayTag>                   HideCollisionName;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SuperArmor">();
	}
	static class UAnimNotifyState_SuperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SuperArmor>();
	}
};
static_assert(alignof(UAnimNotifyState_SuperArmor) == 0x000008, "Wrong alignment on UAnimNotifyState_SuperArmor");
static_assert(sizeof(UAnimNotifyState_SuperArmor) == 0x000048, "Wrong size on UAnimNotifyState_SuperArmor");
static_assert(offsetof(UAnimNotifyState_SuperArmor, HideCollisionName) == 0x000038, "Member 'UAnimNotifyState_SuperArmor::HideCollisionName' has a wrong offset!");

// Class DarwinGame.ForcedBattleEndCondition
// 0x0018 (0x0240 - 0x0228)
class AForcedBattleEndCondition : public AActor
{
public:
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForcedBattleEndCondition">();
	}
	static class AForcedBattleEndCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AForcedBattleEndCondition>();
	}
};
static_assert(alignof(AForcedBattleEndCondition) == 0x000008, "Wrong alignment on AForcedBattleEndCondition");
static_assert(sizeof(AForcedBattleEndCondition) == 0x000240, "Wrong size on AForcedBattleEndCondition");

// Class DarwinGame.EndConditionOfTimer
// 0x0008 (0x0248 - 0x0240)
class AEndConditionOfTimer final : public AForcedBattleEndCondition
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndConditionOfTimer">();
	}
	static class AEndConditionOfTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndConditionOfTimer>();
	}
};
static_assert(alignof(AEndConditionOfTimer) == 0x000008, "Wrong alignment on AEndConditionOfTimer");
static_assert(sizeof(AEndConditionOfTimer) == 0x000248, "Wrong size on AEndConditionOfTimer");

// Class DarwinGame.AnimNotifyState_SwitchDamageCollisonTransform
// 0x0110 (0x0148 - 0x0038)
class UAnimNotifyState_SwitchDamageCollisonTransform final : public UAnimNotifyState
{
public:
	TArray<struct FST_SwitchDamageCollisionTransform> Parameters;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x100];                                     // 0x0048(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SwitchDamageCollisonTransform">();
	}
	static class UAnimNotifyState_SwitchDamageCollisonTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SwitchDamageCollisonTransform>();
	}
};
static_assert(alignof(UAnimNotifyState_SwitchDamageCollisonTransform) == 0x000008, "Wrong alignment on UAnimNotifyState_SwitchDamageCollisonTransform");
static_assert(sizeof(UAnimNotifyState_SwitchDamageCollisonTransform) == 0x000148, "Wrong size on UAnimNotifyState_SwitchDamageCollisonTransform");
static_assert(offsetof(UAnimNotifyState_SwitchDamageCollisonTransform, Parameters) == 0x000038, "Member 'UAnimNotifyState_SwitchDamageCollisonTransform::Parameters' has a wrong offset!");

// Class DarwinGame.UIContentMenu_Page02
// 0x0010 (0x0500 - 0x04F0)
class UUIContentMenu_Page02 : public UUIFreeScrollBase
{
public:
	uint8                                         Pad_4F0[0x10];                                     // 0x04F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Page02">();
	}
	static class UUIContentMenu_Page02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Page02>();
	}
};
static_assert(alignof(UUIContentMenu_Page02) == 0x000008, "Wrong alignment on UUIContentMenu_Page02");
static_assert(sizeof(UUIContentMenu_Page02) == 0x000500, "Wrong size on UUIContentMenu_Page02");

// Class DarwinGame.EstimateSceneCapture
// 0x0080 (0x03F0 - 0x0370)
class AEstimateSceneCapture final : public ASceneCaptureBase
{
public:
	TMap<ELuminousEffectType, TSubclassOf<class AEffectBase>> LuminousEffectResList;                             // 0x0370(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                PopEffectRes;                                      // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            LuminousEffect;                                    // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            PopEffect;                                         // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x18];                                     // 0x03D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateSceneCapture">();
	}
	static class AEstimateSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimateSceneCapture>();
	}
};
static_assert(alignof(AEstimateSceneCapture) == 0x000010, "Wrong alignment on AEstimateSceneCapture");
static_assert(sizeof(AEstimateSceneCapture) == 0x0003F0, "Wrong size on AEstimateSceneCapture");
static_assert(offsetof(AEstimateSceneCapture, LuminousEffectResList) == 0x000370, "Member 'AEstimateSceneCapture::LuminousEffectResList' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCapture, PopEffectRes) == 0x0003C0, "Member 'AEstimateSceneCapture::PopEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCapture, LuminousEffect) == 0x0003C8, "Member 'AEstimateSceneCapture::LuminousEffect' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCapture, PopEffect) == 0x0003D0, "Member 'AEstimateSceneCapture::PopEffect' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_TargetInRangeFin
// 0x0010 (0x0048 - 0x0038)
class UAnimNotifyState_TargetInRangeFin final : public UAnimNotifyState
{
public:
	float                                         mRange;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDurationTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mWatePassageTime;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TargetInRangeFin">();
	}
	static class UAnimNotifyState_TargetInRangeFin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TargetInRangeFin>();
	}
};
static_assert(alignof(UAnimNotifyState_TargetInRangeFin) == 0x000008, "Wrong alignment on UAnimNotifyState_TargetInRangeFin");
static_assert(sizeof(UAnimNotifyState_TargetInRangeFin) == 0x000048, "Wrong size on UAnimNotifyState_TargetInRangeFin");
static_assert(offsetof(UAnimNotifyState_TargetInRangeFin, mRange) == 0x000038, "Member 'UAnimNotifyState_TargetInRangeFin::mRange' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TargetInRangeFin, mDurationTime) == 0x00003C, "Member 'UAnimNotifyState_TargetInRangeFin::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TargetInRangeFin, mWatePassageTime) == 0x000040, "Member 'UAnimNotifyState_TargetInRangeFin::mWatePassageTime' has a wrong offset!");

// Class DarwinGame.DebugTimer
// 0x0050 (0x0080 - 0x0030)
class UDebugTimer final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTimer">();
	}
	static class UDebugTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTimer>();
	}
};
static_assert(alignof(UDebugTimer) == 0x000008, "Wrong alignment on UDebugTimer");
static_assert(sizeof(UDebugTimer) == 0x000080, "Wrong size on UDebugTimer");

// Class DarwinGame.AnimNotifyState_TimeCheckMultipleAttack
// 0x0040 (0x0078 - 0x0038)
class UAnimNotifyState_TimeCheckMultipleAttack final : public UAnimNotifyState
{
public:
	float                                         mDurationTime;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mFailSection;                                      // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mSuccessSection;                                   // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mTimeOutLeftSection;                               // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mTimeOutRightSection;                              // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mContLeftSection;                                  // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mContRightSection;                                 // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         mContCnt;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TimeCheckMultipleAttack">();
	}
	static class UAnimNotifyState_TimeCheckMultipleAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TimeCheckMultipleAttack>();
	}
};
static_assert(alignof(UAnimNotifyState_TimeCheckMultipleAttack) == 0x000008, "Wrong alignment on UAnimNotifyState_TimeCheckMultipleAttack");
static_assert(sizeof(UAnimNotifyState_TimeCheckMultipleAttack) == 0x000078, "Wrong size on UAnimNotifyState_TimeCheckMultipleAttack");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mDurationTime) == 0x000038, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mDurationTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mFailSection) == 0x00003C, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mFailSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mSuccessSection) == 0x000044, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mSuccessSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mTimeOutLeftSection) == 0x00004C, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mTimeOutLeftSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mTimeOutRightSection) == 0x000054, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mTimeOutRightSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mContLeftSection) == 0x00005C, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mContLeftSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mContRightSection) == 0x000064, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mContRightSection' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_TimeCheckMultipleAttack, mContCnt) == 0x00006C, "Member 'UAnimNotifyState_TimeCheckMultipleAttack::mContCnt' has a wrong offset!");

// Class DarwinGame.DungeonPointBase
// 0x0000 (0x02B0 - 0x02B0)
class ADungeonPointBase : public AFieldObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonPointBase">();
	}
	static class ADungeonPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonPointBase>();
	}
};
static_assert(alignof(ADungeonPointBase) == 0x000008, "Wrong alignment on ADungeonPointBase");
static_assert(sizeof(ADungeonPointBase) == 0x0002B0, "Wrong size on ADungeonPointBase");

// Class DarwinGame.DungeonPointMaze
// 0x00B8 (0x0368 - 0x02B0)
class ADungeonPointMaze final : public ADungeonPointBase
{
public:
	int32                                         Hierarchy;                                         // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChoiceTextID;                                      // 0x02B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ClearChoiceTextID;                                 // 0x02BC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                SealEventData;                                     // 0x02C8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class FName>                      HierarchyTipsID;                                   // 0x0318(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	struct FVector GetEffectLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonPointMaze">();
	}
	static class ADungeonPointMaze* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonPointMaze>();
	}
};
static_assert(alignof(ADungeonPointMaze) == 0x000008, "Wrong alignment on ADungeonPointMaze");
static_assert(sizeof(ADungeonPointMaze) == 0x000368, "Wrong size on ADungeonPointMaze");
static_assert(offsetof(ADungeonPointMaze, Hierarchy) == 0x0002B0, "Member 'ADungeonPointMaze::Hierarchy' has a wrong offset!");
static_assert(offsetof(ADungeonPointMaze, ChoiceTextID) == 0x0002B4, "Member 'ADungeonPointMaze::ChoiceTextID' has a wrong offset!");
static_assert(offsetof(ADungeonPointMaze, ClearChoiceTextID) == 0x0002BC, "Member 'ADungeonPointMaze::ClearChoiceTextID' has a wrong offset!");
static_assert(offsetof(ADungeonPointMaze, SealEventData) == 0x0002C8, "Member 'ADungeonPointMaze::SealEventData' has a wrong offset!");
static_assert(offsetof(ADungeonPointMaze, HierarchyTipsID) == 0x000318, "Member 'ADungeonPointMaze::HierarchyTipsID' has a wrong offset!");

// Class DarwinGame.AnimNotifyState_TimedSkillEffect
// 0x0008 (0x0070 - 0x0068)
class UAnimNotifyState_TimedSkillEffect final : public UAnimNotifyState_TimedParticleEffect
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_TimedSkillEffect">();
	}
	static class UAnimNotifyState_TimedSkillEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_TimedSkillEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_TimedSkillEffect) == 0x000008, "Wrong alignment on UAnimNotifyState_TimedSkillEffect");
static_assert(sizeof(UAnimNotifyState_TimedSkillEffect) == 0x000070, "Wrong size on UAnimNotifyState_TimedSkillEffect");

// Class DarwinGame.MonsterBattleAIBase
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIBase : public UObject
{
public:
	static EMonsterBattleAIPart GetCurrentAIPart(class AMonsterBase* Monster);

	void ActionCycleMoveSelect(class AMonsterBase* Monster);
	void CheckDistancingToBehavior(class AMonsterBase* Monster);
	void MoveSelect(class AMonsterBase* Monster);
	void PreAction(class AMonsterBase* Monster);
	void SetupActionCycle(class AMonsterBase* Monster);
	void SetupActionLocation(class AMonsterBase* Monster);
	void StartActionCycle(class AMonsterBase* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIBase">();
	}
	static class UMonsterBattleAIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIBase>();
	}
};
static_assert(alignof(UMonsterBattleAIBase) == 0x000008, "Wrong alignment on UMonsterBattleAIBase");
static_assert(sizeof(UMonsterBattleAIBase) == 0x000030, "Wrong size on UMonsterBattleAIBase");

// Class DarwinGame.AnimNotifyState_Turn
// 0x0018 (0x0050 - 0x0038)
class UAnimNotifyState_Turn final : public UAnimNotifyState
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_Turn">();
	}
	static class UAnimNotifyState_Turn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_Turn>();
	}
};
static_assert(alignof(UAnimNotifyState_Turn) == 0x000008, "Wrong alignment on UAnimNotifyState_Turn");
static_assert(sizeof(UAnimNotifyState_Turn) == 0x000050, "Wrong size on UAnimNotifyState_Turn");

// Class DarwinGame.MonsterService
// 0x0008 (0x0038 - 0x0030)
class UMonsterService : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterService">();
	}
	static class UMonsterService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterService>();
	}
};
static_assert(alignof(UMonsterService) == 0x000008, "Wrong alignment on UMonsterService");
static_assert(sizeof(UMonsterService) == 0x000038, "Wrong size on UMonsterService");

// Class DarwinGame.EventWhileTracing
// 0x0000 (0x0038 - 0x0038)
class UEventWhileTracing final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventWhileTracing">();
	}
	static class UEventWhileTracing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventWhileTracing>();
	}
};
static_assert(alignof(UEventWhileTracing) == 0x000008, "Wrong alignment on UEventWhileTracing");
static_assert(sizeof(UEventWhileTracing) == 0x000038, "Wrong size on UEventWhileTracing");

// Class DarwinGame.UIBoardmenu_WinAddMonster
// 0x0220 (0x06B0 - 0x0490)
class UUIBoardmenu_WinAddMonster final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinTwoSceneCaptureImage*            CaptureImage;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x1E0];                                    // 0x04A8(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITalk_WinStatusBase*                  TalkWinStatus;                                     // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_690[0x20];                                     // 0x0690(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_WinAddMonster">();
	}
	static class UUIBoardmenu_WinAddMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_WinAddMonster>();
	}
};
static_assert(alignof(UUIBoardmenu_WinAddMonster) == 0x000008, "Wrong alignment on UUIBoardmenu_WinAddMonster");
static_assert(sizeof(UUIBoardmenu_WinAddMonster) == 0x0006B0, "Wrong size on UUIBoardmenu_WinAddMonster");
static_assert(offsetof(UUIBoardmenu_WinAddMonster, CaptureImage) == 0x0004A0, "Member 'UUIBoardmenu_WinAddMonster::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_WinAddMonster, TalkWinStatus) == 0x000688, "Member 'UUIBoardmenu_WinAddMonster::TalkWinStatus' has a wrong offset!");

// Class DarwinGame.EventFlagBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UEventFlagBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCrearSelectRangeEventFlag(const class FString& FlagNameBase, int32 StartNum, int32 EndNum);
	static void SetSelectRangeEventFlag(const class FString& FlagNameBase, int32 StartNum, int32 EndNum, bool on);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventFlagBlueprintLibrary">();
	}
	static class UEventFlagBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventFlagBlueprintLibrary>();
	}
};
static_assert(alignof(UEventFlagBlueprintLibrary) == 0x000008, "Wrong alignment on UEventFlagBlueprintLibrary");
static_assert(sizeof(UEventFlagBlueprintLibrary) == 0x000030, "Wrong size on UEventFlagBlueprintLibrary");

// Class DarwinGame.AppDebugMenu
// 0x0170 (0x01A0 - 0x0030)
class UAppDebugMenu final : public UObject
{
public:
	uint8                                         Pad_30[0x158];                                     // 0x0030(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class UBPDebugMenuInterface*                  DebugMenuInterface;                                // 0x0188(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextLevelName;                                     // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void DebugDrawText(const class FString& Text, const float sec, const struct FColor& Color);

	void ResetNextLevel();
	void UpdateInput(const float DeltaTime, const bool bGamePaused, const struct FKeyInput& KeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output);

	void GetRevision(class FString* Text) const;
	bool IsActive() const;
	bool IsIdle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppDebugMenu">();
	}
	static class UAppDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppDebugMenu>();
	}
};
static_assert(alignof(UAppDebugMenu) == 0x000008, "Wrong alignment on UAppDebugMenu");
static_assert(sizeof(UAppDebugMenu) == 0x0001A0, "Wrong size on UAppDebugMenu");
static_assert(offsetof(UAppDebugMenu, DebugMenuInterface) == 0x000188, "Member 'UAppDebugMenu::DebugMenuInterface' has a wrong offset!");
static_assert(offsetof(UAppDebugMenu, NextLevelName) == 0x000190, "Member 'UAppDebugMenu::NextLevelName' has a wrong offset!");

// Class DarwinGame.DiscoveryMetalDataTable
// 0x0000 (0x0030 - 0x0030)
class UDiscoveryMetalDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiscoveryMetalDataTable">();
	}
	static class UDiscoveryMetalDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiscoveryMetalDataTable>();
	}
};
static_assert(alignof(UDiscoveryMetalDataTable) == 0x000008, "Wrong alignment on UDiscoveryMetalDataTable");
static_assert(sizeof(UDiscoveryMetalDataTable) == 0x000030, "Wrong size on UDiscoveryMetalDataTable");

// Class DarwinGame.AppGameInstance
// 0x00E0 (0x0280 - 0x01A0)
class alignas(0x10) UAppGameInstance : public UGameInstance
{
public:
	class UPersistentLevelDataAsset*              mPersistentLevelData;                              // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mManagerContainerPtr;                              // 0x01A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x28];                                     // 0x01D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UManagerContainer*                      mManagerContainer;                                 // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSetting*                           mGameSetting;                                      // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugTimer*                            mDebugTimer;                                       // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebugPeriodicSlowdownTest*             mDebugPeriodicSlowdownTest;                        // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x48];                                     // 0x0218(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameDatabase*                          LauncherGameDatabase;                              // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAppDebugMenu*                          mDebugMenu;                                        // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAppGameInstance* GetAppGameInstance();

	void AsyncLoadMainField();
	void AsyncLoadMainFieldFinish();
	class UGameSetting* GetGameSettings();
	void GotoDebugLunture();
	void GotoGameMain();
	void HideDebugMenu();
	void OnCreateDebugMenu();
	void ShowDebugMenu();
	void StartGame();
	void UnLoadMainField();

	class UAppDebugMenu* GetDebugMenu() const;
	class UWorld* GetGameWorld() const;
	bool IsStatedGameInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppGameInstance">();
	}
	static class UAppGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppGameInstance>();
	}
};
static_assert(alignof(UAppGameInstance) == 0x000010, "Wrong alignment on UAppGameInstance");
static_assert(sizeof(UAppGameInstance) == 0x000280, "Wrong size on UAppGameInstance");
static_assert(offsetof(UAppGameInstance, mPersistentLevelData) == 0x0001A0, "Member 'UAppGameInstance::mPersistentLevelData' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, mManagerContainerPtr) == 0x0001A8, "Member 'UAppGameInstance::mManagerContainerPtr' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, mManagerContainer) == 0x0001F8, "Member 'UAppGameInstance::mManagerContainer' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, mGameSetting) == 0x000200, "Member 'UAppGameInstance::mGameSetting' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, mDebugTimer) == 0x000208, "Member 'UAppGameInstance::mDebugTimer' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, mDebugPeriodicSlowdownTest) == 0x000210, "Member 'UAppGameInstance::mDebugPeriodicSlowdownTest' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, LauncherGameDatabase) == 0x000260, "Member 'UAppGameInstance::LauncherGameDatabase' has a wrong offset!");
static_assert(offsetof(UAppGameInstance, mDebugMenu) == 0x000268, "Member 'UAppGameInstance::mDebugMenu' has a wrong offset!");

// Class DarwinGame.DarwinTextSetShop
// 0x0000 (0x0030 - 0x0030)
class UDarwinTextSetShop final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinTextSetShop">();
	}
	static class UDarwinTextSetShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinTextSetShop>();
	}
};
static_assert(alignof(UDarwinTextSetShop) == 0x000008, "Wrong alignment on UDarwinTextSetShop");
static_assert(sizeof(UDarwinTextSetShop) == 0x000030, "Wrong size on UDarwinTextSetShop");

// Class DarwinGame.AppGameMode
// 0x0000 (0x02C8 - 0x02C8)
class AAppGameMode final : public AAppGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppGameMode">();
	}
	static class AAppGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppGameMode>();
	}
};
static_assert(alignof(AAppGameMode) == 0x000008, "Wrong alignment on AAppGameMode");
static_assert(sizeof(AAppGameMode) == 0x0002C8, "Wrong size on AAppGameMode");

// Class DarwinGame.MonsterBattleAICharactersSortFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAICharactersSortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAICharactersSortFunctionLibrary">();
	}
	static class UMonsterBattleAICharactersSortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAICharactersSortFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAICharactersSortFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAICharactersSortFunctionLibrary");
static_assert(sizeof(UMonsterBattleAICharactersSortFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAICharactersSortFunctionLibrary");

// Class DarwinGame.AppInputComponent
// 0x0010 (0x0150 - 0x0140)
class UAppInputComponent final : public UInputComponent
{
public:
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInputEvent(const class FString& UniqueId, TDelegate<void(float DeltaTime, bool bGamePaused, const struct FKeyInput& InKeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)> InEvent, int32 InPriority, int32 FirstInterval, int32 AfterSecondInterval);
	void AddInputEventWithInterruptedEvent(const class FString& UniqueId, TDelegate<void(float DeltaTime, bool bGamePaused, const struct FKeyInput& InKeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)> InEvent, TDelegate<void()> InInterruptedEvent, int32 InPriority, int32 FirstInterval, int32 AfterSecondInterval);
	void RemoveSingleInputEvent(const class FString& UniqueId);

	int32 GetInputPriority_DebugMenu() const;
	int32 GetInputPriority_EVENT() const;
	int32 GetInputPriority_Max() const;
	int32 GetInputPriority_Min() const;
	int32 GetInputPriority_PLAYER() const;
	int32 GetInputPriority_UI() const;
	void OutputLogInputEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppInputComponent">();
	}
	static class UAppInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppInputComponent>();
	}
};
static_assert(alignof(UAppInputComponent) == 0x000008, "Wrong alignment on UAppInputComponent");
static_assert(sizeof(UAppInputComponent) == 0x000150, "Wrong size on UAppInputComponent");

// Class DarwinGame.EmoteCue
// 0x0020 (0x02B8 - 0x0298)
class AEmoteCue : public AGameplayCueNotify_Actor
{
public:
	EEmoteType                                    mEmoteType;                                        // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EEmoteMethod>                          mIgnoreMethodList;                                 // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mEmoteTime;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteCue">();
	}
	static class AEmoteCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEmoteCue>();
	}
};
static_assert(alignof(AEmoteCue) == 0x000008, "Wrong alignment on AEmoteCue");
static_assert(sizeof(AEmoteCue) == 0x0002B8, "Wrong size on AEmoteCue");
static_assert(offsetof(AEmoteCue, mEmoteType) == 0x000298, "Member 'AEmoteCue::mEmoteType' has a wrong offset!");
static_assert(offsetof(AEmoteCue, mIgnoreMethodList) == 0x0002A0, "Member 'AEmoteCue::mIgnoreMethodList' has a wrong offset!");
static_assert(offsetof(AEmoteCue, mEmoteTime) == 0x0002B0, "Member 'AEmoteCue::mEmoteTime' has a wrong offset!");

// Class DarwinGame.UIButtonArrow
// 0x0008 (0x0498 - 0x0490)
class UUIButtonArrow : public UDarwinUserWidget
{
public:
	EAxisMappingType                              ArrowType;                                         // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void off();
	void on();
	void Push();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIButtonArrow">();
	}
	static class UUIButtonArrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIButtonArrow>();
	}
};
static_assert(alignof(UUIButtonArrow) == 0x000008, "Wrong alignment on UUIButtonArrow");
static_assert(sizeof(UUIButtonArrow) == 0x000498, "Wrong size on UUIButtonArrow");
static_assert(offsetof(UUIButtonArrow, ArrowType) == 0x000490, "Member 'UUIButtonArrow::ArrowType' has a wrong offset!");

// Class DarwinGame.EventSystemManagerActor
// 0x0018 (0x0240 - 0x0228)
class AEventSystemManagerActor : public AActor
{
public:
	class UEventExecuter*                         EventExecuter;                                     // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventManager*                          EventManager;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USequencerController*                   SequencerContorller;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void StartDebugEvent(const class FName EventID);

	class UEventExecuter* GetEventExecuter() const;
	class UEventManager* GetEventManager() const;
	class USequencerController* GetSequencerContorller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSystemManagerActor">();
	}
	static class AEventSystemManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSystemManagerActor>();
	}
};
static_assert(alignof(AEventSystemManagerActor) == 0x000008, "Wrong alignment on AEventSystemManagerActor");
static_assert(sizeof(AEventSystemManagerActor) == 0x000240, "Wrong size on AEventSystemManagerActor");
static_assert(offsetof(AEventSystemManagerActor, EventExecuter) == 0x000228, "Member 'AEventSystemManagerActor::EventExecuter' has a wrong offset!");
static_assert(offsetof(AEventSystemManagerActor, EventManager) == 0x000230, "Member 'AEventSystemManagerActor::EventManager' has a wrong offset!");
static_assert(offsetof(AEventSystemManagerActor, SequencerContorller) == 0x000238, "Member 'AEventSystemManagerActor::SequencerContorller' has a wrong offset!");

// Class DarwinGame.AppPlayerController
// 0x0070 (0x05E8 - 0x0578)
class AAppPlayerController : public APlayerController
{
public:
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKeyInput                              KeyInput;                                          // 0x0580(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LeftStickInput;                                    // 0x0590(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightStickInput;                                   // 0x059C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKeyStateUpdateComponent*               KeyStateUpdater;                                   // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAppInputComponent*                     AppInputComponent;                                 // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x30];                                     // 0x05B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float AdjustInputValueWithFPS(float Value, float DeltaTime);
	bool CanOperateCamera();
	void ClearLeftStickInput();
	void ClearRightStickInput();
	class UAppInputComponent* GetAppInputComponent();
	void SetInputEnable(bool enable);
	void SetKeyRepeatInterval(int32 FirstInterval, int32 Interval);
	void UpdateKeyState(EAxisMappingType Type, float Value);

	float GetMouseWheelAxis() const;
	bool HasAppWindowFocus() const;
	void OutputLogStackInputComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPlayerController">();
	}
	static class AAppPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppPlayerController>();
	}
};
static_assert(alignof(AAppPlayerController) == 0x000008, "Wrong alignment on AAppPlayerController");
static_assert(sizeof(AAppPlayerController) == 0x0005E8, "Wrong size on AAppPlayerController");
static_assert(offsetof(AAppPlayerController, KeyInput) == 0x000580, "Member 'AAppPlayerController::KeyInput' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, LeftStickInput) == 0x000590, "Member 'AAppPlayerController::LeftStickInput' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, RightStickInput) == 0x00059C, "Member 'AAppPlayerController::RightStickInput' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, KeyStateUpdater) == 0x0005A8, "Member 'AAppPlayerController::KeyStateUpdater' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, AppInputComponent) == 0x0005B0, "Member 'AAppPlayerController::AppInputComponent' has a wrong offset!");

// Class DarwinGame.AppSpringArmComponent
// 0x0060 (0x02F0 - 0x0290)
class UAppSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bEnableHitBlendLocationLag;                        // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitBlendLocationLagSpeed;                          // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HitBlendLocationLagExp;                            // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             CameraBodyProbeChannel;                            // 0x029C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x48];                                     // 0x02A8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppSpringArmComponent">();
	}
	static class UAppSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppSpringArmComponent>();
	}
};
static_assert(alignof(UAppSpringArmComponent) == 0x000010, "Wrong alignment on UAppSpringArmComponent");
static_assert(sizeof(UAppSpringArmComponent) == 0x0002F0, "Wrong size on UAppSpringArmComponent");
static_assert(offsetof(UAppSpringArmComponent, bEnableHitBlendLocationLag) == 0x000290, "Member 'UAppSpringArmComponent::bEnableHitBlendLocationLag' has a wrong offset!");
static_assert(offsetof(UAppSpringArmComponent, HitBlendLocationLagSpeed) == 0x000294, "Member 'UAppSpringArmComponent::HitBlendLocationLagSpeed' has a wrong offset!");
static_assert(offsetof(UAppSpringArmComponent, HitBlendLocationLagExp) == 0x000298, "Member 'UAppSpringArmComponent::HitBlendLocationLagExp' has a wrong offset!");
static_assert(offsetof(UAppSpringArmComponent, CameraBodyProbeChannel) == 0x00029C, "Member 'UAppSpringArmComponent::CameraBodyProbeChannel' has a wrong offset!");
static_assert(offsetof(UAppSpringArmComponent, CameraComponent) == 0x0002A0, "Member 'UAppSpringArmComponent::CameraComponent' has a wrong offset!");

// Class DarwinGame.DataTableManager
// 0x1F60 (0x1F98 - 0x0038)
class UDataTableManager : public UManagerBase
{
public:
	TSoftObjectPtr<class UDataTable>              mFlagDefinitionDT;                                 // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mItemListDT;                                       // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mGameplayEffectDT;                                 // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBraveDT;                                          // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mExpDT;                                            // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mKindDT;                                           // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mActionOverviewDT;                                 // 0x0128(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mActionDetailDT;                                   // 0x0150(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDerivateActionDT;                                 // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFeatureDT;                                        // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFeatureConditionDT;                               // 0x01C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFeatureEffectDT;                                  // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFeatureGameplayEffectDT;                          // 0x0218(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mResistanceDT;                                     // 0x0240(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mAttributeDT;                                      // 0x0268(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMovementDT;                                       // 0x0290(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mInteractionDT;                                    // 0x02B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mOriginParameterDT;                                // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mWeaponDT;                                         // 0x0308(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCustomEquipmentDT;                                // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCustomRandomEquipmentDT;                          // 0x0358(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCustomMonsterMaterialDT;                          // 0x0380(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeamMonsterEquipmentDT;                      // 0x03A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mPlayerWeaponDT;                                   // 0x03D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCoinSlotParameterDT;                              // 0x03F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mSoftMonsterDT;                                    // 0x0420(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCommonMonsterAssetDT;                             // 0x0448(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mEnemyPlacementDT;                                 // 0x0470(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mShootAttackCollisionDT;                           // 0x0498(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCollectionPointDT;                                // 0x04C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCollectionPointGetItemDT;                         // 0x04E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterParameterDT;                               // 0x0510(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mEncountDT;                                        // 0x0538(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBattleIdDT;                                       // 0x0560(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mStalkerBattleIdDT;                                // 0x0588(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mHyenaBattleIdDT;                                  // 0x05B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDefenceBattleIdDT;                                // 0x05D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRevengeBattleIdDT;                                // 0x0600(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDungeonNormalMonsterBattleIdDT;                   // 0x0628(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDungeonToughMonsterBattleIdDT;                    // 0x0650(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDungeonBossMonsterBattleIdDT;                     // 0x0678(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDungeonGroupBattleIdDT;                           // 0x06A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDiscoveryMetalBattleIdDT;                         // 0x06C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDiscoveryTreasureBattleIdDT;                      // 0x06F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCommonGeneraterParamDT;                           // 0x0718(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mParameterTypeDT;                                  // 0x0740(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mPartyJoinDT;                                      // 0x0768(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCoinRarityDT;                                     // 0x0790(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCoinFixedDT;                                      // 0x07B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCAvatarDT;                                      // 0x07E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFixTreasureBoxDT;                                 // 0x0808(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTreasureBoxAdditionDataAsset*          mTreasureBoxAdditionData;                          // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFieldObjectDT;                                    // 0x0838(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFieldObjectGetItemDT;                             // 0x0860(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mStationDT;                                        // 0x0888(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBonfireDT;                                        // 0x08B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIMonsterResourceDT;                              // 0x08D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIOriginMonsterResourceDT;                        // 0x0900(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUISpecialMonsterResourceDT;                       // 0x0928(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIStatusResourceDT;                               // 0x0950(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIStatusIconResourceDT;                           // 0x0978(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDropMoveParameterDT;                              // 0x09A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAreaDataAsset*                         mAreaDataDA;                                       // 0x09C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFastTravelPointDT;                                // 0x09D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUiNpcDataDT;                                      // 0x09F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mEmojiIconDT;                                      // 0x0A20(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUI3DCharacterDT;                                  // 0x0A48(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUI3DDispatchDirectingDT;                          // 0x0A70(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBoardMonsterRankDT;                               // 0x0A98(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIResistanceResourceDT;                           // 0x0AC0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIUtilityIconDT;                                  // 0x0AE8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIBoardAutoMonsterDT;                             // 0x0B10(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIBoardAutoLevelDT;                               // 0x0B38(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIBoardNickNameJaDT;                              // 0x0B60(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIBoardNickNameEnDT;                              // 0x0B88(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIBoardRequireItemDT;                             // 0x0BB0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIEventRequireItemDT;                             // 0x0BD8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIBoardRequireScaleDT;                            // 0x0C00(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIFacilityFoodItemDT;                             // 0x0C28(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIFacilityBulletItemDT;                           // 0x0C50(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterRingDT;                                    // 0x0C78(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterCommonDT;                                  // 0x0CA0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterTraceLocationDT;                           // 0x0CC8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterActionCycleDT;                             // 0x0CF0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIMonsterSpecialAbilityNameDT;                    // 0x0D18(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIHubClerkDataDT;                                 // 0x0D40(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIHubMessageDataDT;                               // 0x0D68(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIHubBackMonsterDataDT;                           // 0x0D90(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCoinNameSortDT;                                   // 0x0DB8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIStationListDT;                                  // 0x0DE0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIMainMenuHomeDT;                                 // 0x0E08(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIPanelIconDT;                                    // 0x0E30(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBulletDT;                                         // 0x0E58(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mInputGuideCautionDT;                              // 0x0E80(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mTutorialGuideTextDT;                              // 0x0EA8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mTutorialGuideDT;                                  // 0x0ED0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mTipsManagementDT;                                 // 0x0EF8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIMyTeamFlagDataDT;                               // 0x0F20(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMyTeamLevelDataAsset*                  mMyTeamLevelDataAsset;                             // 0x0F48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIMonsterDictHabitatDT;                           // 0x0F50(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIMonsterDictInfoDT;                              // 0x0F78(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mShopDataDT;                                       // 0x0FA0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mShopArtifactDataDT;                               // 0x0FC8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterVariableLevelRateDT;                       // 0x0FF0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterVariableExpRateDT;                         // 0x1018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUITutorialVisionDT;                               // 0x1040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mFoodEffectDT;                                     // 0x1068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIFoodEffectDT;                                   // 0x1090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBossMonsterParameterDT;                           // 0x10B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBossMonsterCombatSequenceDT;                      // 0x10E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBossMonsterActionListDT;                          // 0x1108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBossMonsterActionScenarioDT;                      // 0x1130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBossMonsterActionConvertDT;                       // 0x1158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBossMonsterGuideConditionDT;                      // 0x1180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDesertBossMonsterMaterialDT;                      // 0x11A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mVolcanoBossMonsterMaterialDT;                     // 0x11D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mIceBossMonsterMaterialDT;                         // 0x11F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame1DialogDT;                              // 0x1220(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame2DialogDT;                              // 0x1248(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame3DialogDT;                              // 0x1270(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame4DialogDT;                              // 0x1298(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame5DialogDT;                              // 0x12C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame6DialogDT;                              // 0x12E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame7DialogDT;                              // 0x1310(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame8DialogDT;                              // 0x1338(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeame9DialogDT;                              // 0x1360(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIQuestTypeDataDT;                                // 0x1388(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIStatusBaseDataDT;                               // 0x13B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mArtifactDT;                                       // 0x13D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtifactPointDataAsset*                mArtifactPoint;                                    // 0x1400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIArtifactCategoryDT;                             // 0x1408(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIArtifactSmallCategoryDT;                        // 0x1430(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mCommonEmoteDT;                                    // 0x1458(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mEmoteFaceDT;                                      // 0x1480(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIComboTimingDT;                                  // 0x14A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDungeonDataAsset*                      mDungeon;                                          // 0x14D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDungeonMonsterSpawnPointDT;                       // 0x14D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mAttackCollisionClassDT;                           // 0x1500(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mWordClassListDT;                                  // 0x1528(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArtifactFigureDataAsset*               mArtifactFigureData;                               // 0x1550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNetworkTermsDataDT;                               // 0x1558(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetObjectDataAsset*                 mTargetObjectData;                                 // 0x1580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseAreaBattleDataAsset*               mBaseAreaBattleData;                               // 0x1588(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOutbreakQuestPointDataAsset*           mOutbreakQuestPointData;                           // 0x1590(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNetworkQuestDataAsset*                 mNetworkQuestData;                                 // 0x1598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDailyQuestDataAsset*                   mDailyQuestData;                                   // 0x15A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseAreaLevelUpDataAsset*              mBaseAreaLevelUpData;                              // 0x15A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDispatchDataAsset*                     mDispatchDataAsset;                                // 0x15B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIKnowledeDataDT;                                 // 0x15B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIKnowledeCategoryDT;                             // 0x15E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUINetworkManagementTravelTimeDT;                  // 0x1608(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemConvertTreasureDataAsset*          mItemConvertTreasureData;                          // 0x1630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIQuestOverviewDictDataDT;                        // 0x1638(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIArtifactClassificationDataDT;                   // 0x1660(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIArtifactAuthorityDataDT;                        // 0x1688(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mRivalTeamLotteryWeightDT;                         // 0x16B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mReplicaDifficultyDataTableDT;                     // 0x16D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectionPointDataAsset*              mCollectionPointDataAsset;                         // 0x1700(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestDestinationDT;                               // 0x1708(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUEstimateBonusDataTableDT;                        // 0x1730(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mBoardSceneDT;                                     // 0x1758(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNetworkReturnCaptureDT;                           // 0x1780(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULiftDataAsset*                         mLiftData;                                         // 0x17A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mArtifactCompleteDT;                               // 0x17B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mArtifactCompRewardDT;                             // 0x17D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mHangulCharacterDT;                                // 0x1800(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterKindIdBlackListDT;                         // 0x1828(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterNickNameIdBlackListDT;                     // 0x1850(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mMonsterEquipmentWhiteListDT;                      // 0x1878(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mAddOnContentMasterDT;                             // 0x18A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mAddOnContentRewordGroupDT;                        // 0x18C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQualityUpBonusDT;                                 // 0x18F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIArtifactQualityDT;                              // 0x1918(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUITextColorDT;                                    // 0x1940(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIArtifactFrameDT;                                // 0x1968(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIResourceBtnDT;                                  // 0x1990(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mUIResourceInputIconsDT;                           // 0x19B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mActionSoundRangeDataDT;                           // 0x19E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTagTextRubyDataAsset*                  mTagTextRubyData;                                  // 0x1A08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBGMSoundMapDataAsset*                  mBGMSoundMapData;                                  // 0x1A10(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A18[0x580];                                   // 0x1A18(0x0580)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDataTableManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableManager">();
	}
	static class UDataTableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableManager>();
	}
};
static_assert(alignof(UDataTableManager) == 0x000008, "Wrong alignment on UDataTableManager");
static_assert(sizeof(UDataTableManager) == 0x001F98, "Wrong size on UDataTableManager");
static_assert(offsetof(UDataTableManager, mFlagDefinitionDT) == 0x000038, "Member 'UDataTableManager::mFlagDefinitionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mItemListDT) == 0x000060, "Member 'UDataTableManager::mItemListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mGameplayEffectDT) == 0x000088, "Member 'UDataTableManager::mGameplayEffectDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBraveDT) == 0x0000B0, "Member 'UDataTableManager::mBraveDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mExpDT) == 0x0000D8, "Member 'UDataTableManager::mExpDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mKindDT) == 0x000100, "Member 'UDataTableManager::mKindDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mActionOverviewDT) == 0x000128, "Member 'UDataTableManager::mActionOverviewDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mActionDetailDT) == 0x000150, "Member 'UDataTableManager::mActionDetailDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDerivateActionDT) == 0x000178, "Member 'UDataTableManager::mDerivateActionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFeatureDT) == 0x0001A0, "Member 'UDataTableManager::mFeatureDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFeatureConditionDT) == 0x0001C8, "Member 'UDataTableManager::mFeatureConditionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFeatureEffectDT) == 0x0001F0, "Member 'UDataTableManager::mFeatureEffectDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFeatureGameplayEffectDT) == 0x000218, "Member 'UDataTableManager::mFeatureGameplayEffectDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mResistanceDT) == 0x000240, "Member 'UDataTableManager::mResistanceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mAttributeDT) == 0x000268, "Member 'UDataTableManager::mAttributeDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMovementDT) == 0x000290, "Member 'UDataTableManager::mMovementDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mInteractionDT) == 0x0002B8, "Member 'UDataTableManager::mInteractionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mOriginParameterDT) == 0x0002E0, "Member 'UDataTableManager::mOriginParameterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mWeaponDT) == 0x000308, "Member 'UDataTableManager::mWeaponDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCustomEquipmentDT) == 0x000330, "Member 'UDataTableManager::mCustomEquipmentDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCustomRandomEquipmentDT) == 0x000358, "Member 'UDataTableManager::mCustomRandomEquipmentDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCustomMonsterMaterialDT) == 0x000380, "Member 'UDataTableManager::mCustomMonsterMaterialDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeamMonsterEquipmentDT) == 0x0003A8, "Member 'UDataTableManager::mRivalTeamMonsterEquipmentDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mPlayerWeaponDT) == 0x0003D0, "Member 'UDataTableManager::mPlayerWeaponDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCoinSlotParameterDT) == 0x0003F8, "Member 'UDataTableManager::mCoinSlotParameterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mSoftMonsterDT) == 0x000420, "Member 'UDataTableManager::mSoftMonsterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCommonMonsterAssetDT) == 0x000448, "Member 'UDataTableManager::mCommonMonsterAssetDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mEnemyPlacementDT) == 0x000470, "Member 'UDataTableManager::mEnemyPlacementDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mShootAttackCollisionDT) == 0x000498, "Member 'UDataTableManager::mShootAttackCollisionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCollectionPointDT) == 0x0004C0, "Member 'UDataTableManager::mCollectionPointDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCollectionPointGetItemDT) == 0x0004E8, "Member 'UDataTableManager::mCollectionPointGetItemDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterParameterDT) == 0x000510, "Member 'UDataTableManager::mMonsterParameterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mEncountDT) == 0x000538, "Member 'UDataTableManager::mEncountDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBattleIdDT) == 0x000560, "Member 'UDataTableManager::mBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mStalkerBattleIdDT) == 0x000588, "Member 'UDataTableManager::mStalkerBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mHyenaBattleIdDT) == 0x0005B0, "Member 'UDataTableManager::mHyenaBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDefenceBattleIdDT) == 0x0005D8, "Member 'UDataTableManager::mDefenceBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRevengeBattleIdDT) == 0x000600, "Member 'UDataTableManager::mRevengeBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDungeonNormalMonsterBattleIdDT) == 0x000628, "Member 'UDataTableManager::mDungeonNormalMonsterBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDungeonToughMonsterBattleIdDT) == 0x000650, "Member 'UDataTableManager::mDungeonToughMonsterBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDungeonBossMonsterBattleIdDT) == 0x000678, "Member 'UDataTableManager::mDungeonBossMonsterBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDungeonGroupBattleIdDT) == 0x0006A0, "Member 'UDataTableManager::mDungeonGroupBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDiscoveryMetalBattleIdDT) == 0x0006C8, "Member 'UDataTableManager::mDiscoveryMetalBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDiscoveryTreasureBattleIdDT) == 0x0006F0, "Member 'UDataTableManager::mDiscoveryTreasureBattleIdDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCommonGeneraterParamDT) == 0x000718, "Member 'UDataTableManager::mCommonGeneraterParamDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mParameterTypeDT) == 0x000740, "Member 'UDataTableManager::mParameterTypeDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mPartyJoinDT) == 0x000768, "Member 'UDataTableManager::mPartyJoinDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCoinRarityDT) == 0x000790, "Member 'UDataTableManager::mCoinRarityDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCoinFixedDT) == 0x0007B8, "Member 'UDataTableManager::mCoinFixedDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mNPCAvatarDT) == 0x0007E0, "Member 'UDataTableManager::mNPCAvatarDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFixTreasureBoxDT) == 0x000808, "Member 'UDataTableManager::mFixTreasureBoxDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mTreasureBoxAdditionData) == 0x000830, "Member 'UDataTableManager::mTreasureBoxAdditionData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFieldObjectDT) == 0x000838, "Member 'UDataTableManager::mFieldObjectDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFieldObjectGetItemDT) == 0x000860, "Member 'UDataTableManager::mFieldObjectGetItemDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mStationDT) == 0x000888, "Member 'UDataTableManager::mStationDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBonfireDT) == 0x0008B0, "Member 'UDataTableManager::mBonfireDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIMonsterResourceDT) == 0x0008D8, "Member 'UDataTableManager::mUIMonsterResourceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIOriginMonsterResourceDT) == 0x000900, "Member 'UDataTableManager::mUIOriginMonsterResourceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUISpecialMonsterResourceDT) == 0x000928, "Member 'UDataTableManager::mUISpecialMonsterResourceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIStatusResourceDT) == 0x000950, "Member 'UDataTableManager::mUIStatusResourceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIStatusIconResourceDT) == 0x000978, "Member 'UDataTableManager::mUIStatusIconResourceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDropMoveParameterDT) == 0x0009A0, "Member 'UDataTableManager::mDropMoveParameterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mAreaDataDA) == 0x0009C8, "Member 'UDataTableManager::mAreaDataDA' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFastTravelPointDT) == 0x0009D0, "Member 'UDataTableManager::mFastTravelPointDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUiNpcDataDT) == 0x0009F8, "Member 'UDataTableManager::mUiNpcDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mEmojiIconDT) == 0x000A20, "Member 'UDataTableManager::mEmojiIconDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUI3DCharacterDT) == 0x000A48, "Member 'UDataTableManager::mUI3DCharacterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUI3DDispatchDirectingDT) == 0x000A70, "Member 'UDataTableManager::mUI3DDispatchDirectingDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBoardMonsterRankDT) == 0x000A98, "Member 'UDataTableManager::mBoardMonsterRankDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIResistanceResourceDT) == 0x000AC0, "Member 'UDataTableManager::mUIResistanceResourceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIUtilityIconDT) == 0x000AE8, "Member 'UDataTableManager::mUIUtilityIconDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIBoardAutoMonsterDT) == 0x000B10, "Member 'UDataTableManager::mUIBoardAutoMonsterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIBoardAutoLevelDT) == 0x000B38, "Member 'UDataTableManager::mUIBoardAutoLevelDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIBoardNickNameJaDT) == 0x000B60, "Member 'UDataTableManager::mUIBoardNickNameJaDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIBoardNickNameEnDT) == 0x000B88, "Member 'UDataTableManager::mUIBoardNickNameEnDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIBoardRequireItemDT) == 0x000BB0, "Member 'UDataTableManager::mUIBoardRequireItemDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIEventRequireItemDT) == 0x000BD8, "Member 'UDataTableManager::mUIEventRequireItemDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIBoardRequireScaleDT) == 0x000C00, "Member 'UDataTableManager::mUIBoardRequireScaleDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIFacilityFoodItemDT) == 0x000C28, "Member 'UDataTableManager::mUIFacilityFoodItemDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIFacilityBulletItemDT) == 0x000C50, "Member 'UDataTableManager::mUIFacilityBulletItemDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterRingDT) == 0x000C78, "Member 'UDataTableManager::mMonsterRingDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterCommonDT) == 0x000CA0, "Member 'UDataTableManager::mMonsterCommonDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterTraceLocationDT) == 0x000CC8, "Member 'UDataTableManager::mMonsterTraceLocationDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterActionCycleDT) == 0x000CF0, "Member 'UDataTableManager::mMonsterActionCycleDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIMonsterSpecialAbilityNameDT) == 0x000D18, "Member 'UDataTableManager::mUIMonsterSpecialAbilityNameDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIHubClerkDataDT) == 0x000D40, "Member 'UDataTableManager::mUIHubClerkDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIHubMessageDataDT) == 0x000D68, "Member 'UDataTableManager::mUIHubMessageDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIHubBackMonsterDataDT) == 0x000D90, "Member 'UDataTableManager::mUIHubBackMonsterDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCoinNameSortDT) == 0x000DB8, "Member 'UDataTableManager::mCoinNameSortDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIStationListDT) == 0x000DE0, "Member 'UDataTableManager::mUIStationListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIMainMenuHomeDT) == 0x000E08, "Member 'UDataTableManager::mUIMainMenuHomeDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIPanelIconDT) == 0x000E30, "Member 'UDataTableManager::mUIPanelIconDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBulletDT) == 0x000E58, "Member 'UDataTableManager::mBulletDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mInputGuideCautionDT) == 0x000E80, "Member 'UDataTableManager::mInputGuideCautionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mTutorialGuideTextDT) == 0x000EA8, "Member 'UDataTableManager::mTutorialGuideTextDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mTutorialGuideDT) == 0x000ED0, "Member 'UDataTableManager::mTutorialGuideDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mTipsManagementDT) == 0x000EF8, "Member 'UDataTableManager::mTipsManagementDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIMyTeamFlagDataDT) == 0x000F20, "Member 'UDataTableManager::mUIMyTeamFlagDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMyTeamLevelDataAsset) == 0x000F48, "Member 'UDataTableManager::mMyTeamLevelDataAsset' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIMonsterDictHabitatDT) == 0x000F50, "Member 'UDataTableManager::mUIMonsterDictHabitatDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIMonsterDictInfoDT) == 0x000F78, "Member 'UDataTableManager::mUIMonsterDictInfoDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mShopDataDT) == 0x000FA0, "Member 'UDataTableManager::mShopDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mShopArtifactDataDT) == 0x000FC8, "Member 'UDataTableManager::mShopArtifactDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterVariableLevelRateDT) == 0x000FF0, "Member 'UDataTableManager::mMonsterVariableLevelRateDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterVariableExpRateDT) == 0x001018, "Member 'UDataTableManager::mMonsterVariableExpRateDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUITutorialVisionDT) == 0x001040, "Member 'UDataTableManager::mUITutorialVisionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mFoodEffectDT) == 0x001068, "Member 'UDataTableManager::mFoodEffectDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIFoodEffectDT) == 0x001090, "Member 'UDataTableManager::mUIFoodEffectDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBossMonsterParameterDT) == 0x0010B8, "Member 'UDataTableManager::mBossMonsterParameterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBossMonsterCombatSequenceDT) == 0x0010E0, "Member 'UDataTableManager::mBossMonsterCombatSequenceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBossMonsterActionListDT) == 0x001108, "Member 'UDataTableManager::mBossMonsterActionListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBossMonsterActionScenarioDT) == 0x001130, "Member 'UDataTableManager::mBossMonsterActionScenarioDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBossMonsterActionConvertDT) == 0x001158, "Member 'UDataTableManager::mBossMonsterActionConvertDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBossMonsterGuideConditionDT) == 0x001180, "Member 'UDataTableManager::mBossMonsterGuideConditionDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDesertBossMonsterMaterialDT) == 0x0011A8, "Member 'UDataTableManager::mDesertBossMonsterMaterialDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mVolcanoBossMonsterMaterialDT) == 0x0011D0, "Member 'UDataTableManager::mVolcanoBossMonsterMaterialDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mIceBossMonsterMaterialDT) == 0x0011F8, "Member 'UDataTableManager::mIceBossMonsterMaterialDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame1DialogDT) == 0x001220, "Member 'UDataTableManager::mRivalTeame1DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame2DialogDT) == 0x001248, "Member 'UDataTableManager::mRivalTeame2DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame3DialogDT) == 0x001270, "Member 'UDataTableManager::mRivalTeame3DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame4DialogDT) == 0x001298, "Member 'UDataTableManager::mRivalTeame4DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame5DialogDT) == 0x0012C0, "Member 'UDataTableManager::mRivalTeame5DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame6DialogDT) == 0x0012E8, "Member 'UDataTableManager::mRivalTeame6DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame7DialogDT) == 0x001310, "Member 'UDataTableManager::mRivalTeame7DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame8DialogDT) == 0x001338, "Member 'UDataTableManager::mRivalTeame8DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeame9DialogDT) == 0x001360, "Member 'UDataTableManager::mRivalTeame9DialogDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIQuestTypeDataDT) == 0x001388, "Member 'UDataTableManager::mUIQuestTypeDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIStatusBaseDataDT) == 0x0013B0, "Member 'UDataTableManager::mUIStatusBaseDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mArtifactDT) == 0x0013D8, "Member 'UDataTableManager::mArtifactDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mArtifactPoint) == 0x001400, "Member 'UDataTableManager::mArtifactPoint' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIArtifactCategoryDT) == 0x001408, "Member 'UDataTableManager::mUIArtifactCategoryDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIArtifactSmallCategoryDT) == 0x001430, "Member 'UDataTableManager::mUIArtifactSmallCategoryDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCommonEmoteDT) == 0x001458, "Member 'UDataTableManager::mCommonEmoteDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mEmoteFaceDT) == 0x001480, "Member 'UDataTableManager::mEmoteFaceDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIComboTimingDT) == 0x0014A8, "Member 'UDataTableManager::mUIComboTimingDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDungeon) == 0x0014D0, "Member 'UDataTableManager::mDungeon' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDungeonMonsterSpawnPointDT) == 0x0014D8, "Member 'UDataTableManager::mDungeonMonsterSpawnPointDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mAttackCollisionClassDT) == 0x001500, "Member 'UDataTableManager::mAttackCollisionClassDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mWordClassListDT) == 0x001528, "Member 'UDataTableManager::mWordClassListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mArtifactFigureData) == 0x001550, "Member 'UDataTableManager::mArtifactFigureData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mNetworkTermsDataDT) == 0x001558, "Member 'UDataTableManager::mNetworkTermsDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mTargetObjectData) == 0x001580, "Member 'UDataTableManager::mTargetObjectData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBaseAreaBattleData) == 0x001588, "Member 'UDataTableManager::mBaseAreaBattleData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mOutbreakQuestPointData) == 0x001590, "Member 'UDataTableManager::mOutbreakQuestPointData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mNetworkQuestData) == 0x001598, "Member 'UDataTableManager::mNetworkQuestData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDailyQuestData) == 0x0015A0, "Member 'UDataTableManager::mDailyQuestData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBaseAreaLevelUpData) == 0x0015A8, "Member 'UDataTableManager::mBaseAreaLevelUpData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mDispatchDataAsset) == 0x0015B0, "Member 'UDataTableManager::mDispatchDataAsset' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIKnowledeDataDT) == 0x0015B8, "Member 'UDataTableManager::mUIKnowledeDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIKnowledeCategoryDT) == 0x0015E0, "Member 'UDataTableManager::mUIKnowledeCategoryDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUINetworkManagementTravelTimeDT) == 0x001608, "Member 'UDataTableManager::mUINetworkManagementTravelTimeDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mItemConvertTreasureData) == 0x001630, "Member 'UDataTableManager::mItemConvertTreasureData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIQuestOverviewDictDataDT) == 0x001638, "Member 'UDataTableManager::mUIQuestOverviewDictDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIArtifactClassificationDataDT) == 0x001660, "Member 'UDataTableManager::mUIArtifactClassificationDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIArtifactAuthorityDataDT) == 0x001688, "Member 'UDataTableManager::mUIArtifactAuthorityDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mRivalTeamLotteryWeightDT) == 0x0016B0, "Member 'UDataTableManager::mRivalTeamLotteryWeightDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mReplicaDifficultyDataTableDT) == 0x0016D8, "Member 'UDataTableManager::mReplicaDifficultyDataTableDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mCollectionPointDataAsset) == 0x001700, "Member 'UDataTableManager::mCollectionPointDataAsset' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mQuestDestinationDT) == 0x001708, "Member 'UDataTableManager::mQuestDestinationDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUEstimateBonusDataTableDT) == 0x001730, "Member 'UDataTableManager::mUEstimateBonusDataTableDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBoardSceneDT) == 0x001758, "Member 'UDataTableManager::mBoardSceneDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mNetworkReturnCaptureDT) == 0x001780, "Member 'UDataTableManager::mNetworkReturnCaptureDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mLiftData) == 0x0017A8, "Member 'UDataTableManager::mLiftData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mArtifactCompleteDT) == 0x0017B0, "Member 'UDataTableManager::mArtifactCompleteDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mArtifactCompRewardDT) == 0x0017D8, "Member 'UDataTableManager::mArtifactCompRewardDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mHangulCharacterDT) == 0x001800, "Member 'UDataTableManager::mHangulCharacterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterKindIdBlackListDT) == 0x001828, "Member 'UDataTableManager::mMonsterKindIdBlackListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterNickNameIdBlackListDT) == 0x001850, "Member 'UDataTableManager::mMonsterNickNameIdBlackListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mMonsterEquipmentWhiteListDT) == 0x001878, "Member 'UDataTableManager::mMonsterEquipmentWhiteListDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mAddOnContentMasterDT) == 0x0018A0, "Member 'UDataTableManager::mAddOnContentMasterDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mAddOnContentRewordGroupDT) == 0x0018C8, "Member 'UDataTableManager::mAddOnContentRewordGroupDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mQualityUpBonusDT) == 0x0018F0, "Member 'UDataTableManager::mQualityUpBonusDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIArtifactQualityDT) == 0x001918, "Member 'UDataTableManager::mUIArtifactQualityDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUITextColorDT) == 0x001940, "Member 'UDataTableManager::mUITextColorDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIArtifactFrameDT) == 0x001968, "Member 'UDataTableManager::mUIArtifactFrameDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIResourceBtnDT) == 0x001990, "Member 'UDataTableManager::mUIResourceBtnDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mUIResourceInputIconsDT) == 0x0019B8, "Member 'UDataTableManager::mUIResourceInputIconsDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mActionSoundRangeDataDT) == 0x0019E0, "Member 'UDataTableManager::mActionSoundRangeDataDT' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mTagTextRubyData) == 0x001A08, "Member 'UDataTableManager::mTagTextRubyData' has a wrong offset!");
static_assert(offsetof(UDataTableManager, mBGMSoundMapData) == 0x001A10, "Member 'UDataTableManager::mBGMSoundMapData' has a wrong offset!");

// Class DarwinGame.AreaDataTable
// 0x0000 (0x0030 - 0x0030)
class UAreaDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaDataTable">();
	}
	static class UAreaDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaDataTable>();
	}
};
static_assert(alignof(UAreaDataTable) == 0x000008, "Wrong alignment on UAreaDataTable");
static_assert(sizeof(UAreaDataTable) == 0x000030, "Wrong size on UAreaDataTable");

// Class DarwinGame.MonsterBossBattleAI
// 0x0008 (0x0038 - 0x0030)
class UMonsterBossBattleAI final : public UMonsterBattleAIBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBossBattleAI">();
	}
	static class UMonsterBossBattleAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBossBattleAI>();
	}
};
static_assert(alignof(UMonsterBossBattleAI) == 0x000008, "Wrong alignment on UMonsterBossBattleAI");
static_assert(sizeof(UMonsterBossBattleAI) == 0x000038, "Wrong size on UMonsterBossBattleAI");

// Class DarwinGame.AreaOfEffectBase
// 0x0028 (0x0250 - 0x0228)
class AAreaOfEffectBase : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootComp;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAreaOfEffectDecalComponet*             Decal;                                             // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalHeight;                                       // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeIn(float StartDelay, float Duration);
	void FadeOut(float StartDelay, float Duration);
	void SetHeight(float Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaOfEffectBase">();
	}
	static class AAreaOfEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAreaOfEffectBase>();
	}
};
static_assert(alignof(AAreaOfEffectBase) == 0x000008, "Wrong alignment on AAreaOfEffectBase");
static_assert(sizeof(AAreaOfEffectBase) == 0x000250, "Wrong size on AAreaOfEffectBase");
static_assert(offsetof(AAreaOfEffectBase, RootComp) == 0x000238, "Member 'AAreaOfEffectBase::RootComp' has a wrong offset!");
static_assert(offsetof(AAreaOfEffectBase, Decal) == 0x000240, "Member 'AAreaOfEffectBase::Decal' has a wrong offset!");
static_assert(offsetof(AAreaOfEffectBase, DecalHeight) == 0x000248, "Member 'AAreaOfEffectBase::DecalHeight' has a wrong offset!");

// Class DarwinGame.EmoteBlinkOverwriteOption
// 0x0008 (0x0038 - 0x0030)
class UEmoteBlinkOverwriteOption final : public UObject
{
public:
	struct FEmoteBlinkSetting                     OverwriteParam;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteBlinkOverwriteOption">();
	}
	static class UEmoteBlinkOverwriteOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteBlinkOverwriteOption>();
	}
};
static_assert(alignof(UEmoteBlinkOverwriteOption) == 0x000008, "Wrong alignment on UEmoteBlinkOverwriteOption");
static_assert(sizeof(UEmoteBlinkOverwriteOption) == 0x000038, "Wrong size on UEmoteBlinkOverwriteOption");
static_assert(offsetof(UEmoteBlinkOverwriteOption, OverwriteParam) == 0x000030, "Member 'UEmoteBlinkOverwriteOption::OverwriteParam' has a wrong offset!");

// Class DarwinGame.SoundPatternControlComponent
// 0x0010 (0x00C8 - 0x00B8)
class USoundPatternControlComponent final : public UFieldObjectComponentBase
{
public:
	TArray<class UPointEnvironmentSoundBase*>     mSoundList;                                        // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPattern(EEnvironmentSoundPatternID ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPatternControlComponent">();
	}
	static class USoundPatternControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPatternControlComponent>();
	}
};
static_assert(alignof(USoundPatternControlComponent) == 0x000008, "Wrong alignment on USoundPatternControlComponent");
static_assert(sizeof(USoundPatternControlComponent) == 0x0000C8, "Wrong size on USoundPatternControlComponent");
static_assert(offsetof(USoundPatternControlComponent, mSoundList) == 0x0000B8, "Member 'USoundPatternControlComponent::mSoundList' has a wrong offset!");

// Class DarwinGame.AreaOfEffectControlComponent
// 0x0040 (0x00F8 - 0x00B8)
class UAreaOfEffectControlComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadTargetAreaInfo(class FName ID);
	void TargetAreaPlayEnd();
	void TargetAreaPlayStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaOfEffectControlComponent">();
	}
	static class UAreaOfEffectControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaOfEffectControlComponent>();
	}
};
static_assert(alignof(UAreaOfEffectControlComponent) == 0x000008, "Wrong alignment on UAreaOfEffectControlComponent");
static_assert(sizeof(UAreaOfEffectControlComponent) == 0x0000F8, "Wrong size on UAreaOfEffectControlComponent");

// Class DarwinGame.UICategory_SortIconChoice
// 0x0010 (0x0540 - 0x0530)
class UUICategory_SortIconChoice final : public UUIScrollMenuItemBase
{
public:
	class UImage*                                 CategoryIcon;                                      // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_SortIconChoice">();
	}
	static class UUICategory_SortIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_SortIconChoice>();
	}
};
static_assert(alignof(UUICategory_SortIconChoice) == 0x000008, "Wrong alignment on UUICategory_SortIconChoice");
static_assert(sizeof(UUICategory_SortIconChoice) == 0x000540, "Wrong size on UUICategory_SortIconChoice");
static_assert(offsetof(UUICategory_SortIconChoice, CategoryIcon) == 0x000530, "Member 'UUICategory_SortIconChoice::CategoryIcon' has a wrong offset!");

// Class DarwinGame.EffectSceneCapture
// 0x0010 (0x0390 - 0x0380)
class AEffectSceneCapture final : public ASceneCaptureTwoCameraBase
{
public:
	TArray<class AEffectBase*>                    EffectList;                                        // 0x0380(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectSceneCapture">();
	}
	static class AEffectSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectSceneCapture>();
	}
};
static_assert(alignof(AEffectSceneCapture) == 0x000010, "Wrong alignment on AEffectSceneCapture");
static_assert(sizeof(AEffectSceneCapture) == 0x000390, "Wrong size on AEffectSceneCapture");
static_assert(offsetof(AEffectSceneCapture, EffectList) == 0x000380, "Member 'AEffectSceneCapture::EffectList' has a wrong offset!");

// Class DarwinGame.AreaOfEffectDecalComponet
// 0x0010 (0x0250 - 0x0240)
class UAreaOfEffectDecalComponet final : public UDecalComponent
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeComplete(EAoEDecalState FadeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaOfEffectDecalComponet">();
	}
	static class UAreaOfEffectDecalComponet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaOfEffectDecalComponet>();
	}
};
static_assert(alignof(UAreaOfEffectDecalComponet) == 0x000010, "Wrong alignment on UAreaOfEffectDecalComponet");
static_assert(sizeof(UAreaOfEffectDecalComponet) == 0x000250, "Wrong size on UAreaOfEffectDecalComponet");

// Class DarwinGame.StateComponent
// 0x0178 (0x0230 - 0x00B8)
class UStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x178];                                     // 0x00B8(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeAbnormalState(const struct FGameplayTag& NextAbnormalStateTag, bool End);
	void ChangeActionState(const struct FGameplayTag& NextActionStateTag);
	void ChangeActionStateWithResult(const struct FGameplayTag& NextActionStateTag, const struct FActionResult& ActionResult);
	void ChangeEventState(const struct FGameplayTag& NextEventStateTag);
	void ChangeMoveState(const struct FGameplayTag& NextMoveStateTag);
	void Initialize(const class FName OriginKindID);
	void Move(const struct FVector& Input);
	void ResetState();
	void SetEnableInput(bool Enabled);
	void TakeAction(const struct FGameplayTag& ActionTag, bool bRelease);

	TMap<struct FGameplayTag, class UActionStateBase*> GetActionStateList() const;
	class UActionStateBase* GetCurrentActionState() const;
	class UStateBase* GetCurrentState() const;
	TMap<struct FGameplayTag, class UStateBase*> GetMoveStateList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateComponent">();
	}
	static class UStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateComponent>();
	}
};
static_assert(alignof(UStateComponent) == 0x000008, "Wrong alignment on UStateComponent");
static_assert(sizeof(UStateComponent) == 0x000230, "Wrong size on UStateComponent");

// Class DarwinGame.EstimatedPriceUpSceneCapture
// 0x0080 (0x03F0 - 0x0370)
class AEstimatedPriceUpSceneCapture final : public ASceneCaptureBase
{
public:
	TSubclassOf<class AEffectBase>                GlitterEffectRes;                                  // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                AfterGlowEffectRes;                                // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                FlashEffectRes;                                    // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEstimateLighting>          LightRes;                                          // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            Glitter;                                           // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            AfterGlow;                                         // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            Flash;                                             // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEstimateLighting*                      LightActor;                                        // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x40];                                     // 0x03B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimatedPriceUpSceneCapture">();
	}
	static class AEstimatedPriceUpSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimatedPriceUpSceneCapture>();
	}
};
static_assert(alignof(AEstimatedPriceUpSceneCapture) == 0x000010, "Wrong alignment on AEstimatedPriceUpSceneCapture");
static_assert(sizeof(AEstimatedPriceUpSceneCapture) == 0x0003F0, "Wrong size on AEstimatedPriceUpSceneCapture");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, GlitterEffectRes) == 0x000370, "Member 'AEstimatedPriceUpSceneCapture::GlitterEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, AfterGlowEffectRes) == 0x000378, "Member 'AEstimatedPriceUpSceneCapture::AfterGlowEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, FlashEffectRes) == 0x000380, "Member 'AEstimatedPriceUpSceneCapture::FlashEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, LightRes) == 0x000388, "Member 'AEstimatedPriceUpSceneCapture::LightRes' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, Glitter) == 0x000390, "Member 'AEstimatedPriceUpSceneCapture::Glitter' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, AfterGlow) == 0x000398, "Member 'AEstimatedPriceUpSceneCapture::AfterGlow' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, Flash) == 0x0003A0, "Member 'AEstimatedPriceUpSceneCapture::Flash' has a wrong offset!");
static_assert(offsetof(AEstimatedPriceUpSceneCapture, LightActor) == 0x0003A8, "Member 'AEstimatedPriceUpSceneCapture::LightActor' has a wrong offset!");

// Class DarwinGame.AreaOfEffectManager
// 0x0078 (0x00B0 - 0x0038)
class UAreaOfEffectManager final : public UManagerBase
{
public:
	TSoftClassPtr<class UClass>                   RectAngleAoEClass;                                 // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SectorAoEClass;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             SectorMaterialTable;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAreaOfEffectManager* GetInstance();

	class UMaterialInterface* LoadSectorAoEMaterial(ESectorAoEAngle Type);
	class ARectangleAreaOfEffect* SpawnRectangleAreaOfEffect(const struct FVector2D& Size, float DecalHeight, const struct FVector& WorldLoc, const struct FRotator& WorldRot, const struct FVector& WorldScale);
	class ASectorAreaOfEffect* SpawnSectorAreaOfEffect(float Radius, float DecalHeight, ESectorAoEAngle AngleType, const struct FVector& WorldLoc, const struct FRotator& WorldRot, const struct FVector& WorldScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaOfEffectManager">();
	}
	static class UAreaOfEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaOfEffectManager>();
	}
};
static_assert(alignof(UAreaOfEffectManager) == 0x000008, "Wrong alignment on UAreaOfEffectManager");
static_assert(sizeof(UAreaOfEffectManager) == 0x0000B0, "Wrong size on UAreaOfEffectManager");
static_assert(offsetof(UAreaOfEffectManager, RectAngleAoEClass) == 0x000038, "Member 'UAreaOfEffectManager::RectAngleAoEClass' has a wrong offset!");
static_assert(offsetof(UAreaOfEffectManager, SectorAoEClass) == 0x000060, "Member 'UAreaOfEffectManager::SectorAoEClass' has a wrong offset!");
static_assert(offsetof(UAreaOfEffectManager, SectorMaterialTable) == 0x0000A8, "Member 'UAreaOfEffectManager::SectorMaterialTable' has a wrong offset!");

// Class DarwinGame.AreaSoundCollision
// 0x0018 (0x0240 - 0x0228)
class AAreaSoundCollision : public AActor
{
public:
	EAreaSoundType                                AreaType;                                          // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAreaSoundCollisionType                       CollisionType;                                     // 0x0229(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionScale;                                    // 0x022C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShapeComponent*                        mCollision;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaSoundCollision">();
	}
	static class AAreaSoundCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAreaSoundCollision>();
	}
};
static_assert(alignof(AAreaSoundCollision) == 0x000008, "Wrong alignment on AAreaSoundCollision");
static_assert(sizeof(AAreaSoundCollision) == 0x000240, "Wrong size on AAreaSoundCollision");
static_assert(offsetof(AAreaSoundCollision, AreaType) == 0x000228, "Member 'AAreaSoundCollision::AreaType' has a wrong offset!");
static_assert(offsetof(AAreaSoundCollision, CollisionType) == 0x000229, "Member 'AAreaSoundCollision::CollisionType' has a wrong offset!");
static_assert(offsetof(AAreaSoundCollision, CollisionScale) == 0x00022C, "Member 'AAreaSoundCollision::CollisionScale' has a wrong offset!");
static_assert(offsetof(AAreaSoundCollision, mCollision) == 0x000238, "Member 'AAreaSoundCollision::mCollision' has a wrong offset!");

// Class DarwinGame.TextManager
// 0x01B8 (0x01F0 - 0x0038)
class UTextManager : public UManagerBase
{
public:
	class UDataTable*                             DT_NPCList;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_SerifuDataCS;                                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_SerifuDataIE;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_SerifuDataSIE;                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_SerifuDataFukidashi;                            // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              mNPCListDT;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mSerifuDataCS_DT;                                  // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mSerifuDataSIE_DT;                                 // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mSerifuDataIE_DT;                                  // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mSerifuDataFukidashi_DT;                           // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mColorTagTableDT;                                  // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mStampTagTableDT;                                  // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mEventReplaceTextDT;                               // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UDataTable>              mEventPairReplaceTextDT;                           // 0x01A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_ColorTagTable;                                  // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_StampTagTable;                                  // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_EventReplaceText;                               // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_EventPairReplaceText;                           // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static const class FName ETextDataType_Fukidasi();
	static const class FName ETextDataType_None();
	static const class FName ETextDataType_Reference();
	static const class FName ETextDataType_Serifu();
	static const class FName ETextDataType_SystemMessage();
	static class UTextManager* GetInstance();

	class UDataTable* getNPCList();
	void SetLanguageSetting(const ETextLanguage newSetting);

	class UDataTable* GetColorTagTable() const;
	class UDataTable* GetEventPairReplaceText() const;
	class UDataTable* GetEventReplaceText() const;
	const class FName GetFriendAppearanceID(const class FName& NpcID) const;
	const ETextLanguage GetLanguageSetting() const;
	const class FName GetNpcAppearanceID(const class FName& NpcID) const;
	class FString GetNpcDisplayName(const class FName& NpcID) const;
	const bool GetNpcDisplayNameAndCheck(const class FName& NpcID, class FString* DisplayName) const;
	const bool GetNpcInfo(const class FName& NpcID, struct FNPCInfoData* NpcInfo) const;
	void GetNpcNickName(const class FName& NpcID, class FString* NickName1, class FString* NickName2) const;
	const int32 GetNpcPartTalkerType(const class FName NpcID) const;
	const ENpcSeType GetNpcSeType(const class FName NpcID) const;
	class UDataTable* GetStampTagTable() const;
	class FString GetTextByTableName(const class FString& TableName, const class FName& TextID) const;
	class FString GetTextCS(const class FName& TextID) const;
	class FString GetTextFukidasi(const class FName& TextID) const;
	class FString GetTextIE(const class FName& TextID) const;
	struct FTextInfoWorkData GetTextInfo(const class FName& TextID) const;
	class FString GetTextSIE(const class FName& TextID) const;
	bool IsTextInfo(const class FName& TextID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextManager">();
	}
	static class UTextManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextManager>();
	}
};
static_assert(alignof(UTextManager) == 0x000008, "Wrong alignment on UTextManager");
static_assert(sizeof(UTextManager) == 0x0001F0, "Wrong size on UTextManager");
static_assert(offsetof(UTextManager, DT_NPCList) == 0x000038, "Member 'UTextManager::DT_NPCList' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_SerifuDataCS) == 0x000040, "Member 'UTextManager::DT_SerifuDataCS' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_SerifuDataIE) == 0x000048, "Member 'UTextManager::DT_SerifuDataIE' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_SerifuDataSIE) == 0x000050, "Member 'UTextManager::DT_SerifuDataSIE' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_SerifuDataFukidashi) == 0x000058, "Member 'UTextManager::DT_SerifuDataFukidashi' has a wrong offset!");
static_assert(offsetof(UTextManager, mNPCListDT) == 0x000068, "Member 'UTextManager::mNPCListDT' has a wrong offset!");
static_assert(offsetof(UTextManager, mSerifuDataCS_DT) == 0x000090, "Member 'UTextManager::mSerifuDataCS_DT' has a wrong offset!");
static_assert(offsetof(UTextManager, mSerifuDataSIE_DT) == 0x0000B8, "Member 'UTextManager::mSerifuDataSIE_DT' has a wrong offset!");
static_assert(offsetof(UTextManager, mSerifuDataIE_DT) == 0x0000E0, "Member 'UTextManager::mSerifuDataIE_DT' has a wrong offset!");
static_assert(offsetof(UTextManager, mSerifuDataFukidashi_DT) == 0x000108, "Member 'UTextManager::mSerifuDataFukidashi_DT' has a wrong offset!");
static_assert(offsetof(UTextManager, mColorTagTableDT) == 0x000130, "Member 'UTextManager::mColorTagTableDT' has a wrong offset!");
static_assert(offsetof(UTextManager, mStampTagTableDT) == 0x000158, "Member 'UTextManager::mStampTagTableDT' has a wrong offset!");
static_assert(offsetof(UTextManager, mEventReplaceTextDT) == 0x000180, "Member 'UTextManager::mEventReplaceTextDT' has a wrong offset!");
static_assert(offsetof(UTextManager, mEventPairReplaceTextDT) == 0x0001A8, "Member 'UTextManager::mEventPairReplaceTextDT' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_ColorTagTable) == 0x0001D0, "Member 'UTextManager::DT_ColorTagTable' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_StampTagTable) == 0x0001D8, "Member 'UTextManager::DT_StampTagTable' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_EventReplaceText) == 0x0001E0, "Member 'UTextManager::DT_EventReplaceText' has a wrong offset!");
static_assert(offsetof(UTextManager, DT_EventPairReplaceText) == 0x0001E8, "Member 'UTextManager::DT_EventPairReplaceText' has a wrong offset!");

// Class DarwinGame.UICoinMenu_CoinPlate_Set
// 0x0030 (0x0600 - 0x05D0)
class UUICoinMenu_CoinPlate_Set : public UUIScrollMenuBase
{
public:
	TArray<class FName>                           PanelNames;                                        // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoinHolderType                               HolderType;                                        // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0x1F];                                     // 0x05E1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_CoinPlate_Set">();
	}
	static class UUICoinMenu_CoinPlate_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_CoinPlate_Set>();
	}
};
static_assert(alignof(UUICoinMenu_CoinPlate_Set) == 0x000008, "Wrong alignment on UUICoinMenu_CoinPlate_Set");
static_assert(sizeof(UUICoinMenu_CoinPlate_Set) == 0x000600, "Wrong size on UUICoinMenu_CoinPlate_Set");
static_assert(offsetof(UUICoinMenu_CoinPlate_Set, PanelNames) == 0x0005D0, "Member 'UUICoinMenu_CoinPlate_Set::PanelNames' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinPlate_Set, HolderType) == 0x0005E0, "Member 'UUICoinMenu_CoinPlate_Set::HolderType' has a wrong offset!");

// Class DarwinGame.DebugPeriodicSlowdownTest
// 0x0010 (0x0040 - 0x0030)
class UDebugPeriodicSlowdownTest final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPeriodicSlowdownTest">();
	}
	static class UDebugPeriodicSlowdownTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugPeriodicSlowdownTest>();
	}
};
static_assert(alignof(UDebugPeriodicSlowdownTest) == 0x000008, "Wrong alignment on UDebugPeriodicSlowdownTest");
static_assert(sizeof(UDebugPeriodicSlowdownTest) == 0x000040, "Wrong size on UDebugPeriodicSlowdownTest");

// Class DarwinGame.CaptureLightBase
// 0x0000 (0x0228 - 0x0228)
class ACaptureLightBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CaptureLightBase">();
	}
	static class ACaptureLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACaptureLightBase>();
	}
};
static_assert(alignof(ACaptureLightBase) == 0x000008, "Wrong alignment on ACaptureLightBase");
static_assert(sizeof(ACaptureLightBase) == 0x000228, "Wrong size on ACaptureLightBase");

// Class DarwinGame.MonsterEcologicalAI
// 0x0020 (0x0050 - 0x0030)
class UMonsterEcologicalAI final : public UObject
{
public:
	class FName                                   RunningEcologyMontageID;                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcWaitActionSecond(class AMonster* Monster);
	void ClearRunningEcologyMontageID();
	class FName PopRunningEcologyMontageID();
	void PushRunningEcologyMontageID(const class FName& ID);
	void SetRunningEcologyMontageID(const class FName& ID);

	const class FName GetRunningEcologyMontageID() const;
	bool IsRunningEcologyMontage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterEcologicalAI">();
	}
	static class UMonsterEcologicalAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterEcologicalAI>();
	}
};
static_assert(alignof(UMonsterEcologicalAI) == 0x000008, "Wrong alignment on UMonsterEcologicalAI");
static_assert(sizeof(UMonsterEcologicalAI) == 0x000050, "Wrong size on UMonsterEcologicalAI");
static_assert(offsetof(UMonsterEcologicalAI, RunningEcologyMontageID) == 0x000030, "Member 'UMonsterEcologicalAI::RunningEcologyMontageID' has a wrong offset!");

// Class DarwinGame.ArtifactCaptureLightBase
// 0x0028 (0x0250 - 0x0228)
class AArtifactCaptureLightBase : public ACaptureLightBase
{
public:
	class USkyLightComponent*                     SkyLightComponent;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    SpotLightComponent;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootComp;                                          // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionalLightComponent*             DirectionalLightComponent;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactCaptureLightBase">();
	}
	static class AArtifactCaptureLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactCaptureLightBase>();
	}
};
static_assert(alignof(AArtifactCaptureLightBase) == 0x000008, "Wrong alignment on AArtifactCaptureLightBase");
static_assert(sizeof(AArtifactCaptureLightBase) == 0x000250, "Wrong size on AArtifactCaptureLightBase");
static_assert(offsetof(AArtifactCaptureLightBase, SkyLightComponent) == 0x000228, "Member 'AArtifactCaptureLightBase::SkyLightComponent' has a wrong offset!");
static_assert(offsetof(AArtifactCaptureLightBase, PostProcessComponent) == 0x000230, "Member 'AArtifactCaptureLightBase::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(AArtifactCaptureLightBase, SpotLightComponent) == 0x000238, "Member 'AArtifactCaptureLightBase::SpotLightComponent' has a wrong offset!");
static_assert(offsetof(AArtifactCaptureLightBase, RootComp) == 0x000240, "Member 'AArtifactCaptureLightBase::RootComp' has a wrong offset!");
static_assert(offsetof(AArtifactCaptureLightBase, DirectionalLightComponent) == 0x000248, "Member 'AArtifactCaptureLightBase::DirectionalLightComponent' has a wrong offset!");

// Class DarwinGame.MonsterBossBattleAICheckFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBossBattleAICheckFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBossBattleAICheckFunctionLibrary">();
	}
	static class UMonsterBossBattleAICheckFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBossBattleAICheckFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBossBattleAICheckFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBossBattleAICheckFunctionLibrary");
static_assert(sizeof(UMonsterBossBattleAICheckFunctionLibrary) == 0x000030, "Wrong size on UMonsterBossBattleAICheckFunctionLibrary");

// Class DarwinGame.TargetObjectBase
// 0x0018 (0x02C8 - 0x02B0)
class ATargetObjectBase final : public AFieldObjectBase
{
public:
	EObjectBreakEffectID                          mEffectID;                                         // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mSoundID;                                          // 0x02B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0xC];                                      // 0x02BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetObjectBase">();
	}
	static class ATargetObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetObjectBase>();
	}
};
static_assert(alignof(ATargetObjectBase) == 0x000008, "Wrong alignment on ATargetObjectBase");
static_assert(sizeof(ATargetObjectBase) == 0x0002C8, "Wrong size on ATargetObjectBase");
static_assert(offsetof(ATargetObjectBase, mEffectID) == 0x0002B0, "Member 'ATargetObjectBase::mEffectID' has a wrong offset!");
static_assert(offsetof(ATargetObjectBase, mSoundID) == 0x0002B4, "Member 'ATargetObjectBase::mSoundID' has a wrong offset!");

// Class DarwinGame.ArtifactCaptureLight
// 0x0000 (0x0250 - 0x0250)
class AArtifactCaptureLight final : public AArtifactCaptureLightBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactCaptureLight">();
	}
	static class AArtifactCaptureLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactCaptureLight>();
	}
};
static_assert(alignof(AArtifactCaptureLight) == 0x000008, "Wrong alignment on AArtifactCaptureLight");
static_assert(sizeof(AArtifactCaptureLight) == 0x000250, "Wrong size on AArtifactCaptureLight");

// Class DarwinGame.EnemySpawnGeneratorFix
// 0x0000 (0x01A8 - 0x01A8)
class UEnemySpawnGeneratorFix final : public UEnemySpawnGeneratorBase
{
public:
	void SetSpawnBox(class UBoxComponent* Box);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorFix">();
	}
	static class UEnemySpawnGeneratorFix* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorFix>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorFix) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorFix");
static_assert(sizeof(UEnemySpawnGeneratorFix) == 0x0001A8, "Wrong size on UEnemySpawnGeneratorFix");

// Class DarwinGame.ArtifactFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UArtifactFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetCarryingArtifactsNum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactFunctionLibrary">();
	}
	static class UArtifactFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactFunctionLibrary>();
	}
};
static_assert(alignof(UArtifactFunctionLibrary) == 0x000008, "Wrong alignment on UArtifactFunctionLibrary");
static_assert(sizeof(UArtifactFunctionLibrary) == 0x000030, "Wrong size on UArtifactFunctionLibrary");

// Class DarwinGame.UIDispatch_MemberPanel
// 0x0040 (0x04D0 - 0x0490)
class UUIDispatch_MemberPanel final : public UDarwinUserWidget
{
public:
	TArray<struct FST_SceneCapture2DLight>        DirectionalLights;                                 // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x04A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CaptureOffset;                                     // 0x04A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinSceneCaptureImage*               CaptureImage;                                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackPanelTexture;                                  // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_MemberPanel">();
	}
	static class UUIDispatch_MemberPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_MemberPanel>();
	}
};
static_assert(alignof(UUIDispatch_MemberPanel) == 0x000008, "Wrong alignment on UUIDispatch_MemberPanel");
static_assert(sizeof(UUIDispatch_MemberPanel) == 0x0004D0, "Wrong size on UUIDispatch_MemberPanel");
static_assert(offsetof(UUIDispatch_MemberPanel, DirectionalLights) == 0x000490, "Member 'UUIDispatch_MemberPanel::DirectionalLights' has a wrong offset!");
static_assert(offsetof(UUIDispatch_MemberPanel, RenderTarget) == 0x0004A0, "Member 'UUIDispatch_MemberPanel::RenderTarget' has a wrong offset!");
static_assert(offsetof(UUIDispatch_MemberPanel, CaptureOffset) == 0x0004A8, "Member 'UUIDispatch_MemberPanel::CaptureOffset' has a wrong offset!");
static_assert(offsetof(UUIDispatch_MemberPanel, CaptureImage) == 0x0004B8, "Member 'UUIDispatch_MemberPanel::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIDispatch_MemberPanel, BackPanelTexture) == 0x0004C0, "Member 'UUIDispatch_MemberPanel::BackPanelTexture' has a wrong offset!");

// Class DarwinGame.EnemySpawnGeneratorRandom
// 0x0000 (0x01A8 - 0x01A8)
class UEnemySpawnGeneratorRandom final : public UEnemySpawnGeneratorBase
{
public:
	void SetSpawnBox(class UBoxComponent* Box);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorRandom">();
	}
	static class UEnemySpawnGeneratorRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorRandom>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorRandom) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorRandom");
static_assert(sizeof(UEnemySpawnGeneratorRandom) == 0x0001A8, "Wrong size on UEnemySpawnGeneratorRandom");

// Class DarwinGame.FieldObjectSpline
// 0x0008 (0x02B8 - 0x02B0)
class AFieldObjectSpline : public AFieldObjectBase
{
public:
	bool                                          IsLoop;                                            // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USplineComponent* GetSplineComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectSpline">();
	}
	static class AFieldObjectSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldObjectSpline>();
	}
};
static_assert(alignof(AFieldObjectSpline) == 0x000008, "Wrong alignment on AFieldObjectSpline");
static_assert(sizeof(AFieldObjectSpline) == 0x0002B8, "Wrong size on AFieldObjectSpline");
static_assert(offsetof(AFieldObjectSpline, IsLoop) == 0x0002B0, "Member 'AFieldObjectSpline::IsLoop' has a wrong offset!");

// Class DarwinGame.SplineMeshObject
// 0x0038 (0x02F0 - 0x02B8)
class ASplineMeshObject : public AFieldObjectSpline
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MeshMaterial;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESplineMeshAxis                               InForwardAxis;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SplineMeshScale;                                   // 0x02CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SpawnSplineMeshFrame;                              // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USplineMeshComponent*>           SplineMeshComponets;                               // 0x02D8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineMeshObject">();
	}
	static class ASplineMeshObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineMeshObject>();
	}
};
static_assert(alignof(ASplineMeshObject) == 0x000008, "Wrong alignment on ASplineMeshObject");
static_assert(sizeof(ASplineMeshObject) == 0x0002F0, "Wrong size on ASplineMeshObject");
static_assert(offsetof(ASplineMeshObject, StaticMesh) == 0x0002B8, "Member 'ASplineMeshObject::StaticMesh' has a wrong offset!");
static_assert(offsetof(ASplineMeshObject, MeshMaterial) == 0x0002C0, "Member 'ASplineMeshObject::MeshMaterial' has a wrong offset!");
static_assert(offsetof(ASplineMeshObject, InForwardAxis) == 0x0002C8, "Member 'ASplineMeshObject::InForwardAxis' has a wrong offset!");
static_assert(offsetof(ASplineMeshObject, SplineMeshScale) == 0x0002CC, "Member 'ASplineMeshObject::SplineMeshScale' has a wrong offset!");
static_assert(offsetof(ASplineMeshObject, SpawnSplineMeshFrame) == 0x0002D4, "Member 'ASplineMeshObject::SpawnSplineMeshFrame' has a wrong offset!");
static_assert(offsetof(ASplineMeshObject, SplineMeshComponets) == 0x0002D8, "Member 'ASplineMeshObject::SplineMeshComponets' has a wrong offset!");

// Class DarwinGame.ArtifactManager
// 0x00C8 (0x00F8 - 0x0030)
class UArtifactManager : public UObject
{
public:
	TSubclassOf<class AArtifactPoint>             PointActorOriginal;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADungeonPointNest>          DungeonActorOriginal;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class AArtifactPointBase*>  mPointList;                                        // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           mPointIDList_DungeonPointNestEvent;                // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x58];                                      // 0x00A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableArtifactPointEffect();
	void EnableArtifactPointEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactManager">();
	}
	static class UArtifactManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactManager>();
	}
};
static_assert(alignof(UArtifactManager) == 0x000008, "Wrong alignment on UArtifactManager");
static_assert(sizeof(UArtifactManager) == 0x0000F8, "Wrong size on UArtifactManager");
static_assert(offsetof(UArtifactManager, PointActorOriginal) == 0x000030, "Member 'UArtifactManager::PointActorOriginal' has a wrong offset!");
static_assert(offsetof(UArtifactManager, DungeonActorOriginal) == 0x000038, "Member 'UArtifactManager::DungeonActorOriginal' has a wrong offset!");
static_assert(offsetof(UArtifactManager, mPointList) == 0x000040, "Member 'UArtifactManager::mPointList' has a wrong offset!");
static_assert(offsetof(UArtifactManager, mPointIDList_DungeonPointNestEvent) == 0x000090, "Member 'UArtifactManager::mPointIDList_DungeonPointNestEvent' has a wrong offset!");

// Class DarwinGame.EndConditionOfFlag
// 0x0020 (0x0260 - 0x0240)
class AEndConditionOfFlag final : public AForcedBattleEndCondition
{
public:
	uint8                                         Pad_240[0x20];                                     // 0x0240(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndConditionOfFlag">();
	}
	static class AEndConditionOfFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndConditionOfFlag>();
	}
};
static_assert(alignof(AEndConditionOfFlag) == 0x000008, "Wrong alignment on AEndConditionOfFlag");
static_assert(sizeof(AEndConditionOfFlag) == 0x000260, "Wrong size on AEndConditionOfFlag");

// Class DarwinGame.ArtifactPointDataAsset
// 0x02B8 (0x02F0 - 0x0038)
class UArtifactPointDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_ArtifactPointEventCheckData> CheckList;                                         // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                DungeonSetting;                                    // 0x0088(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FST_ArtifactPointSetting               mPointSetting;                                     // 0x00D8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         mDungeonSpawnTeamLevel;                            // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         mDungeonSpawnPercent;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         mJunkSpawnPercent;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LogInterval;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         mNotHaveArtifactProbability;                       // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            mTeamLevelDifficultyList;                          // 0x00F8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	int32                                         AutoTreasureDLOnce;                                // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAreaType, int32>                        AutoTreasurePointNum;                              // 0x0150(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FST_ArtifactPointData> list;                                              // 0x01A0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, int32>                            ReactionRange;                                     // 0x01F0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, int32>                            ReactionRangeNotMillion;                           // 0x0240(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<int32>                                 mQualityProbabilityList;                           // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_ArtifactRarityProbability> mArtifactRarityProbabilityList;                    // 0x02A0(0x0050)(Edit, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactPointDataAsset">();
	}
	static class UArtifactPointDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactPointDataAsset>();
	}
};
static_assert(alignof(UArtifactPointDataAsset) == 0x000008, "Wrong alignment on UArtifactPointDataAsset");
static_assert(sizeof(UArtifactPointDataAsset) == 0x0002F0, "Wrong size on UArtifactPointDataAsset");
static_assert(offsetof(UArtifactPointDataAsset, CheckList) == 0x000038, "Member 'UArtifactPointDataAsset::CheckList' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, DungeonSetting) == 0x000088, "Member 'UArtifactPointDataAsset::DungeonSetting' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mPointSetting) == 0x0000D8, "Member 'UArtifactPointDataAsset::mPointSetting' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mDungeonSpawnTeamLevel) == 0x0000E0, "Member 'UArtifactPointDataAsset::mDungeonSpawnTeamLevel' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mDungeonSpawnPercent) == 0x0000E4, "Member 'UArtifactPointDataAsset::mDungeonSpawnPercent' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mJunkSpawnPercent) == 0x0000E8, "Member 'UArtifactPointDataAsset::mJunkSpawnPercent' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, LogInterval) == 0x0000EC, "Member 'UArtifactPointDataAsset::LogInterval' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mNotHaveArtifactProbability) == 0x0000F0, "Member 'UArtifactPointDataAsset::mNotHaveArtifactProbability' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mTeamLevelDifficultyList) == 0x0000F8, "Member 'UArtifactPointDataAsset::mTeamLevelDifficultyList' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, AutoTreasureDLOnce) == 0x000148, "Member 'UArtifactPointDataAsset::AutoTreasureDLOnce' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, AutoTreasurePointNum) == 0x000150, "Member 'UArtifactPointDataAsset::AutoTreasurePointNum' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, list) == 0x0001A0, "Member 'UArtifactPointDataAsset::list' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, ReactionRange) == 0x0001F0, "Member 'UArtifactPointDataAsset::ReactionRange' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, ReactionRangeNotMillion) == 0x000240, "Member 'UArtifactPointDataAsset::ReactionRangeNotMillion' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mQualityProbabilityList) == 0x000290, "Member 'UArtifactPointDataAsset::mQualityProbabilityList' has a wrong offset!");
static_assert(offsetof(UArtifactPointDataAsset, mArtifactRarityProbabilityList) == 0x0002A0, "Member 'UArtifactPointDataAsset::mArtifactRarityProbabilityList' has a wrong offset!");

// Class DarwinGame.UIBaseBattle_Logo_00
// 0x0060 (0x04F0 - 0x0490)
class UUIBaseBattle_Logo_00 final : public UDarwinUserWidget
{
public:
	class UDataTable*                             FlagDataTable;                                     // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FlagImage;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OpenAnim;                                          // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       CloseAnim;                                         // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x38];                                     // 0x04B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCloseAnimation();
	void EndOpenAnimation();
	void EndWaitAnimation();
	void SetBaseBattleType(EBaseBattleType Type, bool isEnableCloseAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseBattle_Logo_00">();
	}
	static class UUIBaseBattle_Logo_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBaseBattle_Logo_00>();
	}
};
static_assert(alignof(UUIBaseBattle_Logo_00) == 0x000008, "Wrong alignment on UUIBaseBattle_Logo_00");
static_assert(sizeof(UUIBaseBattle_Logo_00) == 0x0004F0, "Wrong size on UUIBaseBattle_Logo_00");
static_assert(offsetof(UUIBaseBattle_Logo_00, FlagDataTable) == 0x000490, "Member 'UUIBaseBattle_Logo_00::FlagDataTable' has a wrong offset!");
static_assert(offsetof(UUIBaseBattle_Logo_00, FlagImage) == 0x000498, "Member 'UUIBaseBattle_Logo_00::FlagImage' has a wrong offset!");
static_assert(offsetof(UUIBaseBattle_Logo_00, OpenAnim) == 0x0004A0, "Member 'UUIBaseBattle_Logo_00::OpenAnim' has a wrong offset!");
static_assert(offsetof(UUIBaseBattle_Logo_00, WaitAnim) == 0x0004A8, "Member 'UUIBaseBattle_Logo_00::WaitAnim' has a wrong offset!");
static_assert(offsetof(UUIBaseBattle_Logo_00, CloseAnim) == 0x0004B0, "Member 'UUIBaseBattle_Logo_00::CloseAnim' has a wrong offset!");

// Class DarwinGame.ArtifactPointDataTable
// 0x0000 (0x0030 - 0x0030)
class UArtifactPointDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactPointDataTable">();
	}
	static class UArtifactPointDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactPointDataTable>();
	}
};
static_assert(alignof(UArtifactPointDataTable) == 0x000008, "Wrong alignment on UArtifactPointDataTable");
static_assert(sizeof(UArtifactPointDataTable) == 0x000030, "Wrong size on UArtifactPointDataTable");

// Class DarwinGame.ArtifactPointMarker
// 0x0000 (0x0228 - 0x0228)
class AArtifactPointMarker final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactPointMarker">();
	}
	static class AArtifactPointMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArtifactPointMarker>();
	}
};
static_assert(alignof(AArtifactPointMarker) == 0x000008, "Wrong alignment on AArtifactPointMarker");
static_assert(sizeof(AArtifactPointMarker) == 0x000228, "Wrong size on AArtifactPointMarker");

// Class DarwinGame.AttachObjectBase
// 0x0030 (0x0258 - 0x0228)
class AAttachObjectBase : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         EquipmentMesh;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDitheringComponent*                    Dithering;                                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDefaultHidden;                                    // 0x0250(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDitheringComponent* GetDitheringComponent() const;
	class USkeletalMeshComponent* GetSkeletalMesh() const;
	class UStaticMeshComponent* GetStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachObjectBase">();
	}
	static class AAttachObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttachObjectBase>();
	}
};
static_assert(alignof(AAttachObjectBase) == 0x000008, "Wrong alignment on AAttachObjectBase");
static_assert(sizeof(AAttachObjectBase) == 0x000258, "Wrong size on AAttachObjectBase");
static_assert(offsetof(AAttachObjectBase, DefaultSceneRoot) == 0x000238, "Member 'AAttachObjectBase::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AAttachObjectBase, EquipmentMesh) == 0x000240, "Member 'AAttachObjectBase::EquipmentMesh' has a wrong offset!");
static_assert(offsetof(AAttachObjectBase, Dithering) == 0x000248, "Member 'AAttachObjectBase::Dithering' has a wrong offset!");
static_assert(offsetof(AAttachObjectBase, bDefaultHidden) == 0x000250, "Member 'AAttachObjectBase::bDefaultHidden' has a wrong offset!");

// Class DarwinGame.OutbreakQuestGimmickBase
// 0x0028 (0x02D8 - 0x02B0)
class AOutbreakQuestGimmickBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestGimmickBase">();
	}
	static class AOutbreakQuestGimmickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestGimmickBase>();
	}
};
static_assert(alignof(AOutbreakQuestGimmickBase) == 0x000008, "Wrong alignment on AOutbreakQuestGimmickBase");
static_assert(sizeof(AOutbreakQuestGimmickBase) == 0x0002D8, "Wrong size on AOutbreakQuestGimmickBase");

// Class DarwinGame.OutbreakQuestDiscoveryMetal
// 0x0020 (0x02F8 - 0x02D8)
class AOutbreakQuestDiscoveryMetal final : public AOutbreakQuestGimmickBase
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterSpawnedCallbackHolder*          spawnedCallback;                                   // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestDiscoveryMetal">();
	}
	static class AOutbreakQuestDiscoveryMetal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestDiscoveryMetal>();
	}
};
static_assert(alignof(AOutbreakQuestDiscoveryMetal) == 0x000008, "Wrong alignment on AOutbreakQuestDiscoveryMetal");
static_assert(sizeof(AOutbreakQuestDiscoveryMetal) == 0x0002F8, "Wrong size on AOutbreakQuestDiscoveryMetal");
static_assert(offsetof(AOutbreakQuestDiscoveryMetal, spawnedCallback) == 0x0002E8, "Member 'AOutbreakQuestDiscoveryMetal::spawnedCallback' has a wrong offset!");

// Class DarwinGame.AttackCollisionClassDataTable
// 0x0000 (0x0030 - 0x0030)
class UAttackCollisionClassDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackCollisionClassDataTable">();
	}
	static class UAttackCollisionClassDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackCollisionClassDataTable>();
	}
};
static_assert(alignof(UAttackCollisionClassDataTable) == 0x000008, "Wrong alignment on UAttackCollisionClassDataTable");
static_assert(sizeof(UAttackCollisionClassDataTable) == 0x000030, "Wrong size on UAttackCollisionClassDataTable");

// Class DarwinGame.AttackElementBaseComponent
// 0x0030 (0x0230 - 0x0200)
class UAttackElementBaseComponent final : public USceneComponent
{
public:
	TMulticastInlineDelegate<void(struct FOverlapEventInfo& Info, class FName ElementID)> OnComponentHit;                                    // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ElementID;                                         // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            colliderList;                                      // 0x0218(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackElementBaseComponent">();
	}
	static class UAttackElementBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackElementBaseComponent>();
	}
};
static_assert(alignof(UAttackElementBaseComponent) == 0x000010, "Wrong alignment on UAttackElementBaseComponent");
static_assert(sizeof(UAttackElementBaseComponent) == 0x000230, "Wrong size on UAttackElementBaseComponent");
static_assert(offsetof(UAttackElementBaseComponent, OnComponentHit) == 0x000200, "Member 'UAttackElementBaseComponent::OnComponentHit' has a wrong offset!");
static_assert(offsetof(UAttackElementBaseComponent, ElementID) == 0x000210, "Member 'UAttackElementBaseComponent::ElementID' has a wrong offset!");
static_assert(offsetof(UAttackElementBaseComponent, colliderList) == 0x000218, "Member 'UAttackElementBaseComponent::colliderList' has a wrong offset!");

// Class DarwinGame.AttributeDataTable
// 0x0000 (0x0030 - 0x0030)
class UAttributeDataTable final : public UBlueprintFunctionLibrary
{
public:
	static int32 ClampLevel(class FName ID, int32 CurrentLevel, int32 AddLevel);
	static struct FGameplayTag GetAttributeTag(class FName AttributeID);
	static bool GetBlockOccursionList(class FName AttributeID, TArray<class FName>* OutList);
	static EAttributeDurationType GetDurationType(class FName AttributeID);
	static EAttributeOtherType GetEffectOtherType(const class FName& AttributeID);
	static EStatusParamType GetEffectParamType(class FName AttributeID);
	static EFeatureSystemType GetEffectType(class FName AttributeID);
	static float GetEffectValue(class FName AttributeID, int32 Level, bool IsTarget);
	static float GetExecutionRate(class FName AttributeID, int32 Level);
	static EInfluenceAttribute GetInfluenceType(class FName AttributeID, int32 Level);
	static EInfluenceAttribute GetOriginalInfluenceType(class FName AttributeID);
	static EAttributeProcessPolicy GetProcessPolicy(const class FName& AttributeID);
	static void GetReleasedTagsByDamage(bool bTargetIsEnemy, struct FGameplayTagContainer* ReleaseTags);
	static void GetReleaseTags(class FName AttributeID, struct FGameplayTagContainer* ReleaseTags);
	static void GetRequirementTags(class FName AttributeID, struct FGameplayTagContainer* RequirementTags);
	static class FName GetStatusIconID(class FName AttributeID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeDataTable">();
	}
	static class UAttributeDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeDataTable>();
	}
};
static_assert(alignof(UAttributeDataTable) == 0x000008, "Wrong alignment on UAttributeDataTable");
static_assert(sizeof(UAttributeDataTable) == 0x000030, "Wrong size on UAttributeDataTable");

// Class DarwinGame.OriginParameterDataTable
// 0x0000 (0x0030 - 0x0030)
class UOriginParameterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static TArray<TSoftClassPtr<class UClass>> GetAbilityClassList(class FName OriginID);
	static TMap<struct FGameplayTag, TSubclassOf<class UActionStateBase>> GetActionStateClassMap(class FName OriginID);
	static struct FGameplayTag GetDefaultMoveState(class FName OriginID);
	static struct FGameplayTagContainer GetEnableMoveStateTagList(class FName OriginID);
	static TMap<struct FGameplayTag, TSubclassOf<class UEventStateBase>> GetEventStateClassMap(class FName OriginID);
	static TMap<struct FGameplayTag, TSubclassOf<class UStateBase>> GetMoveStateClassMap(class FName OriginID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OriginParameterDataTable">();
	}
	static class UOriginParameterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOriginParameterDataTable>();
	}
};
static_assert(alignof(UOriginParameterDataTable) == 0x000008, "Wrong alignment on UOriginParameterDataTable");
static_assert(sizeof(UOriginParameterDataTable) == 0x000030, "Wrong size on UOriginParameterDataTable");

// Class DarwinGame.UIField_WinEnemy
// 0x00B0 (0x0660 - 0x05B0)
class UUIField_WinEnemy : public UUI3DBase
{
public:
	class UDataTable*                             LevelColorTable;                                   // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x80];                                     // 0x05B0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIGaugeBase*                           HPGauge;                                           // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             LevelText;                                         // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         IconList;                                          // 0x0640(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISpirit_Gauge*                        SpiritGauge;                                       // 0x0650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             NameText;                                          // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank);
	void ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList);
	void DebugSetIsHideFlag(bool bFlag);
	void DeleteAllStatusIcon();
	void DeleteStatusIcon(const class FName& StatusParameterID);
	class UUISpirit_Gauge* GetSpiritGauge();
	void InitData(int32 InHP, int32 InMaxHP, int32 InLevel);
	void SetHP(int32 InHP);
	void SetLevel(int32 InLevel);
	void SetMaxHP(int32 InMaxHP);
	void SetName(const class FText& InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinEnemy">();
	}
	static class UUIField_WinEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinEnemy>();
	}
};
static_assert(alignof(UUIField_WinEnemy) == 0x000010, "Wrong alignment on UUIField_WinEnemy");
static_assert(sizeof(UUIField_WinEnemy) == 0x000660, "Wrong size on UUIField_WinEnemy");
static_assert(offsetof(UUIField_WinEnemy, LevelColorTable) == 0x0005A8, "Member 'UUIField_WinEnemy::LevelColorTable' has a wrong offset!");
static_assert(offsetof(UUIField_WinEnemy, HPGauge) == 0x000630, "Member 'UUIField_WinEnemy::HPGauge' has a wrong offset!");
static_assert(offsetof(UUIField_WinEnemy, LevelText) == 0x000638, "Member 'UUIField_WinEnemy::LevelText' has a wrong offset!");
static_assert(offsetof(UUIField_WinEnemy, IconList) == 0x000640, "Member 'UUIField_WinEnemy::IconList' has a wrong offset!");
static_assert(offsetof(UUIField_WinEnemy, SpiritGauge) == 0x000650, "Member 'UUIField_WinEnemy::SpiritGauge' has a wrong offset!");
static_assert(offsetof(UUIField_WinEnemy, NameText) == 0x000658, "Member 'UUIField_WinEnemy::NameText' has a wrong offset!");

// Class DarwinGame.AttributeFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UAttributeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool K2_IsSeal(const class AGPACharacter* Target, EAttributeProcessPolicy Policy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeFunctionLibrary">();
	}
	static class UAttributeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeFunctionLibrary>();
	}
};
static_assert(alignof(UAttributeFunctionLibrary) == 0x000008, "Wrong alignment on UAttributeFunctionLibrary");
static_assert(sizeof(UAttributeFunctionLibrary) == 0x000030, "Wrong size on UAttributeFunctionLibrary");

// Class DarwinGame.DarwinGameplayEffect
// 0x0000 (0x07C0 - 0x07C0)
class UDarwinGameplayEffect : public UGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinGameplayEffect">();
	}
	static class UDarwinGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinGameplayEffect>();
	}
};
static_assert(alignof(UDarwinGameplayEffect) == 0x000008, "Wrong alignment on UDarwinGameplayEffect");
static_assert(sizeof(UDarwinGameplayEffect) == 0x0007C0, "Wrong size on UDarwinGameplayEffect");

// Class DarwinGame.FieldObjectBasicBase
// 0x0000 (0x0238 - 0x0238)
class AFieldObjectBasicBase : public AFieldObjectActorTemplate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectBasicBase">();
	}
	static class AFieldObjectBasicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldObjectBasicBase>();
	}
};
static_assert(alignof(AFieldObjectBasicBase) == 0x000008, "Wrong alignment on AFieldObjectBasicBase");
static_assert(sizeof(AFieldObjectBasicBase) == 0x000238, "Wrong size on AFieldObjectBasicBase");

// Class DarwinGame.OutbreakQuestPointMaker
// 0x0000 (0x0238 - 0x0238)
class AOutbreakQuestPointMaker final : public AFieldObjectBasicBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestPointMaker">();
	}
	static class AOutbreakQuestPointMaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestPointMaker>();
	}
};
static_assert(alignof(AOutbreakQuestPointMaker) == 0x000008, "Wrong alignment on AOutbreakQuestPointMaker");
static_assert(sizeof(AOutbreakQuestPointMaker) == 0x000238, "Wrong size on AOutbreakQuestPointMaker");

// Class DarwinGame.AttributeGameplayEffect
// 0x0008 (0x07C8 - 0x07C0)
class UAttributeGameplayEffect : public UDarwinGameplayEffect
{
public:
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeGameplayEffect">();
	}
	static class UAttributeGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeGameplayEffect>();
	}
};
static_assert(alignof(UAttributeGameplayEffect) == 0x000008, "Wrong alignment on UAttributeGameplayEffect");
static_assert(sizeof(UAttributeGameplayEffect) == 0x0007C8, "Wrong size on UAttributeGameplayEffect");

// Class DarwinGame.AutoTextBlock
// 0x0028 (0x02D0 - 0x02A8)
class UAutoTextBlock final : public UTextBlock
{
public:
	struct FVector2D                              DefaultDesiredSize;                                // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x20];                                     // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoTextBlock">();
	}
	static class UAutoTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoTextBlock>();
	}
};
static_assert(alignof(UAutoTextBlock) == 0x000008, "Wrong alignment on UAutoTextBlock");
static_assert(sizeof(UAutoTextBlock) == 0x0002D0, "Wrong size on UAutoTextBlock");
static_assert(offsetof(UAutoTextBlock, DefaultDesiredSize) == 0x0002A8, "Member 'UAutoTextBlock::DefaultDesiredSize' has a wrong offset!");

// Class DarwinGame.AvatarDataTable
// 0x0000 (0x0030 - 0x0030)
class UAvatarDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvatarDataTable">();
	}
	static class UAvatarDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvatarDataTable>();
	}
};
static_assert(alignof(UAvatarDataTable) == 0x000008, "Wrong alignment on UAvatarDataTable");
static_assert(sizeof(UAvatarDataTable) == 0x000030, "Wrong size on UAvatarDataTable");

// Class DarwinGame.UI3DDispatchDirectingDataTable
// 0x0000 (0x0030 - 0x0030)
class UUI3DDispatchDirectingDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI3DDispatchDirectingDataTable">();
	}
	static class UUI3DDispatchDirectingDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI3DDispatchDirectingDataTable>();
	}
};
static_assert(alignof(UUI3DDispatchDirectingDataTable) == 0x000008, "Wrong alignment on UUI3DDispatchDirectingDataTable");
static_assert(sizeof(UUI3DDispatchDirectingDataTable) == 0x000030, "Wrong size on UUI3DDispatchDirectingDataTable");

// Class DarwinGame.BaseAreaBattle
// 0x0048 (0x02F8 - 0x02B0)
class ABaseAreaBattle final : public AFieldObjectBase
{
public:
	class FName                                   mFastTravelIDToHomeArea;                           // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x38];                                     // 0x02B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseAreaBattleMonsterBeginCallbackHolder* mCallBackHolder;                                   // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MonserDefeatCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaBattle">();
	}
	static class ABaseAreaBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseAreaBattle>();
	}
};
static_assert(alignof(ABaseAreaBattle) == 0x000008, "Wrong alignment on ABaseAreaBattle");
static_assert(sizeof(ABaseAreaBattle) == 0x0002F8, "Wrong size on ABaseAreaBattle");
static_assert(offsetof(ABaseAreaBattle, mFastTravelIDToHomeArea) == 0x0002B0, "Member 'ABaseAreaBattle::mFastTravelIDToHomeArea' has a wrong offset!");
static_assert(offsetof(ABaseAreaBattle, mCallBackHolder) == 0x0002F0, "Member 'ABaseAreaBattle::mCallBackHolder' has a wrong offset!");

// Class DarwinGame.OutbreakQuestPointDataAsset
// 0x00B0 (0x00E8 - 0x0038)
class UOutbreakQuestPointDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_OutbreakQuestPointData> mDataList;                                         // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, int32>                            mDifficultyMap;                                    // 0x0088(0x0050)(Edit, NativeAccessSpecifierPrivate)
	struct FVector                                mARCorrectionVector;                               // 0x00D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestPointDataAsset">();
	}
	static class UOutbreakQuestPointDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutbreakQuestPointDataAsset>();
	}
};
static_assert(alignof(UOutbreakQuestPointDataAsset) == 0x000008, "Wrong alignment on UOutbreakQuestPointDataAsset");
static_assert(sizeof(UOutbreakQuestPointDataAsset) == 0x0000E8, "Wrong size on UOutbreakQuestPointDataAsset");
static_assert(offsetof(UOutbreakQuestPointDataAsset, mDataList) == 0x000038, "Member 'UOutbreakQuestPointDataAsset::mDataList' has a wrong offset!");
static_assert(offsetof(UOutbreakQuestPointDataAsset, mDifficultyMap) == 0x000088, "Member 'UOutbreakQuestPointDataAsset::mDifficultyMap' has a wrong offset!");
static_assert(offsetof(UOutbreakQuestPointDataAsset, mARCorrectionVector) == 0x0000D8, "Member 'UOutbreakQuestPointDataAsset::mARCorrectionVector' has a wrong offset!");

// Class DarwinGame.BaseAreaBattleDataTable
// 0x0000 (0x0030 - 0x0030)
class UBaseAreaBattleDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaBattleDataTable">();
	}
	static class UBaseAreaBattleDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAreaBattleDataTable>();
	}
};
static_assert(alignof(UBaseAreaBattleDataTable) == 0x000008, "Wrong alignment on UBaseAreaBattleDataTable");
static_assert(sizeof(UBaseAreaBattleDataTable) == 0x000030, "Wrong size on UBaseAreaBattleDataTable");

// Class DarwinGame.BaseAreaBattleMonsterBeginCallbackHolder
// 0x0008 (0x0038 - 0x0030)
class UBaseAreaBattleMonsterBeginCallbackHolder final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MonserCreatedCallback(class AMonsterBase* MonsterBase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaBattleMonsterBeginCallbackHolder">();
	}
	static class UBaseAreaBattleMonsterBeginCallbackHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAreaBattleMonsterBeginCallbackHolder>();
	}
};
static_assert(alignof(UBaseAreaBattleMonsterBeginCallbackHolder) == 0x000008, "Wrong alignment on UBaseAreaBattleMonsterBeginCallbackHolder");
static_assert(sizeof(UBaseAreaBattleMonsterBeginCallbackHolder) == 0x000038, "Wrong size on UBaseAreaBattleMonsterBeginCallbackHolder");

// Class DarwinGame.UIBonus_Points_00
// 0x0018 (0x04A8 - 0x0490)
class UUIBonus_Points_00 final : public UDarwinUserWidget
{
public:
	TArray<class UImage*>                         CountList;                                         // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CountDataTable;                                    // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBonus_Points_00">();
	}
	static class UUIBonus_Points_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBonus_Points_00>();
	}
};
static_assert(alignof(UUIBonus_Points_00) == 0x000008, "Wrong alignment on UUIBonus_Points_00");
static_assert(sizeof(UUIBonus_Points_00) == 0x0004A8, "Wrong size on UUIBonus_Points_00");
static_assert(offsetof(UUIBonus_Points_00, CountList) == 0x000490, "Member 'UUIBonus_Points_00::CountList' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_00, CountDataTable) == 0x0004A0, "Member 'UUIBonus_Points_00::CountDataTable' has a wrong offset!");

// Class DarwinGame.EventManager
// 0x0148 (0x0200 - 0x00B8)
class UEventManager : public UActorComponent
{
public:
	bool                                          IsPlayEventStartFadeOut;                           // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsPlayEventEndFadeIn;                              // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsSpawnMonsterEvent;                               // 0x00BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          CancelEvent;                                       // 0x00BB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEndFinalize;                                     // 0x00BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EventSendActor;                                    // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventSender*                           EventSender;                                       // 0x00C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ResistedEventIDs;                                  // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ResetEventIds;                                     // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x58];                                      // 0x00F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class AForcedBattlePlayer*> mForcedBattlePlayers;                              // 0x0148(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	class AEventMonsterSpawnedCallback*           mCallBackHolder;                                   // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x60];                                     // 0x01A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const class FString GetDebugEventId();
	static void SetDebugEventId(const class FString& ID);

	void AutoSave(const class FName EventID);
	void DeleteEventArtifact(const class FName& EventID);
	void EventFinishMove(const class FName& EventID);
	void ForcedEndEvent(const class FName& EventID);
	class FName GetCurrentEventID();
	bool GetEventClearData(class FName EventID, struct FST_EventClearTableInfo* EventClearData);
	bool GetEventData(class FName EventID, struct FST_EventData* EventData, EQuestState QuestState);
	int32 GetReleaseStigmataNum();
	bool IsReleaseStigmataEvent(class FName EventID);
	void OnEventFinished(const class FName& EventID);
	void PlayEvent(const class FName& EventID, EQuestState QuestState);
	void PlayEventMonster(const class FName& EventID);
	void PlayEventOfItemFirstAdd(const class FName& ItemFirstAdd);
	void RemoveFriendMonster(const class FName EventID);
	void RemoveResetEvent(const class FName& EventID);
	void SetCurrentEventID(const class FName EventID);
	void SetEventSender(class UEventSender* Sender);
	void SetEventSkip(bool IsSkip);
	void SetSendEventActor(class AActor* Actor);
	void SpawnEventArtifact(const class FName& EventID);
	void SpawnRequestEventMonster(const class FName& EventID);
	void UpdateEpisode(EEpisodeType EpisodeType);
	void UpdateQuestTargetEnemyUI(int32 KindId);
	void UseEventClearItems(const class FName EventID);

	bool EventMonsterIsReady(const class FName& EventID) const;
	bool EventMonsterIsRequested(const class FName& EventID) const;
	const class AActor* GetEventSendActor() const;
	class FName GetResistedEventIDLast() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManager">();
	}
	static class UEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventManager>();
	}
};
static_assert(alignof(UEventManager) == 0x000008, "Wrong alignment on UEventManager");
static_assert(sizeof(UEventManager) == 0x000200, "Wrong size on UEventManager");
static_assert(offsetof(UEventManager, IsPlayEventStartFadeOut) == 0x0000B8, "Member 'UEventManager::IsPlayEventStartFadeOut' has a wrong offset!");
static_assert(offsetof(UEventManager, IsPlayEventEndFadeIn) == 0x0000B9, "Member 'UEventManager::IsPlayEventEndFadeIn' has a wrong offset!");
static_assert(offsetof(UEventManager, IsSpawnMonsterEvent) == 0x0000BA, "Member 'UEventManager::IsSpawnMonsterEvent' has a wrong offset!");
static_assert(offsetof(UEventManager, CancelEvent) == 0x0000BB, "Member 'UEventManager::CancelEvent' has a wrong offset!");
static_assert(offsetof(UEventManager, IsEndFinalize) == 0x0000BC, "Member 'UEventManager::IsEndFinalize' has a wrong offset!");
static_assert(offsetof(UEventManager, EventSendActor) == 0x0000C0, "Member 'UEventManager::EventSendActor' has a wrong offset!");
static_assert(offsetof(UEventManager, EventSender) == 0x0000C8, "Member 'UEventManager::EventSender' has a wrong offset!");
static_assert(offsetof(UEventManager, ResistedEventIDs) == 0x0000D0, "Member 'UEventManager::ResistedEventIDs' has a wrong offset!");
static_assert(offsetof(UEventManager, ResetEventIds) == 0x0000E0, "Member 'UEventManager::ResetEventIds' has a wrong offset!");
static_assert(offsetof(UEventManager, mForcedBattlePlayers) == 0x000148, "Member 'UEventManager::mForcedBattlePlayers' has a wrong offset!");
static_assert(offsetof(UEventManager, mCallBackHolder) == 0x000198, "Member 'UEventManager::mCallBackHolder' has a wrong offset!");

// Class DarwinGame.BaseAreaLevelUpDataTable
// 0x0000 (0x0030 - 0x0030)
class UBaseAreaLevelUpDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaLevelUpDataTable">();
	}
	static class UBaseAreaLevelUpDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAreaLevelUpDataTable>();
	}
};
static_assert(alignof(UBaseAreaLevelUpDataTable) == 0x000008, "Wrong alignment on UBaseAreaLevelUpDataTable");
static_assert(sizeof(UBaseAreaLevelUpDataTable) == 0x000030, "Wrong size on UBaseAreaLevelUpDataTable");

// Class DarwinGame.GameBelongingsCoin
// 0x0080 (0x00B0 - 0x0030)
class UGameBelongingsCoin final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddCoin(const struct FST_CoinParam& Param);
	class UGameBelongingsCoin* Clone();
	void InitCoinMenuSetting();
	void Overwrite(class UGameBelongingsCoin* game_data);
	void RemoveCoin(int32 Uid);
	void SetCoinMenuAutoEquip(ECoinAutoEquip CoinAutoEquip);
	void SetCoinMenuFilter(const TArray<ECoinFilter>& CoinFilter);
	void SetCoinMenuSort(ECoinSort CoinSort);
	void SetNew(int32 Uid, bool IsNew);

	int32 GetCapacity() const;
	bool GetCoin(int32 Uid, struct FST_CoinData* CoinData) const;
	const TMap<int32, struct FST_CoinData> GetCoinAll() const;
	ECoinAutoEquip GetCoinMenuAutoEquip() const;
	const TArray<ECoinFilter> GetCoinMenuFilter() const;
	ECoinSort GetCoinMenuSort() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBelongingsCoin">();
	}
	static class UGameBelongingsCoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBelongingsCoin>();
	}
};
static_assert(alignof(UGameBelongingsCoin) == 0x000008, "Wrong alignment on UGameBelongingsCoin");
static_assert(sizeof(UGameBelongingsCoin) == 0x0000B0, "Wrong size on UGameBelongingsCoin");

// Class DarwinGame.BaseAreaTreasureStolenFlag
// 0x0008 (0x02C0 - 0x02B8)
class ABaseAreaTreasureStolenFlag final : public AFlagBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAreaTreasureStolenFlag">();
	}
	static class ABaseAreaTreasureStolenFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseAreaTreasureStolenFlag>();
	}
};
static_assert(alignof(ABaseAreaTreasureStolenFlag) == 0x000008, "Wrong alignment on ABaseAreaTreasureStolenFlag");
static_assert(sizeof(ABaseAreaTreasureStolenFlag) == 0x0002C0, "Wrong size on ABaseAreaTreasureStolenFlag");

// Class DarwinGame.EnergyMaterialControlComponent
// 0x0018 (0x00D0 - 0x00B8)
class UEnergyMaterialControlComponent final : public UFieldObjectComponentBase
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEnergyValue(float Value);
	void SetEnergyValue(float Value);
	void SetRelease();
	void SetSeal();
	void ToRelease(float Time);
	void ToSeal(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnergyMaterialControlComponent">();
	}
	static class UEnergyMaterialControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnergyMaterialControlComponent>();
	}
};
static_assert(alignof(UEnergyMaterialControlComponent) == 0x000008, "Wrong alignment on UEnergyMaterialControlComponent");
static_assert(sizeof(UEnergyMaterialControlComponent) == 0x0000D0, "Wrong size on UEnergyMaterialControlComponent");

// Class DarwinGame.UICategory_Set_Base
// 0x0010 (0x04A0 - 0x0490)
class UUICategory_Set_Base : public UDarwinUserWidget
{
public:
	TArray<class UUICategory_Panel_00*>           CategoryPanels;                                    // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_Set_Base">();
	}
	static class UUICategory_Set_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_Set_Base>();
	}
};
static_assert(alignof(UUICategory_Set_Base) == 0x000008, "Wrong alignment on UUICategory_Set_Base");
static_assert(sizeof(UUICategory_Set_Base) == 0x0004A0, "Wrong size on UUICategory_Set_Base");
static_assert(offsetof(UUICategory_Set_Base, CategoryPanels) == 0x000490, "Member 'UUICategory_Set_Base::CategoryPanels' has a wrong offset!");

// Class DarwinGame.EffectBase
// 0x00A8 (0x02D0 - 0x0228)
class AEffectBase : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mEffectID;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnOffset;                                       // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x74];                                     // 0x025C(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePhase(EEffectProgress NextPhase_0);
	void ChangePhaseTrail(EEffectProgress NextPhase_0, class USceneComponent* Parent, class FName soket_A, class FName soket_B, ETrailWidthMode Mode, float Width);
	void DarwinAttachToActor(class AActor* Parent, class FName socket, EDarwinCoordRule scale_rule);
	void DarwinAttachToComponent(class USceneComponent* Parent, class FName socket, EDarwinCoordRule scale_rule);
	void DarwinSetLocation(EDarwinCoordRule Rule, const struct FVector& Location);
	void DarwinSetLocationAndRotator(EDarwinCoordRule Rule, const struct FVector& Location, const struct FRotator& Rotator);
	void DarwinSetLocationAndScale(EDarwinCoordRule Rule, const struct FVector& Location, const struct FVector& Scale);
	void DarwinSetRotator(EDarwinCoordRule Rule, const struct FRotator& Rotator);
	void DarwinSetRotatorAndScale(EDarwinCoordRule Rule, const struct FRotator& Rotator, const struct FVector& Scale);
	void DarwinSetScale(EDarwinCoordRule Rule, const struct FVector& Scale);
	void DarwinSetScaleFromSize(EDarwinCoordRule Rule, EEffectSizeID SizeID);
	void DarwinSetTransform(EDarwinCoordRule Rule, const struct FVector& Location, const struct FRotator& Rotator, const struct FVector& Scale);
	void DarwinSetUsingAbsoluteRotation(const bool IsAbsoluteRotation);
	void NextPhase();
	void NextPhaseTrail(class USceneComponent* Parent, class FName soket_A, class FName soket_B, ETrailWidthMode Mode, float Width);
	void ParticleDelayPlay(const struct FTimerHandle& Handle, class UExtendParticleComponent* Component);
	void Pause(bool isPause);
	void PauseEmit(bool isPause);
	void Play();
	void PlaySound(class FName EffectId);
	void PlayTrail(class USceneComponent* Parent, class FName soket_A, class FName soket_B, ETrailWidthMode Mode, float Width);
	void SetBeamSourcePoint(int32 EmitterIndex, const struct FVector& NewSourcePoint, int32 SourceIndex);
	void SetBeamSourcePointAllEmitters(const struct FVector& NewSourcePoint, int32 SourceIndex);
	void SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex);
	void SetBeamSourceTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 SourceIndex);
	void SetBeamTargetPoint(int32 EmitterIndex, const struct FVector& NewTargetPoint, int32 TargetIndex);
	void SetBeamTargetPointAllEmitters(const struct FVector& NewTargetPoint, int32 TargetIndex);
	void SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex);
	void SetBeamTargetTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 TargetIndex);
	void Stop();
	void StopEmit();

	EEffectProgress GetCurrentPhase() const;
	class FName GetEffectID() const;
	bool GetPhasePlayComplete() const;
	bool IsComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBase">();
	}
	static class AEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectBase>();
	}
};
static_assert(alignof(AEffectBase) == 0x000008, "Wrong alignment on AEffectBase");
static_assert(sizeof(AEffectBase) == 0x0002D0, "Wrong size on AEffectBase");
static_assert(offsetof(AEffectBase, mEffectID) == 0x000238, "Member 'AEffectBase::mEffectID' has a wrong offset!");
static_assert(offsetof(AEffectBase, SpawnOffset) == 0x000250, "Member 'AEffectBase::SpawnOffset' has a wrong offset!");

// Class DarwinGame.BasicTimer
// 0x0008 (0x0038 - 0x0030)
class UBasicTimer final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasicTimer">();
	}
	static class UBasicTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasicTimer>();
	}
};
static_assert(alignof(UBasicTimer) == 0x000008, "Wrong alignment on UBasicTimer");
static_assert(sizeof(UBasicTimer) == 0x000038, "Wrong size on UBasicTimer");

// Class DarwinGame.FarEnough
// 0x0000 (0x0038 - 0x0038)
class UFarEnough final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FarEnough">();
	}
	static class UFarEnough* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFarEnough>();
	}
};
static_assert(alignof(UFarEnough) == 0x000008, "Wrong alignment on UFarEnough");
static_assert(sizeof(UFarEnough) == 0x000038, "Wrong size on UFarEnough");

// Class DarwinGame.BattleDamageGameplayEffect
// 0x0000 (0x07C0 - 0x07C0)
class UBattleDamageGameplayEffect : public UDarwinGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleDamageGameplayEffect">();
	}
	static class UBattleDamageGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleDamageGameplayEffect>();
	}
};
static_assert(alignof(UBattleDamageGameplayEffect) == 0x000008, "Wrong alignment on UBattleDamageGameplayEffect");
static_assert(sizeof(UBattleDamageGameplayEffect) == 0x0007C0, "Wrong size on UBattleDamageGameplayEffect");

// Class DarwinGame.BattleIdDataTable
// 0x0000 (0x0030 - 0x0030)
class UBattleIdDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleIdDataTable">();
	}
	static class UBattleIdDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleIdDataTable>();
	}
};
static_assert(alignof(UBattleIdDataTable) == 0x000008, "Wrong alignment on UBattleIdDataTable");
static_assert(sizeof(UBattleIdDataTable) == 0x000030, "Wrong size on UBattleIdDataTable");

// Class DarwinGame.FieldTerrainBase
// 0x0038 (0x02E8 - 0x02B0)
class AFieldTerrainBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFieldTerrainType                             TerrainType;                                       // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsWork;                                            // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceMove;                                        // 0x02BA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BB[0x1];                                      // 0x02BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceSpeed;                                        // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisableRange;                                      // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSink;                                             // 0x02C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSinkValue;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SinkSpeed;                                         // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyDamage;                                      // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EResistanceType                               Type;                                              // 0x02D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFieldTerrainEffectType                       EffectType;                                        // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D3[0x1];                                      // 0x02D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Interval;                                          // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         damageRate;                                        // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoolTime;                                          // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          mIsCorrectFloorToNear;                             // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldTerrainBase">();
	}
	static class AFieldTerrainBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldTerrainBase>();
	}
};
static_assert(alignof(AFieldTerrainBase) == 0x000008, "Wrong alignment on AFieldTerrainBase");
static_assert(sizeof(AFieldTerrainBase) == 0x0002E8, "Wrong size on AFieldTerrainBase");
static_assert(offsetof(AFieldTerrainBase, TerrainType) == 0x0002B8, "Member 'AFieldTerrainBase::TerrainType' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, IsWork) == 0x0002B9, "Member 'AFieldTerrainBase::IsWork' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, bForceMove) == 0x0002BA, "Member 'AFieldTerrainBase::bForceMove' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, ForceSpeed) == 0x0002BC, "Member 'AFieldTerrainBase::ForceSpeed' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, DisableRange) == 0x0002C0, "Member 'AFieldTerrainBase::DisableRange' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, bSink) == 0x0002C4, "Member 'AFieldTerrainBase::bSink' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, MaxSinkValue) == 0x0002C8, "Member 'AFieldTerrainBase::MaxSinkValue' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, SinkSpeed) == 0x0002CC, "Member 'AFieldTerrainBase::SinkSpeed' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, bApplyDamage) == 0x0002D0, "Member 'AFieldTerrainBase::bApplyDamage' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, Type) == 0x0002D1, "Member 'AFieldTerrainBase::Type' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, EffectType) == 0x0002D2, "Member 'AFieldTerrainBase::EffectType' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, Interval) == 0x0002D4, "Member 'AFieldTerrainBase::Interval' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, damageRate) == 0x0002D8, "Member 'AFieldTerrainBase::damageRate' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, CoolTime) == 0x0002DC, "Member 'AFieldTerrainBase::CoolTime' has a wrong offset!");
static_assert(offsetof(AFieldTerrainBase, mIsCorrectFloorToNear) == 0x0002E0, "Member 'AFieldTerrainBase::mIsCorrectFloorToNear' has a wrong offset!");

// Class DarwinGame.UICharAdd_Base
// 0x0080 (0x0510 - 0x0490)
class UUICharAdd_Base : public UDarwinUserWidget
{
public:
	class UTextBlock*                             Line1[0x2];                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Line2[0x2];                                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LineName[0x2];                                     // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ERivalTeamForce, struct FLinearColor>    ShadowTextColor;                                   // 0x04C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	bool IsPressedDecide();
	void SetNpc(class FName NpcID, ERivalTeamForce Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharAdd_Base">();
	}
	static class UUICharAdd_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharAdd_Base>();
	}
};
static_assert(alignof(UUICharAdd_Base) == 0x000008, "Wrong alignment on UUICharAdd_Base");
static_assert(sizeof(UUICharAdd_Base) == 0x000510, "Wrong size on UUICharAdd_Base");
static_assert(offsetof(UUICharAdd_Base, Line1) == 0x000490, "Member 'UUICharAdd_Base::Line1' has a wrong offset!");
static_assert(offsetof(UUICharAdd_Base, Line2) == 0x0004A0, "Member 'UUICharAdd_Base::Line2' has a wrong offset!");
static_assert(offsetof(UUICharAdd_Base, LineName) == 0x0004B0, "Member 'UUICharAdd_Base::LineName' has a wrong offset!");
static_assert(offsetof(UUICharAdd_Base, ShadowTextColor) == 0x0004C0, "Member 'UUICharAdd_Base::ShadowTextColor' has a wrong offset!");

// Class DarwinGame.UICharAdd_00
// 0x0070 (0x0580 - 0x0510)
class UUICharAdd_00 : public UUICharAdd_Base
{
public:
	float                                         ButtonVisibleWaitTime;                             // 0x0510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x6C];                                     // 0x0514(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharAdd_00">();
	}
	static class UUICharAdd_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharAdd_00>();
	}
};
static_assert(alignof(UUICharAdd_00) == 0x000008, "Wrong alignment on UUICharAdd_00");
static_assert(sizeof(UUICharAdd_00) == 0x000580, "Wrong size on UUICharAdd_00");
static_assert(offsetof(UUICharAdd_00, ButtonVisibleWaitTime) == 0x000510, "Member 'UUICharAdd_00::ButtonVisibleWaitTime' has a wrong offset!");

// Class DarwinGame.EmoteFaceDataTable
// 0x0000 (0x0030 - 0x0030)
class UEmoteFaceDataTable final : public UBlueprintFunctionLibrary
{
public:
	static bool GetFaceParameter(EEmoteFaceType FaceType, struct FEmoteFace* outFace, struct FEmoteFaceSetting* outSetting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteFaceDataTable">();
	}
	static class UEmoteFaceDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteFaceDataTable>();
	}
};
static_assert(alignof(UEmoteFaceDataTable) == 0x000008, "Wrong alignment on UEmoteFaceDataTable");
static_assert(sizeof(UEmoteFaceDataTable) == 0x000030, "Wrong size on UEmoteFaceDataTable");

// Class DarwinGame.FieldActionAbility
// 0x00A8 (0x04C8 - 0x0420)
class UFieldActionAbility : public UActionGameplayAbility
{
public:
	uint8                                         Pad_420[0x3C];                                     // 0x0420(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTurning;                                          // 0x045C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45D[0x3];                                      // 0x045D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFieldActionEventStruct                FieldActInfo;                                      // 0x0460(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActingArtifact>            DugUpObjectClass;                                  // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartSectionName;                                  // 0x0480(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActingArtifact*                        mDugUpArtifact;                                    // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            mDigSpeedCurve;                                    // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           mDigTimerHandle;                                   // 0x04B8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Access();
	void AdjustDigRate();
	void AdjustRotation();
	void CancelAccess();
	void CancelDig();
	void DestroyAtcingArtifact();
	void DigUp();
	void DirectRotation();
	void EndAccess();
	void EndDig();
	void Give();
	void LookAt();
	void MoveToTarget();
	void OnPointFilled();
	void Pickup();
	void PrepareTurn();
	void ResetFlagRotation();
	void SetTurnAngle(float Angle);
	void StartPull();
	void StartSevenStoneDirection(ESevenStoneDirectionType Type);

	struct FParkour GetParkourData() const;
	struct FRotator GetTurnRotation() const;
	bool IsDirectRotationAction() const;
	bool IsRequiredRotationAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldActionAbility">();
	}
	static class UFieldActionAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldActionAbility>();
	}
};
static_assert(alignof(UFieldActionAbility) == 0x000008, "Wrong alignment on UFieldActionAbility");
static_assert(sizeof(UFieldActionAbility) == 0x0004C8, "Wrong size on UFieldActionAbility");
static_assert(offsetof(UFieldActionAbility, bTurning) == 0x00045C, "Member 'UFieldActionAbility::bTurning' has a wrong offset!");
static_assert(offsetof(UFieldActionAbility, FieldActInfo) == 0x000460, "Member 'UFieldActionAbility::FieldActInfo' has a wrong offset!");
static_assert(offsetof(UFieldActionAbility, DugUpObjectClass) == 0x000478, "Member 'UFieldActionAbility::DugUpObjectClass' has a wrong offset!");
static_assert(offsetof(UFieldActionAbility, StartSectionName) == 0x000480, "Member 'UFieldActionAbility::StartSectionName' has a wrong offset!");
static_assert(offsetof(UFieldActionAbility, mDugUpArtifact) == 0x000488, "Member 'UFieldActionAbility::mDugUpArtifact' has a wrong offset!");
static_assert(offsetof(UFieldActionAbility, mDigSpeedCurve) == 0x0004A8, "Member 'UFieldActionAbility::mDigSpeedCurve' has a wrong offset!");
static_assert(offsetof(UFieldActionAbility, mDigTimerHandle) == 0x0004B8, "Member 'UFieldActionAbility::mDigTimerHandle' has a wrong offset!");

// Class DarwinGame.BattleSystemComponent
// 0x0058 (0x0110 - 0x00B8)
class UBattleSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRampageOnMagicAbility;                            // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeleteAttackCollision(const class FString& OrderId);
	class AAttackCollisionBase* GenerateShootAttackCollision(class AActor* Target, class FName actionDetailID, const class FString& AttackCollisionID, const struct FActionGameplayEffectContainerSpec& Spec);
	void GenerateTouchAttackCollision(class AGPACharacter* Target, class FName actionDetailID, const class FString& AttackCollisionID, const struct FActionGameplayEffectContainerSpec& Spec);

	bool GetAttackCollisionId(const class FString& OrderId, int32* outUniqueCollisionID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSystemComponent">();
	}
	static class UBattleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSystemComponent>();
	}
};
static_assert(alignof(UBattleSystemComponent) == 0x000008, "Wrong alignment on UBattleSystemComponent");
static_assert(sizeof(UBattleSystemComponent) == 0x000110, "Wrong size on UBattleSystemComponent");
static_assert(offsetof(UBattleSystemComponent, bRampageOnMagicAbility) == 0x000108, "Member 'UBattleSystemComponent::bRampageOnMagicAbility' has a wrong offset!");

// Class DarwinGame.UIDelivery_ItemListPanel
// 0x0008 (0x0498 - 0x0490)
class UUIDelivery_ItemListPanel final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_ItemListPanel">();
	}
	static class UUIDelivery_ItemListPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_ItemListPanel>();
	}
};
static_assert(alignof(UUIDelivery_ItemListPanel) == 0x000008, "Wrong alignment on UUIDelivery_ItemListPanel");
static_assert(sizeof(UUIDelivery_ItemListPanel) == 0x000498, "Wrong size on UUIDelivery_ItemListPanel");

// Class DarwinGame.FadeCSVolumeGroupNotify
// 0x0008 (0x0048 - 0x0040)
class UFadeCSVolumeGroupNotify final : public UAnimNotify
{
public:
	class FName                                   GroupID;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeCSVolumeGroupNotify">();
	}
	static class UFadeCSVolumeGroupNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeCSVolumeGroupNotify>();
	}
};
static_assert(alignof(UFadeCSVolumeGroupNotify) == 0x000008, "Wrong alignment on UFadeCSVolumeGroupNotify");
static_assert(sizeof(UFadeCSVolumeGroupNotify) == 0x000048, "Wrong size on UFadeCSVolumeGroupNotify");
static_assert(offsetof(UFadeCSVolumeGroupNotify, GroupID) == 0x000040, "Member 'UFadeCSVolumeGroupNotify::GroupID' has a wrong offset!");

// Class DarwinGame.BehaviorDecisionMonsterBoss
// 0x0008 (0x0038 - 0x0030)
class UBehaviorDecisionMonsterBoss final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviorDecisionMonsterBoss">();
	}
	static class UBehaviorDecisionMonsterBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviorDecisionMonsterBoss>();
	}
};
static_assert(alignof(UBehaviorDecisionMonsterBoss) == 0x000008, "Wrong alignment on UBehaviorDecisionMonsterBoss");
static_assert(sizeof(UBehaviorDecisionMonsterBoss) == 0x000038, "Wrong size on UBehaviorDecisionMonsterBoss");

// Class DarwinGame.BGMAreaActor
// 0x0000 (0x0228 - 0x0228)
class ABGMAreaActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGMAreaActor">();
	}
	static class ABGMAreaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGMAreaActor>();
	}
};
static_assert(alignof(ABGMAreaActor) == 0x000008, "Wrong alignment on ABGMAreaActor");
static_assert(sizeof(ABGMAreaActor) == 0x000228, "Wrong size on ABGMAreaActor");

// Class DarwinGame.FoodEffectFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UFoodEffectFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoodEffectFunctionLibrary">();
	}
	static class UFoodEffectFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoodEffectFunctionLibrary>();
	}
};
static_assert(alignof(UFoodEffectFunctionLibrary) == 0x000008, "Wrong alignment on UFoodEffectFunctionLibrary");
static_assert(sizeof(UFoodEffectFunctionLibrary) == 0x000030, "Wrong size on UFoodEffectFunctionLibrary");

// Class DarwinGame.UIDispatch_CategoryIcon
// 0x0010 (0x04A0 - 0x0490)
class UUIDispatch_CategoryIcon : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_CategoryIcon">();
	}
	static class UUIDispatch_CategoryIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_CategoryIcon>();
	}
};
static_assert(alignof(UUIDispatch_CategoryIcon) == 0x000008, "Wrong alignment on UUIDispatch_CategoryIcon");
static_assert(sizeof(UUIDispatch_CategoryIcon) == 0x0004A0, "Wrong size on UUIDispatch_CategoryIcon");

// Class DarwinGame.EncountDataTable
// 0x0000 (0x0030 - 0x0030)
class UEncountDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EncountDataTable">();
	}
	static class UEncountDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEncountDataTable>();
	}
};
static_assert(alignof(UEncountDataTable) == 0x000008, "Wrong alignment on UEncountDataTable");
static_assert(sizeof(UEncountDataTable) == 0x000030, "Wrong size on UEncountDataTable");

// Class DarwinGame.BGMSoundMapDataAsset
// 0x0050 (0x0088 - 0x0038)
class UBGMSoundMapDataAsset final : public UDataAsset
{
public:
	TMap<EAreaType, struct FST_BGMRegionSettingData> DataList;                                          // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGMSoundMapDataAsset">();
	}
	static class UBGMSoundMapDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGMSoundMapDataAsset>();
	}
};
static_assert(alignof(UBGMSoundMapDataAsset) == 0x000008, "Wrong alignment on UBGMSoundMapDataAsset");
static_assert(sizeof(UBGMSoundMapDataAsset) == 0x000088, "Wrong size on UBGMSoundMapDataAsset");
static_assert(offsetof(UBGMSoundMapDataAsset, DataList) == 0x000038, "Member 'UBGMSoundMapDataAsset::DataList' has a wrong offset!");

// Class DarwinGame.FieldManager
// 0x02A0 (0x02D8 - 0x0038)
class UFieldManager : public UManagerBase
{
public:
	TSoftClassPtr<class UClass>                   mWorldTimeManager;                                 // 0x0038(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mFieldAreaManager;                                 // 0x0060(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mEnvironmentManager;                               // 0x0088(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mFieldObjectManager;                               // 0x00B0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mNPCManager;                                       // 0x00D8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mCollectionPointManager;                           // 0x0100(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mGameScriptManager;                                // 0x0128(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mArtifactManager;                                  // 0x0150(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mForcedBattleAreaManager;                          // 0x0178(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mDungeonManager;                                   // 0x01A0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mTargetObjectManager;                              // 0x01C8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mOutbreakQuestPointManager;                        // 0x01F0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APulloutFlag*                           mRivalTeamFlag;                                    // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mRivalTeamFlagBpRef;                               // 0x0220(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldTimeManager*                      mWorldTimeManager_0;                               // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFieldAreaManager*                      mFieldAreaManager_0;                               // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvironmentManager*                    mEnvironmentManager_0;                             // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFieldObjectManager*                    mFieldObjectManager_0;                             // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNPCManager*                            mNPCManager_0;                                     // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleInformation*                     mEnemyBattleInformation;                           // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleInformation*                     mAllyBattleInformation;                            // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattleDirector*                        mBattleDirector;                                   // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMonsterServiceArranger*                mMonsterServiceArranger;                           // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMonsterBTTaskExecuter*                 mMonsterBTTaskExecuter;                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemySpawnManager*                     mEnemySpawnManager;                                // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollectionPointManager*                mCollectionPointManager_0;                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameScriptManager*                     mGameScriptManager_0;                              // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArtifactManager*                       mArtifactManager_0;                                // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UForcedBattleAreaManager*               mForcedBattleAreaManager_0;                        // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDungeonManager*                        mDungeonManager_0;                                 // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetObjectManager*                   mTargetObjectManager_0;                            // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOutbreakQuestPointManager*             mOutbreakQuestPointManager_0;                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFieldManager* GetInstance();

	void DestroyRivalTeamFlag();
	void SpawnRivalTeamFlag(ERivalTeamForce Force, const struct FVector& Location, const struct FRotator& Rotation);

	class UBattleInformation* GetAllyBattleInformation() const;
	class UArtifactManager* GetArtifactManager() const;
	class UBattleDirector* GetBattleDirector() const;
	class UCollectionPointManager* GetCollectionPointManager() const;
	class UDungeonManager* GetDungeonManager() const;
	class UBattleInformation* GetEnemyBattleInformation() const;
	class UEnemySpawnManager* GetEnemySpawnManager() const;
	class UEnvironmentManager* GetEnvironmentManager() const;
	class UFieldAreaManager* GetFieldAreaManager() const;
	class UFieldObjectManager* GetFieldObjectManager() const;
	class UForcedBattleAreaManager* GetForcedBattleAreaManager() const;
	class UGameScriptManager* GetGameScriptManager() const;
	class UMonsterBTTaskExecuter* GetMonsterBTTaskExecuter() const;
	class UMonsterServiceArranger* GetMonsterServiceArranger() const;
	class UNPCManager* GetNPCManager() const;
	class UOutbreakQuestPointManager* GetOutbreakQuestPointManager() const;
	class AGameCharacter* GetPlayer() const;
	class UTargetObjectManager* GetTargetObjectManager() const;
	class UWorldTimeManager* GetWorldTimeManager() const;
	bool IsPulledOutRivalTeamFlag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldManager">();
	}
	static class UFieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldManager>();
	}
};
static_assert(alignof(UFieldManager) == 0x000008, "Wrong alignment on UFieldManager");
static_assert(sizeof(UFieldManager) == 0x0002D8, "Wrong size on UFieldManager");
static_assert(offsetof(UFieldManager, mWorldTimeManager) == 0x000038, "Member 'UFieldManager::mWorldTimeManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mFieldAreaManager) == 0x000060, "Member 'UFieldManager::mFieldAreaManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mEnvironmentManager) == 0x000088, "Member 'UFieldManager::mEnvironmentManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mFieldObjectManager) == 0x0000B0, "Member 'UFieldManager::mFieldObjectManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mNPCManager) == 0x0000D8, "Member 'UFieldManager::mNPCManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mCollectionPointManager) == 0x000100, "Member 'UFieldManager::mCollectionPointManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mGameScriptManager) == 0x000128, "Member 'UFieldManager::mGameScriptManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mArtifactManager) == 0x000150, "Member 'UFieldManager::mArtifactManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mForcedBattleAreaManager) == 0x000178, "Member 'UFieldManager::mForcedBattleAreaManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mDungeonManager) == 0x0001A0, "Member 'UFieldManager::mDungeonManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mTargetObjectManager) == 0x0001C8, "Member 'UFieldManager::mTargetObjectManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mOutbreakQuestPointManager) == 0x0001F0, "Member 'UFieldManager::mOutbreakQuestPointManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mRivalTeamFlag) == 0x000218, "Member 'UFieldManager::mRivalTeamFlag' has a wrong offset!");
static_assert(offsetof(UFieldManager, mRivalTeamFlagBpRef) == 0x000220, "Member 'UFieldManager::mRivalTeamFlagBpRef' has a wrong offset!");
static_assert(offsetof(UFieldManager, mWorldTimeManager_0) == 0x000248, "Member 'UFieldManager::mWorldTimeManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mFieldAreaManager_0) == 0x000250, "Member 'UFieldManager::mFieldAreaManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mEnvironmentManager_0) == 0x000258, "Member 'UFieldManager::mEnvironmentManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mFieldObjectManager_0) == 0x000260, "Member 'UFieldManager::mFieldObjectManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mNPCManager_0) == 0x000268, "Member 'UFieldManager::mNPCManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mEnemyBattleInformation) == 0x000270, "Member 'UFieldManager::mEnemyBattleInformation' has a wrong offset!");
static_assert(offsetof(UFieldManager, mAllyBattleInformation) == 0x000278, "Member 'UFieldManager::mAllyBattleInformation' has a wrong offset!");
static_assert(offsetof(UFieldManager, mBattleDirector) == 0x000280, "Member 'UFieldManager::mBattleDirector' has a wrong offset!");
static_assert(offsetof(UFieldManager, mMonsterServiceArranger) == 0x000288, "Member 'UFieldManager::mMonsterServiceArranger' has a wrong offset!");
static_assert(offsetof(UFieldManager, mMonsterBTTaskExecuter) == 0x000290, "Member 'UFieldManager::mMonsterBTTaskExecuter' has a wrong offset!");
static_assert(offsetof(UFieldManager, mEnemySpawnManager) == 0x000298, "Member 'UFieldManager::mEnemySpawnManager' has a wrong offset!");
static_assert(offsetof(UFieldManager, mCollectionPointManager_0) == 0x0002A0, "Member 'UFieldManager::mCollectionPointManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mGameScriptManager_0) == 0x0002A8, "Member 'UFieldManager::mGameScriptManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mArtifactManager_0) == 0x0002B0, "Member 'UFieldManager::mArtifactManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mForcedBattleAreaManager_0) == 0x0002B8, "Member 'UFieldManager::mForcedBattleAreaManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mDungeonManager_0) == 0x0002C0, "Member 'UFieldManager::mDungeonManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mTargetObjectManager_0) == 0x0002C8, "Member 'UFieldManager::mTargetObjectManager_0' has a wrong offset!");
static_assert(offsetof(UFieldManager, mOutbreakQuestPointManager_0) == 0x0002D0, "Member 'UFieldManager::mOutbreakQuestPointManager_0' has a wrong offset!");

// Class DarwinGame.BGMWorldActor
// 0x0000 (0x0228 - 0x0228)
class ABGMWorldActor final : public AActor
{
public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGMWorldActor">();
	}
	static class ABGMWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGMWorldActor>();
	}
};
static_assert(alignof(ABGMWorldActor) == 0x000008, "Wrong alignment on ABGMWorldActor");
static_assert(sizeof(ABGMWorldActor) == 0x000228, "Wrong size on ABGMWorldActor");

// Class DarwinGame.UIFacilityMenu_Quest_Root
// 0x0020 (0x04F0 - 0x04D0)
class UUIFacilityMenu_Quest_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x20];                                     // 0x04D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityMenu_Quest_Root">();
	}
	static class UUIFacilityMenu_Quest_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityMenu_Quest_Root>();
	}
};
static_assert(alignof(UUIFacilityMenu_Quest_Root) == 0x000008, "Wrong alignment on UUIFacilityMenu_Quest_Root");
static_assert(sizeof(UUIFacilityMenu_Quest_Root) == 0x0004F0, "Wrong size on UUIFacilityMenu_Quest_Root");

// Class DarwinGame.DungeonGimmickObjectBase
// 0x0008 (0x02B8 - 0x02B0)
class ADungeonGimmickObjectBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickObjectBase">();
	}
	static class ADungeonGimmickObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickObjectBase>();
	}
};
static_assert(alignof(ADungeonGimmickObjectBase) == 0x000008, "Wrong alignment on ADungeonGimmickObjectBase");
static_assert(sizeof(ADungeonGimmickObjectBase) == 0x0002B8, "Wrong size on ADungeonGimmickObjectBase");

// Class DarwinGame.DungeonGimmickBoss
// 0x0028 (0x02E0 - 0x02B8)
class ADungeonGimmickBoss final : public ADungeonGimmickObjectBase
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterSpawnedCallbackHolder*          spawnedCallback;                                   // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnemyMonsterSpawned(class AMonsterBase* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickBoss">();
	}
	static class ADungeonGimmickBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickBoss>();
	}
};
static_assert(alignof(ADungeonGimmickBoss) == 0x000008, "Wrong alignment on ADungeonGimmickBoss");
static_assert(sizeof(ADungeonGimmickBoss) == 0x0002E0, "Wrong size on ADungeonGimmickBoss");
static_assert(offsetof(ADungeonGimmickBoss, spawnedCallback) == 0x0002C8, "Member 'ADungeonGimmickBoss::spawnedCallback' has a wrong offset!");

// Class DarwinGame.BoardMonsterRankDataTable
// 0x0000 (0x0030 - 0x0030)
class UBoardMonsterRankDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoardMonsterRankDataTable">();
	}
	static class UBoardMonsterRankDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoardMonsterRankDataTable>();
	}
};
static_assert(alignof(UBoardMonsterRankDataTable) == 0x000008, "Wrong alignment on UBoardMonsterRankDataTable");
static_assert(sizeof(UBoardMonsterRankDataTable) == 0x000030, "Wrong size on UBoardMonsterRankDataTable");

// Class DarwinGame.SceneCaptureCharacter
// 0x0000 (0x0380 - 0x0380)
class ASceneCaptureCharacter : public ASceneCaptureTwoCameraBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureCharacter">();
	}
	static class ASceneCaptureCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneCaptureCharacter>();
	}
};
static_assert(alignof(ASceneCaptureCharacter) == 0x000010, "Wrong alignment on ASceneCaptureCharacter");
static_assert(sizeof(ASceneCaptureCharacter) == 0x000380, "Wrong size on ASceneCaptureCharacter");

// Class DarwinGame.ObjectCommunicationInterface
// 0x0000 (0x0030 - 0x0030)
class IObjectCommunicationInterface final : public IInterface
{
public:
	void HandleAreaTransitionEvent();
	void HandleEnteringArtifactAreaEvent(EArtifactType ArtifactType, bool IsNear, bool IsAddEmphasis, class FName UniID);
	void HandleExitArtifactAreaEvent();
	bool HandleGetArtifactEvent(const struct FGetArtifactEventStruct& Info);
	void HandleLinkStartEvent();
	void OnReceiveCallEvent(const struct FCallEventStruct& Info);
	void OnReceiveEvent(const struct FEventStruct& Info);
	void OnReceiveFieldActionEvent(const struct FFieldActionEventStruct& Info);
	void OnReceiveGetCoinEvent(const struct FGetCoinEventStruct& Info);
	void OnReceiveGetItemEvent(const struct FGetItemEventStruct& Info);
	void OnReceiveLiftEvent(const struct FLiftEventStruct& Info);
	void OnReceiveRideEvent(const struct FRideEventStruct& Info);
	void OnReceiveStealEvent(const struct FStealEventStruct& Info);
	void OnRecieveReactionAfterSearch(const struct FAfterSearchEventStruct& Info);
	void RegisterFieldTerrainInfo(const EFieldTerrainType Type, const struct FST_FieldTerrainInfo& Info);
	void UnRegisterFieldTerrainInfo(const EFieldTerrainType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectCommunicationInterface">();
	}
	static class IObjectCommunicationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IObjectCommunicationInterface>();
	}
};
static_assert(alignof(IObjectCommunicationInterface) == 0x000008, "Wrong alignment on IObjectCommunicationInterface");
static_assert(sizeof(IObjectCommunicationInterface) == 0x000030, "Wrong size on IObjectCommunicationInterface");

// Class DarwinGame.CustomStaticMeshActor
// 0x0008 (0x0240 - 0x0238)
class ACustomStaticMeshActor final : public AStaticMeshActor
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomStaticMeshActor">();
	}
	static class ACustomStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomStaticMeshActor>();
	}
};
static_assert(alignof(ACustomStaticMeshActor) == 0x000008, "Wrong alignment on ACustomStaticMeshActor");
static_assert(sizeof(ACustomStaticMeshActor) == 0x000240, "Wrong size on ACustomStaticMeshActor");
static_assert(offsetof(ACustomStaticMeshActor, Mesh) == 0x000238, "Member 'ACustomStaticMeshActor::Mesh' has a wrong offset!");

// Class DarwinGame.BoardSceneCapture
// 0x0030 (0x03B0 - 0x0380)
class ABoardSceneCapture final : public ASceneCaptureCharacter
{
public:
	class AGPACharacter*                          Player;                                            // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMonster*                               Monster;                                           // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   LevelSequencePlayer;                               // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       CineCameraActor;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSequencerImpl();
	class AMonster* GetMonster();
	class AGPACharacter* GetPlayer();
	void StartSequencerImpl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoardSceneCapture">();
	}
	static class ABoardSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoardSceneCapture>();
	}
};
static_assert(alignof(ABoardSceneCapture) == 0x000010, "Wrong alignment on ABoardSceneCapture");
static_assert(sizeof(ABoardSceneCapture) == 0x0003B0, "Wrong size on ABoardSceneCapture");
static_assert(offsetof(ABoardSceneCapture, Player) == 0x000380, "Member 'ABoardSceneCapture::Player' has a wrong offset!");
static_assert(offsetof(ABoardSceneCapture, Monster) == 0x000388, "Member 'ABoardSceneCapture::Monster' has a wrong offset!");
static_assert(offsetof(ABoardSceneCapture, LevelSequenceActor) == 0x000390, "Member 'ABoardSceneCapture::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(ABoardSceneCapture, LevelSequencePlayer) == 0x000398, "Member 'ABoardSceneCapture::LevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(ABoardSceneCapture, CineCameraActor) == 0x0003A0, "Member 'ABoardSceneCapture::CineCameraActor' has a wrong offset!");

// Class DarwinGame.OutbreakQuestRevengeBattle
// 0x0068 (0x0340 - 0x02D8)
class AOutbreakQuestRevengeBattle : public AOutbreakQuestGimmickBase
{
public:
	TSoftClassPtr<class UClass>                   mRivalTeamFlagBpRef;                               // 0x02D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APulloutFlag*                           mpFlag;                                            // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x20];                                     // 0x0310(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterSpawnedCallbackHolder*          mSpawnedCallback;                                  // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpawnRevengeMonsterCallBack(class AMonsterBase* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestRevengeBattle">();
	}
	static class AOutbreakQuestRevengeBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestRevengeBattle>();
	}
};
static_assert(alignof(AOutbreakQuestRevengeBattle) == 0x000008, "Wrong alignment on AOutbreakQuestRevengeBattle");
static_assert(sizeof(AOutbreakQuestRevengeBattle) == 0x000340, "Wrong size on AOutbreakQuestRevengeBattle");
static_assert(offsetof(AOutbreakQuestRevengeBattle, mRivalTeamFlagBpRef) == 0x0002D8, "Member 'AOutbreakQuestRevengeBattle::mRivalTeamFlagBpRef' has a wrong offset!");
static_assert(offsetof(AOutbreakQuestRevengeBattle, mpFlag) == 0x000308, "Member 'AOutbreakQuestRevengeBattle::mpFlag' has a wrong offset!");
static_assert(offsetof(AOutbreakQuestRevengeBattle, mSpawnedCallback) == 0x000330, "Member 'AOutbreakQuestRevengeBattle::mSpawnedCallback' has a wrong offset!");

// Class DarwinGame.BoardSceneDataTableLibrary
// 0x0000 (0x0030 - 0x0030)
class UBoardSceneDataTableLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoardSceneDataTableLibrary">();
	}
	static class UBoardSceneDataTableLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoardSceneDataTableLibrary>();
	}
};
static_assert(alignof(UBoardSceneDataTableLibrary) == 0x000008, "Wrong alignment on UBoardSceneDataTableLibrary");
static_assert(sizeof(UBoardSceneDataTableLibrary) == 0x000030, "Wrong size on UBoardSceneDataTableLibrary");

// Class DarwinGame.NetworkReturnCaptureDataTableLibrary
// 0x0000 (0x0030 - 0x0030)
class UNetworkReturnCaptureDataTableLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkReturnCaptureDataTableLibrary">();
	}
	static class UNetworkReturnCaptureDataTableLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkReturnCaptureDataTableLibrary>();
	}
};
static_assert(alignof(UNetworkReturnCaptureDataTableLibrary) == 0x000008, "Wrong alignment on UNetworkReturnCaptureDataTableLibrary");
static_assert(sizeof(UNetworkReturnCaptureDataTableLibrary) == 0x000030, "Wrong size on UNetworkReturnCaptureDataTableLibrary");

// Class DarwinGame.UIProfile_Treasure
// 0x0020 (0x05F0 - 0x05D0)
class UUIProfile_Treasure : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x20];                                     // 0x05D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProfile_Treasure">();
	}
	static class UUIProfile_Treasure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProfile_Treasure>();
	}
};
static_assert(alignof(UUIProfile_Treasure) == 0x000008, "Wrong alignment on UUIProfile_Treasure");
static_assert(sizeof(UUIProfile_Treasure) == 0x0005F0, "Wrong size on UUIProfile_Treasure");

// Class DarwinGame.ObjectUtilInterface
// 0x0000 (0x0030 - 0x0030)
class IObjectUtilInterface final : public IInterface
{
public:
	void OnDestroy();

	class FName GetObjectID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectUtilInterface">();
	}
	static class IObjectUtilInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IObjectUtilInterface>();
	}
};
static_assert(alignof(IObjectUtilInterface) == 0x000008, "Wrong alignment on IObjectUtilInterface");
static_assert(sizeof(IObjectUtilInterface) == 0x000030, "Wrong size on IObjectUtilInterface");

// Class DarwinGame.BonfireBase
// 0x0010 (0x02C0 - 0x02B0)
class ABonfireBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BonfireBase">();
	}
	static class ABonfireBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABonfireBase>();
	}
};
static_assert(alignof(ABonfireBase) == 0x000008, "Wrong alignment on ABonfireBase");
static_assert(sizeof(ABonfireBase) == 0x0002C0, "Wrong size on ABonfireBase");

// Class DarwinGame.BonfireDataTable
// 0x0000 (0x0030 - 0x0030)
class UBonfireDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BonfireDataTable">();
	}
	static class UBonfireDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBonfireDataTable>();
	}
};
static_assert(alignof(UBonfireDataTable) == 0x000008, "Wrong alignment on UBonfireDataTable");
static_assert(sizeof(UBonfireDataTable) == 0x000030, "Wrong size on UBonfireDataTable");

// Class DarwinGame.DarwinCamera
// 0x0160 (0x0388 - 0x0228)
class ADarwinCamera : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraSpringArmComponent*              CameraBoom;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       Camera;                                            // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x20];                                     // 0x0250(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CurrentStateTag;                                   // 0x0270(0x0008)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ControlRotation;                                   // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RotateAxisValue;                                   // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawValue;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchValue;                                        // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CameraAngle;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x2];                                      // 0x0294(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableKeyInputControl;                            // 0x0296(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_297[0x5];                                      // 0x0297(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxHighAngle;                                      // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLowAngle;                                       // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalInterpSpeed;                             // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalInterpSpeed;                               // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceInterpSpeed;                               // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AssistInterpSpeed;                                 // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x28];                                     // 0x02B4(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBoomLength;                                 // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinBoomLength;                                     // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxBoomLength;                                     // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x4];                                      // 0x02E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBoomLengthWhileBattle;                      // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Target;                                            // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceAtRotateInterpSpeedMax;                    // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultRotateInterpSpeed;                          // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BackwardRotateInterpSpeed;                         // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x8];                                      // 0x030C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpEndAngle;                                    // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InterpRangeOfWidth;                                // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InterpRangeOfHeight;                               // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x4];                                      // 0x0320(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBoomLengthWhileAiming;                      // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalValueWhileAiming;                        // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalValueWhileAiming;                          // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistStartAngle;                               // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistMaxInterpSpeed;                           // 0x0334(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimAssistMinInterpSpeed;                           // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDitherInfoManager*                     DitherTargetManager;                               // 0x0340(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       InterporationCamera;                               // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x4];                                      // 0x0350(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDarwinViewBlendParam                  BlendParam;                                        // 0x0354(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0xC];                                      // 0x037C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void AdjustBoomLength();
	void Deactivate();
	void InitCameraCurve();
	void LimitRotationAndUpdate(const struct FRotator& Rotation);
	void MoveWhileAbyss();
	void MoveWhileAiming();
	void MoveWhileDeath();
	void MoveWhileDebug();
	void MoveWhileDirection();
	void MoveWhileNormal();
	void RequestCameraTransition(const struct FDarwinViewBlendRequestParam& BlendRequest, const struct FDarwinCameraResetParam& ResetParam);
	void RequestCameraTransitionByMoveLinear(class AActor* StartTarget, EViewBlendRateType Type, float BlendTime, const struct FDarwinCameraResetParam& ResetParam, float BlendRateEaseExpo);
	void ResetCamera(const struct FDarwinCameraResetParam& ResetParam);
	void ResetObstacleJudgeRadius();
	void ResetRotation();
	void ResetRotationFromKeyInput();
	void ResetState();
	void ResetStateAndRotation();
	void ResetWithKeepPosition(const struct FVector& keepPosition);
	void ResetWithKeepRotation(const struct FRotator& keepRotation);
	void RotateWhileAbyss();
	void RotateWhileAiming();
	void RotateWhileDeath();
	void RotateWhileDirection();
	void RotateWhileNormal();
	void SetBoomLength(float Length);
	void SetCameraAspectRatio(float AspectRatio);
	void SetCameraFOV(float FOV);
	void SetObstacleJudgeRadius(float Radius);
	void ShowCameraInfo(bool bEnd);
	void SwitchPostProcess(ECameraPostProcessType Type, bool on);
	void UpdateBoomLength();
	void UpdateCameraInfo();
	void Zoom(const struct FVector& Location, const struct FRotator& Rotation, float Length, float InterapSpeed);

	float GetBoomLength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinCamera">();
	}
	static class ADarwinCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarwinCamera>();
	}
};
static_assert(alignof(ADarwinCamera) == 0x000008, "Wrong alignment on ADarwinCamera");
static_assert(sizeof(ADarwinCamera) == 0x000388, "Wrong size on ADarwinCamera");
static_assert(offsetof(ADarwinCamera, DefaultSceneRoot) == 0x000238, "Member 'ADarwinCamera::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, CameraBoom) == 0x000240, "Member 'ADarwinCamera::CameraBoom' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, Camera) == 0x000248, "Member 'ADarwinCamera::Camera' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, CurrentStateTag) == 0x000270, "Member 'ADarwinCamera::CurrentStateTag' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, ControlRotation) == 0x000278, "Member 'ADarwinCamera::ControlRotation' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, RotateAxisValue) == 0x000284, "Member 'ADarwinCamera::RotateAxisValue' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, YawValue) == 0x000288, "Member 'ADarwinCamera::YawValue' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, PitchValue) == 0x00028C, "Member 'ADarwinCamera::PitchValue' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, CameraAngle) == 0x000290, "Member 'ADarwinCamera::CameraAngle' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, bEnableKeyInputControl) == 0x000296, "Member 'ADarwinCamera::bEnableKeyInputControl' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, MaxHighAngle) == 0x00029C, "Member 'ADarwinCamera::MaxHighAngle' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, MaxLowAngle) == 0x0002A0, "Member 'ADarwinCamera::MaxLowAngle' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, HorizontalInterpSpeed) == 0x0002A4, "Member 'ADarwinCamera::HorizontalInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, VerticalInterpSpeed) == 0x0002A8, "Member 'ADarwinCamera::VerticalInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DistanceInterpSpeed) == 0x0002AC, "Member 'ADarwinCamera::DistanceInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, AssistInterpSpeed) == 0x0002B0, "Member 'ADarwinCamera::AssistInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DefaultBoomLength) == 0x0002DC, "Member 'ADarwinCamera::DefaultBoomLength' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, MinBoomLength) == 0x0002E0, "Member 'ADarwinCamera::MinBoomLength' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, MaxBoomLength) == 0x0002E4, "Member 'ADarwinCamera::MaxBoomLength' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DefaultBoomLengthWhileBattle) == 0x0002EC, "Member 'ADarwinCamera::DefaultBoomLengthWhileBattle' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, Target) == 0x0002F8, "Member 'ADarwinCamera::Target' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DistanceAtRotateInterpSpeedMax) == 0x000300, "Member 'ADarwinCamera::DistanceAtRotateInterpSpeedMax' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DefaultRotateInterpSpeed) == 0x000304, "Member 'ADarwinCamera::DefaultRotateInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, BackwardRotateInterpSpeed) == 0x000308, "Member 'ADarwinCamera::BackwardRotateInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, InterpEndAngle) == 0x000314, "Member 'ADarwinCamera::InterpEndAngle' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, InterpRangeOfWidth) == 0x000318, "Member 'ADarwinCamera::InterpRangeOfWidth' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, InterpRangeOfHeight) == 0x00031C, "Member 'ADarwinCamera::InterpRangeOfHeight' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DefaultBoomLengthWhileAiming) == 0x000324, "Member 'ADarwinCamera::DefaultBoomLengthWhileAiming' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, HorizontalValueWhileAiming) == 0x000328, "Member 'ADarwinCamera::HorizontalValueWhileAiming' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, VerticalValueWhileAiming) == 0x00032C, "Member 'ADarwinCamera::VerticalValueWhileAiming' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, AimAssistStartAngle) == 0x000330, "Member 'ADarwinCamera::AimAssistStartAngle' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, AimAssistMaxInterpSpeed) == 0x000334, "Member 'ADarwinCamera::AimAssistMaxInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, AimAssistMinInterpSpeed) == 0x000338, "Member 'ADarwinCamera::AimAssistMinInterpSpeed' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, DitherTargetManager) == 0x000340, "Member 'ADarwinCamera::DitherTargetManager' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, InterporationCamera) == 0x000348, "Member 'ADarwinCamera::InterporationCamera' has a wrong offset!");
static_assert(offsetof(ADarwinCamera, BlendParam) == 0x000354, "Member 'ADarwinCamera::BlendParam' has a wrong offset!");

// Class DarwinGame.BossAvoidWall
// 0x00D0 (0x02F8 - 0x0228)
class ABossAvoidWall final : public AActor
{
public:
	float                                         mWidth;                                            // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mDepth;                                            // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mBoxLocation;                                      // 0x0230(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mStartLocation;                                    // 0x023C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mEndLocation;                                      // 0x0248(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mRightLocation;                                    // 0x0254(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mCenterLocation;                                   // 0x0260(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mLeftLocation;                                     // 0x026C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mRadius;                                           // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mLargeRightLocation;                               // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mLargeLeftLocation;                                // 0x0288(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mLargeRadius;                                      // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mWdRightLocation;                                  // 0x0298(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mWdCenterLocation;                                 // 0x02A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mWdLeftLocation;                                   // 0x02B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mWdLargeRightLocation;                             // 0x02BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mWdLargeLeftLocation;                              // 0x02C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x24];                                     // 0x02D4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPlayInitialize();
	void Initialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BossAvoidWall">();
	}
	static class ABossAvoidWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABossAvoidWall>();
	}
};
static_assert(alignof(ABossAvoidWall) == 0x000008, "Wrong alignment on ABossAvoidWall");
static_assert(sizeof(ABossAvoidWall) == 0x0002F8, "Wrong size on ABossAvoidWall");
static_assert(offsetof(ABossAvoidWall, mWidth) == 0x000228, "Member 'ABossAvoidWall::mWidth' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mDepth) == 0x00022C, "Member 'ABossAvoidWall::mDepth' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mBoxLocation) == 0x000230, "Member 'ABossAvoidWall::mBoxLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mStartLocation) == 0x00023C, "Member 'ABossAvoidWall::mStartLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mEndLocation) == 0x000248, "Member 'ABossAvoidWall::mEndLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mRightLocation) == 0x000254, "Member 'ABossAvoidWall::mRightLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mCenterLocation) == 0x000260, "Member 'ABossAvoidWall::mCenterLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mLeftLocation) == 0x00026C, "Member 'ABossAvoidWall::mLeftLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mRadius) == 0x000278, "Member 'ABossAvoidWall::mRadius' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mLargeRightLocation) == 0x00027C, "Member 'ABossAvoidWall::mLargeRightLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mLargeLeftLocation) == 0x000288, "Member 'ABossAvoidWall::mLargeLeftLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mLargeRadius) == 0x000294, "Member 'ABossAvoidWall::mLargeRadius' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mWdRightLocation) == 0x000298, "Member 'ABossAvoidWall::mWdRightLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mWdCenterLocation) == 0x0002A4, "Member 'ABossAvoidWall::mWdCenterLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mWdLeftLocation) == 0x0002B0, "Member 'ABossAvoidWall::mWdLeftLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mWdLargeRightLocation) == 0x0002BC, "Member 'ABossAvoidWall::mWdLargeRightLocation' has a wrong offset!");
static_assert(offsetof(ABossAvoidWall, mWdLargeLeftLocation) == 0x0002C8, "Member 'ABossAvoidWall::mWdLargeLeftLocation' has a wrong offset!");

// Class DarwinGame.NPCOptionDataTable
// 0x0000 (0x0030 - 0x0030)
class UNPCOptionDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCOptionDataTable">();
	}
	static class UNPCOptionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCOptionDataTable>();
	}
};
static_assert(alignof(UNPCOptionDataTable) == 0x000008, "Wrong alignment on UNPCOptionDataTable");
static_assert(sizeof(UNPCOptionDataTable) == 0x000030, "Wrong size on UNPCOptionDataTable");

// Class DarwinGame.UIHeader_01
// 0x0010 (0x04A0 - 0x0490)
class UUIHeader_01 : public UDarwinUserWidget
{
public:
	class FName                                   DefaultHeaderType;                                 // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHeaderType(class FName HeaderType);
	void SetName(const class FText& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHeader_01">();
	}
	static class UUIHeader_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHeader_01>();
	}
};
static_assert(alignof(UUIHeader_01) == 0x000008, "Wrong alignment on UUIHeader_01");
static_assert(sizeof(UUIHeader_01) == 0x0004A0, "Wrong size on UUIHeader_01");
static_assert(offsetof(UUIHeader_01, DefaultHeaderType) == 0x000490, "Member 'UUIHeader_01::DefaultHeaderType' has a wrong offset!");

// Class DarwinGame.DungeonMonsterSpawnPoint
// 0x0000 (0x0030 - 0x0030)
class UDungeonMonsterSpawnPoint final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonMonsterSpawnPoint">();
	}
	static class UDungeonMonsterSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonMonsterSpawnPoint>();
	}
};
static_assert(alignof(UDungeonMonsterSpawnPoint) == 0x000008, "Wrong alignment on UDungeonMonsterSpawnPoint");
static_assert(sizeof(UDungeonMonsterSpawnPoint) == 0x000030, "Wrong size on UDungeonMonsterSpawnPoint");

// Class DarwinGame.BossGimmicks
// 0x0000 (0x0228 - 0x0228)
class ABossGimmicks : public AActor
{
public:
	void HitGimmickCheck(const struct FVector& Location, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BossGimmicks">();
	}
	static class ABossGimmicks* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABossGimmicks>();
	}
};
static_assert(alignof(ABossGimmicks) == 0x000008, "Wrong alignment on ABossGimmicks");
static_assert(sizeof(ABossGimmicks) == 0x000228, "Wrong size on ABossGimmicks");

// Class DarwinGame.BossMonsterParameterDataTable
// 0x0000 (0x0030 - 0x0030)
class UBossMonsterParameterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BossMonsterParameterDataTable">();
	}
	static class UBossMonsterParameterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBossMonsterParameterDataTable>();
	}
};
static_assert(alignof(UBossMonsterParameterDataTable) == 0x000008, "Wrong alignment on UBossMonsterParameterDataTable");
static_assert(sizeof(UBossMonsterParameterDataTable) == 0x000030, "Wrong size on UBossMonsterParameterDataTable");

// Class DarwinGame.ObjectReactionBaseComponent
// 0x00B0 (0x0168 - 0x00B8)
class UObjectReactionBaseComponent : public UFieldObjectComponentBase
{
public:
	class FName                                   mParentTag;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   mParentSocket;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectReactionTargetUIType                   mUIType;                                           // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                mLocationOffset;                                   // 0x00CC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                mSearchPointOffset;                                // 0x00D8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EObjectReactionCollisionType                  mCollisionType;                                    // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                mCollisionSize;                                    // 0x00E8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               mCollisionRotator;                                 // 0x00F4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x68];                                     // 0x0100(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionBaseComponent">();
	}
	static class UObjectReactionBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionBaseComponent>();
	}
};
static_assert(alignof(UObjectReactionBaseComponent) == 0x000008, "Wrong alignment on UObjectReactionBaseComponent");
static_assert(sizeof(UObjectReactionBaseComponent) == 0x000168, "Wrong size on UObjectReactionBaseComponent");
static_assert(offsetof(UObjectReactionBaseComponent, mParentTag) == 0x0000B8, "Member 'UObjectReactionBaseComponent::mParentTag' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mParentSocket) == 0x0000C0, "Member 'UObjectReactionBaseComponent::mParentSocket' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mUIType) == 0x0000C8, "Member 'UObjectReactionBaseComponent::mUIType' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mLocationOffset) == 0x0000CC, "Member 'UObjectReactionBaseComponent::mLocationOffset' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mSearchPointOffset) == 0x0000D8, "Member 'UObjectReactionBaseComponent::mSearchPointOffset' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mCollisionType) == 0x0000E4, "Member 'UObjectReactionBaseComponent::mCollisionType' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mCollisionSize) == 0x0000E8, "Member 'UObjectReactionBaseComponent::mCollisionSize' has a wrong offset!");
static_assert(offsetof(UObjectReactionBaseComponent, mCollisionRotator) == 0x0000F4, "Member 'UObjectReactionBaseComponent::mCollisionRotator' has a wrong offset!");

// Class DarwinGame.ObjectReactionDefaultComponent
// 0x0000 (0x0168 - 0x0168)
class UObjectReactionDefaultComponent final : public UObjectReactionBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionDefaultComponent">();
	}
	static class UObjectReactionDefaultComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionDefaultComponent>();
	}
};
static_assert(alignof(UObjectReactionDefaultComponent) == 0x000008, "Wrong alignment on UObjectReactionDefaultComponent");
static_assert(sizeof(UObjectReactionDefaultComponent) == 0x000168, "Wrong size on UObjectReactionDefaultComponent");

// Class DarwinGame.SkillChainDamageExecution
// 0x0000 (0x0048 - 0x0048)
class USkillChainDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChainDamageExecution">();
	}
	static class USkillChainDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillChainDamageExecution>();
	}
};
static_assert(alignof(USkillChainDamageExecution) == 0x000008, "Wrong alignment on USkillChainDamageExecution");
static_assert(sizeof(USkillChainDamageExecution) == 0x000048, "Wrong size on USkillChainDamageExecution");

// Class DarwinGame.ForcedBattleAreaBase
// 0x0068 (0x0318 - 0x02B0)
class AForcedBattleAreaBase : public AFieldObjectBase
{
public:
	class USceneComponent*                        mRoot;                                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AreaExtent;                                        // 0x02B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBoxComponent*>                  BoxComps;                                          // 0x02D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDecalComponent*                        DecalComponent;                                    // 0x02E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EForcedBattleAreaCollisionType                CollisionType;                                     // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DecalMaterial;                                     // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PN_Color;                                          // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DecalLineColor;                                    // 0x0300(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DecalDMI;                                          // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForcedBattleAreaBase">();
	}
	static class AForcedBattleAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AForcedBattleAreaBase>();
	}
};
static_assert(alignof(AForcedBattleAreaBase) == 0x000008, "Wrong alignment on AForcedBattleAreaBase");
static_assert(sizeof(AForcedBattleAreaBase) == 0x000318, "Wrong size on AForcedBattleAreaBase");
static_assert(offsetof(AForcedBattleAreaBase, mRoot) == 0x0002B0, "Member 'AForcedBattleAreaBase::mRoot' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, AreaExtent) == 0x0002B8, "Member 'AForcedBattleAreaBase::AreaExtent' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, BoxComps) == 0x0002D0, "Member 'AForcedBattleAreaBase::BoxComps' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, DecalComponent) == 0x0002E0, "Member 'AForcedBattleAreaBase::DecalComponent' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, CollisionType) == 0x0002E8, "Member 'AForcedBattleAreaBase::CollisionType' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, DecalMaterial) == 0x0002F0, "Member 'AForcedBattleAreaBase::DecalMaterial' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, PN_Color) == 0x0002F8, "Member 'AForcedBattleAreaBase::PN_Color' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, DecalLineColor) == 0x000300, "Member 'AForcedBattleAreaBase::DecalLineColor' has a wrong offset!");
static_assert(offsetof(AForcedBattleAreaBase, DecalDMI) == 0x000310, "Member 'AForcedBattleAreaBase::DecalDMI' has a wrong offset!");

// Class DarwinGame.OverHeadFallMagicBase
// 0x0148 (0x0458 - 0x0310)
class AOverHeadFallMagicBase final : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x148];                                    // 0x0310(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverHeadFallMagicBase">();
	}
	static class AOverHeadFallMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOverHeadFallMagicBase>();
	}
};
static_assert(alignof(AOverHeadFallMagicBase) == 0x000008, "Wrong alignment on AOverHeadFallMagicBase");
static_assert(sizeof(AOverHeadFallMagicBase) == 0x000458, "Wrong size on AOverHeadFallMagicBase");

// Class DarwinGame.BoxForcedBattleArea
// 0x0020 (0x0338 - 0x0318)
class ABoxForcedBattleArea : public AForcedBattleAreaBase
{
public:
	float                                         TopBoxHeight;                                      // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoxWidth;                                          // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BaseSize;                                          // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PN_ThicknessScaleX;                                // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PN_ThicknessScaleY;                                // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxForcedBattleArea">();
	}
	static class ABoxForcedBattleArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoxForcedBattleArea>();
	}
};
static_assert(alignof(ABoxForcedBattleArea) == 0x000008, "Wrong alignment on ABoxForcedBattleArea");
static_assert(sizeof(ABoxForcedBattleArea) == 0x000338, "Wrong size on ABoxForcedBattleArea");
static_assert(offsetof(ABoxForcedBattleArea, TopBoxHeight) == 0x000318, "Member 'ABoxForcedBattleArea::TopBoxHeight' has a wrong offset!");
static_assert(offsetof(ABoxForcedBattleArea, BoxWidth) == 0x00031C, "Member 'ABoxForcedBattleArea::BoxWidth' has a wrong offset!");
static_assert(offsetof(ABoxForcedBattleArea, BaseSize) == 0x000320, "Member 'ABoxForcedBattleArea::BaseSize' has a wrong offset!");
static_assert(offsetof(ABoxForcedBattleArea, PN_ThicknessScaleX) == 0x000328, "Member 'ABoxForcedBattleArea::PN_ThicknessScaleX' has a wrong offset!");
static_assert(offsetof(ABoxForcedBattleArea, PN_ThicknessScaleY) == 0x000330, "Member 'ABoxForcedBattleArea::PN_ThicknessScaleY' has a wrong offset!");

// Class DarwinGame.UIField_TacticsWord
// 0x0010 (0x05C0 - 0x05B0)
class UUIField_TacticsWord : public UUI3DBase
{
public:
	class UWidgetAnimation*                       BindAnim;                                          // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTacticsCloseAnim();
	void EndTacticsOpenAnim();
	void EndTacticsWaitAnim();
	bool Input_Button_Down_Implementation();
	bool Input_Button_Up_Implementation();
	void StartTacticsAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_TacticsWord">();
	}
	static class UUIField_TacticsWord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_TacticsWord>();
	}
};
static_assert(alignof(UUIField_TacticsWord) == 0x000010, "Wrong alignment on UUIField_TacticsWord");
static_assert(sizeof(UUIField_TacticsWord) == 0x0005C0, "Wrong size on UUIField_TacticsWord");
static_assert(offsetof(UUIField_TacticsWord, BindAnim) == 0x0005A8, "Member 'UUIField_TacticsWord::BindAnim' has a wrong offset!");

// Class DarwinGame.CommonGenereterEnableInfo
// 0x0000 (0x0030 - 0x0030)
class UCommonGenereterEnableInfo final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonGenereterEnableInfo">();
	}
	static class UCommonGenereterEnableInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonGenereterEnableInfo>();
	}
};
static_assert(alignof(UCommonGenereterEnableInfo) == 0x000008, "Wrong alignment on UCommonGenereterEnableInfo");
static_assert(sizeof(UCommonGenereterEnableInfo) == 0x000030, "Wrong size on UCommonGenereterEnableInfo");

// Class DarwinGame.BPDebugMenuInterface
// 0x0010 (0x0040 - 0x0030)
class UBPDebugMenuInterface final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetDisplayItemNum() const;
	int32 GetFontHeight() const;
	int32 GetFontWidth() const;
	void GetItemNameLayout(int32 displayNo, class FString* Text, float* X, float* Y, struct FLinearColor* Color) const;
	void GetItemValueLayout(int32 displayNo, class FString* Text, float* X, float* Y, struct FLinearColor* Color) const;
	void GetScrollLayout(class FString* Text, float* X, float* Y, struct FLinearColor* Color) const;
	void GetTitleLayout(class FString* Text, float* X, float* Y, struct FLinearColor* Color) const;
	bool IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPDebugMenuInterface">();
	}
	static class UBPDebugMenuInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPDebugMenuInterface>();
	}
};
static_assert(alignof(UBPDebugMenuInterface) == 0x000008, "Wrong alignment on UBPDebugMenuInterface");
static_assert(sizeof(UBPDebugMenuInterface) == 0x000040, "Wrong size on UBPDebugMenuInterface");

// Class DarwinGame.OutbreakQuestGetBackBattle
// 0x0000 (0x0340 - 0x0340)
class AOutbreakQuestGetBackBattle final : public AOutbreakQuestRevengeBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestGetBackBattle">();
	}
	static class AOutbreakQuestGetBackBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestGetBackBattle>();
	}
};
static_assert(alignof(AOutbreakQuestGetBackBattle) == 0x000008, "Wrong alignment on AOutbreakQuestGetBackBattle");
static_assert(sizeof(AOutbreakQuestGetBackBattle) == 0x000340, "Wrong size on AOutbreakQuestGetBackBattle");

// Class DarwinGame.BPFDebugParamInterface
// 0x0000 (0x0030 - 0x0030)
class UBPFDebugParamInterface final : public UBlueprintFunctionLibrary
{
public:
	static void DoSlowdownTest();
	static int32 GetBattleTableRowId();
	static int32 GetFastTravelId();
	static struct FVector GetFastTravelLocation();
	static bool GetFriendMonsterSpawnDisable();
	static bool GetIsActiveWipeCamera();
	static bool GetIsBattleMotionCheck();
	static bool GetIsDispLookAtTargetInfo();
	static bool GetIsFastTravel();
	static bool GetIsHiddenFieldComment();
	static bool GetIsLockCameraRelativeLocation();
	static bool GetIsSlowdownTest();
	static bool GetIsSwitchCameraController();
	static bool GetIsSwitchTargetMarkerController();
	static class FName GetNextLevelPathOfTitle();
	static int32 GetTargetBoneId();
	static int32 GetTargetRowId();
	static bool GetTriggerChangeFocusTarget();
	static bool GetTriggerModelChange();
	static bool GetTriggerOpenWarpMenu();
	static void OutputLogBossCameraStartForCheckConflictWithBossPerformance();
	static void OutputLogExecAnimNotifyState(const class FString& AnimNotifyText);
	static void OutputLogStartDespoilForCheckConflictWithBossPerformance();
	static void SetFastTravelId(int32 ID);
	static void SetFastTravelLocation(const struct FVector& Location);
	static void SetIsFastTravel(bool Value);
	static void SetTriggerOffModelChange();
	static void SetTriggerOffMoveCameraPreset();
	static void SetTriggerOffOpenWarpMenu();
	static bool UseFieldCommentHiddenFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFDebugParamInterface">();
	}
	static class UBPFDebugParamInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFDebugParamInterface>();
	}
};
static_assert(alignof(UBPFDebugParamInterface) == 0x000008, "Wrong alignment on UBPFDebugParamInterface");
static_assert(sizeof(UBPFDebugParamInterface) == 0x000030, "Wrong size on UBPFDebugParamInterface");

// Class DarwinGame.BreakObjectBase
// 0x0010 (0x02C0 - 0x02B0)
class ABreakObjectBase : public AFieldObjectBase
{
public:
	EObjectBreakEffectID                          mBreakEffectID;                                    // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropMoveParameterID;                               // 0x02B4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakObjectBase">();
	}
	static class ABreakObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakObjectBase>();
	}
};
static_assert(alignof(ABreakObjectBase) == 0x000008, "Wrong alignment on ABreakObjectBase");
static_assert(sizeof(ABreakObjectBase) == 0x0002C0, "Wrong size on ABreakObjectBase");
static_assert(offsetof(ABreakObjectBase, mBreakEffectID) == 0x0002B0, "Member 'ABreakObjectBase::mBreakEffectID' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, DropMoveParameterID) == 0x0002B4, "Member 'ABreakObjectBase::DropMoveParameterID' has a wrong offset!");

// Class DarwinGame.DarwinFrameGrabber
// 0x0038 (0x0068 - 0x0030)
class UDarwinFrameGrabber final : public UObject
{
public:
	TArray<uint8>                                 CaptureFrameData;                                  // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             CaptureFrameTexture;                               // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinFrameGrabber">();
	}
	static class UDarwinFrameGrabber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinFrameGrabber>();
	}
};
static_assert(alignof(UDarwinFrameGrabber) == 0x000008, "Wrong alignment on UDarwinFrameGrabber");
static_assert(sizeof(UDarwinFrameGrabber) == 0x000068, "Wrong size on UDarwinFrameGrabber");
static_assert(offsetof(UDarwinFrameGrabber, CaptureFrameData) == 0x000030, "Member 'UDarwinFrameGrabber::CaptureFrameData' has a wrong offset!");
static_assert(offsetof(UDarwinFrameGrabber, CaptureFrameTexture) == 0x000040, "Member 'UDarwinFrameGrabber::CaptureFrameTexture' has a wrong offset!");

// Class DarwinGame.BreathMagicBase
// 0x0068 (0x0358 - 0x02F0)
class ABreathMagicBase final : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x60];                                     // 0x02F8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleCollisionHit(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreathMagicBase">();
	}
	static class ABreathMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreathMagicBase>();
	}
};
static_assert(alignof(ABreathMagicBase) == 0x000008, "Wrong alignment on ABreathMagicBase");
static_assert(sizeof(ABreathMagicBase) == 0x000358, "Wrong size on ABreathMagicBase");
static_assert(offsetof(ABreathMagicBase, collision) == 0x0002F0, "Member 'ABreathMagicBase::collision' has a wrong offset!");

// Class DarwinGame.ObjectReactionDataBase
// 0x0000 (0x0030 - 0x0030)
class UObjectReactionDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionDataBase">();
	}
	static class UObjectReactionDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionDataBase>();
	}
};
static_assert(alignof(UObjectReactionDataBase) == 0x000008, "Wrong alignment on UObjectReactionDataBase");
static_assert(sizeof(UObjectReactionDataBase) == 0x000030, "Wrong size on UObjectReactionDataBase");

// Class DarwinGame.UIField_WinLink
// 0x00C0 (0x0550 - 0x0490)
class UUIField_WinLink : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0xC0];                                     // 0x0490(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinLink">();
	}
	static class UUIField_WinLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinLink>();
	}
};
static_assert(alignof(UUIField_WinLink) == 0x000008, "Wrong alignment on UUIField_WinLink");
static_assert(sizeof(UUIField_WinLink) == 0x000550, "Wrong size on UUIField_WinLink");

// Class DarwinGame.ComputeTextBlock
// 0x0008 (0x02B0 - 0x02A8)
class UComputeTextBlock final : public UTextBlock
{
public:
	struct FVector2D                              DefaultDesiredSize;                                // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComputeTextBlock">();
	}
	static class UComputeTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComputeTextBlock>();
	}
};
static_assert(alignof(UComputeTextBlock) == 0x000008, "Wrong alignment on UComputeTextBlock");
static_assert(sizeof(UComputeTextBlock) == 0x0002B0, "Wrong size on UComputeTextBlock");
static_assert(offsetof(UComputeTextBlock, DefaultDesiredSize) == 0x0002A8, "Member 'UComputeTextBlock::DefaultDesiredSize' has a wrong offset!");

// Class DarwinGame.BTD_NPCAiTypeCheck
// 0x0008 (0x0078 - 0x0070)
class UBTD_NPCAiTypeCheck final : public UBTDecorator
{
public:
	ENPCAiType                                    TargetNPCAiType;                                   // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_NPCAiTypeCheck">();
	}
	static class UBTD_NPCAiTypeCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_NPCAiTypeCheck>();
	}
};
static_assert(alignof(UBTD_NPCAiTypeCheck) == 0x000008, "Wrong alignment on UBTD_NPCAiTypeCheck");
static_assert(sizeof(UBTD_NPCAiTypeCheck) == 0x000078, "Wrong size on UBTD_NPCAiTypeCheck");
static_assert(offsetof(UBTD_NPCAiTypeCheck, TargetNPCAiType) == 0x000070, "Member 'UBTD_NPCAiTypeCheck::TargetNPCAiType' has a wrong offset!");

// Class DarwinGame.BTS_NPCLookAtBody
// 0x0000 (0x0078 - 0x0078)
class UBTS_NPCLookAtBody final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_NPCLookAtBody">();
	}
	static class UBTS_NPCLookAtBody* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_NPCLookAtBody>();
	}
};
static_assert(alignof(UBTS_NPCLookAtBody) == 0x000008, "Wrong alignment on UBTS_NPCLookAtBody");
static_assert(sizeof(UBTS_NPCLookAtBody) == 0x000078, "Wrong size on UBTS_NPCLookAtBody");

// Class DarwinGame.DarwinTextBlock
// 0x0008 (0x02B0 - 0x02A8)
class UDarwinTextBlock final : public UTextBlock
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinTextBlock">();
	}
	static class UDarwinTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinTextBlock>();
	}
};
static_assert(alignof(UDarwinTextBlock) == 0x000008, "Wrong alignment on UDarwinTextBlock");
static_assert(sizeof(UDarwinTextBlock) == 0x0002B0, "Wrong size on UDarwinTextBlock");

// Class DarwinGame.MonsterBTTask
// 0x0008 (0x0038 - 0x0030)
class UMonsterBTTask : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBTTask">();
	}
	static class UMonsterBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBTTask>();
	}
};
static_assert(alignof(UMonsterBTTask) == 0x000008, "Wrong alignment on UMonsterBTTask");
static_assert(sizeof(UMonsterBTTask) == 0x000038, "Wrong size on UMonsterBTTask");

// Class DarwinGame.RangeMagicBase
// 0x0060 (0x0350 - 0x02F0)
class ARangeMagicBase final : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x58];                                     // 0x02F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeMagicBase">();
	}
	static class ARangeMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARangeMagicBase>();
	}
};
static_assert(alignof(ARangeMagicBase) == 0x000008, "Wrong alignment on ARangeMagicBase");
static_assert(sizeof(ARangeMagicBase) == 0x000350, "Wrong size on ARangeMagicBase");
static_assert(offsetof(ARangeMagicBase, collision) == 0x0002F0, "Member 'ARangeMagicBase::collision' has a wrong offset!");

// Class DarwinGame.BTTask_ActionCycleGesture
// 0x0000 (0x0038 - 0x0038)
class UBTTask_ActionCycleGesture final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ActionCycleGesture">();
	}
	static class UBTTask_ActionCycleGesture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ActionCycleGesture>();
	}
};
static_assert(alignof(UBTTask_ActionCycleGesture) == 0x000008, "Wrong alignment on UBTTask_ActionCycleGesture");
static_assert(sizeof(UBTTask_ActionCycleGesture) == 0x000038, "Wrong size on UBTTask_ActionCycleGesture");

// Class DarwinGame.BTTask_BackStep
// 0x0000 (0x0038 - 0x0038)
class UBTTask_BackStep final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_BackStep">();
	}
	static class UBTTask_BackStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_BackStep>();
	}
};
static_assert(alignof(UBTTask_BackStep) == 0x000008, "Wrong alignment on UBTTask_BackStep");
static_assert(sizeof(UBTTask_BackStep) == 0x000038, "Wrong size on UBTTask_BackStep");

// Class DarwinGame.RideStateBase
// 0x0058 (0x01C8 - 0x0170)
class URideStateBase final : public UMoveStateBase
{
public:
	uint8                                         Pad_170[0x58];                                     // 0x0170(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RideStateBase">();
	}
	static class URideStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URideStateBase>();
	}
};
static_assert(alignof(URideStateBase) == 0x000008, "Wrong alignment on URideStateBase");
static_assert(sizeof(URideStateBase) == 0x0001C8, "Wrong size on URideStateBase");

// Class DarwinGame.BTTask_BossMoveDirectlyToward
// 0x0000 (0x00C0 - 0x00C0)
class UBTTask_BossMoveDirectlyToward final : public UBTTask_MoveDirectlyToward
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_BossMoveDirectlyToward">();
	}
	static class UBTTask_BossMoveDirectlyToward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_BossMoveDirectlyToward>();
	}
};
static_assert(alignof(UBTTask_BossMoveDirectlyToward) == 0x000008, "Wrong alignment on UBTTask_BossMoveDirectlyToward");
static_assert(sizeof(UBTTask_BossMoveDirectlyToward) == 0x0000C0, "Wrong size on UBTTask_BossMoveDirectlyToward");

// Class DarwinGame.CompassBase
// 0x0118 (0x0340 - 0x0228)
class ACompassBase : public AActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComp;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EArtifactNotifyType, float>              PlayRateList;                                      // 0x0230(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EArtifactNotifyType, float>              EmissiveList;                                      // 0x0280(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EArtifactNotifyType, float>              OpacityList;                                       // 0x02D0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultRadius;                                     // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x14];                                     // 0x032C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompassBase">();
	}
	static class ACompassBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACompassBase>();
	}
};
static_assert(alignof(ACompassBase) == 0x000008, "Wrong alignment on ACompassBase");
static_assert(sizeof(ACompassBase) == 0x000340, "Wrong size on ACompassBase");
static_assert(offsetof(ACompassBase, SkeletalMeshComp) == 0x000228, "Member 'ACompassBase::SkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(ACompassBase, PlayRateList) == 0x000230, "Member 'ACompassBase::PlayRateList' has a wrong offset!");
static_assert(offsetof(ACompassBase, EmissiveList) == 0x000280, "Member 'ACompassBase::EmissiveList' has a wrong offset!");
static_assert(offsetof(ACompassBase, OpacityList) == 0x0002D0, "Member 'ACompassBase::OpacityList' has a wrong offset!");
static_assert(offsetof(ACompassBase, DefaultRadius) == 0x000328, "Member 'ACompassBase::DefaultRadius' has a wrong offset!");

// Class DarwinGame.BTTask_BossMoveTo
// 0x0008 (0x00C0 - 0x00B8)
class UBTTask_BossMoveTo final : public UBTTask_MoveTo
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_BossMoveTo">();
	}
	static class UBTTask_BossMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_BossMoveTo>();
	}
};
static_assert(alignof(UBTTask_BossMoveTo) == 0x000008, "Wrong alignment on UBTTask_BossMoveTo");
static_assert(sizeof(UBTTask_BossMoveTo) == 0x0000C0, "Wrong size on UBTTask_BossMoveTo");

// Class DarwinGame.RestorationConsole
// 0x0008 (0x02B8 - 0x02B0)
class ARestorationConsole final : public AFieldObjectBase
{
public:
	class FName                                   mNpcId;                                            // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestorationConsole">();
	}
	static class ARestorationConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARestorationConsole>();
	}
};
static_assert(alignof(ARestorationConsole) == 0x000008, "Wrong alignment on ARestorationConsole");
static_assert(sizeof(ARestorationConsole) == 0x0002B8, "Wrong size on ARestorationConsole");
static_assert(offsetof(ARestorationConsole, mNpcId) == 0x0002B0, "Member 'ARestorationConsole::mNpcId' has a wrong offset!");

// Class DarwinGame.UIField_WinLogbox
// 0x00A0 (0x0530 - 0x0490)
class UUIField_WinLogbox : public UDarwinUserWidget
{
public:
	class UDataTable*                             DT_LogDataTable;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULogWindow*                             LogWindow;                                         // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 LogIntervalList;                                   // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LogLife;                                           // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LogSpace;                                          // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ELogDataSpecialWaitType, float>          SpecialWaitMap;                                    // 0x04B8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class UUIField_WinLog*>                WinLogList;                                        // 0x0508(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x18];                                     // 0x0518(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDataCharacter(class FName Key, class FName ID, const class FText& Unique, int32 Value);
	void SetDataCoin(class FName Key, const struct FST_CoinParam& CoinParam, const class FText& Unique, int32 Value);
	void SetDataFood(class FName Key, class FName FoodEffectId, const class FText& Unique, int32 Value);
	void SetDataItem(class FName Key, class FName ID, const class FText& Unique, int32 Value);
	void SetDataQuest(class FName Key, class FName QuestID, const class FText& Unique, int32 Value, bool bInIsOpenQuestConfirmation);
	void SetDataSimple(class FName Key, const class FText& Unique, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinLogbox">();
	}
	static class UUIField_WinLogbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinLogbox>();
	}
};
static_assert(alignof(UUIField_WinLogbox) == 0x000008, "Wrong alignment on UUIField_WinLogbox");
static_assert(sizeof(UUIField_WinLogbox) == 0x000530, "Wrong size on UUIField_WinLogbox");
static_assert(offsetof(UUIField_WinLogbox, DT_LogDataTable) == 0x000490, "Member 'UUIField_WinLogbox::DT_LogDataTable' has a wrong offset!");
static_assert(offsetof(UUIField_WinLogbox, LogWindow) == 0x000498, "Member 'UUIField_WinLogbox::LogWindow' has a wrong offset!");
static_assert(offsetof(UUIField_WinLogbox, LogIntervalList) == 0x0004A0, "Member 'UUIField_WinLogbox::LogIntervalList' has a wrong offset!");
static_assert(offsetof(UUIField_WinLogbox, LogLife) == 0x0004B0, "Member 'UUIField_WinLogbox::LogLife' has a wrong offset!");
static_assert(offsetof(UUIField_WinLogbox, LogSpace) == 0x0004B4, "Member 'UUIField_WinLogbox::LogSpace' has a wrong offset!");
static_assert(offsetof(UUIField_WinLogbox, SpecialWaitMap) == 0x0004B8, "Member 'UUIField_WinLogbox::SpecialWaitMap' has a wrong offset!");
static_assert(offsetof(UUIField_WinLogbox, WinLogList) == 0x000508, "Member 'UUIField_WinLogbox::WinLogList' has a wrong offset!");

// Class DarwinGame.ControlBgmNotify
// 0x0020 (0x0060 - 0x0040)
class UControlBgmNotify final : public UAnimNotify
{
public:
	ESoundControlType                             Type;                                              // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAtomCompCategory                             Category;                                          // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CueName;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time;                                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Volume;                                            // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlBgmNotify">();
	}
	static class UControlBgmNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlBgmNotify>();
	}
};
static_assert(alignof(UControlBgmNotify) == 0x000008, "Wrong alignment on UControlBgmNotify");
static_assert(sizeof(UControlBgmNotify) == 0x000060, "Wrong size on UControlBgmNotify");
static_assert(offsetof(UControlBgmNotify, Type) == 0x000040, "Member 'UControlBgmNotify::Type' has a wrong offset!");
static_assert(offsetof(UControlBgmNotify, Category) == 0x000041, "Member 'UControlBgmNotify::Category' has a wrong offset!");
static_assert(offsetof(UControlBgmNotify, CueName) == 0x000048, "Member 'UControlBgmNotify::CueName' has a wrong offset!");
static_assert(offsetof(UControlBgmNotify, Time) == 0x000058, "Member 'UControlBgmNotify::Time' has a wrong offset!");
static_assert(offsetof(UControlBgmNotify, Volume) == 0x00005C, "Member 'UControlBgmNotify::Volume' has a wrong offset!");

// Class DarwinGame.BTTask_EmoteWait
// 0x0000 (0x0038 - 0x0038)
class UBTTask_EmoteWait final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_EmoteWait">();
	}
	static class UBTTask_EmoteWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_EmoteWait>();
	}
};
static_assert(alignof(UBTTask_EmoteWait) == 0x000008, "Wrong alignment on UBTTask_EmoteWait");
static_assert(sizeof(UBTTask_EmoteWait) == 0x000038, "Wrong size on UBTTask_EmoteWait");

// Class DarwinGame.BTTask_FormTo
// 0x0000 (0x0038 - 0x0038)
class UBTTask_FormTo final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FormTo">();
	}
	static class UBTTask_FormTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FormTo>();
	}
};
static_assert(alignof(UBTTask_FormTo) == 0x000008, "Wrong alignment on UBTTask_FormTo");
static_assert(sizeof(UBTTask_FormTo) == 0x000038, "Wrong size on UBTTask_FormTo");

// Class DarwinGame.DarwinDPICustomScalingRule
// 0x0000 (0x0030 - 0x0030)
class UDarwinDPICustomScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinDPICustomScalingRule">();
	}
	static class UDarwinDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinDPICustomScalingRule>();
	}
};
static_assert(alignof(UDarwinDPICustomScalingRule) == 0x000008, "Wrong alignment on UDarwinDPICustomScalingRule");
static_assert(sizeof(UDarwinDPICustomScalingRule) == 0x000030, "Wrong size on UDarwinDPICustomScalingRule");

// Class DarwinGame.BTTask_GazePlayer
// 0x0000 (0x0038 - 0x0038)
class UBTTask_GazePlayer final : public UMonsterBTTask
{
public:
	bool CheckGazeMotion(class AMonsterBase* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_GazePlayer">();
	}
	static class UBTTask_GazePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_GazePlayer>();
	}
};
static_assert(alignof(UBTTask_GazePlayer) == 0x000008, "Wrong alignment on UBTTask_GazePlayer");
static_assert(sizeof(UBTTask_GazePlayer) == 0x000038, "Wrong size on UBTTask_GazePlayer");

// Class DarwinGame.BTTask_Hide
// 0x0000 (0x0038 - 0x0038)
class UBTTask_Hide final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Hide">();
	}
	static class UBTTask_Hide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Hide>();
	}
};
static_assert(alignof(UBTTask_Hide) == 0x000008, "Wrong alignment on UBTTask_Hide");
static_assert(sizeof(UBTTask_Hide) == 0x000038, "Wrong size on UBTTask_Hide");

// Class DarwinGame.FieldGameState
// 0x0008 (0x0280 - 0x0278)
class AFieldGameState final : public AGameStateBase
{
public:
	class USkillChainSystemComponent*             SkillChainSystem;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CancelChain();
	void EndChain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldGameState">();
	}
	static class AFieldGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldGameState>();
	}
};
static_assert(alignof(AFieldGameState) == 0x000008, "Wrong alignment on AFieldGameState");
static_assert(sizeof(AFieldGameState) == 0x000280, "Wrong size on AFieldGameState");
static_assert(offsetof(AFieldGameState, SkillChainSystem) == 0x000278, "Member 'AFieldGameState::SkillChainSystem' has a wrong offset!");

// Class DarwinGame.UIEstimatePerformanceBase
// 0x00C8 (0x0558 - 0x0490)
class UUIEstimatePerformanceBase : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BackTexture;                                       // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Default_Vec;                                       // 0x04A8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               Default_Rotator;                                   // 0x04B4(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                StartScale;                                        // 0x04C0(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StopScale;                                         // 0x04CC(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SlideScale;                                        // 0x04D8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UntilStopTime;                                     // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopTime;                                          // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Slide_Vec;                                         // 0x04EC(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Slide_Rotator;                                     // 0x04F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIAppraise_Menu*                       AppraiseMenu;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWhiteFade*                           WhitePanel;                                        // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x48];                                     // 0x0510(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetRotateProcessVec(float InTime);
	float GetRotateProcessYaw(float InTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimatePerformanceBase">();
	}
	static class UUIEstimatePerformanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimatePerformanceBase>();
	}
};
static_assert(alignof(UUIEstimatePerformanceBase) == 0x000008, "Wrong alignment on UUIEstimatePerformanceBase");
static_assert(sizeof(UUIEstimatePerformanceBase) == 0x000558, "Wrong size on UUIEstimatePerformanceBase");
static_assert(offsetof(UUIEstimatePerformanceBase, BackTexture) == 0x0004A0, "Member 'UUIEstimatePerformanceBase::BackTexture' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, Default_Vec) == 0x0004A8, "Member 'UUIEstimatePerformanceBase::Default_Vec' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, Default_Rotator) == 0x0004B4, "Member 'UUIEstimatePerformanceBase::Default_Rotator' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, StartScale) == 0x0004C0, "Member 'UUIEstimatePerformanceBase::StartScale' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, StopScale) == 0x0004CC, "Member 'UUIEstimatePerformanceBase::StopScale' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, SlideScale) == 0x0004D8, "Member 'UUIEstimatePerformanceBase::SlideScale' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, UntilStopTime) == 0x0004E4, "Member 'UUIEstimatePerformanceBase::UntilStopTime' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, StopTime) == 0x0004E8, "Member 'UUIEstimatePerformanceBase::StopTime' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, Slide_Vec) == 0x0004EC, "Member 'UUIEstimatePerformanceBase::Slide_Vec' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, Slide_Rotator) == 0x0004F8, "Member 'UUIEstimatePerformanceBase::Slide_Rotator' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, AppraiseMenu) == 0x000500, "Member 'UUIEstimatePerformanceBase::AppraiseMenu' has a wrong offset!");
static_assert(offsetof(UUIEstimatePerformanceBase, WhitePanel) == 0x000508, "Member 'UUIEstimatePerformanceBase::WhitePanel' has a wrong offset!");

// Class DarwinGame.UIAppraisePerformance
// 0x0078 (0x05D0 - 0x0558)
class UUIAppraisePerformance final : public UUIEstimatePerformanceBase
{
public:
	class UDarwinArtifactTwoCaptureImage*         FrontCaptureImage;                                 // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinSceneCaptureImage*               BackCaptureImage;                                  // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIType_Legend_00*                      LegendWord;                                        // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x60];                                     // 0x0570(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraisePerformance">();
	}
	static class UUIAppraisePerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraisePerformance>();
	}
};
static_assert(alignof(UUIAppraisePerformance) == 0x000008, "Wrong alignment on UUIAppraisePerformance");
static_assert(sizeof(UUIAppraisePerformance) == 0x0005D0, "Wrong size on UUIAppraisePerformance");
static_assert(offsetof(UUIAppraisePerformance, FrontCaptureImage) == 0x000558, "Member 'UUIAppraisePerformance::FrontCaptureImage' has a wrong offset!");
static_assert(offsetof(UUIAppraisePerformance, BackCaptureImage) == 0x000560, "Member 'UUIAppraisePerformance::BackCaptureImage' has a wrong offset!");
static_assert(offsetof(UUIAppraisePerformance, LegendWord) == 0x000568, "Member 'UUIAppraisePerformance::LegendWord' has a wrong offset!");

// Class DarwinGame.BTTask_JumpingMoveTo
// 0x0000 (0x0038 - 0x0038)
class UBTTask_JumpingMoveTo final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_JumpingMoveTo">();
	}
	static class UBTTask_JumpingMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_JumpingMoveTo>();
	}
};
static_assert(alignof(UBTTask_JumpingMoveTo) == 0x000008, "Wrong alignment on UBTTask_JumpingMoveTo");
static_assert(sizeof(UBTTask_JumpingMoveTo) == 0x000038, "Wrong size on UBTTask_JumpingMoveTo");

// Class DarwinGame.BTTask_JumpTo
// 0x0000 (0x0038 - 0x0038)
class UBTTask_JumpTo final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_JumpTo">();
	}
	static class UBTTask_JumpTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_JumpTo>();
	}
};
static_assert(alignof(UBTTask_JumpTo) == 0x000008, "Wrong alignment on UBTTask_JumpTo");
static_assert(sizeof(UBTTask_JumpTo) == 0x000038, "Wrong size on UBTTask_JumpTo");

// Class DarwinGame.UICountBase
// 0x0008 (0x0498 - 0x0490)
class UUICountBase : public UDarwinUserWidget
{
public:
	class UImage*                                 CountImage;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICountBase">();
	}
	static class UUICountBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICountBase>();
	}
};
static_assert(alignof(UUICountBase) == 0x000008, "Wrong alignment on UUICountBase");
static_assert(sizeof(UUICountBase) == 0x000498, "Wrong size on UUICountBase");
static_assert(offsetof(UUICountBase, CountImage) == 0x000490, "Member 'UUICountBase::CountImage' has a wrong offset!");

// Class DarwinGame.UIAppraise_Count
// 0x0008 (0x04A0 - 0x0498)
class UUIAppraise_Count : public UUICountBase
{
public:
	class UDataTable*                             CountDataTable;                                    // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraise_Count">();
	}
	static class UUIAppraise_Count* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraise_Count>();
	}
};
static_assert(alignof(UUIAppraise_Count) == 0x000008, "Wrong alignment on UUIAppraise_Count");
static_assert(sizeof(UUIAppraise_Count) == 0x0004A0, "Wrong size on UUIAppraise_Count");
static_assert(offsetof(UUIAppraise_Count, CountDataTable) == 0x000498, "Member 'UUIAppraise_Count::CountDataTable' has a wrong offset!");

// Class DarwinGame.BTTask_MoveDirectlyTowardEx
// 0x0000 (0x00C0 - 0x00C0)
class UBTTask_MoveDirectlyTowardEx final : public UBTTask_MoveDirectlyToward
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveDirectlyTowardEx">();
	}
	static class UBTTask_MoveDirectlyTowardEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveDirectlyTowardEx>();
	}
};
static_assert(alignof(UBTTask_MoveDirectlyTowardEx) == 0x000008, "Wrong alignment on UBTTask_MoveDirectlyTowardEx");
static_assert(sizeof(UBTTask_MoveDirectlyTowardEx) == 0x0000C0, "Wrong size on UBTTask_MoveDirectlyTowardEx");

// Class DarwinGame.BTTask_MoveToEx
// 0x0000 (0x00B8 - 0x00B8)
class UBTTask_MoveToEx final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToEx">();
	}
	static class UBTTask_MoveToEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToEx>();
	}
};
static_assert(alignof(UBTTask_MoveToEx) == 0x000008, "Wrong alignment on UBTTask_MoveToEx");
static_assert(sizeof(UBTTask_MoveToEx) == 0x0000B8, "Wrong size on UBTTask_MoveToEx");

// Class DarwinGame.UIEstimate_WordBase
// 0x0000 (0x0490 - 0x0490)
class UUIEstimate_WordBase final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_WordBase">();
	}
	static class UUIEstimate_WordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_WordBase>();
	}
};
static_assert(alignof(UUIEstimate_WordBase) == 0x000008, "Wrong alignment on UUIEstimate_WordBase");
static_assert(sizeof(UUIEstimate_WordBase) == 0x000490, "Wrong size on UUIEstimate_WordBase");

// Class DarwinGame.DailyQuestFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UDailyQuestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void OrderQuest(int32 RealYear, int32 RealMonth, int32 RealDay, int32 RealHour, int32 RealMinute);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyQuestFunctionLibrary">();
	}
	static class UDailyQuestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDailyQuestFunctionLibrary>();
	}
};
static_assert(alignof(UDailyQuestFunctionLibrary) == 0x000008, "Wrong alignment on UDailyQuestFunctionLibrary");
static_assert(sizeof(UDailyQuestFunctionLibrary) == 0x000030, "Wrong size on UDailyQuestFunctionLibrary");

// Class DarwinGame.BTTask_NPCAiCheck
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCAiCheck final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCAiCheck">();
	}
	static class UBTTask_NPCAiCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCAiCheck>();
	}
};
static_assert(alignof(UBTTask_NPCAiCheck) == 0x000008, "Wrong alignment on UBTTask_NPCAiCheck");
static_assert(sizeof(UBTTask_NPCAiCheck) == 0x000078, "Wrong size on UBTTask_NPCAiCheck");

// Class DarwinGame.BTTask_NPCAiIndexCheck
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCAiIndexCheck final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCAiIndexCheck">();
	}
	static class UBTTask_NPCAiIndexCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCAiIndexCheck>();
	}
};
static_assert(alignof(UBTTask_NPCAiIndexCheck) == 0x000008, "Wrong alignment on UBTTask_NPCAiIndexCheck");
static_assert(sizeof(UBTTask_NPCAiIndexCheck) == 0x000078, "Wrong size on UBTTask_NPCAiIndexCheck");

// Class DarwinGame.PCAchievements
// 0x6BA8 (0x6DD0 - 0x0228)
class APCAchievements final : public AActor
{
public:
	uint8                                         Pad_228[0x6BA8];                                   // 0x0228(0x6BA8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCAchievements">();
	}
	static class APCAchievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCAchievements>();
	}
};
static_assert(alignof(APCAchievements) == 0x000008, "Wrong alignment on APCAchievements");
static_assert(sizeof(APCAchievements) == 0x006DD0, "Wrong size on APCAchievements");

// Class DarwinGame.BTTask_NPCAiIsWalkStop
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCAiIsWalkStop final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCAiIsWalkStop">();
	}
	static class UBTTask_NPCAiIsWalkStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCAiIsWalkStop>();
	}
};
static_assert(alignof(UBTTask_NPCAiIsWalkStop) == 0x000008, "Wrong alignment on UBTTask_NPCAiIsWalkStop");
static_assert(sizeof(UBTTask_NPCAiIsWalkStop) == 0x000078, "Wrong size on UBTTask_NPCAiIsWalkStop");

// Class DarwinGame.BTTask_NPCEventCheck
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCEventCheck final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCEventCheck">();
	}
	static class UBTTask_NPCEventCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCEventCheck>();
	}
};
static_assert(alignof(UBTTask_NPCEventCheck) == 0x000008, "Wrong alignment on UBTTask_NPCEventCheck");
static_assert(sizeof(UBTTask_NPCEventCheck) == 0x000078, "Wrong size on UBTTask_NPCEventCheck");

// Class DarwinGame.FieldObjectDataTable
// 0x0000 (0x0030 - 0x0030)
class UFieldObjectDataTable final : public UBlueprintFunctionLibrary
{
public:
	static const EAreaType GetAreaType(class FName AssortID);
	static const class FName GetEventID(class FName RowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectDataTable">();
	}
	static class UFieldObjectDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldObjectDataTable>();
	}
};
static_assert(alignof(UFieldObjectDataTable) == 0x000008, "Wrong alignment on UFieldObjectDataTable");
static_assert(sizeof(UFieldObjectDataTable) == 0x000030, "Wrong size on UFieldObjectDataTable");

// Class DarwinGame.UICursor_Partymenu_08
// 0x0000 (0x05E8 - 0x05E8)
class UUICursor_Partymenu_08 : public UUICursor_PartymenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_08">();
	}
	static class UUICursor_Partymenu_08* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_08>();
	}
};
static_assert(alignof(UUICursor_Partymenu_08) == 0x000008, "Wrong alignment on UUICursor_Partymenu_08");
static_assert(sizeof(UUICursor_Partymenu_08) == 0x0005E8, "Wrong size on UUICursor_Partymenu_08");

// Class DarwinGame.StrokeExecution
// 0x0000 (0x0048 - 0x0048)
class UStrokeExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrokeExecution">();
	}
	static class UStrokeExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrokeExecution>();
	}
};
static_assert(alignof(UStrokeExecution) == 0x000008, "Wrong alignment on UStrokeExecution");
static_assert(sizeof(UStrokeExecution) == 0x000048, "Wrong size on UStrokeExecution");

// Class DarwinGame.UIStartLoopAnimation
// 0x0068 (0x04F8 - 0x0490)
class UUIStartLoopAnimation : public UDarwinUserWidget
{
public:
	TMap<class FName, struct FST_StartLoopAnimationData> AnimationData;                                     // 0x0490(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TDelegate<void()>                             StartAnimationEndDelegate;                         // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayLoopAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStartLoopAnimation">();
	}
	static class UUIStartLoopAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStartLoopAnimation>();
	}
};
static_assert(alignof(UUIStartLoopAnimation) == 0x000008, "Wrong alignment on UUIStartLoopAnimation");
static_assert(sizeof(UUIStartLoopAnimation) == 0x0004F8, "Wrong size on UUIStartLoopAnimation");
static_assert(offsetof(UUIStartLoopAnimation, AnimationData) == 0x000490, "Member 'UUIStartLoopAnimation::AnimationData' has a wrong offset!");
static_assert(offsetof(UUIStartLoopAnimation, StartAnimationEndDelegate) == 0x0004E0, "Member 'UUIStartLoopAnimation::StartAnimationEndDelegate' has a wrong offset!");

// Class DarwinGame.UITabLRItemBase
// 0x0008 (0x0500 - 0x04F8)
class UUITabLRItemBase : public UUIStartLoopAnimation
{
public:
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITabLRItemBase">();
	}
	static class UUITabLRItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITabLRItemBase>();
	}
};
static_assert(alignof(UUITabLRItemBase) == 0x000008, "Wrong alignment on UUITabLRItemBase");
static_assert(sizeof(UUITabLRItemBase) == 0x000500, "Wrong size on UUITabLRItemBase");

// Class DarwinGame.UIAreaIcon_00
// 0x0050 (0x0550 - 0x0500)
class UUIAreaIcon_00 final : public UUITabLRItemBase
{
public:
	TMap<EAreaType, struct FST_StationAreaIcon>   AreaIcons;                                         // 0x0500(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaIcon_00">();
	}
	static class UUIAreaIcon_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaIcon_00>();
	}
};
static_assert(alignof(UUIAreaIcon_00) == 0x000008, "Wrong alignment on UUIAreaIcon_00");
static_assert(sizeof(UUIAreaIcon_00) == 0x000550, "Wrong size on UUIAreaIcon_00");
static_assert(offsetof(UUIAreaIcon_00, AreaIcons) == 0x000500, "Member 'UUIAreaIcon_00::AreaIcons' has a wrong offset!");

// Class DarwinGame.BTTask_NPCExWaitTIme
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCExWaitTIme final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCExWaitTIme">();
	}
	static class UBTTask_NPCExWaitTIme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCExWaitTIme>();
	}
};
static_assert(alignof(UBTTask_NPCExWaitTIme) == 0x000008, "Wrong alignment on UBTTask_NPCExWaitTIme");
static_assert(sizeof(UBTTask_NPCExWaitTIme) == 0x000078, "Wrong size on UBTTask_NPCExWaitTIme");

// Class DarwinGame.UIDarkness_Map
// 0x0000 (0x0490 - 0x0490)
class UUIDarkness_Map : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDarkness_Map">();
	}
	static class UUIDarkness_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDarkness_Map>();
	}
};
static_assert(alignof(UUIDarkness_Map) == 0x000008, "Wrong alignment on UUIDarkness_Map");
static_assert(sizeof(UUIDarkness_Map) == 0x000490, "Wrong size on UUIDarkness_Map");

// Class DarwinGame.ExpDataTable
// 0x0000 (0x0030 - 0x0030)
class UExpDataTable final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetRequiredExp(int32 Level, int32 GrowthType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExpDataTable">();
	}
	static class UExpDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExpDataTable>();
	}
};
static_assert(alignof(UExpDataTable) == 0x000008, "Wrong alignment on UExpDataTable");
static_assert(sizeof(UExpDataTable) == 0x000030, "Wrong size on UExpDataTable");

// Class DarwinGame.BTTask_NPCIdleChange
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCIdleChange final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCIdleChange">();
	}
	static class UBTTask_NPCIdleChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCIdleChange>();
	}
};
static_assert(alignof(UBTTask_NPCIdleChange) == 0x000008, "Wrong alignment on UBTTask_NPCIdleChange");
static_assert(sizeof(UBTTask_NPCIdleChange) == 0x000078, "Wrong size on UBTTask_NPCIdleChange");

// Class DarwinGame.BTTask_NPCMoveWaitTime
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCMoveWaitTime final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCMoveWaitTime">();
	}
	static class UBTTask_NPCMoveWaitTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCMoveWaitTime>();
	}
};
static_assert(alignof(UBTTask_NPCMoveWaitTime) == 0x000008, "Wrong alignment on UBTTask_NPCMoveWaitTime");
static_assert(sizeof(UBTTask_NPCMoveWaitTime) == 0x000078, "Wrong size on UBTTask_NPCMoveWaitTime");

// Class DarwinGame.BTTask_NPCNaviCheckPlayerDistance
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCNaviCheckPlayerDistance final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCNaviCheckPlayerDistance">();
	}
	static class UBTTask_NPCNaviCheckPlayerDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCNaviCheckPlayerDistance>();
	}
};
static_assert(alignof(UBTTask_NPCNaviCheckPlayerDistance) == 0x000008, "Wrong alignment on UBTTask_NPCNaviCheckPlayerDistance");
static_assert(sizeof(UBTTask_NPCNaviCheckPlayerDistance) == 0x000078, "Wrong size on UBTTask_NPCNaviCheckPlayerDistance");

// Class DarwinGame.PartyJoinDataTable
// 0x0000 (0x0030 - 0x0030)
class UPartyJoinDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyJoinDataTable">();
	}
	static class UPartyJoinDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyJoinDataTable>();
	}
};
static_assert(alignof(UPartyJoinDataTable) == 0x000008, "Wrong alignment on UPartyJoinDataTable");
static_assert(sizeof(UPartyJoinDataTable) == 0x000030, "Wrong size on UPartyJoinDataTable");

// Class DarwinGame.UIEventRequireItemDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIEventRequireItemDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventRequireItemDataTable">();
	}
	static class UUIEventRequireItemDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventRequireItemDataTable>();
	}
};
static_assert(alignof(UUIEventRequireItemDataTable) == 0x000008, "Wrong alignment on UUIEventRequireItemDataTable");
static_assert(sizeof(UUIEventRequireItemDataTable) == 0x000030, "Wrong size on UUIEventRequireItemDataTable");

// Class DarwinGame.AdditionalDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UAdditionalDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	void CalculateDamage(class AGPACharacter* Target, const struct FAdditionalDamageParam& Request, float* Damage) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdditionalDamageExecution">();
	}
	static class UAdditionalDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdditionalDamageExecution>();
	}
};
static_assert(alignof(UAdditionalDamageExecution) == 0x000008, "Wrong alignment on UAdditionalDamageExecution");
static_assert(sizeof(UAdditionalDamageExecution) == 0x000048, "Wrong size on UAdditionalDamageExecution");

// Class DarwinGame.BTTask_NPCNaviIdleChange
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCNaviIdleChange final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCNaviIdleChange">();
	}
	static class UBTTask_NPCNaviIdleChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCNaviIdleChange>();
	}
};
static_assert(alignof(UBTTask_NPCNaviIdleChange) == 0x000008, "Wrong alignment on UBTTask_NPCNaviIdleChange");
static_assert(sizeof(UBTTask_NPCNaviIdleChange) == 0x000078, "Wrong size on UBTTask_NPCNaviIdleChange");

// Class DarwinGame.BTTask_NpcNaviMoveTo
// 0x0000 (0x00C0 - 0x00C0)
class UBTTask_NpcNaviMoveTo final : public UBTTask_MoveDirectlyToward
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NpcNaviMoveTo">();
	}
	static class UBTTask_NpcNaviMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NpcNaviMoveTo>();
	}
};
static_assert(alignof(UBTTask_NpcNaviMoveTo) == 0x000008, "Wrong alignment on UBTTask_NpcNaviMoveTo");
static_assert(sizeof(UBTTask_NpcNaviMoveTo) == 0x0000C0, "Wrong size on UBTTask_NpcNaviMoveTo");

// Class DarwinGame.ScriptEventBase
// 0x0080 (0x02A8 - 0x0228)
class AScriptEventBase : public AActor
{
public:
	class FName                                   PlayingEventID;                                    // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSection;                                    // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextSection;                                       // 0x0234(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BranchBaseTextID;                                  // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlaySequencer;                                   // 0x024C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsLoading;                                         // 0x024D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsLoadComplete;                                    // 0x024E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24F[0x1];                                      // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SelectFastTravelID;                                // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      CandidateMonsterInfo;                              // 0x0258(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void AddArtifact(int32 ArtifactID, class FName AreaID);
	void AddPartyMember(const int32 UniqueId);
	void CallEventObjectDoEnd(class FName EventID);
	void CallEventObjectDoStart(class FName EventID);
	void CancelBaseAreaBattle();
	void EndEvent();
	void EndingAutoSave(class UTexture2D* Texture);
	void ExecuteEvent();
	void FinPlayerLookAt();
	class FName GetPCChangeTalkID();
	bool HasArtifact(int32 ArtifactID);
	bool IsNpcLoading();
	void LoadPlanEvent(class FName EventID);
	void MoveInverseSideFromEventActor(float MoveTime, int32 NextSectionNum);
	void OpenArtifactRepositoryUI(int32 NextSectionNum);
	void OpenDialogWindow(class FName DaialogTextID, int32 NextSectionNum);
	void OpenFacilityMenu(const int32 NextSectionNum);
	void OpenGroupDialogUI(int32 NextSectionNum);
	void OpenLithographyUI(const class FName MessageID, const int32 NextSectionNum);
	void OpenMainMenuQuest(const int32 NextSectionNum);
	void OpenNewItemTips(class FName ItemId, int32 NextSectionNum, bool IsFirstTimeAddItem);
	void OpenPCChangeUI(int32 NextSectionNum);
	void OpenQuestOrderUI(const TArray<class FName>& QuestIdList, const class FName& NpcID, bool bIsParentDisplay, int32 NextSectionNum, bool bIsNewOrderQuest, bool bIsClearedDisplay);
	void OpenQuestRewardWindow(const class FName QuestID, const int32 NextSectionNum);
	void OpenShopUI(ETradePlace ShopType, int32 NextSectionNum);
	void OpenStaffRoll(const int32 NextSectionNum);
	void OpenTips(class FName TipsID, int32 NextSectionNum);
	void OpenTreasureAppraiseUI(int32 NextSectionNum);
	void PartyMonsterReLocation();
	void PlayIE(class FName EventID, int32 NextSectionNum);
	void PlaySequencerEvent(class FName EventID, int32 NextSectionNum);
	void ReceiveCloseTalkWindow();
	void ReceiveSelectResult();
	void RemoveAllPartyArtifact();
	TArray<int32> RemoveAllPartyMember();
	bool RequestBaseAreaBattleEvent(const class FName QuestID);
	void ResetGameScriptAll();
	void ResetPlayerAndCameraTransform(const struct FTransform& playerTransform, bool isTeleport, const struct FDarwinCameraResetParam& resetCameraParam);
	void SetCandidateMonsterInfo(class FName MonsterId, const int32 MonsterNum, bool IsOverwrite);
	void SetMyTreasure(int32 ArtifactID);
	void SetSelectFastTravelID(class FName FastTravelID);
	void UnLoadEvent(class FName EventID);
	void Update();
	void UpdateMyTreasure(bool IsSoundOn);

	bool IsDispatchPartner() const;
	bool IsLoadingNpcAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptEventBase">();
	}
	static class AScriptEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScriptEventBase>();
	}
};
static_assert(alignof(AScriptEventBase) == 0x000008, "Wrong alignment on AScriptEventBase");
static_assert(sizeof(AScriptEventBase) == 0x0002A8, "Wrong size on AScriptEventBase");
static_assert(offsetof(AScriptEventBase, PlayingEventID) == 0x000228, "Member 'AScriptEventBase::PlayingEventID' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, CurrentSection) == 0x000230, "Member 'AScriptEventBase::CurrentSection' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, NextSection) == 0x000234, "Member 'AScriptEventBase::NextSection' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, BranchBaseTextID) == 0x000238, "Member 'AScriptEventBase::BranchBaseTextID' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, SelectIndex) == 0x000248, "Member 'AScriptEventBase::SelectIndex' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, IsPlaySequencer) == 0x00024C, "Member 'AScriptEventBase::IsPlaySequencer' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, IsLoading) == 0x00024D, "Member 'AScriptEventBase::IsLoading' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, IsLoadComplete) == 0x00024E, "Member 'AScriptEventBase::IsLoadComplete' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, SelectFastTravelID) == 0x000250, "Member 'AScriptEventBase::SelectFastTravelID' has a wrong offset!");
static_assert(offsetof(AScriptEventBase, CandidateMonsterInfo) == 0x000258, "Member 'AScriptEventBase::CandidateMonsterInfo' has a wrong offset!");

// Class DarwinGame.NetworkPersonEvent
// 0x0008 (0x02B0 - 0x02A8)
class ANetworkPersonEvent final : public AScriptEventBase
{
public:
	EOpenNetworkUIType                            NetworkUIOpenType;                                 // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTermsAccept;                                    // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AA[0x6];                                      // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenNetworkTerms();
	void PlaySound();
	void SetEndReplicaTalkEvent(bool flg);
	void SetTreasureHideUpDLCountFlg(bool flg);

	bool GetDipronUIDeleteNpcFlag() const;
	bool GetEndReplicaTalkEvent() const;
	bool GetIsOpenedReplicaTips() const;
	bool GetTreasureHideUpDLCountFlg() const;
	void StartTeamRankUpSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkPersonEvent">();
	}
	static class ANetworkPersonEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANetworkPersonEvent>();
	}
};
static_assert(alignof(ANetworkPersonEvent) == 0x000008, "Wrong alignment on ANetworkPersonEvent");
static_assert(sizeof(ANetworkPersonEvent) == 0x0002B0, "Wrong size on ANetworkPersonEvent");
static_assert(offsetof(ANetworkPersonEvent, NetworkUIOpenType) == 0x0002A8, "Member 'ANetworkPersonEvent::NetworkUIOpenType' has a wrong offset!");
static_assert(offsetof(ANetworkPersonEvent, bIsTermsAccept) == 0x0002A9, "Member 'ANetworkPersonEvent::bIsTermsAccept' has a wrong offset!");

// Class DarwinGame.CommonMonsterAssetData
// 0x0000 (0x0030 - 0x0030)
class UCommonMonsterAssetData final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonMonsterAssetData">();
	}
	static class UCommonMonsterAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonMonsterAssetData>();
	}
};
static_assert(alignof(UCommonMonsterAssetData) == 0x000008, "Wrong alignment on UCommonMonsterAssetData");
static_assert(sizeof(UCommonMonsterAssetData) == 0x000030, "Wrong size on UCommonMonsterAssetData");

// Class DarwinGame.BTTask_NPCNaviSetMoveNextPoint
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCNaviSetMoveNextPoint final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCNaviSetMoveNextPoint">();
	}
	static class UBTTask_NPCNaviSetMoveNextPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCNaviSetMoveNextPoint>();
	}
};
static_assert(alignof(UBTTask_NPCNaviSetMoveNextPoint) == 0x000008, "Wrong alignment on UBTTask_NPCNaviSetMoveNextPoint");
static_assert(sizeof(UBTTask_NPCNaviSetMoveNextPoint) == 0x000078, "Wrong size on UBTTask_NPCNaviSetMoveNextPoint");

// Class DarwinGame.BTTask_NPCNaviSetTurn
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCNaviSetTurn final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCNaviSetTurn">();
	}
	static class UBTTask_NPCNaviSetTurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCNaviSetTurn>();
	}
};
static_assert(alignof(UBTTask_NPCNaviSetTurn) == 0x000008, "Wrong alignment on UBTTask_NPCNaviSetTurn");
static_assert(sizeof(UBTTask_NPCNaviSetTurn) == 0x000078, "Wrong size on UBTTask_NPCNaviSetTurn");

// Class DarwinGame.BTTask_NPCNaviUpdateIndex
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCNaviUpdateIndex final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCNaviUpdateIndex">();
	}
	static class UBTTask_NPCNaviUpdateIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCNaviUpdateIndex>();
	}
};
static_assert(alignof(UBTTask_NPCNaviUpdateIndex) == 0x000008, "Wrong alignment on UBTTask_NPCNaviUpdateIndex");
static_assert(sizeof(UBTTask_NPCNaviUpdateIndex) == 0x000078, "Wrong size on UBTTask_NPCNaviUpdateIndex");

// Class DarwinGame.BTTask_NPCSetMoveNextPoint
// 0x0010 (0x0088 - 0x0078)
class UBTTask_NPCSetMoveNextPoint final : public UBTTaskNode
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCSetMoveNextPoint">();
	}
	static class UBTTask_NPCSetMoveNextPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCSetMoveNextPoint>();
	}
};
static_assert(alignof(UBTTask_NPCSetMoveNextPoint) == 0x000008, "Wrong alignment on UBTTask_NPCSetMoveNextPoint");
static_assert(sizeof(UBTTask_NPCSetMoveNextPoint) == 0x000088, "Wrong size on UBTTask_NPCSetMoveNextPoint");

// Class DarwinGame.BTTask_NPCUpdateMovePointIndex
// 0x0000 (0x0078 - 0x0078)
class UBTTask_NPCUpdateMovePointIndex final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_NPCUpdateMovePointIndex">();
	}
	static class UBTTask_NPCUpdateMovePointIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_NPCUpdateMovePointIndex>();
	}
};
static_assert(alignof(UBTTask_NPCUpdateMovePointIndex) == 0x000008, "Wrong alignment on UBTTask_NPCUpdateMovePointIndex");
static_assert(sizeof(UBTTask_NPCUpdateMovePointIndex) == 0x000078, "Wrong size on UBTTask_NPCUpdateMovePointIndex");

// Class DarwinGame.BTTask_PlayMontage
// 0x0000 (0x0038 - 0x0038)
class UBTTask_PlayMontage final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PlayMontage">();
	}
	static class UBTTask_PlayMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PlayMontage>();
	}
};
static_assert(alignof(UBTTask_PlayMontage) == 0x000008, "Wrong alignment on UBTTask_PlayMontage");
static_assert(sizeof(UBTTask_PlayMontage) == 0x000038, "Wrong size on UBTTask_PlayMontage");

// Class DarwinGame.NetworkManagementSceneCapture
// 0x0020 (0x03A0 - 0x0380)
class ANetworkManagementSceneCapture final : public ASceneCaptureCharacter
{
public:
	class AMonster*                               Monster;                                           // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   LevelSequencePlayer;                               // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       CineCameraActor;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void CopyCameraSettingsToAllSceneCapture(class UCameraComponent* SrcCamera, class USceneCaptureComponent2D* Dst1, class USceneCaptureComponent2D* Dst2);

	class AMonster* GetMonster();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkManagementSceneCapture">();
	}
	static class ANetworkManagementSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANetworkManagementSceneCapture>();
	}
};
static_assert(alignof(ANetworkManagementSceneCapture) == 0x000010, "Wrong alignment on ANetworkManagementSceneCapture");
static_assert(sizeof(ANetworkManagementSceneCapture) == 0x0003A0, "Wrong size on ANetworkManagementSceneCapture");
static_assert(offsetof(ANetworkManagementSceneCapture, Monster) == 0x000380, "Member 'ANetworkManagementSceneCapture::Monster' has a wrong offset!");
static_assert(offsetof(ANetworkManagementSceneCapture, LevelSequenceActor) == 0x000388, "Member 'ANetworkManagementSceneCapture::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(ANetworkManagementSceneCapture, LevelSequencePlayer) == 0x000390, "Member 'ANetworkManagementSceneCapture::LevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(ANetworkManagementSceneCapture, CineCameraActor) == 0x000398, "Member 'ANetworkManagementSceneCapture::CineCameraActor' has a wrong offset!");

// Class DarwinGame.UIStatusBase
// 0x0038 (0x0508 - 0x04D0)
class UUIStatusBase : public UUILeftMenuUseBase
{
public:
	class UUITopbar_00*                           Topbar;                                            // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_PMR_Page_Base*             CurrentPage;                                       // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIPartyMenu_PMR_Page_Base*>     PageArray;                                         // 0x04E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             StatusBaseData;                                    // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusBase">();
	}
	static class UUIStatusBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusBase>();
	}
};
static_assert(alignof(UUIStatusBase) == 0x000008, "Wrong alignment on UUIStatusBase");
static_assert(sizeof(UUIStatusBase) == 0x000508, "Wrong size on UUIStatusBase");
static_assert(offsetof(UUIStatusBase, Topbar) == 0x0004D0, "Member 'UUIStatusBase::Topbar' has a wrong offset!");
static_assert(offsetof(UUIStatusBase, CurrentPage) == 0x0004D8, "Member 'UUIStatusBase::CurrentPage' has a wrong offset!");
static_assert(offsetof(UUIStatusBase, PageArray) == 0x0004E0, "Member 'UUIStatusBase::PageArray' has a wrong offset!");
static_assert(offsetof(UUIStatusBase, StatusBaseData) == 0x0004F8, "Member 'UUIStatusBase::StatusBaseData' has a wrong offset!");

// Class DarwinGame.UIFacility_MonsterStatus
// 0x0070 (0x0578 - 0x0508)
class UUIFacility_MonsterStatus final : public UUIStatusBase
{
public:
	uint8                                         Pad_508[0x10];                                     // 0x0508(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPartyMenu_PMR_Page_00*               Page00;                                            // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_01*               Page01;                                            // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_02*               Page02;                                            // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_03*               Page03;                                            // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_04*               Page04;                                            // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_06_Set*           CoinInfomation;                                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x10];                                     // 0x0548(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICoinMenu*                            CoinMenu;                                          // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0x18];                                     // 0x0560(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Refresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_MonsterStatus">();
	}
	static class UUIFacility_MonsterStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_MonsterStatus>();
	}
};
static_assert(alignof(UUIFacility_MonsterStatus) == 0x000008, "Wrong alignment on UUIFacility_MonsterStatus");
static_assert(sizeof(UUIFacility_MonsterStatus) == 0x000578, "Wrong size on UUIFacility_MonsterStatus");
static_assert(offsetof(UUIFacility_MonsterStatus, Page00) == 0x000518, "Member 'UUIFacility_MonsterStatus::Page00' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterStatus, Page01) == 0x000520, "Member 'UUIFacility_MonsterStatus::Page01' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterStatus, Page02) == 0x000528, "Member 'UUIFacility_MonsterStatus::Page02' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterStatus, Page03) == 0x000530, "Member 'UUIFacility_MonsterStatus::Page03' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterStatus, Page04) == 0x000538, "Member 'UUIFacility_MonsterStatus::Page04' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterStatus, CoinInfomation) == 0x000540, "Member 'UUIFacility_MonsterStatus::CoinInfomation' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterStatus, CoinMenu) == 0x000558, "Member 'UUIFacility_MonsterStatus::CoinMenu' has a wrong offset!");

// Class DarwinGame.DitheringSyncControlBase
// 0x0038 (0x0068 - 0x0030)
class UDitheringSyncControlBase : public UObject
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitheringSyncControlBase">();
	}
	static class UDitheringSyncControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitheringSyncControlBase>();
	}
};
static_assert(alignof(UDitheringSyncControlBase) == 0x000008, "Wrong alignment on UDitheringSyncControlBase");
static_assert(sizeof(UDitheringSyncControlBase) == 0x000068, "Wrong size on UDitheringSyncControlBase");

// Class DarwinGame.DitheringSyncControlConnect
// 0x0010 (0x0078 - 0x0068)
class UDitheringSyncControlConnect final : public UDitheringSyncControlBase
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitheringSyncControlConnect">();
	}
	static class UDitheringSyncControlConnect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitheringSyncControlConnect>();
	}
};
static_assert(alignof(UDitheringSyncControlConnect) == 0x000008, "Wrong alignment on UDitheringSyncControlConnect");
static_assert(sizeof(UDitheringSyncControlConnect) == 0x000078, "Wrong size on UDitheringSyncControlConnect");

// Class DarwinGame.BTTask_Relocation
// 0x0000 (0x0038 - 0x0038)
class UBTTask_Relocation final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Relocation">();
	}
	static class UBTTask_Relocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Relocation>();
	}
};
static_assert(alignof(UBTTask_Relocation) == 0x000008, "Wrong alignment on UBTTask_Relocation");
static_assert(sizeof(UBTTask_Relocation) == 0x000038, "Wrong size on UBTTask_Relocation");

// Class DarwinGame.BTTask_SearchNearestArtifact
// 0x0000 (0x0038 - 0x0038)
class UBTTask_SearchNearestArtifact final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SearchNearestArtifact">();
	}
	static class UBTTask_SearchNearestArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SearchNearestArtifact>();
	}
};
static_assert(alignof(UBTTask_SearchNearestArtifact) == 0x000008, "Wrong alignment on UBTTask_SearchNearestArtifact");
static_assert(sizeof(UBTTask_SearchNearestArtifact) == 0x000038, "Wrong size on UBTTask_SearchNearestArtifact");

// Class DarwinGame.CharacterAssetManagerBase
// 0x00F0 (0x0128 - 0x0038)
class UCharacterAssetManagerBase : public UManagerBase
{
public:
	TMap<class FName, class UCharacterAssetInfo*> CharcterAssetInfoMap;                              // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0xA0];                                      // 0x0088(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCompletedLoad(const class FName& ID);
	bool IsLoading(const class FName& ID);
	void RequestASyncLoadActor(const class FName& ID, const TDelegate<void(class FName ID)>& onEvent);
	void Unload(const class FName& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAssetManagerBase">();
	}
	static class UCharacterAssetManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAssetManagerBase>();
	}
};
static_assert(alignof(UCharacterAssetManagerBase) == 0x000008, "Wrong alignment on UCharacterAssetManagerBase");
static_assert(sizeof(UCharacterAssetManagerBase) == 0x000128, "Wrong size on UCharacterAssetManagerBase");
static_assert(offsetof(UCharacterAssetManagerBase, CharcterAssetInfoMap) == 0x000038, "Member 'UCharacterAssetManagerBase::CharcterAssetInfoMap' has a wrong offset!");

// Class DarwinGame.NPCAssetManager
// 0x0000 (0x0128 - 0x0128)
class UNPCAssetManager : public UCharacterAssetManagerBase
{
public:
	static class UNPCAssetManager* GetInstance();
	static TArray<struct FSoftObjectPath> GetNPCAssetArray(const class FName& ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCAssetManager">();
	}
	static class UNPCAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCAssetManager>();
	}
};
static_assert(alignof(UNPCAssetManager) == 0x000008, "Wrong alignment on UNPCAssetManager");
static_assert(sizeof(UNPCAssetManager) == 0x000128, "Wrong size on UNPCAssetManager");

// Class DarwinGame.NonActionHealExecutionBase
// 0x0000 (0x0048 - 0x0048)
class UNonActionHealExecutionBase : public UGameplayEffectExecutionCalculation
{
public:
	void CalculateHeal(class AGPACharacter* Target, const struct FST_HealRequest& Request, float* Heal) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NonActionHealExecutionBase">();
	}
	static class UNonActionHealExecutionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNonActionHealExecutionBase>();
	}
};
static_assert(alignof(UNonActionHealExecutionBase) == 0x000008, "Wrong alignment on UNonActionHealExecutionBase");
static_assert(sizeof(UNonActionHealExecutionBase) == 0x000048, "Wrong size on UNonActionHealExecutionBase");

// Class DarwinGame.ConstantHealExecution
// 0x0000 (0x0048 - 0x0048)
class UConstantHealExecution final : public UNonActionHealExecutionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstantHealExecution">();
	}
	static class UConstantHealExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstantHealExecution>();
	}
};
static_assert(alignof(UConstantHealExecution) == 0x000008, "Wrong alignment on UConstantHealExecution");
static_assert(sizeof(UConstantHealExecution) == 0x000048, "Wrong size on UConstantHealExecution");

// Class DarwinGame.BTTask_SideStep
// 0x0000 (0x0038 - 0x0038)
class UBTTask_SideStep final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SideStep">();
	}
	static class UBTTask_SideStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SideStep>();
	}
};
static_assert(alignof(UBTTask_SideStep) == 0x000008, "Wrong alignment on UBTTask_SideStep");
static_assert(sizeof(UBTTask_SideStep) == 0x000038, "Wrong size on UBTTask_SideStep");

// Class DarwinGame.ObjectReactionInterface
// 0x0000 (0x0030 - 0x0030)
class IObjectReactionInterface final : public IInterface
{
public:
	void BindEventCalledWhileAccess(const struct FEventCalledWhileAccess& Event);
	void GetObjectReactionTypeWithCaution(EObjectReactionType* ReactionType, EInputGuideCaution* CautionType);
	void HandleAimEvent(bool End);
	void HandleShakeEvent(const struct FVector& HitLocation);
	void OnReceiveHit(EObjectEffectionEnum Type, class AActor* Instigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionInterface">();
	}
	static class IObjectReactionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IObjectReactionInterface>();
	}
};
static_assert(alignof(IObjectReactionInterface) == 0x000008, "Wrong alignment on IObjectReactionInterface");
static_assert(sizeof(IObjectReactionInterface) == 0x000030, "Wrong size on IObjectReactionInterface");

// Class DarwinGame.BTTask_SpecialAbilityEnd
// 0x0000 (0x0038 - 0x0038)
class UBTTask_SpecialAbilityEnd final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SpecialAbilityEnd">();
	}
	static class UBTTask_SpecialAbilityEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SpecialAbilityEnd>();
	}
};
static_assert(alignof(UBTTask_SpecialAbilityEnd) == 0x000008, "Wrong alignment on UBTTask_SpecialAbilityEnd");
static_assert(sizeof(UBTTask_SpecialAbilityEnd) == 0x000038, "Wrong size on UBTTask_SpecialAbilityEnd");

// Class DarwinGame.UIField_ActionIconBase
// 0x0000 (0x05B0 - 0x05B0)
class UUIField_ActionIconBase : public UUI3DBase
{
public:
	class UWidgetAnimation*                       WaitAnimation;                                     // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_ActionIconBase">();
	}
	static class UUIField_ActionIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_ActionIconBase>();
	}
};
static_assert(alignof(UUIField_ActionIconBase) == 0x000010, "Wrong alignment on UUIField_ActionIconBase");
static_assert(sizeof(UUIField_ActionIconBase) == 0x0005B0, "Wrong size on UUIField_ActionIconBase");
static_assert(offsetof(UUIField_ActionIconBase, WaitAnimation) == 0x0005A8, "Member 'UUIField_ActionIconBase::WaitAnimation' has a wrong offset!");

// Class DarwinGame.DarwinCheatManager
// 0x0000 (0x0080 - 0x0080)
class UDarwinCheatManager final : public UCheatManager
{
public:
	void DumpClusterOutsideRefs(const class FString& ClusterName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinCheatManager">();
	}
	static class UDarwinCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinCheatManager>();
	}
};
static_assert(alignof(UDarwinCheatManager) == 0x000008, "Wrong alignment on UDarwinCheatManager");
static_assert(sizeof(UDarwinCheatManager) == 0x000080, "Wrong size on UDarwinCheatManager");

// Class DarwinGame.BTTask_SpecialAbilityStart
// 0x0000 (0x0038 - 0x0038)
class UBTTask_SpecialAbilityStart final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SpecialAbilityStart">();
	}
	static class UBTTask_SpecialAbilityStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SpecialAbilityStart>();
	}
};
static_assert(alignof(UBTTask_SpecialAbilityStart) == 0x000008, "Wrong alignment on UBTTask_SpecialAbilityStart");
static_assert(sizeof(UBTTask_SpecialAbilityStart) == 0x000038, "Wrong size on UBTTask_SpecialAbilityStart");

// Class DarwinGame.BTTask_TraceTo
// 0x0030 (0x0068 - 0x0038)
class UBTTask_TraceTo final : public UMonsterBTTask
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TraceTo">();
	}
	static class UBTTask_TraceTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TraceTo>();
	}
};
static_assert(alignof(UBTTask_TraceTo) == 0x000008, "Wrong alignment on UBTTask_TraceTo");
static_assert(sizeof(UBTTask_TraceTo) == 0x000068, "Wrong size on UBTTask_TraceTo");

// Class DarwinGame.BTTask_TurnToBase
// 0x0000 (0x0038 - 0x0038)
class UBTTask_TurnToBase : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TurnToBase">();
	}
	static class UBTTask_TurnToBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TurnToBase>();
	}
};
static_assert(alignof(UBTTask_TurnToBase) == 0x000008, "Wrong alignment on UBTTask_TurnToBase");
static_assert(sizeof(UBTTask_TurnToBase) == 0x000038, "Wrong size on UBTTask_TurnToBase");

// Class DarwinGame.DarwinAddOnComponent
// 0x0000 (0x0030 - 0x0030)
class UDarwinAddOnComponent final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinAddOnComponent">();
	}
	static class UDarwinAddOnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinAddOnComponent>();
	}
};
static_assert(alignof(UDarwinAddOnComponent) == 0x000008, "Wrong alignment on UDarwinAddOnComponent");
static_assert(sizeof(UDarwinAddOnComponent) == 0x000030, "Wrong size on UDarwinAddOnComponent");

// Class DarwinGame.BTTask_TurnToAngle
// 0x0000 (0x0038 - 0x0038)
class UBTTask_TurnToAngle final : public UBTTask_TurnToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TurnToAngle">();
	}
	static class UBTTask_TurnToAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TurnToAngle>();
	}
};
static_assert(alignof(UBTTask_TurnToAngle) == 0x000008, "Wrong alignment on UBTTask_TurnToAngle");
static_assert(sizeof(UBTTask_TurnToAngle) == 0x000038, "Wrong size on UBTTask_TurnToAngle");

// Class DarwinGame.NotInWaterRequirement
// 0x0000 (0x0030 - 0x0030)
class UNotInWaterRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotInWaterRequirement">();
	}
	static class UNotInWaterRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotInWaterRequirement>();
	}
};
static_assert(alignof(UNotInWaterRequirement) == 0x000008, "Wrong alignment on UNotInWaterRequirement");
static_assert(sizeof(UNotInWaterRequirement) == 0x000030, "Wrong size on UNotInWaterRequirement");

// Class DarwinGame.UIStation_TabIconChoice
// 0x0050 (0x0550 - 0x0500)
class UUIStation_TabIconChoice final : public UUITabLRItemBase
{
public:
	TMap<EAreaType, class UTexture2D*>            AreaIconList;                                      // 0x0500(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_TabIconChoice">();
	}
	static class UUIStation_TabIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_TabIconChoice>();
	}
};
static_assert(alignof(UUIStation_TabIconChoice) == 0x000008, "Wrong alignment on UUIStation_TabIconChoice");
static_assert(sizeof(UUIStation_TabIconChoice) == 0x000550, "Wrong size on UUIStation_TabIconChoice");
static_assert(offsetof(UUIStation_TabIconChoice, AreaIconList) == 0x000500, "Member 'UUIStation_TabIconChoice::AreaIconList' has a wrong offset!");

// Class DarwinGame.UIGood_Directing
// 0x0070 (0x0500 - 0x0490)
class alignas(0x10) UUIGood_Directing final : public UDarwinUserWidget
{
public:
	class UUIGood*                                GoodWidget;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGood_TopLayer*                       GoodTopLayer;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITalk_WinStatusBase*                  TalkWin;                                           // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinArtifactTwoCaptureImage*         CaptureEffectImage;                                // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x50];                                     // 0x04B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_Directing">();
	}
	static class UUIGood_Directing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_Directing>();
	}
};
static_assert(alignof(UUIGood_Directing) == 0x000010, "Wrong alignment on UUIGood_Directing");
static_assert(sizeof(UUIGood_Directing) == 0x000500, "Wrong size on UUIGood_Directing");
static_assert(offsetof(UUIGood_Directing, GoodWidget) == 0x000490, "Member 'UUIGood_Directing::GoodWidget' has a wrong offset!");
static_assert(offsetof(UUIGood_Directing, GoodTopLayer) == 0x000498, "Member 'UUIGood_Directing::GoodTopLayer' has a wrong offset!");
static_assert(offsetof(UUIGood_Directing, TalkWin) == 0x0004A0, "Member 'UUIGood_Directing::TalkWin' has a wrong offset!");
static_assert(offsetof(UUIGood_Directing, CaptureEffectImage) == 0x0004A8, "Member 'UUIGood_Directing::CaptureEffectImage' has a wrong offset!");

// Class DarwinGame.EstimateSceneCaptureSecond
// 0x0040 (0x03C0 - 0x0380)
class AEstimateSceneCaptureSecond final : public ASceneCaptureTwoCameraBase
{
public:
	TSubclassOf<class AEffectBase>                RainbowConfettiEffectRes;                          // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                SilverConfettiEffectRes;                           // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEstimateLighting>          LightRes;                                          // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            ConfettiEffect;                                    // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEstimateLighting*                      LightActor;                                        // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateSceneCaptureSecond">();
	}
	static class AEstimateSceneCaptureSecond* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimateSceneCaptureSecond>();
	}
};
static_assert(alignof(AEstimateSceneCaptureSecond) == 0x000010, "Wrong alignment on AEstimateSceneCaptureSecond");
static_assert(sizeof(AEstimateSceneCaptureSecond) == 0x0003C0, "Wrong size on AEstimateSceneCaptureSecond");
static_assert(offsetof(AEstimateSceneCaptureSecond, RainbowConfettiEffectRes) == 0x000380, "Member 'AEstimateSceneCaptureSecond::RainbowConfettiEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCaptureSecond, SilverConfettiEffectRes) == 0x000388, "Member 'AEstimateSceneCaptureSecond::SilverConfettiEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCaptureSecond, LightRes) == 0x000390, "Member 'AEstimateSceneCaptureSecond::LightRes' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCaptureSecond, ConfettiEffect) == 0x000398, "Member 'AEstimateSceneCaptureSecond::ConfettiEffect' has a wrong offset!");
static_assert(offsetof(AEstimateSceneCaptureSecond, LightActor) == 0x0003A0, "Member 'AEstimateSceneCaptureSecond::LightActor' has a wrong offset!");

// Class DarwinGame.BTTask_TurnToLocation
// 0x0000 (0x0038 - 0x0038)
class UBTTask_TurnToLocation final : public UBTTask_TurnToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TurnToLocation">();
	}
	static class UBTTask_TurnToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TurnToLocation>();
	}
};
static_assert(alignof(UBTTask_TurnToLocation) == 0x000008, "Wrong alignment on UBTTask_TurnToLocation");
static_assert(sizeof(UBTTask_TurnToLocation) == 0x000038, "Wrong size on UBTTask_TurnToLocation");

// Class DarwinGame.GameDataHeaderLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataHeaderLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataHeaderLibrary">();
	}
	static class UGameDataHeaderLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataHeaderLibrary>();
	}
};
static_assert(alignof(UGameDataHeaderLibrary) == 0x000008, "Wrong alignment on UGameDataHeaderLibrary");
static_assert(sizeof(UGameDataHeaderLibrary) == 0x000030, "Wrong size on UGameDataHeaderLibrary");

// Class DarwinGame.ReduceStunRequirement
// 0x0000 (0x0030 - 0x0030)
class UReduceStunRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReduceStunRequirement">();
	}
	static class UReduceStunRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReduceStunRequirement>();
	}
};
static_assert(alignof(UReduceStunRequirement) == 0x000008, "Wrong alignment on UReduceStunRequirement");
static_assert(sizeof(UReduceStunRequirement) == 0x000030, "Wrong size on UReduceStunRequirement");

// Class DarwinGame.BTTask_WaitActionCycle
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_WaitActionCycle final : public UBTTask_WaitBlackboardTime
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitActionCycle">();
	}
	static class UBTTask_WaitActionCycle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitActionCycle>();
	}
};
static_assert(alignof(UBTTask_WaitActionCycle) == 0x000008, "Wrong alignment on UBTTask_WaitActionCycle");
static_assert(sizeof(UBTTask_WaitActionCycle) == 0x0000A8, "Wrong size on UBTTask_WaitActionCycle");

// Class DarwinGame.UIHub_Coin_01
// 0x0000 (0x0490 - 0x0490)
class UUIHub_Coin_01 final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_Coin_01">();
	}
	static class UUIHub_Coin_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_Coin_01>();
	}
};
static_assert(alignof(UUIHub_Coin_01) == 0x000008, "Wrong alignment on UUIHub_Coin_01");
static_assert(sizeof(UUIHub_Coin_01) == 0x000490, "Wrong size on UUIHub_Coin_01");

// Class DarwinGame.DungeonPointNest
// 0x00D8 (0x0398 - 0x02C0)
class ADungeonPointNest : public AArtifactPointBase
{
public:
	class USceneComponent*                        mRoot;                                             // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       EffectCollision;                                   // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            EntranceEffect;                                    // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectReactionDefaultComponent*        ObjectReactionComponent;                           // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDungeonNestType, class FName>           ChoiceTextID;                                      // 0x02E0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EDungeonNestType, class FName>           AppearanceTextID;                                  // 0x0330(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   BigStarScarBossChoiceTextID;                       // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NestTipsID;                                        // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonPointNest">();
	}
	static class ADungeonPointNest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonPointNest>();
	}
};
static_assert(alignof(ADungeonPointNest) == 0x000008, "Wrong alignment on ADungeonPointNest");
static_assert(sizeof(ADungeonPointNest) == 0x000398, "Wrong size on ADungeonPointNest");
static_assert(offsetof(ADungeonPointNest, mRoot) == 0x0002C0, "Member 'ADungeonPointNest::mRoot' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, EffectCollision) == 0x0002C8, "Member 'ADungeonPointNest::EffectCollision' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, EntranceEffect) == 0x0002D0, "Member 'ADungeonPointNest::EntranceEffect' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, ObjectReactionComponent) == 0x0002D8, "Member 'ADungeonPointNest::ObjectReactionComponent' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, ChoiceTextID) == 0x0002E0, "Member 'ADungeonPointNest::ChoiceTextID' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, AppearanceTextID) == 0x000330, "Member 'ADungeonPointNest::AppearanceTextID' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, BigStarScarBossChoiceTextID) == 0x000380, "Member 'ADungeonPointNest::BigStarScarBossChoiceTextID' has a wrong offset!");
static_assert(offsetof(ADungeonPointNest, NestTipsID) == 0x000388, "Member 'ADungeonPointNest::NestTipsID' has a wrong offset!");

// Class DarwinGame.BTTask_WaitState
// 0x0000 (0x0038 - 0x0038)
class UBTTask_WaitState final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitState">();
	}
	static class UBTTask_WaitState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitState>();
	}
};
static_assert(alignof(UBTTask_WaitState) == 0x000008, "Wrong alignment on UBTTask_WaitState");
static_assert(sizeof(UBTTask_WaitState) == 0x000038, "Wrong size on UBTTask_WaitState");

// Class DarwinGame.QuicksandBase
// 0x0018 (0x0300 - 0x02E8)
class AQuicksandBase final : public AFieldTerrainBase
{
public:
	class UMaterialInstanceDynamic*               QuicksandDMI;                                      // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PN_SandFlow;                                       // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SandFlowUV;                                        // 0x02F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetQuicksandDMI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuicksandBase">();
	}
	static class AQuicksandBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuicksandBase>();
	}
};
static_assert(alignof(AQuicksandBase) == 0x000008, "Wrong alignment on AQuicksandBase");
static_assert(sizeof(AQuicksandBase) == 0x000300, "Wrong size on AQuicksandBase");
static_assert(offsetof(AQuicksandBase, QuicksandDMI) == 0x0002E8, "Member 'AQuicksandBase::QuicksandDMI' has a wrong offset!");
static_assert(offsetof(AQuicksandBase, PN_SandFlow) == 0x0002F0, "Member 'AQuicksandBase::PN_SandFlow' has a wrong offset!");
static_assert(offsetof(AQuicksandBase, SandFlowUV) == 0x0002F8, "Member 'AQuicksandBase::SandFlowUV' has a wrong offset!");

// Class DarwinGame.BTTask_WaitWhileMontagePlaying
// 0x0000 (0x0080 - 0x0080)
class UBTTask_WaitWhileMontagePlaying final : public UBTTask_Wait
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitWhileMontagePlaying">();
	}
	static class UBTTask_WaitWhileMontagePlaying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitWhileMontagePlaying>();
	}
};
static_assert(alignof(UBTTask_WaitWhileMontagePlaying) == 0x000008, "Wrong alignment on UBTTask_WaitWhileMontagePlaying");
static_assert(sizeof(UBTTask_WaitWhileMontagePlaying) == 0x000080, "Wrong size on UBTTask_WaitWhileMontagePlaying");

// Class DarwinGame.UIStation_AffinityText
// 0x0018 (0x04A8 - 0x0490)
class UUIStation_AffinityText final : public UDarwinUserWidget
{
public:
	TArray<class UObject*>                        MaterialList;                                      // 0x0490(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_AffinityText">();
	}
	static class UUIStation_AffinityText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_AffinityText>();
	}
};
static_assert(alignof(UUIStation_AffinityText) == 0x000008, "Wrong alignment on UUIStation_AffinityText");
static_assert(sizeof(UUIStation_AffinityText) == 0x0004A8, "Wrong size on UUIStation_AffinityText");
static_assert(offsetof(UUIStation_AffinityText, MaterialList) == 0x000490, "Member 'UUIStation_AffinityText::MaterialList' has a wrong offset!");

// Class DarwinGame.BTTask_Warp
// 0x0000 (0x0038 - 0x0038)
class UBTTask_Warp final : public UMonsterBTTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Warp">();
	}
	static class UBTTask_Warp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Warp>();
	}
};
static_assert(alignof(UBTTask_Warp) == 0x000008, "Wrong alignment on UBTTask_Warp");
static_assert(sizeof(UBTTask_Warp) == 0x000038, "Wrong size on UBTTask_Warp");

// Class DarwinGame.DungeonGimmickMonster
// 0x0028 (0x02E0 - 0x02B8)
class ADungeonGimmickMonster final : public ADungeonGimmickObjectBase
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterSpawnedCallbackHolder*          spawnedCallback;                                   // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnemyMonsterSpawned(class AMonsterBase* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickMonster">();
	}
	static class ADungeonGimmickMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickMonster>();
	}
};
static_assert(alignof(ADungeonGimmickMonster) == 0x000008, "Wrong alignment on ADungeonGimmickMonster");
static_assert(sizeof(ADungeonGimmickMonster) == 0x0002E0, "Wrong size on ADungeonGimmickMonster");
static_assert(offsetof(ADungeonGimmickMonster, spawnedCallback) == 0x0002C8, "Member 'ADungeonGimmickMonster::spawnedCallback' has a wrong offset!");

// Class DarwinGame.EventFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UEventFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeCurrentApertureWithResolution(class UCineCameraComponent* Component);
	static struct FST_CecilyTextData GetCecilyTextData();
	static int32 GetEpisodeProgress(EEpisodeType Type);
	static ETalkFukidashiColor GetEventFukidashiColor(const class FName& EventID);
	static struct FVector GetGroundLocation(class ACharacter* Character, const struct FVector& Location);
	static bool GetLocationFromNavimesh(const struct FVector& FromLocation, struct FVector* NaviLocation, const bool IsRaw);
	static class FName GetPCChangeTalkID(const bool IsBefore);
	static class AStationBase* GetStationObject();
	static class FName GetStationReleaseEventID(const class FName StationID);
	static bool HasAllGetSevenStone();
	static void InitializeNotSequencer();
	static void InitializeSequencer();
	static bool IsEventTestFlag();
	static bool IsSkippableEvent(const class FName EventID);
	static bool SetHideVolcaGigarss();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventFunctionLibrary">();
	}
	static class UEventFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventFunctionLibrary>();
	}
};
static_assert(alignof(UEventFunctionLibrary) == 0x000008, "Wrong alignment on UEventFunctionLibrary");
static_assert(sizeof(UEventFunctionLibrary) == 0x000030, "Wrong size on UEventFunctionLibrary");

// Class DarwinGame.BTTaskBlueprintDarwin
// 0x0000 (0x00B0 - 0x00B0)
class UBTTaskBlueprintDarwin : public UBTTask_BlueprintBase
{
public:
	void ReceiveFinished(class AAIController* OwnerController, class APawn* ControlledPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTaskBlueprintDarwin">();
	}
	static class UBTTaskBlueprintDarwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTaskBlueprintDarwin>();
	}
};
static_assert(alignof(UBTTaskBlueprintDarwin) == 0x000008, "Wrong alignment on UBTTaskBlueprintDarwin");
static_assert(sizeof(UBTTaskBlueprintDarwin) == 0x0000B0, "Wrong size on UBTTaskBlueprintDarwin");

// Class DarwinGame.GameDataNPC
// 0x0058 (0x0088 - 0x0030)
class UGameDataNPC final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataNPC* Clone();
	void Overwrite(class UGameDataNPC* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataNPC">();
	}
	static class UGameDataNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataNPC>();
	}
};
static_assert(alignof(UGameDataNPC) == 0x000008, "Wrong alignment on UGameDataNPC");
static_assert(sizeof(UGameDataNPC) == 0x000088, "Wrong size on UGameDataNPC");

// Class DarwinGame.BulletBase
// 0x0088 (0x02B0 - 0x0228)
class ABulletBase : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0230(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           BulletMovement;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBattleSystemComponent*                 BattleSystem;                                      // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            TrailEffect;                                       // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActionGameplayEffectContainerSpec     EffectContainerSpec;                               // 0x0260(0x0038)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	class AAttackCollisionBase*                   mAttackCollision;                                  // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    MoveCollision;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletBase">();
	}
	static class ABulletBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletBase>();
	}
};
static_assert(alignof(ABulletBase) == 0x000008, "Wrong alignment on ABulletBase");
static_assert(sizeof(ABulletBase) == 0x0002B0, "Wrong size on ABulletBase");
static_assert(offsetof(ABulletBase, Direction) == 0x000230, "Member 'ABulletBase::Direction' has a wrong offset!");
static_assert(offsetof(ABulletBase, BulletMovement) == 0x000240, "Member 'ABulletBase::BulletMovement' has a wrong offset!");
static_assert(offsetof(ABulletBase, BattleSystem) == 0x000248, "Member 'ABulletBase::BattleSystem' has a wrong offset!");
static_assert(offsetof(ABulletBase, TrailEffect) == 0x000250, "Member 'ABulletBase::TrailEffect' has a wrong offset!");
static_assert(offsetof(ABulletBase, Speed) == 0x000258, "Member 'ABulletBase::Speed' has a wrong offset!");
static_assert(offsetof(ABulletBase, EffectContainerSpec) == 0x000260, "Member 'ABulletBase::EffectContainerSpec' has a wrong offset!");
static_assert(offsetof(ABulletBase, mAttackCollision) == 0x000298, "Member 'ABulletBase::mAttackCollision' has a wrong offset!");
static_assert(offsetof(ABulletBase, MoveCollision) == 0x0002A8, "Member 'ABulletBase::MoveCollision' has a wrong offset!");

// Class DarwinGame.QuestEvent
// 0x0018 (0x0048 - 0x0030)
class UQuestEvent final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestEvent">();
	}
	static class UQuestEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestEvent>();
	}
};
static_assert(alignof(UQuestEvent) == 0x000008, "Wrong alignment on UQuestEvent");
static_assert(sizeof(UQuestEvent) == 0x000048, "Wrong size on UQuestEvent");

// Class DarwinGame.UIStation_CategoryIconBase
// 0x0008 (0x0498 - 0x0490)
class UUIStation_CategoryIconBase : public UDarwinUserWidget
{
public:
	class UImage*                                 Icon;                                              // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_CategoryIconBase">();
	}
	static class UUIStation_CategoryIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_CategoryIconBase>();
	}
};
static_assert(alignof(UUIStation_CategoryIconBase) == 0x000008, "Wrong alignment on UUIStation_CategoryIconBase");
static_assert(sizeof(UUIStation_CategoryIconBase) == 0x000498, "Wrong size on UUIStation_CategoryIconBase");
static_assert(offsetof(UUIStation_CategoryIconBase, Icon) == 0x000490, "Member 'UUIStation_CategoryIconBase::Icon' has a wrong offset!");

// Class DarwinGame.UIStation_CategoryIcon_S
// 0x0000 (0x0498 - 0x0498)
class UUIStation_CategoryIcon_S final : public UUIStation_CategoryIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_CategoryIcon_S">();
	}
	static class UUIStation_CategoryIcon_S* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_CategoryIcon_S>();
	}
};
static_assert(alignof(UUIStation_CategoryIcon_S) == 0x000008, "Wrong alignment on UUIStation_CategoryIcon_S");
static_assert(sizeof(UUIStation_CategoryIcon_S) == 0x000498, "Wrong size on UUIStation_CategoryIcon_S");

// Class DarwinGame.DiscoveryTreasureDataTable
// 0x0000 (0x0030 - 0x0030)
class UDiscoveryTreasureDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiscoveryTreasureDataTable">();
	}
	static class UDiscoveryTreasureDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiscoveryTreasureDataTable>();
	}
};
static_assert(alignof(UDiscoveryTreasureDataTable) == 0x000008, "Wrong alignment on UDiscoveryTreasureDataTable");
static_assert(sizeof(UDiscoveryTreasureDataTable) == 0x000030, "Wrong size on UDiscoveryTreasureDataTable");

// Class DarwinGame.BulletDataTable
// 0x0000 (0x0030 - 0x0030)
class UBulletDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletDataTable">();
	}
	static class UBulletDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulletDataTable>();
	}
};
static_assert(alignof(UBulletDataTable) == 0x000008, "Wrong alignment on UBulletDataTable");
static_assert(sizeof(UBulletDataTable) == 0x000030, "Wrong size on UBulletDataTable");

// Class DarwinGame.RivalTeamStampManager
// 0x0020 (0x0058 - 0x0038)
class URivalTeamStampManager final : public UManagerBase
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URivalTeamStampManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RivalTeamStampManager">();
	}
	static class URivalTeamStampManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URivalTeamStampManager>();
	}
};
static_assert(alignof(URivalTeamStampManager) == 0x000008, "Wrong alignment on URivalTeamStampManager");
static_assert(sizeof(URivalTeamStampManager) == 0x000058, "Wrong size on URivalTeamStampManager");

// Class DarwinGame.UIHub_Status
// 0x0078 (0x0508 - 0x0490)
class UUIHub_Status : public UDarwinUserWidget
{
public:
	TSoftClassPtr<class UClass>                   CoinWindowSoftClass;                               // 0x0490(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ThomassonSoftClass;                                // 0x04B8(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x28];                                     // 0x04E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_Status">();
	}
	static class UUIHub_Status* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_Status>();
	}
};
static_assert(alignof(UUIHub_Status) == 0x000008, "Wrong alignment on UUIHub_Status");
static_assert(sizeof(UUIHub_Status) == 0x000508, "Wrong size on UUIHub_Status");
static_assert(offsetof(UUIHub_Status, CoinWindowSoftClass) == 0x000490, "Member 'UUIHub_Status::CoinWindowSoftClass' has a wrong offset!");
static_assert(offsetof(UUIHub_Status, ThomassonSoftClass) == 0x0004B8, "Member 'UUIHub_Status::ThomassonSoftClass' has a wrong offset!");

// Class DarwinGame.DarwinTextSetSystem
// 0x0000 (0x0030 - 0x0030)
class UDarwinTextSetSystem final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinTextSetSystem">();
	}
	static class UDarwinTextSetSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinTextSetSystem>();
	}
};
static_assert(alignof(UDarwinTextSetSystem) == 0x000008, "Wrong alignment on UDarwinTextSetSystem");
static_assert(sizeof(UDarwinTextSetSystem) == 0x000030, "Wrong size on UDarwinTextSetSystem");

// Class DarwinGame.BulletMagicBase
// 0x0080 (0x0390 - 0x0310)
class ABulletMagicBase final : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x80];                                     // 0x0310(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamage();
	void OnHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletMagicBase">();
	}
	static class ABulletMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletMagicBase>();
	}
};
static_assert(alignof(ABulletMagicBase) == 0x000008, "Wrong alignment on ABulletMagicBase");
static_assert(sizeof(ABulletMagicBase) == 0x000390, "Wrong size on ABulletMagicBase");

// Class DarwinGame.ResidentDataManager
// 0x0018 (0x0050 - 0x0038)
class UResidentDataManager : public UManagerBase
{
public:
	TArray<TSoftObjectPtr<class UDataTable>>      mDataTablePath;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UResidentDataManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResidentDataManager">();
	}
	static class UResidentDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResidentDataManager>();
	}
};
static_assert(alignof(UResidentDataManager) == 0x000008, "Wrong alignment on UResidentDataManager");
static_assert(sizeof(UResidentDataManager) == 0x000050, "Wrong size on UResidentDataManager");
static_assert(offsetof(UResidentDataManager, mDataTablePath) == 0x000038, "Member 'UResidentDataManager::mDataTablePath' has a wrong offset!");

// Class DarwinGame.UIStartup_Screen
// 0x0028 (0x04B8 - 0x0490)
class UUIStartup_Screen final : public UDarwinUserWidget
{
public:
	TArray<struct FST_StartupScreenSetting>       Settings;                                          // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                BasePanel;                                         // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStartup_Screen">();
	}
	static class UUIStartup_Screen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStartup_Screen>();
	}
};
static_assert(alignof(UUIStartup_Screen) == 0x000008, "Wrong alignment on UUIStartup_Screen");
static_assert(sizeof(UUIStartup_Screen) == 0x0004B8, "Wrong size on UUIStartup_Screen");
static_assert(offsetof(UUIStartup_Screen, Settings) == 0x000490, "Member 'UUIStartup_Screen::Settings' has a wrong offset!");
static_assert(offsetof(UUIStartup_Screen, BasePanel) == 0x0004A8, "Member 'UUIStartup_Screen::BasePanel' has a wrong offset!");

// Class DarwinGame.BulletPath
// 0x0008 (0x0230 - 0x0228)
class ABulletPath final : public AActor
{
public:
	class USplineComponent*                       Path;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ABulletPath* Clone();
	void SetPathPoint(const struct FVector& Start, const struct FVector& End, const struct FVector& StartTangent, const struct FVector& EndTangent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletPath">();
	}
	static class ABulletPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletPath>();
	}
};
static_assert(alignof(ABulletPath) == 0x000008, "Wrong alignment on ABulletPath");
static_assert(sizeof(ABulletPath) == 0x000230, "Wrong size on ABulletPath");
static_assert(offsetof(ABulletPath, Path) == 0x000228, "Member 'ABulletPath::Path' has a wrong offset!");

// Class DarwinGame.CagecartDoorBase
// 0x0010 (0x02C0 - 0x02B0)
class ACagecartDoorBase final : public AFieldObjectBase
{
public:
	class FName                                   EventID;                                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectReactionEventComponent*          ObjectReactionComponent;                           // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AllOpenToClose(bool IsSkip);
	void AllOpenToHalfOpen(bool IsSkip);
	void CloseToAllOpen(bool IsSkip);
	void CloseToHalfOpen(bool IsSkip);
	void HalfOpenToAllOpen(bool IsSkip);
	void HalfOpenToClose(bool IsSkip);
	void InitializeState(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CagecartDoorBase">();
	}
	static class ACagecartDoorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACagecartDoorBase>();
	}
};
static_assert(alignof(ACagecartDoorBase) == 0x000008, "Wrong alignment on ACagecartDoorBase");
static_assert(sizeof(ACagecartDoorBase) == 0x0002C0, "Wrong size on ACagecartDoorBase");
static_assert(offsetof(ACagecartDoorBase, EventID) == 0x0002B0, "Member 'ACagecartDoorBase::EventID' has a wrong offset!");
static_assert(offsetof(ACagecartDoorBase, ObjectReactionComponent) == 0x0002B8, "Member 'ACagecartDoorBase::ObjectReactionComponent' has a wrong offset!");

// Class DarwinGame.GameDataNetworkLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataNetworkLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataNetworkLibrary">();
	}
	static class UGameDataNetworkLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataNetworkLibrary>();
	}
};
static_assert(alignof(UGameDataNetworkLibrary) == 0x000008, "Wrong alignment on UGameDataNetworkLibrary");
static_assert(sizeof(UGameDataNetworkLibrary) == 0x000030, "Wrong size on UGameDataNetworkLibrary");

// Class DarwinGame.DailyQuestDataAsset
// 0x0020 (0x0058 - 0x0038)
class UDailyQuestDataAsset final : public UDataAsset
{
public:
	struct FDailyQuestConfig                      mConfig;                                           // 0x0038(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyQuestDataAsset">();
	}
	static class UDailyQuestDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDailyQuestDataAsset>();
	}
};
static_assert(alignof(UDailyQuestDataAsset) == 0x000008, "Wrong alignment on UDailyQuestDataAsset");
static_assert(sizeof(UDailyQuestDataAsset) == 0x000058, "Wrong size on UDailyQuestDataAsset");
static_assert(offsetof(UDailyQuestDataAsset, mConfig) == 0x000038, "Member 'UDailyQuestDataAsset::mConfig' has a wrong offset!");

// Class DarwinGame.UISign_Fukidashi
// 0x0010 (0x05C0 - 0x05B0)
class UUISign_Fukidashi : public UUI3DBase
{
public:
	class UDataTable*                             FukidashiDataTable;                                // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBalloonData(EFukidashiEnum Type);
	void SetBalloonDataAdvance(ETalkFukidashiType Type, ETalkFukidashiColor Color);
	void SetFukidashiData(EFukidashiEnum Type, const class FText& FukidashiText, float CloseTime);
	void SetFukidashiDataAdvance(const class FString& FukidashiText, float CloseTime, const ETalkFukidashiType Type, const ETalkFukidashiColor Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_Fukidashi">();
	}
	static class UUISign_Fukidashi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_Fukidashi>();
	}
};
static_assert(alignof(UUISign_Fukidashi) == 0x000010, "Wrong alignment on UUISign_Fukidashi");
static_assert(sizeof(UUISign_Fukidashi) == 0x0005C0, "Wrong size on UUISign_Fukidashi");
static_assert(offsetof(UUISign_Fukidashi, FukidashiDataTable) == 0x0005A8, "Member 'UUISign_Fukidashi::FukidashiDataTable' has a wrong offset!");

// Class DarwinGame.EventTrigger
// 0x0038 (0x0260 - 0x0228)
class AEventTrigger : public AActor
{
public:
	bool                                          IsEventPlayOnce;                                   // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventID;                                           // 0x022C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsActiveEvent;                                     // 0x0234(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_235[0x2B];                                     // 0x0235(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartEvent();
	void SetEventIDToEventSender(class FName event_id);
	void SetHitBoxSideNormal(const struct FVector& Normal);
	void SetIsOverlapEvent(bool isOverlap);
	void SetOverlapActorLocation(const struct FVector& Location);
	void SetOverlapActorMovementVector(const struct FVector& Vector);

	bool CanPlayEventUniqueCondition(class FName event_id) const;
	bool Debug_IsNotPlayEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTrigger">();
	}
	static class AEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventTrigger>();
	}
};
static_assert(alignof(AEventTrigger) == 0x000008, "Wrong alignment on AEventTrigger");
static_assert(sizeof(AEventTrigger) == 0x000260, "Wrong size on AEventTrigger");
static_assert(offsetof(AEventTrigger, IsEventPlayOnce) == 0x000228, "Member 'AEventTrigger::IsEventPlayOnce' has a wrong offset!");
static_assert(offsetof(AEventTrigger, EventID) == 0x00022C, "Member 'AEventTrigger::EventID' has a wrong offset!");
static_assert(offsetof(AEventTrigger, IsActiveEvent) == 0x000234, "Member 'AEventTrigger::IsActiveEvent' has a wrong offset!");

// Class DarwinGame.CallingEnemy
// 0x0000 (0x0038 - 0x0038)
class UCallingEnemy final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallingEnemy">();
	}
	static class UCallingEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallingEnemy>();
	}
};
static_assert(alignof(UCallingEnemy) == 0x000008, "Wrong alignment on UCallingEnemy");
static_assert(sizeof(UCallingEnemy) == 0x000038, "Wrong size on UCallingEnemy");

// Class DarwinGame.GameDataQuestLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataQuestLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataQuestLibrary">();
	}
	static class UGameDataQuestLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataQuestLibrary>();
	}
};
static_assert(alignof(UGameDataQuestLibrary) == 0x000008, "Wrong alignment on UGameDataQuestLibrary");
static_assert(sizeof(UGameDataQuestLibrary) == 0x000030, "Wrong size on UGameDataQuestLibrary");

// Class DarwinGame.UIStationMenu_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIStationMenu_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationMenu_Root">();
	}
	static class UUIStationMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationMenu_Root>();
	}
};
static_assert(alignof(UUIStationMenu_Root) == 0x000008, "Wrong alignment on UUIStationMenu_Root");
static_assert(sizeof(UUIStationMenu_Root) == 0x0004D8, "Wrong size on UUIStationMenu_Root");

// Class DarwinGame.DitheringComponent
// 0x0040 (0x00F8 - 0x00B8)
class UDitheringComponent : public UActorComponent
{
public:
	bool                                          UseParrentParameter;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAlpha;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Offset;                                            // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          enable;                                            // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeSpeed;                                         // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseFade;                                           // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDitheringSyncControl*                  SyncData;                                          // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDitherParam();
	void ForceApplyDitherParam(float ForceAlpha);
	TArray<class UDitheringComponent*> GetAttachedChildren();
	class UMeshComponent* GetMesh();
	void SetAlpha(float Alpha_0);
	void SetDirty(bool dirty);
	void SetEnable(bool enable_0);
	void SetFadeEnable(bool enable_0);
	void SetOffset(int32 Offset_0);

	bool CheckTickDisable() const;
	float GetAlpha() const;
	bool GetDirty() const;
	bool GetEnable() const;
	bool GetFadeEnable() const;
	bool IsDithering() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitheringComponent">();
	}
	static class UDitheringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitheringComponent>();
	}
};
static_assert(alignof(UDitheringComponent) == 0x000008, "Wrong alignment on UDitheringComponent");
static_assert(sizeof(UDitheringComponent) == 0x0000F8, "Wrong size on UDitheringComponent");
static_assert(offsetof(UDitheringComponent, UseParrentParameter) == 0x0000B8, "Member 'UDitheringComponent::UseParrentParameter' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, Alpha) == 0x0000BC, "Member 'UDitheringComponent::Alpha' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, CurrentAlpha) == 0x0000C0, "Member 'UDitheringComponent::CurrentAlpha' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, Offset) == 0x0000C4, "Member 'UDitheringComponent::Offset' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, enable) == 0x0000C8, "Member 'UDitheringComponent::enable' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, FadeSpeed) == 0x0000CC, "Member 'UDitheringComponent::FadeSpeed' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, UseFade) == 0x0000D0, "Member 'UDitheringComponent::UseFade' has a wrong offset!");
static_assert(offsetof(UDitheringComponent, SyncData) == 0x0000D8, "Member 'UDitheringComponent::SyncData' has a wrong offset!");

// Class DarwinGame.TagTextRubyDataTable
// 0x0000 (0x0030 - 0x0030)
class UTagTextRubyDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TagTextRubyDataTable">();
	}
	static class UTagTextRubyDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTagTextRubyDataTable>();
	}
};
static_assert(alignof(UTagTextRubyDataTable) == 0x000008, "Wrong alignment on UTagTextRubyDataTable");
static_assert(sizeof(UTagTextRubyDataTable) == 0x000030, "Wrong size on UTagTextRubyDataTable");

// Class DarwinGame.EQT_EscapePoint
// 0x0000 (0x0200 - 0x0200)
class UEQT_EscapePoint final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQT_EscapePoint">();
	}
	static class UEQT_EscapePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQT_EscapePoint>();
	}
};
static_assert(alignof(UEQT_EscapePoint) == 0x000008, "Wrong alignment on UEQT_EscapePoint");
static_assert(sizeof(UEQT_EscapePoint) == 0x000200, "Wrong size on UEQT_EscapePoint");

// Class DarwinGame.SwitchDitheringComponent
// 0x0008 (0x0100 - 0x00F8)
class USwitchDitheringComponent : public UDitheringComponent
{
public:
	float                                         SwitchAlpha;                                       // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SwitchAlphaEnable;                                 // 0x00FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcAlpha(bool switchEnable);
	void SetSwitchAlphaEnable(bool switchEnable);

	float GetSwitchAlpha() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchDitheringComponent">();
	}
	static class USwitchDitheringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchDitheringComponent>();
	}
};
static_assert(alignof(USwitchDitheringComponent) == 0x000008, "Wrong alignment on USwitchDitheringComponent");
static_assert(sizeof(USwitchDitheringComponent) == 0x000100, "Wrong size on USwitchDitheringComponent");
static_assert(offsetof(USwitchDitheringComponent, SwitchAlpha) == 0x0000F8, "Member 'USwitchDitheringComponent::SwitchAlpha' has a wrong offset!");
static_assert(offsetof(USwitchDitheringComponent, SwitchAlphaEnable) == 0x0000FC, "Member 'USwitchDitheringComponent::SwitchAlphaEnable' has a wrong offset!");

// Class DarwinGame.SceneCaptureUtility
// 0x0000 (0x0030 - 0x0030)
class USceneCaptureUtility final : public UBlueprintFunctionLibrary
{
public:
	static class ASceneCaptureBase* SpawnCapture(TSoftClassPtr<class UClass> Capture, class UTextureRenderTarget2D* RenderTarget);
	static class ADirectionalLight* SpawnCaptureLight(TSoftClassPtr<class UClass> DirectionalLight, const struct FRotator& Rotation);
	static class AActor* SpawnCaptureLightActor(TSoftClassPtr<class UClass> Light);
	static class ASceneCaptureBase* SpawnTwoCameraCapture(TSoftClassPtr<class UClass> Capture, class UTextureRenderTarget2D* RenderTarget, class UTextureRenderTarget2D* SubRenderTarge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneCaptureUtility">();
	}
	static class USceneCaptureUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneCaptureUtility>();
	}
};
static_assert(alignof(USceneCaptureUtility) == 0x000008, "Wrong alignment on USceneCaptureUtility");
static_assert(sizeof(USceneCaptureUtility) == 0x000030, "Wrong size on USceneCaptureUtility");

// Class DarwinGame.CameraDitheringComponent
// 0x0038 (0x0138 - 0x0100)
class UCameraDitheringComponent final : public USwitchDitheringComponent
{
public:
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      DitheringTargetComponent;                          // 0x0110(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HideDistance;                                      // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseHideDistance;                                   // 0x011C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDistance;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoGenerateMarker;                               // 0x0124(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraControlled;                                 // 0x0125(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHide;                                            // 0x0126(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTransitionHide;                                  // 0x0127(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDist;                                        // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceDisableSwitchAlpha;                          // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enter();
	void Exit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraDitheringComponent">();
	}
	static class UCameraDitheringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraDitheringComponent>();
	}
};
static_assert(alignof(UCameraDitheringComponent) == 0x000008, "Wrong alignment on UCameraDitheringComponent");
static_assert(sizeof(UCameraDitheringComponent) == 0x000138, "Wrong size on UCameraDitheringComponent");
static_assert(offsetof(UCameraDitheringComponent, DitheringTargetComponent) == 0x000110, "Member 'UCameraDitheringComponent::DitheringTargetComponent' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, HideDistance) == 0x000118, "Member 'UCameraDitheringComponent::HideDistance' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, UseHideDistance) == 0x00011C, "Member 'UCameraDitheringComponent::UseHideDistance' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, StartDistance) == 0x000120, "Member 'UCameraDitheringComponent::StartDistance' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, bAutoGenerateMarker) == 0x000124, "Member 'UCameraDitheringComponent::bAutoGenerateMarker' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, bCameraControlled) == 0x000125, "Member 'UCameraDitheringComponent::bCameraControlled' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, IsHide) == 0x000126, "Member 'UCameraDitheringComponent::IsHide' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, IsTransitionHide) == 0x000127, "Member 'UCameraDitheringComponent::IsTransitionHide' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, CameraDist) == 0x000128, "Member 'UCameraDitheringComponent::CameraDist' has a wrong offset!");
static_assert(offsetof(UCameraDitheringComponent, bForceDisableSwitchAlpha) == 0x000130, "Member 'UCameraDitheringComponent::bForceDisableSwitchAlpha' has a wrong offset!");

// Class DarwinGame.UIIconChoice
// 0x0018 (0x0548 - 0x0530)
class UUIIconChoice : public UUIScrollMenuItemBase
{
public:
	class FText                                   DefaultButtonText;                                 // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIIconChoice">();
	}
	static class UUIIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIIconChoice>();
	}
};
static_assert(alignof(UUIIconChoice) == 0x000008, "Wrong alignment on UUIIconChoice");
static_assert(sizeof(UUIIconChoice) == 0x000548, "Wrong size on UUIIconChoice");
static_assert(offsetof(UUIIconChoice, DefaultButtonText) == 0x000530, "Member 'UUIIconChoice::DefaultButtonText' has a wrong offset!");

// Class DarwinGame.CameraInterface
// 0x0000 (0x0030 - 0x0030)
class ICameraInterface final : public IInterface
{
public:
	bool AssistMode(bool bEnd, class USceneComponent* TargetToAim);
	void BattleMode(bool bEnd);
	void ChangeState(const struct FGameplayTag& NextStateTag);
	void DirectionMode(bool bEnd, ECameraDirectionType Type);
	class UCameraComponent* GetCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraInterface">();
	}
	static class ICameraInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICameraInterface>();
	}
};
static_assert(alignof(ICameraInterface) == 0x000008, "Wrong alignment on ICameraInterface");
static_assert(sizeof(ICameraInterface) == 0x000030, "Wrong size on ICameraInterface");

// Class DarwinGame.ESoundBase
// 0x0018 (0x00D0 - 0x00B8)
class UESoundBase : public UActorComponent
{
public:
	TArray<class USoundAtomCueSheet*>             mCueSheetList;                                     // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mAtomMoveInterval;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESoundInsulationType                          mSIType;                                           // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ESoundBase">();
	}
	static class UESoundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UESoundBase>();
	}
};
static_assert(alignof(UESoundBase) == 0x000008, "Wrong alignment on UESoundBase");
static_assert(sizeof(UESoundBase) == 0x0000D0, "Wrong size on UESoundBase");
static_assert(offsetof(UESoundBase, mCueSheetList) == 0x0000B8, "Member 'UESoundBase::mCueSheetList' has a wrong offset!");
static_assert(offsetof(UESoundBase, mAtomMoveInterval) == 0x0000C8, "Member 'UESoundBase::mAtomMoveInterval' has a wrong offset!");
static_assert(offsetof(UESoundBase, mSIType) == 0x0000CC, "Member 'UESoundBase::mSIType' has a wrong offset!");

// Class DarwinGame.PointEnvironmentSoundBase
// 0x0008 (0x00D8 - 0x00D0)
class UPointEnvironmentSoundBase : public UESoundBase
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentPatternID(EEnvironmentSoundPatternID ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointEnvironmentSoundBase">();
	}
	static class UPointEnvironmentSoundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointEnvironmentSoundBase>();
	}
};
static_assert(alignof(UPointEnvironmentSoundBase) == 0x000008, "Wrong alignment on UPointEnvironmentSoundBase");
static_assert(sizeof(UPointEnvironmentSoundBase) == 0x0000D8, "Wrong size on UPointEnvironmentSoundBase");

// Class DarwinGame.RiverEnvSound
// 0x0058 (0x0130 - 0x00D8)
class URiverEnvSound final : public UPointEnvironmentSoundBase
{
public:
	int32                                         mAtomReactionOffset;                               // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimesEnvironmentSoundData>     mSoundDataList;                                    // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UShapeComponent*>                mCollisionList;                                    // 0x00F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         mAtom;                                             // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSoundActiveRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSoundActiveRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiverEnvSound">();
	}
	static class URiverEnvSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<URiverEnvSound>();
	}
};
static_assert(alignof(URiverEnvSound) == 0x000008, "Wrong alignment on URiverEnvSound");
static_assert(sizeof(URiverEnvSound) == 0x000130, "Wrong size on URiverEnvSound");
static_assert(offsetof(URiverEnvSound, mAtomReactionOffset) == 0x0000D8, "Member 'URiverEnvSound::mAtomReactionOffset' has a wrong offset!");
static_assert(offsetof(URiverEnvSound, mSoundDataList) == 0x0000E0, "Member 'URiverEnvSound::mSoundDataList' has a wrong offset!");
static_assert(offsetof(URiverEnvSound, mCollisionList) == 0x0000F0, "Member 'URiverEnvSound::mCollisionList' has a wrong offset!");
static_assert(offsetof(URiverEnvSound, mAtom) == 0x000100, "Member 'URiverEnvSound::mAtom' has a wrong offset!");

// Class DarwinGame.CameraSpringArmComponent
// 0x0010 (0x02A0 - 0x0290)
class UCameraSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraSpringArmComponent">();
	}
	static class UCameraSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraSpringArmComponent>();
	}
};
static_assert(alignof(UCameraSpringArmComponent) == 0x000010, "Wrong alignment on UCameraSpringArmComponent");
static_assert(sizeof(UCameraSpringArmComponent) == 0x0002A0, "Wrong size on UCameraSpringArmComponent");

// Class DarwinGame.UIStationLandIconMark
// 0x0070 (0x0500 - 0x0490)
class UUIStationLandIconMark final : public UDarwinUserWidget
{
public:
	TMap<EAreaType, TSoftObjectPtr<class UTexture2D>> LandIconMap;                                       // 0x0490(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UImage*                                 MarkImage;                                         // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PerfectMatchOnAnim;                                // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PerfectMatchWaitAnim;                              // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayLoopAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationLandIconMark">();
	}
	static class UUIStationLandIconMark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationLandIconMark>();
	}
};
static_assert(alignof(UUIStationLandIconMark) == 0x000008, "Wrong alignment on UUIStationLandIconMark");
static_assert(sizeof(UUIStationLandIconMark) == 0x000500, "Wrong size on UUIStationLandIconMark");
static_assert(offsetof(UUIStationLandIconMark, LandIconMap) == 0x000490, "Member 'UUIStationLandIconMark::LandIconMap' has a wrong offset!");
static_assert(offsetof(UUIStationLandIconMark, MarkImage) == 0x0004E0, "Member 'UUIStationLandIconMark::MarkImage' has a wrong offset!");
static_assert(offsetof(UUIStationLandIconMark, PerfectMatchOnAnim) == 0x0004E8, "Member 'UUIStationLandIconMark::PerfectMatchOnAnim' has a wrong offset!");
static_assert(offsetof(UUIStationLandIconMark, PerfectMatchWaitAnim) == 0x0004F0, "Member 'UUIStationLandIconMark::PerfectMatchWaitAnim' has a wrong offset!");

// Class DarwinGame.ChangeAreaTriggerBase
// 0x0020 (0x0248 - 0x0228)
class AChangeAreaTriggerBase : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RootComp;                                          // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUpdateFieldAreaInBeginOverlapped;                // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BeginOverlapAreaID;                                // 0x023C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeAreaTriggerBase">();
	}
	static class AChangeAreaTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangeAreaTriggerBase>();
	}
};
static_assert(alignof(AChangeAreaTriggerBase) == 0x000008, "Wrong alignment on AChangeAreaTriggerBase");
static_assert(sizeof(AChangeAreaTriggerBase) == 0x000248, "Wrong size on AChangeAreaTriggerBase");
static_assert(offsetof(AChangeAreaTriggerBase, RootComp) == 0x000230, "Member 'AChangeAreaTriggerBase::RootComp' has a wrong offset!");
static_assert(offsetof(AChangeAreaTriggerBase, IsUpdateFieldAreaInBeginOverlapped) == 0x000238, "Member 'AChangeAreaTriggerBase::IsUpdateFieldAreaInBeginOverlapped' has a wrong offset!");
static_assert(offsetof(AChangeAreaTriggerBase, BeginOverlapAreaID) == 0x00023C, "Member 'AChangeAreaTriggerBase::BeginOverlapAreaID' has a wrong offset!");

// Class DarwinGame.EcologicalAIDataTable
// 0x0000 (0x0030 - 0x0030)
class UEcologicalAIDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EcologicalAIDataTable">();
	}
	static class UEcologicalAIDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEcologicalAIDataTable>();
	}
};
static_assert(alignof(UEcologicalAIDataTable) == 0x000008, "Wrong alignment on UEcologicalAIDataTable");
static_assert(sizeof(UEcologicalAIDataTable) == 0x000030, "Wrong size on UEcologicalAIDataTable");

// Class DarwinGame.ChangeBossBgm
// 0x0008 (0x0048 - 0x0040)
class UChangeBossBgm final : public UAnimNotify
{
public:
	float                                         WaitTime;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeBossBgm">();
	}
	static class UChangeBossBgm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeBossBgm>();
	}
};
static_assert(alignof(UChangeBossBgm) == 0x000008, "Wrong alignment on UChangeBossBgm");
static_assert(sizeof(UChangeBossBgm) == 0x000048, "Wrong size on UChangeBossBgm");
static_assert(offsetof(UChangeBossBgm, WaitTime) == 0x000040, "Member 'UChangeBossBgm::WaitTime' has a wrong offset!");

// Class DarwinGame.GameDataQuest
// 0x03C0 (0x03F0 - 0x0030)
class UGameDataQuest final : public UObject
{
public:
	uint8                                         Pad_30[0x3C0];                                     // 0x0030(0x03C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataQuest* Clone();
	void Overwrite(class UGameDataQuest* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataQuest">();
	}
	static class UGameDataQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataQuest>();
	}
};
static_assert(alignof(UGameDataQuest) == 0x000008, "Wrong alignment on UGameDataQuest");
static_assert(sizeof(UGameDataQuest) == 0x0003F0, "Wrong size on UGameDataQuest");

// Class DarwinGame.SwitchCollisionMovementComponent
// 0x0280 (0x08A0 - 0x0620)
class USwitchCollisionMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_620[0x34];                                     // 0x0620(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToSheathe;                                     // 0x0654(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x14];                                     // 0x0658(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageStartHeight;                                 // 0x066C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_670[0xE0];                                     // 0x0670(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableClimbUp;                                    // 0x0750(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_751[0x3];                                      // 0x0751(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              mClimbableHeightRange;                             // 0x0754(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFindWaterResult                       CurrentWater;                                      // 0x075C(0x008C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FFindFloorResult                       ClimbableFloor;                                    // 0x07E8(0x0094)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_87C[0xC];                                      // 0x087C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDownStepHeight;                                 // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88C[0x14];                                     // 0x088C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCurveMove(bool bLoop);
	void SetCurveMoveEnabled(bool Enabled);
	void SetDirectionOFRootMotion(const struct FVector& Direction);
	void SetFallStartLocation(const struct FVector& Location);
	void SetMoveOnCurve(bool Flag);
	void SetMoveValue(float MoveValue);
	void SetOverrideRootMotionVelocity(bool Flag);
	void StartCurveMove();

	float CalculateJumpZVelocity() const;
	const float GetCurrentSinkValue() const;
	bool IsActionableBurial() const;
	bool IsMovingOnCurve() const;
	bool IsSinking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchCollisionMovementComponent">();
	}
	static class USwitchCollisionMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchCollisionMovementComponent>();
	}
};
static_assert(alignof(USwitchCollisionMovementComponent) == 0x000010, "Wrong alignment on USwitchCollisionMovementComponent");
static_assert(sizeof(USwitchCollisionMovementComponent) == 0x0008A0, "Wrong size on USwitchCollisionMovementComponent");
static_assert(offsetof(USwitchCollisionMovementComponent, TimeToSheathe) == 0x000654, "Member 'USwitchCollisionMovementComponent::TimeToSheathe' has a wrong offset!");
static_assert(offsetof(USwitchCollisionMovementComponent, DamageStartHeight) == 0x00066C, "Member 'USwitchCollisionMovementComponent::DamageStartHeight' has a wrong offset!");
static_assert(offsetof(USwitchCollisionMovementComponent, bEnableClimbUp) == 0x000750, "Member 'USwitchCollisionMovementComponent::bEnableClimbUp' has a wrong offset!");
static_assert(offsetof(USwitchCollisionMovementComponent, mClimbableHeightRange) == 0x000754, "Member 'USwitchCollisionMovementComponent::mClimbableHeightRange' has a wrong offset!");
static_assert(offsetof(USwitchCollisionMovementComponent, CurrentWater) == 0x00075C, "Member 'USwitchCollisionMovementComponent::CurrentWater' has a wrong offset!");
static_assert(offsetof(USwitchCollisionMovementComponent, ClimbableFloor) == 0x0007E8, "Member 'USwitchCollisionMovementComponent::ClimbableFloor' has a wrong offset!");
static_assert(offsetof(USwitchCollisionMovementComponent, MaxDownStepHeight) == 0x000888, "Member 'USwitchCollisionMovementComponent::MaxDownStepHeight' has a wrong offset!");

// Class DarwinGame.EmojiIconDataTable
// 0x0000 (0x0030 - 0x0030)
class UEmojiIconDataTable final : public UBlueprintFunctionLibrary
{
public:
	static void GetEmojiIcon(const class FName& emojiId, struct FST_EmojiIconData* emojiIcon);
	static void GetEmojiPlatformIcon(const class FName& emojiId, struct FST_ResourceInputIcons* emojiIcon, int32 GetCurrentKeyMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmojiIconDataTable">();
	}
	static class UEmojiIconDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmojiIconDataTable>();
	}
};
static_assert(alignof(UEmojiIconDataTable) == 0x000008, "Wrong alignment on UEmojiIconDataTable");
static_assert(sizeof(UEmojiIconDataTable) == 0x000030, "Wrong size on UEmojiIconDataTable");

// Class DarwinGame.ChangeDistrictTrigger
// 0x0000 (0x0248 - 0x0248)
class AChangeDistrictTrigger : public AChangeAreaTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeDistrictTrigger">();
	}
	static class AChangeDistrictTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangeDistrictTrigger>();
	}
};
static_assert(alignof(AChangeDistrictTrigger) == 0x000008, "Wrong alignment on AChangeDistrictTrigger");
static_assert(sizeof(AChangeDistrictTrigger) == 0x000248, "Wrong size on AChangeDistrictTrigger");

// Class DarwinGame.GameDataStationLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataStationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataStationLibrary">();
	}
	static class UGameDataStationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataStationLibrary>();
	}
};
static_assert(alignof(UGameDataStationLibrary) == 0x000008, "Wrong alignment on UGameDataStationLibrary");
static_assert(sizeof(UGameDataStationLibrary) == 0x000030, "Wrong size on UGameDataStationLibrary");

// Class DarwinGame.ChangePointTrigger
// 0x0000 (0x0248 - 0x0248)
class AChangePointTrigger final : public AChangeAreaTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangePointTrigger">();
	}
	static class AChangePointTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangePointTrigger>();
	}
};
static_assert(alignof(AChangePointTrigger) == 0x000008, "Wrong alignment on AChangePointTrigger");
static_assert(sizeof(AChangePointTrigger) == 0x000248, "Wrong size on AChangePointTrigger");

// Class DarwinGame.TerrainDamageCue
// 0x0000 (0x0298 - 0x0298)
class ATerrainDamageCue : public AGameplayCueNotify_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrainDamageCue">();
	}
	static class ATerrainDamageCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATerrainDamageCue>();
	}
};
static_assert(alignof(ATerrainDamageCue) == 0x000008, "Wrong alignment on ATerrainDamageCue");
static_assert(sizeof(ATerrainDamageCue) == 0x000298, "Wrong size on ATerrainDamageCue");

// Class DarwinGame.UIStationMenuArea
// 0x0030 (0x0600 - 0x05D0)
class UUIStationMenuArea final : public UUIScrollMenuBase
{
public:
	class UUIAreaPanel*                           AreaPanel;                                         // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x18];                                     // 0x05D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStartLoopAnimation*                  Deltas[0x2];                                       // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationMenuArea">();
	}
	static class UUIStationMenuArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationMenuArea>();
	}
};
static_assert(alignof(UUIStationMenuArea) == 0x000008, "Wrong alignment on UUIStationMenuArea");
static_assert(sizeof(UUIStationMenuArea) == 0x000600, "Wrong size on UUIStationMenuArea");
static_assert(offsetof(UUIStationMenuArea, AreaPanel) == 0x0005D0, "Member 'UUIStationMenuArea::AreaPanel' has a wrong offset!");
static_assert(offsetof(UUIStationMenuArea, Deltas) == 0x0005F0, "Member 'UUIStationMenuArea::Deltas' has a wrong offset!");

// Class DarwinGame.EstimateLighting
// 0x0000 (0x0228 - 0x0228)
class AEstimateLighting final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateLighting">();
	}
	static class AEstimateLighting* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimateLighting>();
	}
};
static_assert(alignof(AEstimateLighting) == 0x000008, "Wrong alignment on AEstimateLighting");
static_assert(sizeof(AEstimateLighting) == 0x000228, "Wrong size on AEstimateLighting");

// Class DarwinGame.ChangeRegionTrigger
// 0x0000 (0x0248 - 0x0248)
class AChangeRegionTrigger : public AChangeAreaTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeRegionTrigger">();
	}
	static class AChangeRegionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangeRegionTrigger>();
	}
};
static_assert(alignof(AChangeRegionTrigger) == 0x000008, "Wrong alignment on AChangeRegionTrigger");
static_assert(sizeof(AChangeRegionTrigger) == 0x000248, "Wrong size on AChangeRegionTrigger");

// Class DarwinGame.PCInputManager
// 0x0100 (0x0328 - 0x0228)
class APCInputManager final : public AActor
{
public:
	uint8                                         Pad_228[0x100];                                    // 0x0228(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCInputManager">();
	}
	static class APCInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCInputManager>();
	}
};
static_assert(alignof(APCInputManager) == 0x000008, "Wrong alignment on APCInputManager");
static_assert(sizeof(APCInputManager) == 0x000328, "Wrong size on APCInputManager");

// Class DarwinGame.ChangeSectionTrigger
// 0x0000 (0x0248 - 0x0248)
class AChangeSectionTrigger : public AChangeAreaTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeSectionTrigger">();
	}
	static class AChangeSectionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangeSectionTrigger>();
	}
};
static_assert(alignof(AChangeSectionTrigger) == 0x000008, "Wrong alignment on AChangeSectionTrigger");
static_assert(sizeof(AChangeSectionTrigger) == 0x000248, "Wrong size on AChangeSectionTrigger");

// Class DarwinGame.UIField_WinTutorial
// 0x0068 (0x04F8 - 0x0490)
class UUIField_WinTutorial : public UDarwinUserWidget
{
public:
	int32                                         PointIconNum;                                      // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimer;                                          // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     TipsImageList;                                     // 0x0498(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            TextWidget;                                        // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidgetData*                        textData;                                          // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         LoopSe;                                            // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIField_Pointreader*>           PointIconList;                                     // 0x04C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x28];                                     // 0x04D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(class FName TableName);
	void SetTextData(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinTutorial">();
	}
	static class UUIField_WinTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinTutorial>();
	}
};
static_assert(alignof(UUIField_WinTutorial) == 0x000008, "Wrong alignment on UUIField_WinTutorial");
static_assert(sizeof(UUIField_WinTutorial) == 0x0004F8, "Wrong size on UUIField_WinTutorial");
static_assert(offsetof(UUIField_WinTutorial, PointIconNum) == 0x000490, "Member 'UUIField_WinTutorial::PointIconNum' has a wrong offset!");
static_assert(offsetof(UUIField_WinTutorial, MaxTimer) == 0x000494, "Member 'UUIField_WinTutorial::MaxTimer' has a wrong offset!");
static_assert(offsetof(UUIField_WinTutorial, TipsImageList) == 0x000498, "Member 'UUIField_WinTutorial::TipsImageList' has a wrong offset!");
static_assert(offsetof(UUIField_WinTutorial, TextWidget) == 0x0004A8, "Member 'UUIField_WinTutorial::TextWidget' has a wrong offset!");
static_assert(offsetof(UUIField_WinTutorial, textData) == 0x0004B0, "Member 'UUIField_WinTutorial::textData' has a wrong offset!");
static_assert(offsetof(UUIField_WinTutorial, LoopSe) == 0x0004B8, "Member 'UUIField_WinTutorial::LoopSe' has a wrong offset!");
static_assert(offsetof(UUIField_WinTutorial, PointIconList) == 0x0004C0, "Member 'UUIField_WinTutorial::PointIconList' has a wrong offset!");

// Class DarwinGame.DebugSlowdownTestBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UDebugSlowdownTestBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugSlowdownTestBlueprintFunctionLibrary">();
	}
	static class UDebugSlowdownTestBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugSlowdownTestBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UDebugSlowdownTestBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UDebugSlowdownTestBlueprintFunctionLibrary");
static_assert(sizeof(UDebugSlowdownTestBlueprintFunctionLibrary) == 0x000030, "Wrong size on UDebugSlowdownTestBlueprintFunctionLibrary");

// Class DarwinGame.ChangeZoneTrigger
// 0x0000 (0x0248 - 0x0248)
class AChangeZoneTrigger final : public AChangeAreaTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeZoneTrigger">();
	}
	static class AChangeZoneTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangeZoneTrigger>();
	}
};
static_assert(alignof(AChangeZoneTrigger) == 0x000008, "Wrong alignment on AChangeZoneTrigger");
static_assert(sizeof(AChangeZoneTrigger) == 0x000248, "Wrong size on AChangeZoneTrigger");

// Class DarwinGame.SealStatusInterface
// 0x0000 (0x0030 - 0x0030)
class ISealStatusInterface final : public IInterface
{
public:
	void SetReflectionRelease();
	void SetReflectionSeal();
	void ToReflectionRelease();
	void ToReflectionSeal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SealStatusInterface">();
	}
	static class ISealStatusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISealStatusInterface>();
	}
};
static_assert(alignof(ISealStatusInterface) == 0x000008, "Wrong alignment on ISealStatusInterface");
static_assert(sizeof(ISealStatusInterface) == 0x000030, "Wrong size on ISealStatusInterface");

// Class DarwinGame.UIStationLandIcon
// 0x0030 (0x04C0 - 0x0490)
class UUIStationLandIcon final : public UDarwinUserWidget
{
public:
	TArray<class UObject*>                        MaterialList;                                      // 0x0490(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStationLandIconMark*                 Mark;                                              // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PerfectMatchOnAnim;                                // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PerfectMatchWaitAnim;                              // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayWaitAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationLandIcon">();
	}
	static class UUIStationLandIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationLandIcon>();
	}
};
static_assert(alignof(UUIStationLandIcon) == 0x000008, "Wrong alignment on UUIStationLandIcon");
static_assert(sizeof(UUIStationLandIcon) == 0x0004C0, "Wrong size on UUIStationLandIcon");
static_assert(offsetof(UUIStationLandIcon, MaterialList) == 0x000490, "Member 'UUIStationLandIcon::MaterialList' has a wrong offset!");
static_assert(offsetof(UUIStationLandIcon, Mark) == 0x0004A0, "Member 'UUIStationLandIcon::Mark' has a wrong offset!");
static_assert(offsetof(UUIStationLandIcon, PerfectMatchOnAnim) == 0x0004A8, "Member 'UUIStationLandIcon::PerfectMatchOnAnim' has a wrong offset!");
static_assert(offsetof(UUIStationLandIcon, PerfectMatchWaitAnim) == 0x0004B0, "Member 'UUIStationLandIcon::PerfectMatchWaitAnim' has a wrong offset!");

// Class DarwinGame.CharacterAssetInfo
// 0x0018 (0x0048 - 0x0030)
class UCharacterAssetInfo final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAssetInfo">();
	}
	static class UCharacterAssetInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAssetInfo>();
	}
};
static_assert(alignof(UCharacterAssetInfo) == 0x000008, "Wrong alignment on UCharacterAssetInfo");
static_assert(sizeof(UCharacterAssetInfo) == 0x000048, "Wrong size on UCharacterAssetInfo");

// Class DarwinGame.DataTableExportLibrary
// 0x0000 (0x0030 - 0x0030)
class UDataTableExportLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString ConvertRotaterToCSVString(const struct FRotator& Rotator);
	static class FString ConvertVectorToCSVString(const struct FVector& Vector);
	static class FString CreateDataTableCSVHeader(class UScriptStruct* ExportDataTableStruct);
	static void CreateLocationAndRotationCSVLine(const class FName ID, const struct FVector& Position, const struct FRotator& Rotation, class FString* CsvLine);
	static void CreatePointCSVLine(const class FName ID, const struct FVector& Position, const struct FRotator& Rotation, const struct FVector& Scale, class FString* CsvLine);
	static void CreateQuestDestinationRectCSVLine(const class FName ID, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Size, const EQuestDestinationRectShapeType Type, const class FName AreaID, const bool IsRandom, class FString* CsvLine);
	static void FillDataTableFromCSVString(class UDataTable* DataTable, const class FString& CSVHeader, const class FString& CSVRowData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableExportLibrary">();
	}
	static class UDataTableExportLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableExportLibrary>();
	}
};
static_assert(alignof(UDataTableExportLibrary) == 0x000008, "Wrong alignment on UDataTableExportLibrary");
static_assert(sizeof(UDataTableExportLibrary) == 0x000030, "Wrong size on UDataTableExportLibrary");

// Class DarwinGame.CharacterAssetManager
// 0x00A0 (0x01C8 - 0x0128)
class UCharacterAssetManager : public UCharacterAssetManagerBase
{
public:
	uint8                                         Pad_128[0xA0];                                     // 0x0128(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCharacterAssetManager* GetInstance();

	void RequestCommonASyncLoadActor(const class FName& ID, const struct FCommonSpawnParam& spawnParam, const TDelegate<void(class FName ID, struct FCommonSpawnParam& spawnParam)>& onEvent);
	void RequestSimpleASyncLoadActor(const class FName& ID, const struct FTransform& Transform, const TDelegate<void(class FName ID, struct FTransform& Transform)>& onEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAssetManager">();
	}
	static class UCharacterAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAssetManager>();
	}
};
static_assert(alignof(UCharacterAssetManager) == 0x000008, "Wrong alignment on UCharacterAssetManager");
static_assert(sizeof(UCharacterAssetManager) == 0x0001C8, "Wrong size on UCharacterAssetManager");

// Class DarwinGame.GameDataStation
// 0x0058 (0x0088 - 0x0030)
class UGameDataStation final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataStation* Clone();
	bool ExistElevator(const class FName& ID);
	struct FVector GetConsoleLocation(const class FName& ID);
	struct FVector GetElevatorLocation(const class FName& ID);
	struct FVector GetStationLocation(const class FName& ID);
	void Overwrite(class UGameDataStation* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataStation">();
	}
	static class UGameDataStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataStation>();
	}
};
static_assert(alignof(UGameDataStation) == 0x000008, "Wrong alignment on UGameDataStation");
static_assert(sizeof(UGameDataStation) == 0x000088, "Wrong size on UGameDataStation");

// Class DarwinGame.TargetObjectManager
// 0x0010 (0x0040 - 0x0030)
class UTargetObjectManager final : public UObject
{
public:
	TArray<class ATargetObjectBase*>              mTargetObjectList;                                 // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SpawnTargetObjectFromArea(EAreaType AreaType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetObjectManager">();
	}
	static class UTargetObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetObjectManager>();
	}
};
static_assert(alignof(UTargetObjectManager) == 0x000008, "Wrong alignment on UTargetObjectManager");
static_assert(sizeof(UTargetObjectManager) == 0x000040, "Wrong size on UTargetObjectManager");
static_assert(offsetof(UTargetObjectManager, mTargetObjectList) == 0x000030, "Member 'UTargetObjectManager::mTargetObjectList' has a wrong offset!");

// Class DarwinGame.UIItemmenu_02
// 0x00D8 (0x05A8 - 0x04D0)
class UUIItemmenu_02 final : public UUILeftMenuUseBase
{
public:
	uint8                                         Pad_4D0[0x20];                                     // 0x04D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_SynthesisMenu>              SynthesisMenu;                                     // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_RecipeCategory>             FoodMenuTypeList;                                  // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_RecipeCategory>             BulletMenuTypeList;                                // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x20];                                     // 0x0520(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_SynthesisShopBackGroundTexture     BackGroundTex;                                     // 0x0540(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UUICommonmenu_02*                       Commonmenu_02;                                     // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x10];                                     // 0x0598(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ItemChangeFocusCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_02">();
	}
	static class UUIItemmenu_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_02>();
	}
};
static_assert(alignof(UUIItemmenu_02) == 0x000008, "Wrong alignment on UUIItemmenu_02");
static_assert(sizeof(UUIItemmenu_02) == 0x0005A8, "Wrong size on UUIItemmenu_02");
static_assert(offsetof(UUIItemmenu_02, SynthesisMenu) == 0x0004F0, "Member 'UUIItemmenu_02::SynthesisMenu' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02, FoodMenuTypeList) == 0x000500, "Member 'UUIItemmenu_02::FoodMenuTypeList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02, BulletMenuTypeList) == 0x000510, "Member 'UUIItemmenu_02::BulletMenuTypeList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02, BackGroundTex) == 0x000540, "Member 'UUIItemmenu_02::BackGroundTex' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02, Commonmenu_02) == 0x000590, "Member 'UUIItemmenu_02::Commonmenu_02' has a wrong offset!");

// Class DarwinGame.DebugLauncherActor
// 0x0160 (0x0388 - 0x0228)
class ADebugLauncherActor final : public AActor
{
public:
	uint8                                         Pad_228[0x140];                                    // 0x0228(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	class UBPDebugMenuInterface*                  DebugMenuInterface;                                // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NextLevelName;                                     // 0x0370(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DT_StartProgressPreset;                            // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateInput(const float DeltaTime, const bool bGamePaused, const struct FKeyInput& KeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output);

	bool IsActive() const;
	bool IsIdle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugLauncherActor">();
	}
	static class ADebugLauncherActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugLauncherActor>();
	}
};
static_assert(alignof(ADebugLauncherActor) == 0x000008, "Wrong alignment on ADebugLauncherActor");
static_assert(sizeof(ADebugLauncherActor) == 0x000388, "Wrong size on ADebugLauncherActor");
static_assert(offsetof(ADebugLauncherActor, DebugMenuInterface) == 0x000368, "Member 'ADebugLauncherActor::DebugMenuInterface' has a wrong offset!");
static_assert(offsetof(ADebugLauncherActor, NextLevelName) == 0x000370, "Member 'ADebugLauncherActor::NextLevelName' has a wrong offset!");
static_assert(offsetof(ADebugLauncherActor, DT_StartProgressPreset) == 0x000380, "Member 'ADebugLauncherActor::DT_StartProgressPreset' has a wrong offset!");

// Class DarwinGame.CharacterCalculationFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCharacterCalculationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FST_Status CalcFloorStatus(const struct FST_Status& Status);
	static void CalculateAttributeStatus(struct FST_Status* outAttributePercentage, const TMap<class FName, int32>& AttributeList);
	static void CalculateCoinStatus(struct FFeatureEffectStatusResult* outResult, const TArray<struct FST_CoinData>& Coins);
	static void CalculateFeatureStatus(struct FFeatureEffectStatusResult* outResult, const TArray<struct FFeaturePossessionInfo>& Features, bool IsMainPartyMonster);
	static void CalculateFoodStatus(struct FFoodEffectStatusResult* outFoodResult, class FName KindId, const TArray<class FName>& FoodList);
	static struct FST_Status GetAdvanceStatus_FriendMonster(const struct FGameDataFriendMonster& dataFriend, bool isMaxHp);
	static struct FST_Status GetBaseStatus(class FName KindId, int32 Level, const struct FST_Status& IndividualValue);
	static struct FST_Status GetCorrectedStandardStatus(class FName KindId, int32 Level, const struct FST_Status& levelRate, const struct FST_Status& Value);
	static struct FST_Status GetDungeonStatus(class FName KindId, int32 Level, EMonsterType MonsterType, const struct FST_Status& levelRate, const struct FST_Status& Value);
	static struct FST_Status GetIndividualStatus();
	static struct FST_Status GetStandardStatus(class FName KindId, int32 Level);
	static struct FST_Status GetStatus(const struct FST_Status& AdvanceStatus, const struct FFeatureEffectStatusResult& CoinStatus, const struct FFeatureEffectStatusResult& conditionalFeature, const struct FFoodEffectStatusResult& FoodStatus, const struct FST_Status& AttributePercentage, bool isBelongToAlly);
	static struct FST_Status GetStatus_FriendMonster(const struct FGameDataFriendMonster& dataFriend, bool isMaxHp);
	static bool IsMainParty(const struct FGameDataFriendMonster& friendMonster);
	static void TakeBreakFriendMonsterDataBase(int32 Percentage);
	static void TakeBreakFriendMonsterOnly(int32 Percentage, bool IsUIAnim);
	static void TakeBreakPlayerOnly(int32 Percentage, bool IsUIAnim);
	static void TakeBreakPlayerSide(int32 Percentage, bool IsUIAnim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCalculationFunctionLibrary">();
	}
	static class UCharacterCalculationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCalculationFunctionLibrary>();
	}
};
static_assert(alignof(UCharacterCalculationFunctionLibrary) == 0x000008, "Wrong alignment on UCharacterCalculationFunctionLibrary");
static_assert(sizeof(UCharacterCalculationFunctionLibrary) == 0x000030, "Wrong size on UCharacterCalculationFunctionLibrary");

// Class DarwinGame.CharacterCaptureLight
// 0x0020 (0x0248 - 0x0228)
class ACharacterCaptureLight : public ACaptureLightBase
{
public:
	class USkyLightComponent*                     SkyLightComponent;                                 // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDirectionalLightComponent*             DirectionalLightComponen;                          // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootComp;                                          // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCaptureLight">();
	}
	static class ACharacterCaptureLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterCaptureLight>();
	}
};
static_assert(alignof(ACharacterCaptureLight) == 0x000008, "Wrong alignment on ACharacterCaptureLight");
static_assert(sizeof(ACharacterCaptureLight) == 0x000248, "Wrong size on ACharacterCaptureLight");
static_assert(offsetof(ACharacterCaptureLight, SkyLightComponent) == 0x000228, "Member 'ACharacterCaptureLight::SkyLightComponent' has a wrong offset!");
static_assert(offsetof(ACharacterCaptureLight, PostProcessComponent) == 0x000230, "Member 'ACharacterCaptureLight::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(ACharacterCaptureLight, DirectionalLightComponen) == 0x000238, "Member 'ACharacterCaptureLight::DirectionalLightComponen' has a wrong offset!");
static_assert(offsetof(ACharacterCaptureLight, RootComp) == 0x000240, "Member 'ACharacterCaptureLight::RootComp' has a wrong offset!");

// Class DarwinGame.SaveGameFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class USaveGameFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ExecuteAllSave();
	static bool ExecuteAutoSave();
	static bool ExecuteAutoSaveLocation(const struct FVector& Location, const struct FRotator& Rotation, EPersistentLevelID persisten_level_id, class UTexture2D* Texture);
	static bool ExecuteCommonSave();
	static bool ExecuteManualSave();
	static bool IsAutoSaveNow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveGameFunctionLibrary">();
	}
	static class USaveGameFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveGameFunctionLibrary>();
	}
};
static_assert(alignof(USaveGameFunctionLibrary) == 0x000008, "Wrong alignment on USaveGameFunctionLibrary");
static_assert(sizeof(USaveGameFunctionLibrary) == 0x000030, "Wrong size on USaveGameFunctionLibrary");

// Class DarwinGame.DungeonGimmickTreasure
// 0x0018 (0x02D0 - 0x02B8)
class ADungeonGimmickTreasure final : public ADungeonGimmickObjectBase
{
public:
	TArray<class ADungeonTreasureBox*>            mDungeonTreasureBox;                               // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickTreasure">();
	}
	static class ADungeonGimmickTreasure* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickTreasure>();
	}
};
static_assert(alignof(ADungeonGimmickTreasure) == 0x000008, "Wrong alignment on ADungeonGimmickTreasure");
static_assert(sizeof(ADungeonGimmickTreasure) == 0x0002D0, "Wrong size on ADungeonGimmickTreasure");
static_assert(offsetof(ADungeonGimmickTreasure, mDungeonTreasureBox) == 0x0002B8, "Member 'ADungeonGimmickTreasure::mDungeonTreasureBox' has a wrong offset!");

// Class DarwinGame.CharacterDataTable
// 0x0000 (0x0030 - 0x0030)
class UCharacterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDataTable">();
	}
	static class UCharacterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDataTable>();
	}
};
static_assert(alignof(UCharacterDataTable) == 0x000008, "Wrong alignment on UCharacterDataTable");
static_assert(sizeof(UCharacterDataTable) == 0x000030, "Wrong size on UCharacterDataTable");

// Class DarwinGame.NetworkRandomTreasureSearchFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UNetworkRandomTreasureSearchFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkRandomTreasureSearchFunctionLibrary">();
	}
	static class UNetworkRandomTreasureSearchFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkRandomTreasureSearchFunctionLibrary>();
	}
};
static_assert(alignof(UNetworkRandomTreasureSearchFunctionLibrary) == 0x000008, "Wrong alignment on UNetworkRandomTreasureSearchFunctionLibrary");
static_assert(sizeof(UNetworkRandomTreasureSearchFunctionLibrary) == 0x000030, "Wrong size on UNetworkRandomTreasureSearchFunctionLibrary");

// Class DarwinGame.CharacterFootSoundRangeDataTable
// 0x0000 (0x0030 - 0x0030)
class UCharacterFootSoundRangeDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterFootSoundRangeDataTable">();
	}
	static class UCharacterFootSoundRangeDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterFootSoundRangeDataTable>();
	}
};
static_assert(alignof(UCharacterFootSoundRangeDataTable) == 0x000008, "Wrong alignment on UCharacterFootSoundRangeDataTable");
static_assert(sizeof(UCharacterFootSoundRangeDataTable) == 0x000030, "Wrong size on UCharacterFootSoundRangeDataTable");

// Class DarwinGame.UIEvent_FullScreenImageBase
// 0x0010 (0x04A0 - 0x0490)
class UUIEvent_FullScreenImageBase : public UDarwinUserWidget
{
public:
	class UDataTable*                             EventImageDataTable;                               // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FullScreenImage;                                   // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetData(const class FName& ImageKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEvent_FullScreenImageBase">();
	}
	static class UUIEvent_FullScreenImageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEvent_FullScreenImageBase>();
	}
};
static_assert(alignof(UUIEvent_FullScreenImageBase) == 0x000008, "Wrong alignment on UUIEvent_FullScreenImageBase");
static_assert(sizeof(UUIEvent_FullScreenImageBase) == 0x0004A0, "Wrong size on UUIEvent_FullScreenImageBase");
static_assert(offsetof(UUIEvent_FullScreenImageBase, EventImageDataTable) == 0x000490, "Member 'UUIEvent_FullScreenImageBase::EventImageDataTable' has a wrong offset!");
static_assert(offsetof(UUIEvent_FullScreenImageBase, FullScreenImage) == 0x000498, "Member 'UUIEvent_FullScreenImageBase::FullScreenImage' has a wrong offset!");

// Class DarwinGame.UIEvent_FullScreenImage
// 0x0000 (0x04A0 - 0x04A0)
class UUIEvent_FullScreenImage : public UUIEvent_FullScreenImageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEvent_FullScreenImage">();
	}
	static class UUIEvent_FullScreenImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEvent_FullScreenImage>();
	}
};
static_assert(alignof(UUIEvent_FullScreenImage) == 0x000008, "Wrong alignment on UUIEvent_FullScreenImage");
static_assert(sizeof(UUIEvent_FullScreenImage) == 0x0004A0, "Wrong size on UUIEvent_FullScreenImage");

// Class DarwinGame.DamageElementAutoAjustCapsuleComponent
// 0x0010 (0x0470 - 0x0460)
class UDamageElementAutoAjustCapsuleComponent final : public UDamageElementCapsuleComponent
{
public:
	struct FDamageShapeSetting                    ShapeParam;                                        // 0x0460(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageElementAutoAjustCapsuleComponent">();
	}
	static class UDamageElementAutoAjustCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageElementAutoAjustCapsuleComponent>();
	}
};
static_assert(alignof(UDamageElementAutoAjustCapsuleComponent) == 0x000010, "Wrong alignment on UDamageElementAutoAjustCapsuleComponent");
static_assert(sizeof(UDamageElementAutoAjustCapsuleComponent) == 0x000470, "Wrong size on UDamageElementAutoAjustCapsuleComponent");
static_assert(offsetof(UDamageElementAutoAjustCapsuleComponent, ShapeParam) == 0x000460, "Member 'UDamageElementAutoAjustCapsuleComponent::ShapeParam' has a wrong offset!");

// Class DarwinGame.CharacterFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCharacterFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddPlayerMoney(int32 Money);
	static void ChangePlayer(class FName KindId);
	static TArray<class FName> FindActionDetailIDByActionOverViewID(class FName ActionOverviewID);
	static void GetBrave(const TArray<EBraveReason>& BraveReasons);
	static EMonsterRegisterType GetHostilityRegisterType(class AGPACharacter* Character);
	static EMonsterRegisterType GetRegisterType(class AGPACharacter* Character);
	static bool IsGroupMate(class AGPACharacter* character00, class AGPACharacter* character01);
	static class UEmoteBlinkOverwriteOption* MakeEmoteBlinkOverwriteOption();
	static class UEmoteRuntimeOption* MakeEmoteRuntimeOption();
	static class UEmoteStampOverwriteOption* MakeEmoteStampOverwriteOption();
	static class UEmoteVocalizeOverwriteOption* MakeEmoteVocalizeOverwriteOption();
	static void UseBrave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterFunctionLibrary">();
	}
	static class UCharacterFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterFunctionLibrary>();
	}
};
static_assert(alignof(UCharacterFunctionLibrary) == 0x000008, "Wrong alignment on UCharacterFunctionLibrary");
static_assert(sizeof(UCharacterFunctionLibrary) == 0x000030, "Wrong size on UCharacterFunctionLibrary");

// Class DarwinGame.NetworkFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UNetworkFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkFunctionLibrary">();
	}
	static class UNetworkFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkFunctionLibrary>();
	}
};
static_assert(alignof(UNetworkFunctionLibrary) == 0x000008, "Wrong alignment on UNetworkFunctionLibrary");
static_assert(sizeof(UNetworkFunctionLibrary) == 0x000030, "Wrong size on UNetworkFunctionLibrary");

// Class DarwinGame.CharacterInputInterface
// 0x0000 (0x0030 - 0x0030)
class ICharacterInputInterface final : public IInterface
{
public:
	bool ComboKeyAction(EAxisMappingType Key);
	bool FilterFaceButtonInputs(EAxisMappingType Key);
	void Move(const struct FVector& Input);
	void OnInputInterrupted();
	void Rotate(const struct FVector& Input);
	void TakeAction(const struct FGameplayTag& Tag, bool bRelease);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInputInterface">();
	}
	static class ICharacterInputInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterInputInterface>();
	}
};
static_assert(alignof(ICharacterInputInterface) == 0x000008, "Wrong alignment on ICharacterInputInterface");
static_assert(sizeof(ICharacterInputInterface) == 0x000030, "Wrong size on ICharacterInputInterface");

// Class DarwinGame.CharacterInterface
// 0x0000 (0x0030 - 0x0030)
class ICharacterInterface final : public IInterface
{
public:
	void Aim(bool End);
	void ApplyAttribute(class FName AttributeID, int32 AddLevel);
	struct FActiveGameplayEffectHandle ApplyAttributeGameplayEffect(const class FName AttributeID, int32 Level);
	struct FActiveGameplayEffectHandle ApplyAttributeGameplayEffectWithLotteryData(class AGPACharacter* Sorce, const class FName AttributeID, int32 Level, const struct FLotteryAttributeParam& Lottery);
	struct FActiveGameplayEffectHandle ApplyDeathGameplayEffect(const struct FDeadCause& Cause);
	void CallEndLink();
	void CancelAbility(const struct FGameplayTagContainer& Tags);
	void CancelActionState();
	void ChangeAbnormalState(const struct FGameplayTag& NextAbnormalStateTag, bool End);
	void ChangeActionState(const struct FGameplayTag& NextActionStateTag);
	void ChangeActionStateWithResult(const struct FGameplayTag& NextActionStateTag, const struct FActionResult& ActionResult);
	void ChangeDefaultMoveState();
	void ChangeMoveState(const struct FGameplayTag& NextMoveStateTag);
	void ChangeOpeMode(EOperationModeEnum Mode);
	void ChangeStatus(int32 BitMask, bool End);
	void CloseLinkMenu(ELinkType Type);
	void DebugMoveMode(bool on);
	void DetachEffect(const class FString& HandleID);
	void EndActionState();
	void EndLink(bool bCanceled);
	void Equip(class FName equipmentName, ESocket SocketName);
	bool ExecuteAbility(const struct FGameplayTagContainer& Tags);
	void ExecuteLinkAction(int32 Index_0);
	void FastTravel(const int32 ID);
	class FText GetNickName();
	class FName GetOriginID();
	void GetOwningTags(struct FGameplayTagContainer* Tags);
	void HandleBattleEndEvent();
	void HandleBattleStartEvent();
	bool HasAttribute(class FName AttributeID);
	bool HasTag(const struct FGameplayTag& Tag);
	void HoldWeapon(class FName equipmentName, bool End);
	bool IsAbilityRunning(const struct FGameplayTagContainer& Tags);
	bool IsLinkMenuOpened();
	void Land();
	void Launch(const struct FVector& Velocity);
	void OpenLinkMenu(ELinkType Type);
	bool PlayParticle(class FName EffectId, class FName Socke, bool IsAttached, class FString* HandleID);
	bool PlayTrail(class FName EffectId, class FName FirstSocket, class FName SecondSocket, ETrailWidthMode ScaleMode, class FString* HandleID);
	void ReadyToShot(bool Complete);
	void ReleaseAttribute(class FName AttributeID);
	void ResetRotation(const struct FRotator& NewRotation);
	void ResetState();
	void RestartFromAbyss();
	void SetPauseAllAttribute(bool Pause);
	void SetReadyWeapon(class FName equipmentName, bool Ready);
	void SwitchToBattleMode(bool IsEnd, bool SkipMotion);
	void SwitchToCutSceneMode(bool IsEnd);
	void Talk(class AActor* Partner, bool IsCameraEnabled, bool IsEnd);

	bool CanChangeToSpecifiedState(const struct FGameplayTag& NextMoveStateTag) const;
	class UAnimInstance* GetAnimInstance() const;
	struct FRotator GetControlRot() const;
	struct FGameplayTag GetCurrentActionStateTag() const;
	struct FGameplayTag GetCurrentMoveStateTag() const;
	struct FGameplayTag GetCurrentStateTag() const;
	class AActor* GetEquipment(class FName equipmentName) const;
	TArray<class AActor*> GetEquipments() const;
	ELinkType GetLinkType() const;
	struct FGameplayTag GetPrevStateTag() const;
	class AActor* GetReadyWeapon() const;
	class AActor* GetTarget() const;
	class AActor* GetTargetToInteract() const;
	bool IsAiming() const;
	bool IsReadyToShot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInterface">();
	}
	static class ICharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterInterface>();
	}
};
static_assert(alignof(ICharacterInterface) == 0x000008, "Wrong alignment on ICharacterInterface");
static_assert(sizeof(ICharacterInterface) == 0x000030, "Wrong size on ICharacterInterface");

// Class DarwinGame.CSVolumeFadeComponent
// 0x0010 (0x0230 - 0x0220)
class UCSVolumeFadeComponent final : public USoundFadeComponentBase
{
public:
	class FString                                 SoundVolumeCategory;                               // 0x0220(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CSVolumeFadeComponent">();
	}
	static class UCSVolumeFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCSVolumeFadeComponent>();
	}
};
static_assert(alignof(UCSVolumeFadeComponent) == 0x000010, "Wrong alignment on UCSVolumeFadeComponent");
static_assert(sizeof(UCSVolumeFadeComponent) == 0x000230, "Wrong size on UCSVolumeFadeComponent");
static_assert(offsetof(UCSVolumeFadeComponent, SoundVolumeCategory) == 0x000220, "Member 'UCSVolumeFadeComponent::SoundVolumeCategory' has a wrong offset!");

// Class DarwinGame.CharacterMovementFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCharacterMovementFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DrawActor(class AActor* Actor, const struct FVector& DrawPoint, float Scale, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMovementFunctionLibrary">();
	}
	static class UCharacterMovementFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMovementFunctionLibrary>();
	}
};
static_assert(alignof(UCharacterMovementFunctionLibrary) == 0x000008, "Wrong alignment on UCharacterMovementFunctionLibrary");
static_assert(sizeof(UCharacterMovementFunctionLibrary) == 0x000030, "Wrong size on UCharacterMovementFunctionLibrary");

// Class DarwinGame.RuinsBladeBase
// 0x0010 (0x02C0 - 0x02B0)
class ARuinsBladeBase final : public AFieldObjectBase
{
public:
	class FName                                   EventID;                                           // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PlayEventID;                                       // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RuinsBladeBase">();
	}
	static class ARuinsBladeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARuinsBladeBase>();
	}
};
static_assert(alignof(ARuinsBladeBase) == 0x000008, "Wrong alignment on ARuinsBladeBase");
static_assert(sizeof(ARuinsBladeBase) == 0x0002C0, "Wrong size on ARuinsBladeBase");
static_assert(offsetof(ARuinsBladeBase, EventID) == 0x0002B0, "Member 'ARuinsBladeBase::EventID' has a wrong offset!");
static_assert(offsetof(ARuinsBladeBase, PlayEventID) == 0x0002B8, "Member 'ARuinsBladeBase::PlayEventID' has a wrong offset!");

// Class DarwinGame.UIFieldAction_Caution_Base
// 0x0018 (0x04A8 - 0x0490)
class UUIFieldAction_Caution_Base : public UDarwinUserWidget
{
public:
	class UTextBlock*                             CautionTextBlock;                                  // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BaseImage;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Caution_Base">();
	}
	static class UUIFieldAction_Caution_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Caution_Base>();
	}
};
static_assert(alignof(UUIFieldAction_Caution_Base) == 0x000008, "Wrong alignment on UUIFieldAction_Caution_Base");
static_assert(sizeof(UUIFieldAction_Caution_Base) == 0x0004A8, "Wrong size on UUIFieldAction_Caution_Base");
static_assert(offsetof(UUIFieldAction_Caution_Base, CautionTextBlock) == 0x000490, "Member 'UUIFieldAction_Caution_Base::CautionTextBlock' has a wrong offset!");
static_assert(offsetof(UUIFieldAction_Caution_Base, BaseImage) == 0x000498, "Member 'UUIFieldAction_Caution_Base::BaseImage' has a wrong offset!");
static_assert(offsetof(UUIFieldAction_Caution_Base, HorizontalBox) == 0x0004A0, "Member 'UUIFieldAction_Caution_Base::HorizontalBox' has a wrong offset!");

// Class DarwinGame.UIFieldAction_Caution_02
// 0x0000 (0x04A8 - 0x04A8)
class UUIFieldAction_Caution_02 final : public UUIFieldAction_Caution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Caution_02">();
	}
	static class UUIFieldAction_Caution_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Caution_02>();
	}
};
static_assert(alignof(UUIFieldAction_Caution_02) == 0x000008, "Wrong alignment on UUIFieldAction_Caution_02");
static_assert(sizeof(UUIFieldAction_Caution_02) == 0x0004A8, "Wrong size on UUIFieldAction_Caution_02");

// Class DarwinGame.CharacterDefaultWeaponDataTable
// 0x0000 (0x0030 - 0x0030)
class UCharacterDefaultWeaponDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDefaultWeaponDataTable">();
	}
	static class UCharacterDefaultWeaponDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDefaultWeaponDataTable>();
	}
};
static_assert(alignof(UCharacterDefaultWeaponDataTable) == 0x000008, "Wrong alignment on UCharacterDefaultWeaponDataTable");
static_assert(sizeof(UCharacterDefaultWeaponDataTable) == 0x000030, "Wrong size on UCharacterDefaultWeaponDataTable");

// Class DarwinGame.CharacterMovementInterface
// 0x0000 (0x0030 - 0x0030)
class ICharacterMovementInterface final : public IInterface
{
public:
	void ChangeOperationMode(EOperationModeEnum Mode);
	float GetFallingAltitude();
	void OnAim(bool End);
	void OnBattle(bool End);
	void OnClimb(bool End);
	void OnClimbMove(float Time, float Alpha);
	void OnCrouch(bool End);
	void OnDead(bool End);
	void OnFall();
	void OnHop(bool End);
	void OnHopMove(bool End);
	void OnJump();
	void OnLock(bool End);
	void OnMove(float Axis, float Direction, float PlayRate);
	void OnMovementStop();
	void OnRide(class UAnimSequence* RideAnim, bool End);
	void OnSlope(bool End);
	void OnStealCharge(bool End);
	void OnStealMove(bool End);
	void OnSwim(bool End);
	void OnTalk(bool End);

	struct FVector2D GetAltitudeThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMovementInterface">();
	}
	static class ICharacterMovementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterMovementInterface>();
	}
};
static_assert(alignof(ICharacterMovementInterface) == 0x000008, "Wrong alignment on ICharacterMovementInterface");
static_assert(sizeof(ICharacterMovementInterface) == 0x000030, "Wrong size on ICharacterMovementInterface");

// Class DarwinGame.CharacterMovementInterfaceForABP
// 0x0000 (0x0030 - 0x0030)
class ICharacterMovementInterfaceForABP final : public IInterface
{
public:
	void Aim(bool End);
	void BattleMode(bool End);
	void Climb(const struct FTransform& LHand, const struct FTransform& RHand, const struct FTransform& LFoot, const struct FTransform& RFoot);
	void Dead(bool FaceUp);
	void Dive(bool End);
	void Equip(bool End, bool PlayMotion);
	void EquipSlingShot(bool End);
	void FieldLinkMode(bool End);
	void ForceStandUp();
	bool IsDiving();
	void Jump(float Foot);
	void Land(float Speed, float Direction, float PlayRate, bool bDamaged);
	void Look(bool End);
	void Move(float Axis, float Direction, float PlayRate);
	void SetExcursion(float Hip, float Neck);
	void StartParkour(float Foot);
	void Stop();
	void Swim(bool End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMovementInterfaceForABP">();
	}
	static class ICharacterMovementInterfaceForABP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterMovementInterfaceForABP>();
	}
};
static_assert(alignof(ICharacterMovementInterfaceForABP) == 0x000008, "Wrong alignment on ICharacterMovementInterfaceForABP");
static_assert(sizeof(ICharacterMovementInterfaceForABP) == 0x000030, "Wrong size on ICharacterMovementInterfaceForABP");

// Class DarwinGame.NoEntryAreaBase
// 0x0030 (0x02E0 - 0x02B0)
class ANoEntryAreaBase : public AFieldObjectBase
{
public:
	class USceneComponent*                        mRoot;                                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveTime;                                          // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMoveEventType                                EventType;                                         // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FastTravelID;                                      // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventSender*                           EventSender;                                       // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCheckLanding(class AActor* PlayerActor);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoEntryAreaBase">();
	}
	static class ANoEntryAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANoEntryAreaBase>();
	}
};
static_assert(alignof(ANoEntryAreaBase) == 0x000008, "Wrong alignment on ANoEntryAreaBase");
static_assert(sizeof(ANoEntryAreaBase) == 0x0002E0, "Wrong size on ANoEntryAreaBase");
static_assert(offsetof(ANoEntryAreaBase, mRoot) == 0x0002B0, "Member 'ANoEntryAreaBase::mRoot' has a wrong offset!");
static_assert(offsetof(ANoEntryAreaBase, MoveTime) == 0x0002C8, "Member 'ANoEntryAreaBase::MoveTime' has a wrong offset!");
static_assert(offsetof(ANoEntryAreaBase, EventType) == 0x0002CC, "Member 'ANoEntryAreaBase::EventType' has a wrong offset!");
static_assert(offsetof(ANoEntryAreaBase, FastTravelID) == 0x0002D0, "Member 'ANoEntryAreaBase::FastTravelID' has a wrong offset!");
static_assert(offsetof(ANoEntryAreaBase, EventSender) == 0x0002D8, "Member 'ANoEntryAreaBase::EventSender' has a wrong offset!");

// Class DarwinGame.SectorNoEntryArea
// 0x0010 (0x02F0 - 0x02E0)
class ASectorNoEntryArea final : public ANoEntryAreaBase
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectorNoEntryArea">();
	}
	static class ASectorNoEntryArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASectorNoEntryArea>();
	}
};
static_assert(alignof(ASectorNoEntryArea) == 0x000008, "Wrong alignment on ASectorNoEntryArea");
static_assert(sizeof(ASectorNoEntryArea) == 0x0002F0, "Wrong size on ASectorNoEntryArea");

// Class DarwinGame.TreasureBoxBase
// 0x0038 (0x02E8 - 0x02B0)
class ATreasureBoxBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETreasureBoxType                              TreasureBoxType;                                   // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOpen;                                            // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BA[0x6];                                      // 0x02BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     mOriginalMaterial;                                 // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               mDMI;                                              // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            mGlitterEffect;                                    // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mEffectiveSearchRange;                             // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mSearchActiveTime;                                 // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EffectiveRangeCheck(class APlayerCameraManager* cameraManager, float ActorSizeLength);

	class USkeletalMeshComponent* GetRootBoxMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureBoxBase">();
	}
	static class ATreasureBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureBoxBase>();
	}
};
static_assert(alignof(ATreasureBoxBase) == 0x000008, "Wrong alignment on ATreasureBoxBase");
static_assert(sizeof(ATreasureBoxBase) == 0x0002E8, "Wrong size on ATreasureBoxBase");
static_assert(offsetof(ATreasureBoxBase, TreasureBoxType) == 0x0002B8, "Member 'ATreasureBoxBase::TreasureBoxType' has a wrong offset!");
static_assert(offsetof(ATreasureBoxBase, IsOpen) == 0x0002B9, "Member 'ATreasureBoxBase::IsOpen' has a wrong offset!");
static_assert(offsetof(ATreasureBoxBase, mOriginalMaterial) == 0x0002C0, "Member 'ATreasureBoxBase::mOriginalMaterial' has a wrong offset!");
static_assert(offsetof(ATreasureBoxBase, mDMI) == 0x0002C8, "Member 'ATreasureBoxBase::mDMI' has a wrong offset!");
static_assert(offsetof(ATreasureBoxBase, mGlitterEffect) == 0x0002D0, "Member 'ATreasureBoxBase::mGlitterEffect' has a wrong offset!");
static_assert(offsetof(ATreasureBoxBase, mEffectiveSearchRange) == 0x0002E0, "Member 'ATreasureBoxBase::mEffectiveSearchRange' has a wrong offset!");
static_assert(offsetof(ATreasureBoxBase, mSearchActiveTime) == 0x0002E4, "Member 'ATreasureBoxBase::mSearchActiveTime' has a wrong offset!");

// Class DarwinGame.CharacterOverviewFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCharacterOverviewFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterOverviewFunctionLibrary">();
	}
	static class UCharacterOverviewFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterOverviewFunctionLibrary>();
	}
};
static_assert(alignof(UCharacterOverviewFunctionLibrary) == 0x000008, "Wrong alignment on UCharacterOverviewFunctionLibrary");
static_assert(sizeof(UCharacterOverviewFunctionLibrary) == 0x000030, "Wrong size on UCharacterOverviewFunctionLibrary");

// Class DarwinGame.DarwinAnimInstance
// 0x01E0 (0x0450 - 0x0270)
#pragma pack(push, 0x1)
class alignas(0x10) UDarwinAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FaceBlendAlpha;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLooking;                                          // 0x0284(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UsuallyLookAtLocation;                             // 0x0288(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UsuallyLookAtDistance;                             // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtBlendTime;                                   // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEmoteSwitchMotionData                 EmoteBodyData;                                     // 0x02A0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         EmoteFaceApplyRate;                                // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EmoteFacialAnim;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EEmoteFaceType>                        AdditionalUseEmoteFaceTypes;                       // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EmoteFaceBlendRate;                                // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEmoteFacialRequestData                CurrentEmoteFace;                                  // 0x02DC(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FEmoteFacialRequestData                NextEmoteFace;                                     // 0x02E8(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         EmoteBlinkBlendRate;                               // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEmoteBlinkData                        CurrentEmoteBlink;                                 // 0x02F8(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FEmoteBlinkData                        NextEmoteBlink;                                    // 0x0308(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         EmoteVocalizeBlendRate;                            // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEmoteVocalizeAnimData                 CurrentEmoteVocalize;                              // 0x031C(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FEmoteVocalizeAnimData                 NextEmoteVocalize;                                 // 0x032C(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TDelegate<void()>                             EndEmoteBodyDelegate;                              // 0x033C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsLookAt;                                         // 0x034C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_LookAtParams                       LookAtParamHead;                                   // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FST_LookAtParams                       LookAtParamSpine;                                  // 0x0368(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LookAtLocation;                                    // 0x0380(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Velocity;                                          // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootStart;                                         // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSpeed;                                      // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSpeed;                                       // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentDirection;                                  // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDirection;                                   // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpSpeed;                                         // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpDirection;                                     // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandSpeed;                                         // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandDirection;                                     // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovePlayRate;                                      // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyWeight;                                   // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquip;                                            // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming;                                         // 0x03C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceUp;                                           // 0x03CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInWater;                                        // 0x03CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDiving;                                         // 0x03CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  States;                                            // 0x03D0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bFallingDamaged;                                   // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBattleMode;                                     // 0x03F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFieldLinkMode;                                  // 0x03F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPreFieldLinkMode;                               // 0x03F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EcologicalAnimSequence;                            // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionMode                               DefaultRootMotionMode;                             // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x17];                                     // 0x0401(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        RideIdleMotion;                                    // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      RideJumpStMotion;                                  // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      RideJumpRsMotion;                                  // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      RideJumpTpMotion;                                  // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      RideJumpFaMotion;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        RideJumpEdMotion;                                  // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Aim(bool End);
	void AnimNotify_EmoteBodyEnd_Group1();
	void AnimNotify_EmoteBodyEnd_Group2();
	void ChangeAnimState(const struct FGameplayTag& State);
	void ChangeState(const struct FGameplayTag& State, bool End);
	void ClearLookAtTarget();
	void Dive(bool End);
	EEcologicalState GetEcologicalState();
	bool HasTag(const struct FGameplayTag& Tag);
	bool IsEcoSleepGetup();
	void Move(float Axis, float Direction, float PlayRate);
	void NotifyEmoteBodyEnd(EEmoteMotionSwitch Group);
	void OnAbnormalStateEnd();
	void OnLand();
	void OnMontageStart(class UAnimMontage* Montage);
	void ResetRootMode();
	void SetLookAtEnable(const bool enable);
	void SetLookAtTarget(const struct FVector& TargetLocation);
	void SetupEcologicalGestureAnimation(EEcoGestureAnimDataID ID);

	const struct FEmoteBodyMotionSetting GetBodyEmoteSetting(EEmoteMotionSwitch Group) const;
	const struct FEmoteBodyMotionInfo GetEmoteBodyInfo(EEmoteMotionSwitch Group) const;
	class UAnimSequence* GetEmoteBodyPhaseAnim(EEmoteMotionSwitch Group, EEmoteBodyMotionPhase phase) const;
	class UAnimSequence* GetEmoteBodyPhaseAnimFromMotionRequest(const struct FEmoteBodyMotionRequest& Request, EEmoteBodyMotionPhase phase) const;
	struct FST_LookAtParams GetLookAtParamHead() const;
	struct FST_LookAtParams GetLookAtParamSpine() const;
	ERootMotionMode GetRootMode() const;
	bool HasAbnormalAnimationTag() const;
	bool HasEndTrigger(EEmoteMotionSwitch Group) const;
	bool IsAbnormal() const;
	bool IsBeginBodyEmotePhase(EEmoteMotionSwitch Group, EEmoteBodyMotionPhase phase) const;
	bool IsDead() const;
	bool IsEcoSleep() const;
	bool IsEquipping() const;
	bool IsParalysis() const;
	bool IsPlayEmoteBody_Inner() const;
	bool IsSleep() const;
	bool IsStun() const;
	bool IsTriggerEmoteBodyEndToIdle(EEmoteMotionSwitch Group, float RemainingTime, float boarder) const;
	bool IsTriggerEmoteBodyLoopToEnd(EEmoteMotionSwitch Group) const;
	bool IsTriggerEmoteBodyLoopToIdle(EEmoteMotionSwitch Group) const;
	bool IsTriggerEmoteBodyStartToIdle(EEmoteMotionSwitch Group) const;
	bool IsTriggerEmoteBodyStartToLoop(EEmoteMotionSwitch Group, float RemainingTime, float boarder) const;
	bool IsValidEmoteBodyAnim(EEmoteMotionSwitch Group, EEmoteBodyMotionPhase phase) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinAnimInstance">();
	}
	static class UDarwinAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDarwinAnimInstance) == 0x000010, "Wrong alignment on UDarwinAnimInstance");
static_assert(sizeof(UDarwinAnimInstance) == 0x000450, "Wrong size on UDarwinAnimInstance");
static_assert(offsetof(UDarwinAnimInstance, FaceBlendAlpha) == 0x000280, "Member 'UDarwinAnimInstance::FaceBlendAlpha' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bLooking) == 0x000284, "Member 'UDarwinAnimInstance::bLooking' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, UsuallyLookAtLocation) == 0x000288, "Member 'UDarwinAnimInstance::UsuallyLookAtLocation' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, UsuallyLookAtDistance) == 0x000294, "Member 'UDarwinAnimInstance::UsuallyLookAtDistance' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, LookAtBlendTime) == 0x000298, "Member 'UDarwinAnimInstance::LookAtBlendTime' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EmoteBodyData) == 0x0002A0, "Member 'UDarwinAnimInstance::EmoteBodyData' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EmoteFaceApplyRate) == 0x0002B8, "Member 'UDarwinAnimInstance::EmoteFaceApplyRate' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EmoteFacialAnim) == 0x0002C0, "Member 'UDarwinAnimInstance::EmoteFacialAnim' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, AdditionalUseEmoteFaceTypes) == 0x0002C8, "Member 'UDarwinAnimInstance::AdditionalUseEmoteFaceTypes' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EmoteFaceBlendRate) == 0x0002D8, "Member 'UDarwinAnimInstance::EmoteFaceBlendRate' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, CurrentEmoteFace) == 0x0002DC, "Member 'UDarwinAnimInstance::CurrentEmoteFace' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, NextEmoteFace) == 0x0002E8, "Member 'UDarwinAnimInstance::NextEmoteFace' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EmoteBlinkBlendRate) == 0x0002F4, "Member 'UDarwinAnimInstance::EmoteBlinkBlendRate' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, CurrentEmoteBlink) == 0x0002F8, "Member 'UDarwinAnimInstance::CurrentEmoteBlink' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, NextEmoteBlink) == 0x000308, "Member 'UDarwinAnimInstance::NextEmoteBlink' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EmoteVocalizeBlendRate) == 0x000318, "Member 'UDarwinAnimInstance::EmoteVocalizeBlendRate' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, CurrentEmoteVocalize) == 0x00031C, "Member 'UDarwinAnimInstance::CurrentEmoteVocalize' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, NextEmoteVocalize) == 0x00032C, "Member 'UDarwinAnimInstance::NextEmoteVocalize' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EndEmoteBodyDelegate) == 0x00033C, "Member 'UDarwinAnimInstance::EndEmoteBodyDelegate' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsLookAt) == 0x00034C, "Member 'UDarwinAnimInstance::bIsLookAt' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, LookAtParamHead) == 0x000350, "Member 'UDarwinAnimInstance::LookAtParamHead' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, LookAtParamSpine) == 0x000368, "Member 'UDarwinAnimInstance::LookAtParamSpine' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, LookAtLocation) == 0x000380, "Member 'UDarwinAnimInstance::LookAtLocation' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, Velocity) == 0x00038C, "Member 'UDarwinAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, InterpSpeed) == 0x000398, "Member 'UDarwinAnimInstance::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, FootStart) == 0x00039C, "Member 'UDarwinAnimInstance::FootStart' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, CurrentSpeed) == 0x0003A0, "Member 'UDarwinAnimInstance::CurrentSpeed' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, TargetSpeed) == 0x0003A4, "Member 'UDarwinAnimInstance::TargetSpeed' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, CurrentDirection) == 0x0003A8, "Member 'UDarwinAnimInstance::CurrentDirection' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, TargetDirection) == 0x0003AC, "Member 'UDarwinAnimInstance::TargetDirection' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, JumpSpeed) == 0x0003B0, "Member 'UDarwinAnimInstance::JumpSpeed' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, JumpDirection) == 0x0003B4, "Member 'UDarwinAnimInstance::JumpDirection' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, LandSpeed) == 0x0003B8, "Member 'UDarwinAnimInstance::LandSpeed' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, LandDirection) == 0x0003BC, "Member 'UDarwinAnimInstance::LandDirection' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, MovePlayRate) == 0x0003C0, "Member 'UDarwinAnimInstance::MovePlayRate' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, UpperBodyWeight) == 0x0003C4, "Member 'UDarwinAnimInstance::UpperBodyWeight' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bEquip) == 0x0003C8, "Member 'UDarwinAnimInstance::bEquip' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsAiming) == 0x0003C9, "Member 'UDarwinAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bFaceUp) == 0x0003CA, "Member 'UDarwinAnimInstance::bFaceUp' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsInWater) == 0x0003CB, "Member 'UDarwinAnimInstance::bIsInWater' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsDiving) == 0x0003CC, "Member 'UDarwinAnimInstance::bIsDiving' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, States) == 0x0003D0, "Member 'UDarwinAnimInstance::States' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bFallingDamaged) == 0x0003F0, "Member 'UDarwinAnimInstance::bFallingDamaged' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsBattleMode) == 0x0003F1, "Member 'UDarwinAnimInstance::bIsBattleMode' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsFieldLinkMode) == 0x0003F2, "Member 'UDarwinAnimInstance::bIsFieldLinkMode' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, bIsPreFieldLinkMode) == 0x0003F3, "Member 'UDarwinAnimInstance::bIsPreFieldLinkMode' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, EcologicalAnimSequence) == 0x0003F8, "Member 'UDarwinAnimInstance::EcologicalAnimSequence' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, DefaultRootMotionMode) == 0x000400, "Member 'UDarwinAnimInstance::DefaultRootMotionMode' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, RideIdleMotion) == 0x000418, "Member 'UDarwinAnimInstance::RideIdleMotion' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, RideJumpStMotion) == 0x000420, "Member 'UDarwinAnimInstance::RideJumpStMotion' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, RideJumpRsMotion) == 0x000428, "Member 'UDarwinAnimInstance::RideJumpRsMotion' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, RideJumpTpMotion) == 0x000430, "Member 'UDarwinAnimInstance::RideJumpTpMotion' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, RideJumpFaMotion) == 0x000438, "Member 'UDarwinAnimInstance::RideJumpFaMotion' has a wrong offset!");
static_assert(offsetof(UDarwinAnimInstance, RideJumpEdMotion) == 0x000440, "Member 'UDarwinAnimInstance::RideJumpEdMotion' has a wrong offset!");

// Class DarwinGame.NPCCSAnimInstance
// 0x0010 (0x0460 - 0x0450)
class UNPCCSAnimInstance final : public UDarwinAnimInstance
{
public:
	bool                                          bNPC_Looking;                                      // 0x0448(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookTargetLocation;                                // 0x044C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LookTargetActor;                                   // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AnimNotify_EndExAction();
	void SetLookAtActor(class AActor* TargetActor);
	void SetTargetLook(const bool IsLookStart);
	void UpdateLookAtLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCCSAnimInstance">();
	}
	static class UNPCCSAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCCSAnimInstance>();
	}
};
static_assert(alignof(UNPCCSAnimInstance) == 0x000010, "Wrong alignment on UNPCCSAnimInstance");
static_assert(sizeof(UNPCCSAnimInstance) == 0x000460, "Wrong size on UNPCCSAnimInstance");
static_assert(offsetof(UNPCCSAnimInstance, bNPC_Looking) == 0x000448, "Member 'UNPCCSAnimInstance::bNPC_Looking' has a wrong offset!");
static_assert(offsetof(UNPCCSAnimInstance, LookTargetLocation) == 0x00044C, "Member 'UNPCCSAnimInstance::LookTargetLocation' has a wrong offset!");
static_assert(offsetof(UNPCCSAnimInstance, LookTargetActor) == 0x000458, "Member 'UNPCCSAnimInstance::LookTargetActor' has a wrong offset!");

// Class DarwinGame.CharacterStateInterfaceForABP
// 0x0000 (0x0030 - 0x0030)
class ICharacterStateInterfaceForABP final : public IInterface
{
public:
	void ChangeAnimState(const struct FGameplayTag& State);
	void ChangeState(const struct FGameplayTag& State, bool End);
	bool HasTag(const struct FGameplayTag& Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStateInterfaceForABP">();
	}
	static class ICharacterStateInterfaceForABP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterStateInterfaceForABP>();
	}
};
static_assert(alignof(ICharacterStateInterfaceForABP) == 0x000008, "Wrong alignment on ICharacterStateInterfaceForABP");
static_assert(sizeof(ICharacterStateInterfaceForABP) == 0x000030, "Wrong size on ICharacterStateInterfaceForABP");

// Class DarwinGame.UIFacility_FieldStatus
// 0x0058 (0x04E8 - 0x0490)
class UUIFacility_FieldStatus final : public UDarwinUserWidget
{
public:
	TArray<class UObject*>                        MatchMaterialList;                                 // 0x0490(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     AreaIconList;                                      // 0x04A0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x38];                                     // 0x04B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_FieldStatus">();
	}
	static class UUIFacility_FieldStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_FieldStatus>();
	}
};
static_assert(alignof(UUIFacility_FieldStatus) == 0x000008, "Wrong alignment on UUIFacility_FieldStatus");
static_assert(sizeof(UUIFacility_FieldStatus) == 0x0004E8, "Wrong size on UUIFacility_FieldStatus");
static_assert(offsetof(UUIFacility_FieldStatus, MatchMaterialList) == 0x000490, "Member 'UUIFacility_FieldStatus::MatchMaterialList' has a wrong offset!");
static_assert(offsetof(UUIFacility_FieldStatus, AreaIconList) == 0x0004A0, "Member 'UUIFacility_FieldStatus::AreaIconList' has a wrong offset!");

// Class DarwinGame.DitheringInterface
// 0x0000 (0x0030 - 0x0030)
class IDitheringInterface final : public IInterface
{
public:
	void AddSlaveDithering(class UDitheringComponent* slave);
	class UDitheringComponent* GetDithering();
	void ReleaseSlaveDithering(class UDitheringComponent* slave);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitheringInterface">();
	}
	static class IDitheringInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDitheringInterface>();
	}
};
static_assert(alignof(IDitheringInterface) == 0x000008, "Wrong alignment on IDitheringInterface");
static_assert(sizeof(IDitheringInterface) == 0x000030, "Wrong size on IDitheringInterface");

// Class DarwinGame.CharacterSystemLibrary
// 0x0000 (0x0030 - 0x0030)
class UCharacterSystemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetStandActorLocation(class AGPACharacter* Target, struct FVector* StandLocation);
	static bool IsLeftFootFront(class AGameCharacter* Target);
	static bool IsStandable(class AGPACharacter* Target);
	static bool IsSuccessSection(class FName SectionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSystemLibrary">();
	}
	static class UCharacterSystemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSystemLibrary>();
	}
};
static_assert(alignof(UCharacterSystemLibrary) == 0x000008, "Wrong alignment on UCharacterSystemLibrary");
static_assert(sizeof(UCharacterSystemLibrary) == 0x000030, "Wrong size on UCharacterSystemLibrary");

// Class DarwinGame.DarwinGameplayCue
// 0x0010 (0x02A8 - 0x0298)
class ADarwinGameplayCue : public AGameplayCueNotify_Actor
{
public:
	bool                                          bChangeMotion;                                     // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AbnormalStateTag;                                  // 0x029C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetActionDetailID(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters);
	void SetAbnormalStateTag(const struct FGameplayTag& Tag);
	void SetIsChangeMotion(bool flg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinGameplayCue">();
	}
	static class ADarwinGameplayCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADarwinGameplayCue>();
	}
};
static_assert(alignof(ADarwinGameplayCue) == 0x000008, "Wrong alignment on ADarwinGameplayCue");
static_assert(sizeof(ADarwinGameplayCue) == 0x0002A8, "Wrong size on ADarwinGameplayCue");
static_assert(offsetof(ADarwinGameplayCue, bChangeMotion) == 0x000298, "Member 'ADarwinGameplayCue::bChangeMotion' has a wrong offset!");
static_assert(offsetof(ADarwinGameplayCue, AbnormalStateTag) == 0x00029C, "Member 'ADarwinGameplayCue::AbnormalStateTag' has a wrong offset!");

// Class DarwinGame.ChargeBreakGaugeCue
// 0x0018 (0x02C0 - 0x02A8)
class AChargeBreakGaugeCue : public ADarwinGameplayCue
{
public:
	uint8                                         Pad_2A8[0x12];                                     // 0x02A8(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	EBattleCommonEffectID                         BreakEffectID;                                     // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESocket                                       BreakEffectAttachSocket;                           // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeBreakGaugeCue">();
	}
	static class AChargeBreakGaugeCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChargeBreakGaugeCue>();
	}
};
static_assert(alignof(AChargeBreakGaugeCue) == 0x000008, "Wrong alignment on AChargeBreakGaugeCue");
static_assert(sizeof(AChargeBreakGaugeCue) == 0x0002C0, "Wrong size on AChargeBreakGaugeCue");
static_assert(offsetof(AChargeBreakGaugeCue, BreakEffectID) == 0x0002BA, "Member 'AChargeBreakGaugeCue::BreakEffectID' has a wrong offset!");
static_assert(offsetof(AChargeBreakGaugeCue, BreakEffectAttachSocket) == 0x0002BB, "Member 'AChargeBreakGaugeCue::BreakEffectAttachSocket' has a wrong offset!");

// Class DarwinGame.HitEventData
// 0x0090 (0x00C0 - 0x0030)
class UHitEventData final : public UObject
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEventData">();
	}
	static class UHitEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitEventData>();
	}
};
static_assert(alignof(UHitEventData) == 0x000008, "Wrong alignment on UHitEventData");
static_assert(sizeof(UHitEventData) == 0x0000C0, "Wrong size on UHitEventData");

// Class DarwinGame.CloseEnough
// 0x0000 (0x0038 - 0x0038)
class UCloseEnough final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloseEnough">();
	}
	static class UCloseEnough* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloseEnough>();
	}
};
static_assert(alignof(UCloseEnough) == 0x000008, "Wrong alignment on UCloseEnough");
static_assert(sizeof(UCloseEnough) == 0x000038, "Wrong size on UCloseEnough");

// Class DarwinGame.SearchTargetOutsideTerritory
// 0x0000 (0x0038 - 0x0038)
class USearchTargetOutsideTerritory final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchTargetOutsideTerritory">();
	}
	static class USearchTargetOutsideTerritory* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchTargetOutsideTerritory>();
	}
};
static_assert(alignof(USearchTargetOutsideTerritory) == 0x000008, "Wrong alignment on USearchTargetOutsideTerritory");
static_assert(sizeof(USearchTargetOutsideTerritory) == 0x000038, "Wrong size on USearchTargetOutsideTerritory");

// Class DarwinGame.UIStaff_Roll_Title
// 0x0000 (0x0490 - 0x0490)
class UUIStaff_Roll_Title final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_Title">();
	}
	static class UUIStaff_Roll_Title* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_Title>();
	}
};
static_assert(alignof(UUIStaff_Roll_Title) == 0x000008, "Wrong alignment on UUIStaff_Roll_Title");
static_assert(sizeof(UUIStaff_Roll_Title) == 0x000490, "Wrong size on UUIStaff_Roll_Title");

// Class DarwinGame.UIFlagmenu_00
// 0x0020 (0x05F0 - 0x05D0)
class UUIFlagmenu_00 : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICommonmenu_ItemName*                 DetailItemName;                                    // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlagmenu_00">();
	}
	static class UUIFlagmenu_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlagmenu_00>();
	}
};
static_assert(alignof(UUIFlagmenu_00) == 0x000008, "Wrong alignment on UUIFlagmenu_00");
static_assert(sizeof(UUIFlagmenu_00) == 0x0005F0, "Wrong size on UUIFlagmenu_00");
static_assert(offsetof(UUIFlagmenu_00, DetailItemName) == 0x0005E0, "Member 'UUIFlagmenu_00::DetailItemName' has a wrong offset!");

// Class DarwinGame.DispatchDataAssetLibrary
// 0x0000 (0x0030 - 0x0030)
class UDispatchDataAssetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DispatchDataAssetLibrary">();
	}
	static class UDispatchDataAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDispatchDataAssetLibrary>();
	}
};
static_assert(alignof(UDispatchDataAssetLibrary) == 0x000008, "Wrong alignment on UDispatchDataAssetLibrary");
static_assert(sizeof(UDispatchDataAssetLibrary) == 0x000030, "Wrong size on UDispatchDataAssetLibrary");

// Class DarwinGame.CloseEnoughToLocation
// 0x0008 (0x0040 - 0x0038)
class UCloseEnoughToLocation final : public UMonsterService
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloseEnoughToLocation">();
	}
	static class UCloseEnoughToLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloseEnoughToLocation>();
	}
};
static_assert(alignof(UCloseEnoughToLocation) == 0x000008, "Wrong alignment on UCloseEnoughToLocation");
static_assert(sizeof(UCloseEnoughToLocation) == 0x000040, "Wrong size on UCloseEnoughToLocation");

// Class DarwinGame.CloudObjectManager
// 0x0038 (0x02E8 - 0x02B0)
class ACloudObjectManager final : public AFieldObjectBase
{
public:
	class FName                                   mEventID;                                          // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           mSaveFlag;                                         // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x20];                                     // 0x02C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudObjectManager">();
	}
	static class ACloudObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACloudObjectManager>();
	}
};
static_assert(alignof(ACloudObjectManager) == 0x000008, "Wrong alignment on ACloudObjectManager");
static_assert(sizeof(ACloudObjectManager) == 0x0002E8, "Wrong size on ACloudObjectManager");
static_assert(offsetof(ACloudObjectManager, mEventID) == 0x0002B0, "Member 'ACloudObjectManager::mEventID' has a wrong offset!");
static_assert(offsetof(ACloudObjectManager, mSaveFlag) == 0x0002B8, "Member 'ACloudObjectManager::mSaveFlag' has a wrong offset!");

// Class DarwinGame.PlayBossVoice
// 0x0008 (0x0048 - 0x0040)
class UPlayBossVoice final : public UAnimNotify
{
public:
	EVoiceTimingBoss                              Voice;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayBossVoice">();
	}
	static class UPlayBossVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayBossVoice>();
	}
};
static_assert(alignof(UPlayBossVoice) == 0x000008, "Wrong alignment on UPlayBossVoice");
static_assert(sizeof(UPlayBossVoice) == 0x000048, "Wrong size on UPlayBossVoice");
static_assert(offsetof(UPlayBossVoice, Voice) == 0x000040, "Member 'UPlayBossVoice::Voice' has a wrong offset!");

// Class DarwinGame.CoinAutoEquipmentFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCoinAutoEquipmentFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinAutoEquipmentFunctionLibrary">();
	}
	static class UCoinAutoEquipmentFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoinAutoEquipmentFunctionLibrary>();
	}
};
static_assert(alignof(UCoinAutoEquipmentFunctionLibrary) == 0x000008, "Wrong alignment on UCoinAutoEquipmentFunctionLibrary");
static_assert(sizeof(UCoinAutoEquipmentFunctionLibrary) == 0x000030, "Wrong size on UCoinAutoEquipmentFunctionLibrary");

// Class DarwinGame.ObjectReactionCollisionDataBase
// 0x0000 (0x0030 - 0x0030)
class UObjectReactionCollisionDataBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionCollisionDataBase">();
	}
	static class UObjectReactionCollisionDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionCollisionDataBase>();
	}
};
static_assert(alignof(UObjectReactionCollisionDataBase) == 0x000008, "Wrong alignment on UObjectReactionCollisionDataBase");
static_assert(sizeof(UObjectReactionCollisionDataBase) == 0x000030, "Wrong size on UObjectReactionCollisionDataBase");

// Class DarwinGame.ObjectReactionCollisionDataShpher
// 0x0008 (0x0038 - 0x0030)
class UObjectReactionCollisionDataShpher final : public UObjectReactionCollisionDataBase
{
public:
	int32                                         Radius;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionCollisionDataShpher">();
	}
	static class UObjectReactionCollisionDataShpher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionCollisionDataShpher>();
	}
};
static_assert(alignof(UObjectReactionCollisionDataShpher) == 0x000008, "Wrong alignment on UObjectReactionCollisionDataShpher");
static_assert(sizeof(UObjectReactionCollisionDataShpher) == 0x000038, "Wrong size on UObjectReactionCollisionDataShpher");
static_assert(offsetof(UObjectReactionCollisionDataShpher, Radius) == 0x000030, "Member 'UObjectReactionCollisionDataShpher::Radius' has a wrong offset!");

// Class DarwinGame.CoinBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCoinBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddBelongingsCoin(const struct FST_CoinParam& CoinParam);
	static class FText CoinBaseNameOf(const struct FST_CoinParam& CoinParam);
	static bool CreateCoin(int32 Level, int32 KindId, struct FST_CoinParam* CoinParam, bool isRarityUp);
	static bool CreateCoinFixed(int32 ID, struct FST_CoinParam* CoinParam);
	static bool CreateCoinFixedGroup(int32 GroupID, TArray<struct FST_CoinParam>* CoinParamArray);
	static EResistanceType GetCoinAttributeType(const struct FST_CoinParam& CoinParam);
	static int32 GetCoinFeatureIconId(const struct FST_CoinFeature& CoinFeature);
	static TArray<int32> GetCoinIconTypes(const struct FST_CoinFeature& CoinFeature);
	static bool GetCoinIsPlayEquipAnim(const struct FST_CoinFeature& CoinFeature);
	static void GetCoinListName(const struct FST_CoinParam& CoinParam, class FText* Name_0, bool IsEnableIndefSgl);
	static void GetCoinName(const struct FST_CoinParam& CoinParam, class FText* Name_0, bool IsEnableIndefSgl);
	static int32 GetCoinName50Order(const struct FST_CoinParam& CoinParam);
	static EStatusParamType GetCoinParamType(const struct FST_CoinParam& CoinParam);
	static class FName GetCoinRarityIcon(ECoinRarity Rarity);
	static void RemoveBelongingsCoin(int32 Uid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinBlueprintFunctionLibrary">();
	}
	static class UCoinBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoinBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UCoinBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UCoinBlueprintFunctionLibrary");
static_assert(sizeof(UCoinBlueprintFunctionLibrary) == 0x000030, "Wrong size on UCoinBlueprintFunctionLibrary");

// Class DarwinGame.UIFacilityFoodItem
// 0x0000 (0x0030 - 0x0030)
class UUIFacilityFoodItem final : public UBlueprintFunctionLibrary
{
public:
	static bool GetIsLuxuryFoodId(class FName ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityFoodItem">();
	}
	static class UUIFacilityFoodItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityFoodItem>();
	}
};
static_assert(alignof(UUIFacilityFoodItem) == 0x000008, "Wrong alignment on UUIFacilityFoodItem");
static_assert(sizeof(UUIFacilityFoodItem) == 0x000030, "Wrong size on UUIFacilityFoodItem");

// Class DarwinGame.DungeonFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UDungeonFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonFunctionLibrary">();
	}
	static class UDungeonFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonFunctionLibrary>();
	}
};
static_assert(alignof(UDungeonFunctionLibrary) == 0x000008, "Wrong alignment on UDungeonFunctionLibrary");
static_assert(sizeof(UDungeonFunctionLibrary) == 0x000030, "Wrong size on UDungeonFunctionLibrary");

// Class DarwinGame.CoinFilterFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCoinFilterFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinFilterFunctionLibrary">();
	}
	static class UCoinFilterFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoinFilterFunctionLibrary>();
	}
};
static_assert(alignof(UCoinFilterFunctionLibrary) == 0x000008, "Wrong alignment on UCoinFilterFunctionLibrary");
static_assert(sizeof(UCoinFilterFunctionLibrary) == 0x000030, "Wrong size on UCoinFilterFunctionLibrary");

// Class DarwinGame.NPCEmoteDataTable
// 0x0000 (0x0030 - 0x0030)
class UNPCEmoteDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCEmoteDataTable">();
	}
	static class UNPCEmoteDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCEmoteDataTable>();
	}
};
static_assert(alignof(UNPCEmoteDataTable) == 0x000008, "Wrong alignment on UNPCEmoteDataTable");
static_assert(sizeof(UNPCEmoteDataTable) == 0x000030, "Wrong size on UNPCEmoteDataTable");

// Class DarwinGame.CoinIconFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCoinIconFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinIconFunctionLibrary">();
	}
	static class UCoinIconFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoinIconFunctionLibrary>();
	}
};
static_assert(alignof(UCoinIconFunctionLibrary) == 0x000008, "Wrong alignment on UCoinIconFunctionLibrary");
static_assert(sizeof(UCoinIconFunctionLibrary) == 0x000030, "Wrong size on UCoinIconFunctionLibrary");

// Class DarwinGame.CoinObjectBase
// 0x0018 (0x0348 - 0x0330)
class ACoinObjectBase : public ADropItemObject
{
public:
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const struct FST_CoinParam& Param);

	struct FST_CoinParam GetCoinParam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinObjectBase">();
	}
	static class ACoinObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoinObjectBase>();
	}
};
static_assert(alignof(ACoinObjectBase) == 0x000008, "Wrong alignment on ACoinObjectBase");
static_assert(sizeof(ACoinObjectBase) == 0x000348, "Wrong size on ACoinObjectBase");

// Class DarwinGame.ObjectDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UObjectDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectDamageExecution">();
	}
	static class UObjectDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectDamageExecution>();
	}
};
static_assert(alignof(UObjectDamageExecution) == 0x000008, "Wrong alignment on UObjectDamageExecution");
static_assert(sizeof(UObjectDamageExecution) == 0x000048, "Wrong size on UObjectDamageExecution");

// Class DarwinGame.CoinSlotParameterDataTable
// 0x0000 (0x0030 - 0x0030)
class UCoinSlotParameterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinSlotParameterDataTable">();
	}
	static class UCoinSlotParameterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoinSlotParameterDataTable>();
	}
};
static_assert(alignof(UCoinSlotParameterDataTable) == 0x000008, "Wrong alignment on UCoinSlotParameterDataTable");
static_assert(sizeof(UCoinSlotParameterDataTable) == 0x000030, "Wrong size on UCoinSlotParameterDataTable");

// Class DarwinGame.PlayAtomGate
// 0x0018 (0x0050 - 0x0038)
class UPlayAtomGate final : public UAnimNotifyState
{
public:
	class USoundAtomCue*                          Sound;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachedBoneName;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         AtomComp;                                          // 0x0048(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAtomGate">();
	}
	static class UPlayAtomGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAtomGate>();
	}
};
static_assert(alignof(UPlayAtomGate) == 0x000008, "Wrong alignment on UPlayAtomGate");
static_assert(sizeof(UPlayAtomGate) == 0x000050, "Wrong size on UPlayAtomGate");
static_assert(offsetof(UPlayAtomGate, Sound) == 0x000038, "Member 'UPlayAtomGate::Sound' has a wrong offset!");
static_assert(offsetof(UPlayAtomGate, AttachedBoneName) == 0x000040, "Member 'UPlayAtomGate::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UPlayAtomGate, AtomComp) == 0x000048, "Member 'UPlayAtomGate::AtomComp' has a wrong offset!");

// Class DarwinGame.UIGlut_IconRange
// 0x0018 (0x05E8 - 0x05D0)
class UUIGlut_IconRange final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDataUid(const TArray<class FName>& InItemIdList, const int32& InUid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlut_IconRange">();
	}
	static class UUIGlut_IconRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlut_IconRange>();
	}
};
static_assert(alignof(UUIGlut_IconRange) == 0x000008, "Wrong alignment on UUIGlut_IconRange");
static_assert(sizeof(UUIGlut_IconRange) == 0x0005E8, "Wrong size on UUIGlut_IconRange");

// Class DarwinGame.EQT_RandomWalkPos
// 0x0000 (0x0200 - 0x0200)
class UEQT_RandomWalkPos final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQT_RandomWalkPos">();
	}
	static class UEQT_RandomWalkPos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQT_RandomWalkPos>();
	}
};
static_assert(alignof(UEQT_RandomWalkPos) == 0x000008, "Wrong alignment on UEQT_RandomWalkPos");
static_assert(sizeof(UEQT_RandomWalkPos) == 0x000200, "Wrong size on UEQT_RandomWalkPos");

// Class DarwinGame.CoinSortFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCoinSortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinSortFunctionLibrary">();
	}
	static class UCoinSortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoinSortFunctionLibrary>();
	}
};
static_assert(alignof(UCoinSortFunctionLibrary) == 0x000008, "Wrong alignment on UCoinSortFunctionLibrary");
static_assert(sizeof(UCoinSortFunctionLibrary) == 0x000030, "Wrong size on UCoinSortFunctionLibrary");

// Class DarwinGame.CollectionPointDataAsset
// 0x00F0 (0x0128 - 0x0038)
class UCollectionPointDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_CollectionPointData> CollectionPointList;                               // 0x0038(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FST_CollectionPointGetItem> CollectionPointGetItemList;                        // 0x0088(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            ItemNumCorrectionList;                             // 0x00D8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectionPointDataAsset">();
	}
	static class UCollectionPointDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectionPointDataAsset>();
	}
};
static_assert(alignof(UCollectionPointDataAsset) == 0x000008, "Wrong alignment on UCollectionPointDataAsset");
static_assert(sizeof(UCollectionPointDataAsset) == 0x000128, "Wrong size on UCollectionPointDataAsset");
static_assert(offsetof(UCollectionPointDataAsset, CollectionPointList) == 0x000038, "Member 'UCollectionPointDataAsset::CollectionPointList' has a wrong offset!");
static_assert(offsetof(UCollectionPointDataAsset, CollectionPointGetItemList) == 0x000088, "Member 'UCollectionPointDataAsset::CollectionPointGetItemList' has a wrong offset!");
static_assert(offsetof(UCollectionPointDataAsset, ItemNumCorrectionList) == 0x0000D8, "Member 'UCollectionPointDataAsset::ItemNumCorrectionList' has a wrong offset!");

// Class DarwinGame.PlayGuideVoice
// 0x0008 (0x0048 - 0x0040)
class UPlayGuideVoice final : public UAnimNotify
{
public:
	EVoiceTimingGuide                             Voice;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayGuideVoice">();
	}
	static class UPlayGuideVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayGuideVoice>();
	}
};
static_assert(alignof(UPlayGuideVoice) == 0x000008, "Wrong alignment on UPlayGuideVoice");
static_assert(sizeof(UPlayGuideVoice) == 0x000048, "Wrong size on UPlayGuideVoice");
static_assert(offsetof(UPlayGuideVoice, Voice) == 0x000040, "Member 'UPlayGuideVoice::Voice' has a wrong offset!");

// Class DarwinGame.DeathRequirement
// 0x0000 (0x0030 - 0x0030)
class UDeathRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathRequirement">();
	}
	static class UDeathRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathRequirement>();
	}
};
static_assert(alignof(UDeathRequirement) == 0x000008, "Wrong alignment on UDeathRequirement");
static_assert(sizeof(UDeathRequirement) == 0x000030, "Wrong size on UDeathRequirement");

// Class DarwinGame.CollectionPointData
// 0x0000 (0x0030 - 0x0030)
class UCollectionPointData final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectionPointData">();
	}
	static class UCollectionPointData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectionPointData>();
	}
};
static_assert(alignof(UCollectionPointData) == 0x000008, "Wrong alignment on UCollectionPointData");
static_assert(sizeof(UCollectionPointData) == 0x000030, "Wrong size on UCollectionPointData");

// Class DarwinGame.QuestManager
// 0x0408 (0x0440 - 0x0038)
class UQuestManager : public UManagerBase
{
public:
	TSoftObjectPtr<class UDataTable>              mQuestListDT;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListPointDT;                                 // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListRewardDT;                                // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListTextDT;                                  // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListJudgeOpenDT;                             // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListJudgeOrderDT;                            // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListJudgeClearDT;                            // 0x0128(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListJudgeClearRandomTableDT;                 // 0x0150(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForBaseAreaBattleDT;                     // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForEmergencyDT;                          // 0x01A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForNetworkDT;                            // 0x01C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDailyQuestWeightOfCategoryDT;                     // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mDailyQuestWeightOfInCategoryDT;                   // 0x0218(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForDailyDT;                              // 0x0240(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForDailyRewardDT;                        // 0x0268(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForTreasureMapDT;                        // 0x0290(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mQuestListForGetBackDT;                            // 0x02B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mQuestEventPtr;                                    // 0x02E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuestEvent*                            mQuestEvent;                                       // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0xA0];                                     // 0x0318(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UObject*>             mQuestDestinationRects;                            // 0x03B8(0x0050)(NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   mQuestDestinationRectBasePtr;                      // 0x0408(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AQuestDestinationRectBase>  QuestDestinationRectBaseClass;                     // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NpcARMarkerOffsetZ;                                // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TreasureMapARMarkerOffsetZ;                        // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UQuestManager* GetInstance();

	void AddQuestDestinationRect(const class FName ID, const class FName QuestID);
	void AddQuestDestinationRectList(const class FName ID, class UObject* Object);
	void CancelBaseAreaBattleQuest();
	void CancelDailyQuest(const class FName& QuestID);
	void ClearQuest(const class FName& QuestID, bool IsOpenClearUI);
	void ClearQuestDestinationRects();
	void GainCoin();
	void GainFieldLink(const EFieldLinkType Type, const int32 Num);
	void GainGold(const int32 GainGold_0);
	void GainKillMonster(class FName MonsterParameterId, int32 Num);
	void GainMonsterVisionNum(const EAreaType Area, const int32 Num);
	void GainPlayerActionNum(EQuestClearPlayerActionType Type, const int32 Num);
	void GainTeamCommand(const EQuestClearTEamCommandType Type, const int32 Num);
	TArray<class FName> GetActiveChildQuestIDs(class FName ParentQuestID);
	TArray<class FName> GetActiveParentQuestIDs();
	TArray<class FName> GetClearedQuestIDs();
	TArray<class FName> GetOpenQuestIDs();
	TArray<class FName> GetOrderQuestIDs();
	void GetQuestBaseAreaBattleData(const class FName& QuestID, bool* Result, struct FST_QuestBaseAreaBattleData* QuestBaseArea);
	void GetQuestClearJudgeData(const class FName& QuestID, bool* Result, struct FST_QuestListClear* QuestClear);
	void GetQuestClearRandomTableData(const class FName& TableId, bool* Result, struct FST_QuestListClearRandomTable* QuestClearRandomTable);
	TMap<class FName, class UObject*> GetQuestDestinationRects();
	void GetQuestEmergencyData(const class FName& QuestID, bool* Result, struct FST_QuestEmergencyData* Emergency);
	void GetQuestListData(const class FName& QuestID, bool* Result, struct FST_QuestListDataInfo* QuestData);
	void GetQuestOpenJudgeData(const class FName& QuestID, bool* Result, struct FST_QuestListOpen* QuestOpen);
	void GetQuestOrderJudgeData(const class FName& QuestID, bool* Result, struct FST_QuestListOrder* QuestOrder);
	void GetQuestPointData(const class FName& QuestID, bool* Result, struct FST_QuestListPoint* QuestPoint);
	void GetQuestRewardData(const class FName& QuestID, bool* Result, struct FST_QuestListReward* QuestReward);
	void InitData();
	void OpenQuest(const class FName& QuestID);
	bool OrderQuest(const class FName& QuestID, bool IsOpenOrderUI, bool IsSetNewMark);
	void RemoveQuestDestinationRects(const class FName ID);
	void SetOrderedDailyQuest(const class FName& QuestID);
	void SetSelectedQuestID(const class FName& QuestID, bool IsMain);
	void UpdateQuestCount(EQuestClearJudgeType Type, const class FName& ID);

	TArray<class FName> GetOrderDailyQuestIDs() const;
	TArray<class FName> GetOrderDailyQuestIDsWithoutAll() const;
	void GetQuestListTextData(const class FName& QuestID, bool* Result, struct FST_QuestListTextDataInfo* QuestTextData) const;
	EQuestState GetQuestState(const class FName QuestID) const;
	class FName GetSelectedQuestID(bool IsMain) const;
	bool IsActiveQuest(const class FName QuestID) const;
	bool IsAllClearDailyQuestWithoutAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestManager">();
	}
	static class UQuestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestManager>();
	}
};
static_assert(alignof(UQuestManager) == 0x000008, "Wrong alignment on UQuestManager");
static_assert(sizeof(UQuestManager) == 0x000440, "Wrong size on UQuestManager");
static_assert(offsetof(UQuestManager, mQuestListDT) == 0x000038, "Member 'UQuestManager::mQuestListDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListPointDT) == 0x000060, "Member 'UQuestManager::mQuestListPointDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListRewardDT) == 0x000088, "Member 'UQuestManager::mQuestListRewardDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListTextDT) == 0x0000B0, "Member 'UQuestManager::mQuestListTextDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListJudgeOpenDT) == 0x0000D8, "Member 'UQuestManager::mQuestListJudgeOpenDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListJudgeOrderDT) == 0x000100, "Member 'UQuestManager::mQuestListJudgeOrderDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListJudgeClearDT) == 0x000128, "Member 'UQuestManager::mQuestListJudgeClearDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListJudgeClearRandomTableDT) == 0x000150, "Member 'UQuestManager::mQuestListJudgeClearRandomTableDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForBaseAreaBattleDT) == 0x000178, "Member 'UQuestManager::mQuestListForBaseAreaBattleDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForEmergencyDT) == 0x0001A0, "Member 'UQuestManager::mQuestListForEmergencyDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForNetworkDT) == 0x0001C8, "Member 'UQuestManager::mQuestListForNetworkDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mDailyQuestWeightOfCategoryDT) == 0x0001F0, "Member 'UQuestManager::mDailyQuestWeightOfCategoryDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mDailyQuestWeightOfInCategoryDT) == 0x000218, "Member 'UQuestManager::mDailyQuestWeightOfInCategoryDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForDailyDT) == 0x000240, "Member 'UQuestManager::mQuestListForDailyDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForDailyRewardDT) == 0x000268, "Member 'UQuestManager::mQuestListForDailyRewardDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForTreasureMapDT) == 0x000290, "Member 'UQuestManager::mQuestListForTreasureMapDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestListForGetBackDT) == 0x0002B8, "Member 'UQuestManager::mQuestListForGetBackDT' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestEventPtr) == 0x0002E0, "Member 'UQuestManager::mQuestEventPtr' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestEvent) == 0x000310, "Member 'UQuestManager::mQuestEvent' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestDestinationRects) == 0x0003B8, "Member 'UQuestManager::mQuestDestinationRects' has a wrong offset!");
static_assert(offsetof(UQuestManager, mQuestDestinationRectBasePtr) == 0x000408, "Member 'UQuestManager::mQuestDestinationRectBasePtr' has a wrong offset!");
static_assert(offsetof(UQuestManager, QuestDestinationRectBaseClass) == 0x000430, "Member 'UQuestManager::QuestDestinationRectBaseClass' has a wrong offset!");
static_assert(offsetof(UQuestManager, NpcARMarkerOffsetZ) == 0x000438, "Member 'UQuestManager::NpcARMarkerOffsetZ' has a wrong offset!");
static_assert(offsetof(UQuestManager, TreasureMapARMarkerOffsetZ) == 0x00043C, "Member 'UQuestManager::TreasureMapARMarkerOffsetZ' has a wrong offset!");

// Class DarwinGame.CollectionPointManager
// 0x0020 (0x0050 - 0x0030)
class UCollectionPointManager : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RespawnTime;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RespawnAllPoint();
	void RespawnAllPointAfterTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectionPointManager">();
	}
	static class UCollectionPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectionPointManager>();
	}
};
static_assert(alignof(UCollectionPointManager) == 0x000008, "Wrong alignment on UCollectionPointManager");
static_assert(sizeof(UCollectionPointManager) == 0x000050, "Wrong size on UCollectionPointManager");
static_assert(offsetof(UCollectionPointManager, RespawnTime) == 0x000048, "Member 'UCollectionPointManager::RespawnTime' has a wrong offset!");

// Class DarwinGame.UIGood_StateIcon
// 0x0000 (0x0490 - 0x0490)
class UUIGood_StateIcon : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_StateIcon">();
	}
	static class UUIGood_StateIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_StateIcon>();
	}
};
static_assert(alignof(UUIGood_StateIcon) == 0x000008, "Wrong alignment on UUIGood_StateIcon");
static_assert(sizeof(UUIGood_StateIcon) == 0x000490, "Wrong size on UUIGood_StateIcon");

// Class DarwinGame.DungeonGimmickPiller
// 0x0000 (0x02B8 - 0x02B8)
class ADungeonGimmickPiller final : public ADungeonGimmickObjectBase
{
public:
	class ADungeonPiller* GetGimmick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickPiller">();
	}
	static class ADungeonGimmickPiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickPiller>();
	}
};
static_assert(alignof(ADungeonGimmickPiller) == 0x000008, "Wrong alignment on ADungeonGimmickPiller");
static_assert(sizeof(ADungeonGimmickPiller) == 0x0002B8, "Wrong size on ADungeonGimmickPiller");

// Class DarwinGame.CollectionPointObjectBase
// 0x0070 (0x0320 - 0x02B0)
class ACollectionPointObjectBase final : public AFieldObjectBase
{
public:
	class FName                                   CollectionPointID;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputGuideType                               LabelType;                                         // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFieldActionEnum                              FieldActionType;                                   // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SoundID;                                           // 0x02BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectiveSearchRange;                              // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchActiveTime;                                  // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     mOriginalMaterialAtBefore;                         // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     mOriginalMaterialAtAfter;                          // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               mDMIAtBefore;                                      // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               mDMIAtAfter;                                       // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EffectiveRangeCheck(class APlayerCameraManager* cameraManager, float ActorSizeLength);
	class FName GetCollectionPointID();
	void OnChangeState(ECollectionPointState State, bool IsFadeSkip);

	class UPrimitiveComponent* GetAfterMesh() const;
	class UPrimitiveComponent* GetBeforeMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectionPointObjectBase">();
	}
	static class ACollectionPointObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectionPointObjectBase>();
	}
};
static_assert(alignof(ACollectionPointObjectBase) == 0x000008, "Wrong alignment on ACollectionPointObjectBase");
static_assert(sizeof(ACollectionPointObjectBase) == 0x000320, "Wrong size on ACollectionPointObjectBase");
static_assert(offsetof(ACollectionPointObjectBase, CollectionPointID) == 0x0002B0, "Member 'ACollectionPointObjectBase::CollectionPointID' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, LabelType) == 0x0002B8, "Member 'ACollectionPointObjectBase::LabelType' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, FieldActionType) == 0x0002B9, "Member 'ACollectionPointObjectBase::FieldActionType' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, SoundID) == 0x0002BC, "Member 'ACollectionPointObjectBase::SoundID' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, EffectiveSearchRange) == 0x0002C4, "Member 'ACollectionPointObjectBase::EffectiveSearchRange' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, SearchActiveTime) == 0x0002C8, "Member 'ACollectionPointObjectBase::SearchActiveTime' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, mOriginalMaterialAtBefore) == 0x0002F0, "Member 'ACollectionPointObjectBase::mOriginalMaterialAtBefore' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, mOriginalMaterialAtAfter) == 0x0002F8, "Member 'ACollectionPointObjectBase::mOriginalMaterialAtAfter' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, mDMIAtBefore) == 0x000300, "Member 'ACollectionPointObjectBase::mDMIAtBefore' has a wrong offset!");
static_assert(offsetof(ACollectionPointObjectBase, mDMIAtAfter) == 0x000308, "Member 'ACollectionPointObjectBase::mDMIAtAfter' has a wrong offset!");

// Class DarwinGame.ObjectReactionCollisionDataCapsule
// 0x0018 (0x0048 - 0x0030)
class UObjectReactionCollisionDataCapsule final : public UObjectReactionCollisionDataBase
{
public:
	int32                                         Height;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Radius;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Rotate;                                            // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionCollisionDataCapsule">();
	}
	static class UObjectReactionCollisionDataCapsule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionCollisionDataCapsule>();
	}
};
static_assert(alignof(UObjectReactionCollisionDataCapsule) == 0x000008, "Wrong alignment on UObjectReactionCollisionDataCapsule");
static_assert(sizeof(UObjectReactionCollisionDataCapsule) == 0x000048, "Wrong size on UObjectReactionCollisionDataCapsule");
static_assert(offsetof(UObjectReactionCollisionDataCapsule, Height) == 0x000030, "Member 'UObjectReactionCollisionDataCapsule::Height' has a wrong offset!");
static_assert(offsetof(UObjectReactionCollisionDataCapsule, Radius) == 0x000034, "Member 'UObjectReactionCollisionDataCapsule::Radius' has a wrong offset!");
static_assert(offsetof(UObjectReactionCollisionDataCapsule, Rotate) == 0x000038, "Member 'UObjectReactionCollisionDataCapsule::Rotate' has a wrong offset!");

// Class DarwinGame.CollisionDataTable
// 0x0000 (0x0030 - 0x0030)
class UCollisionDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionDataTable">();
	}
	static class UCollisionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionDataTable>();
	}
};
static_assert(alignof(UCollisionDataTable) == 0x000008, "Wrong alignment on UCollisionDataTable");
static_assert(sizeof(UCollisionDataTable) == 0x000030, "Wrong size on UCollisionDataTable");

// Class DarwinGame.AttackCollisionData
// 0x0070 (0x00A0 - 0x0030)
class UAttackCollisionData final : public UObject
{
public:
	int32                                         reserveCounter;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttackCollisionParameter              Param;                                             // 0x0034(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AAttackCollisionBase>    Actor;                                             // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActionGameplayEffectContainerSpec     EffectContainerSpec;                               // 0x0068(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackCollisionData">();
	}
	static class UAttackCollisionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackCollisionData>();
	}
};
static_assert(alignof(UAttackCollisionData) == 0x000008, "Wrong alignment on UAttackCollisionData");
static_assert(sizeof(UAttackCollisionData) == 0x0000A0, "Wrong size on UAttackCollisionData");
static_assert(offsetof(UAttackCollisionData, reserveCounter) == 0x000030, "Member 'UAttackCollisionData::reserveCounter' has a wrong offset!");
static_assert(offsetof(UAttackCollisionData, Param) == 0x000034, "Member 'UAttackCollisionData::Param' has a wrong offset!");
static_assert(offsetof(UAttackCollisionData, Actor) == 0x00005C, "Member 'UAttackCollisionData::Actor' has a wrong offset!");
static_assert(offsetof(UAttackCollisionData, EffectContainerSpec) == 0x000068, "Member 'UAttackCollisionData::EffectContainerSpec' has a wrong offset!");

// Class DarwinGame.DungeonBonfire
// 0x0000 (0x02C0 - 0x02C0)
class ADungeonBonfire final : public ABonfireBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonBonfire">();
	}
	static class ADungeonBonfire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonBonfire>();
	}
};
static_assert(alignof(ADungeonBonfire) == 0x000008, "Wrong alignment on ADungeonBonfire");
static_assert(sizeof(ADungeonBonfire) == 0x0002C0, "Wrong size on ADungeonBonfire");

// Class DarwinGame.CollisionManager
// 0x0070 (0x00A8 - 0x0038)
class UCollisionManager : public UManagerBase
{
public:
	TMap<int32, class UAttackCollisionData*>      ACActorPool;                                       // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCollisionManager* GetInstance();

	class AAttackCollisionBase* CreateShootAttackCollision(class FName actionDetailID, class FName OrderId);
	class AAttackCollisionBase* CreateTouchAttackCollision(class FName actionDetailID, const struct FST_TouchAttackCollision& Param);
	class UAttackCollisionData* GetAttackCollisionData(int32 UniqueId);
	void ReleaseRequest(int32 UniqueId, bool calledAC);
	void RemoveAttackData(int32 UniqueId);
	void ReserveRequest(int32 UniqueId);
	void ReturnCollision(class AAttackCollisionBase* collision);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionManager">();
	}
	static class UCollisionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionManager>();
	}
};
static_assert(alignof(UCollisionManager) == 0x000008, "Wrong alignment on UCollisionManager");
static_assert(sizeof(UCollisionManager) == 0x0000A8, "Wrong size on UCollisionManager");
static_assert(offsetof(UCollisionManager, ACActorPool) == 0x000038, "Member 'UCollisionManager::ACActorPool' has a wrong offset!");

// Class DarwinGame.PlayFootSound
// 0x0018 (0x0058 - 0x0040)
class UPlayFootSound final : public UAnimNotify
{
public:
	bool                                          EnableSoundTrigger;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionSoundType                              ActionSoundType;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedBoneName;                                  // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceDistance;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChID;                                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayFootSound">();
	}
	static class UPlayFootSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayFootSound>();
	}
};
static_assert(alignof(UPlayFootSound) == 0x000008, "Wrong alignment on UPlayFootSound");
static_assert(sizeof(UPlayFootSound) == 0x000058, "Wrong size on UPlayFootSound");
static_assert(offsetof(UPlayFootSound, EnableSoundTrigger) == 0x000040, "Member 'UPlayFootSound::EnableSoundTrigger' has a wrong offset!");
static_assert(offsetof(UPlayFootSound, ActionSoundType) == 0x000041, "Member 'UPlayFootSound::ActionSoundType' has a wrong offset!");
static_assert(offsetof(UPlayFootSound, AttachedBoneName) == 0x000044, "Member 'UPlayFootSound::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UPlayFootSound, TraceDistance) == 0x00004C, "Member 'UPlayFootSound::TraceDistance' has a wrong offset!");
static_assert(offsetof(UPlayFootSound, ChID) == 0x000050, "Member 'UPlayFootSound::ChID' has a wrong offset!");

// Class DarwinGame.CommonEmoteSettingDataTable
// 0x0008 (0x0038 - 0x0030)
class UCommonEmoteSettingDataTable final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EEmoteFaceType GetFaceType(EEmoteType emoteType);
	static bool GetStampParameter(EEmoteType emoteType, EStampIconType* outIconType, struct FEmoteStampSetting* outSetting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonEmoteSettingDataTable">();
	}
	static class UCommonEmoteSettingDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonEmoteSettingDataTable>();
	}
};
static_assert(alignof(UCommonEmoteSettingDataTable) == 0x000008, "Wrong alignment on UCommonEmoteSettingDataTable");
static_assert(sizeof(UCommonEmoteSettingDataTable) == 0x000038, "Wrong size on UCommonEmoteSettingDataTable");

// Class DarwinGame.CommonMagicFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCommonMagicFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonMagicFunctionLibrary">();
	}
	static class UCommonMagicFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonMagicFunctionLibrary>();
	}
};
static_assert(alignof(UCommonMagicFunctionLibrary) == 0x000008, "Wrong alignment on UCommonMagicFunctionLibrary");
static_assert(sizeof(UCommonMagicFunctionLibrary) == 0x000030, "Wrong size on UCommonMagicFunctionLibrary");

// Class DarwinGame.CommunicationComponent
// 0x0340 (0x03F8 - 0x00B8)
class UCommunicationComponent final : public UActorComponent
{
public:
	float                                         TickInterval;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGPACharacter*                          OwnerCharacter;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mSearchRadiusOfInteractPoint;                      // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mSearchRadiusOfActionPoint;                        // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EObjectReactionType, struct FVector>     mSearchExtentList;                                 // 0x00D0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EObjectReactionType, int32>              mReactionMaxPointList;                             // 0x0120(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EObjectReactionType, int32>              mNonBattleReactionMaxPointList;                    // 0x0170(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EObjectReactionType, int32>              mReactionIncreasePointList;                        // 0x01C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         mActorListInSearchArea;                            // 0x0218(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         mActorListInCameraFOV;                             // 0x0228(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 mCurrentManageTarget;                              // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         mCurrentManagePoint;                               // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EObjectReactionType                           mCurrentManagePointType;                           // 0x024C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D[0x27];                                     // 0x024D(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContactRadius;                                     // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetToInteract;                                  // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetToAct;                                       // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCSearchDistance;                                 // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCSearchAngle;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ListOfObstacleObjectTypesToSearch;                 // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x20];                                     // 0x02A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mDespoilEffectiveDistance;                         // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           SearchParam;                                       // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AArtifactPointBase*                     mFoundThousandArtifactPoint;                       // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x94];                                     // 0x02F0(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         mMaxDistance;                                      // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mMinDistance;                                      // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mIntervalDistance;                                 // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mElevationDifference;                              // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mMaxVisionPoint;                                   // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mMinVisionPoint;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AVisionCaptureCameraBase>   CaptureCameraClass;                                // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EVisionHeightType, int32>                mVisionHeightList;                                 // 0x03A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void EndInteraction();
	void FieldSearch(float Range, float Time);
	void SearchArtifact(const struct FVector& Center, float Range, float Time, float Brightness);
	void SearchNPC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommunicationComponent">();
	}
	static class UCommunicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommunicationComponent>();
	}
};
static_assert(alignof(UCommunicationComponent) == 0x000008, "Wrong alignment on UCommunicationComponent");
static_assert(sizeof(UCommunicationComponent) == 0x0003F8, "Wrong size on UCommunicationComponent");
static_assert(offsetof(UCommunicationComponent, TickInterval) == 0x0000B8, "Member 'UCommunicationComponent::TickInterval' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, OwnerCharacter) == 0x0000C0, "Member 'UCommunicationComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mSearchRadiusOfInteractPoint) == 0x0000C8, "Member 'UCommunicationComponent::mSearchRadiusOfInteractPoint' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mSearchRadiusOfActionPoint) == 0x0000CC, "Member 'UCommunicationComponent::mSearchRadiusOfActionPoint' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mSearchExtentList) == 0x0000D0, "Member 'UCommunicationComponent::mSearchExtentList' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mReactionMaxPointList) == 0x000120, "Member 'UCommunicationComponent::mReactionMaxPointList' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mNonBattleReactionMaxPointList) == 0x000170, "Member 'UCommunicationComponent::mNonBattleReactionMaxPointList' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mReactionIncreasePointList) == 0x0001C0, "Member 'UCommunicationComponent::mReactionIncreasePointList' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mActorListInSearchArea) == 0x000218, "Member 'UCommunicationComponent::mActorListInSearchArea' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mActorListInCameraFOV) == 0x000228, "Member 'UCommunicationComponent::mActorListInCameraFOV' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mCurrentManageTarget) == 0x000240, "Member 'UCommunicationComponent::mCurrentManageTarget' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mCurrentManagePoint) == 0x000248, "Member 'UCommunicationComponent::mCurrentManagePoint' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mCurrentManagePointType) == 0x00024C, "Member 'UCommunicationComponent::mCurrentManagePointType' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, ContactRadius) == 0x000274, "Member 'UCommunicationComponent::ContactRadius' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, TargetToInteract) == 0x000278, "Member 'UCommunicationComponent::TargetToInteract' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, TargetToAct) == 0x000280, "Member 'UCommunicationComponent::TargetToAct' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, NPCSearchDistance) == 0x000288, "Member 'UCommunicationComponent::NPCSearchDistance' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, NPCSearchAngle) == 0x00028C, "Member 'UCommunicationComponent::NPCSearchAngle' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, ListOfObstacleObjectTypesToSearch) == 0x000290, "Member 'UCommunicationComponent::ListOfObstacleObjectTypesToSearch' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mDespoilEffectiveDistance) == 0x0002C0, "Member 'UCommunicationComponent::mDespoilEffectiveDistance' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, SearchParam) == 0x0002C8, "Member 'UCommunicationComponent::SearchParam' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mFoundThousandArtifactPoint) == 0x0002E8, "Member 'UCommunicationComponent::mFoundThousandArtifactPoint' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mMaxDistance) == 0x000384, "Member 'UCommunicationComponent::mMaxDistance' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mMinDistance) == 0x000388, "Member 'UCommunicationComponent::mMinDistance' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mIntervalDistance) == 0x00038C, "Member 'UCommunicationComponent::mIntervalDistance' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mElevationDifference) == 0x000390, "Member 'UCommunicationComponent::mElevationDifference' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mMaxVisionPoint) == 0x000394, "Member 'UCommunicationComponent::mMaxVisionPoint' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mMinVisionPoint) == 0x000398, "Member 'UCommunicationComponent::mMinVisionPoint' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, CaptureCameraClass) == 0x0003A0, "Member 'UCommunicationComponent::CaptureCameraClass' has a wrong offset!");
static_assert(offsetof(UCommunicationComponent, mVisionHeightList) == 0x0003A8, "Member 'UCommunicationComponent::mVisionHeightList' has a wrong offset!");

// Class DarwinGame.CompassAnimInstanceBase
// 0x0010 (0x0280 - 0x0270)
class UCompassAnimInstanceBase : public UDarwinAnimInstanceBase
{
public:
	bool                                          bNoReaction;                                       // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNear;                                             // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26A[0x2];                                      // 0x026A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateAngle;                                       // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0xC];                                      // 0x0274(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompassAnimInstanceBase">();
	}
	static class UCompassAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompassAnimInstanceBase>();
	}
};
static_assert(alignof(UCompassAnimInstanceBase) == 0x000010, "Wrong alignment on UCompassAnimInstanceBase");
static_assert(sizeof(UCompassAnimInstanceBase) == 0x000280, "Wrong size on UCompassAnimInstanceBase");
static_assert(offsetof(UCompassAnimInstanceBase, bNoReaction) == 0x000268, "Member 'UCompassAnimInstanceBase::bNoReaction' has a wrong offset!");
static_assert(offsetof(UCompassAnimInstanceBase, bNear) == 0x000269, "Member 'UCompassAnimInstanceBase::bNear' has a wrong offset!");
static_assert(offsetof(UCompassAnimInstanceBase, PlayRate) == 0x00026C, "Member 'UCompassAnimInstanceBase::PlayRate' has a wrong offset!");
static_assert(offsetof(UCompassAnimInstanceBase, RotateAngle) == 0x000270, "Member 'UCompassAnimInstanceBase::RotateAngle' has a wrong offset!");

// Class DarwinGame.CompleteVigilance
// 0x0000 (0x0038 - 0x0038)
class UCompleteVigilance final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompleteVigilance">();
	}
	static class UCompleteVigilance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompleteVigilance>();
	}
};
static_assert(alignof(UCompleteVigilance) == 0x000008, "Wrong alignment on UCompleteVigilance");
static_assert(sizeof(UCompleteVigilance) == 0x000038, "Wrong size on UCompleteVigilance");

// Class DarwinGame.ConstantHealGameplayEffect
// 0x0018 (0x07D8 - 0x07C0)
class UConstantHealGameplayEffect : public UGameplayEffect
{
public:
	struct FST_HealRequest                        HealParam;                                         // 0x07C0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstantHealGameplayEffect">();
	}
	static class UConstantHealGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstantHealGameplayEffect>();
	}
};
static_assert(alignof(UConstantHealGameplayEffect) == 0x000008, "Wrong alignment on UConstantHealGameplayEffect");
static_assert(sizeof(UConstantHealGameplayEffect) == 0x0007D8, "Wrong size on UConstantHealGameplayEffect");
static_assert(offsetof(UConstantHealGameplayEffect, HealParam) == 0x0007C0, "Member 'UConstantHealGameplayEffect::HealParam' has a wrong offset!");

// Class DarwinGame.ControllerInputInterface
// 0x0000 (0x0030 - 0x0030)
class IControllerInputInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerInputInterface">();
	}
	static class IControllerInputInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IControllerInputInterface>();
	}
};
static_assert(alignof(IControllerInputInterface) == 0x000008, "Wrong alignment on IControllerInputInterface");
static_assert(sizeof(IControllerInputInterface) == 0x000030, "Wrong size on IControllerInputInterface");

// Class DarwinGame.CureEffectCue
// 0x0000 (0x0298 - 0x0298)
class ACureEffectCue : public AGameplayCueNotify_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CureEffectCue">();
	}
	static class ACureEffectCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACureEffectCue>();
	}
};
static_assert(alignof(ACureEffectCue) == 0x000008, "Wrong alignment on ACureEffectCue");
static_assert(sizeof(ACureEffectCue) == 0x000298, "Wrong size on ACureEffectCue");

// Class DarwinGame.UIEstimate_Menu_00
// 0x0120 (0x05B0 - 0x0490)
class alignas(0x10) UUIEstimate_Menu_00 final : public UDarwinUserWidget
{
public:
	TArray<class UUIEstimate_ItemPanel_00*>       ItemPanels;                                        // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_ValuePanel_00*              AmountPanel;                                       // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWhiteFade*                           WhiteFadePanel;                                    // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ProfitInAnim;                                      // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ProfitOutAnim;                                     // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ButtonOutAnim;                                     // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_BonusDialog*                BonusDialog;                                       // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x60];                                     // 0x04D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         INTERVAL_VALUE;                                    // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BONUS_COUNT_UP_TIME;                               // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_53C[0x2C];                                     // 0x053C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         LoopSe;                                            // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0x40];                                     // 0x0570(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void End();
	void OpenBonusDialog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_Menu_00">();
	}
	static class UUIEstimate_Menu_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_Menu_00>();
	}
};
static_assert(alignof(UUIEstimate_Menu_00) == 0x000010, "Wrong alignment on UUIEstimate_Menu_00");
static_assert(sizeof(UUIEstimate_Menu_00) == 0x0005B0, "Wrong size on UUIEstimate_Menu_00");
static_assert(offsetof(UUIEstimate_Menu_00, ItemPanels) == 0x000490, "Member 'UUIEstimate_Menu_00::ItemPanels' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, AmountPanel) == 0x0004A0, "Member 'UUIEstimate_Menu_00::AmountPanel' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, WhiteFadePanel) == 0x0004A8, "Member 'UUIEstimate_Menu_00::WhiteFadePanel' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, ProfitInAnim) == 0x0004B0, "Member 'UUIEstimate_Menu_00::ProfitInAnim' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, ProfitOutAnim) == 0x0004B8, "Member 'UUIEstimate_Menu_00::ProfitOutAnim' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, ButtonOutAnim) == 0x0004C0, "Member 'UUIEstimate_Menu_00::ButtonOutAnim' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, BonusDialog) == 0x0004C8, "Member 'UUIEstimate_Menu_00::BonusDialog' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, INTERVAL_VALUE) == 0x000530, "Member 'UUIEstimate_Menu_00::INTERVAL_VALUE' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, BONUS_COUNT_UP_TIME) == 0x000538, "Member 'UUIEstimate_Menu_00::BONUS_COUNT_UP_TIME' has a wrong offset!");
static_assert(offsetof(UUIEstimate_Menu_00, LoopSe) == 0x000568, "Member 'UUIEstimate_Menu_00::LoopSe' has a wrong offset!");

// Class DarwinGame.CustomEquipmentFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UCustomEquipmentFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddRivalTeamEquipment(class AGPACharacter* Target, ERivalTeamForce Force, bool bIsLeader);
	static void ChangeCustomEquipment(class AGPACharacter* Target, const struct FCustomEquipmentInfomation& Info);
	static void ChangeCustomMaterial(class AGPACharacter* Target, class FName KindId);
	static void GenerateCustomEquipment(class AGPACharacter* Target, const struct FST_MonsterCustomEquipmentData& Equipment);
	static void LotteryRivalTeamEquipment(class AMonster* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomEquipmentFunctionLibrary">();
	}
	static class UCustomEquipmentFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomEquipmentFunctionLibrary>();
	}
};
static_assert(alignof(UCustomEquipmentFunctionLibrary) == 0x000008, "Wrong alignment on UCustomEquipmentFunctionLibrary");
static_assert(sizeof(UCustomEquipmentFunctionLibrary) == 0x000030, "Wrong size on UCustomEquipmentFunctionLibrary");

// Class DarwinGame.CylinderForcedBattleArea
// 0x0018 (0x0330 - 0x0318)
class ACylinderForcedBattleArea : public AForcedBattleAreaBase
{
public:
	int32                                         VertexNum;                                         // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoxWidth;                                          // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TopBoxHeight;                                      // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseRadius;                                        // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PN_ThicknessScale;                                 // 0x0328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CylinderForcedBattleArea">();
	}
	static class ACylinderForcedBattleArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACylinderForcedBattleArea>();
	}
};
static_assert(alignof(ACylinderForcedBattleArea) == 0x000008, "Wrong alignment on ACylinderForcedBattleArea");
static_assert(sizeof(ACylinderForcedBattleArea) == 0x000330, "Wrong size on ACylinderForcedBattleArea");
static_assert(offsetof(ACylinderForcedBattleArea, VertexNum) == 0x000318, "Member 'ACylinderForcedBattleArea::VertexNum' has a wrong offset!");
static_assert(offsetof(ACylinderForcedBattleArea, BoxWidth) == 0x00031C, "Member 'ACylinderForcedBattleArea::BoxWidth' has a wrong offset!");
static_assert(offsetof(ACylinderForcedBattleArea, TopBoxHeight) == 0x000320, "Member 'ACylinderForcedBattleArea::TopBoxHeight' has a wrong offset!");
static_assert(offsetof(ACylinderForcedBattleArea, BaseRadius) == 0x000324, "Member 'ACylinderForcedBattleArea::BaseRadius' has a wrong offset!");
static_assert(offsetof(ACylinderForcedBattleArea, PN_ThicknessScale) == 0x000328, "Member 'ACylinderForcedBattleArea::PN_ThicknessScale' has a wrong offset!");

// Class DarwinGame.DamageCollisionComponent
// 0x0070 (0x0270 - 0x0200)
class UDamageCollisionComponent final : public USceneComponent
{
public:
	TMap<int32, class UDamageCollisionTask*>      taskList;                                          // 0x0200(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x20];                                     // 0x0250(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTask(int32 Key, class UDamageCollisionTask* Task);
	void RemoveTask(int32 Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCollisionComponent">();
	}
	static class UDamageCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageCollisionComponent>();
	}
};
static_assert(alignof(UDamageCollisionComponent) == 0x000010, "Wrong alignment on UDamageCollisionComponent");
static_assert(sizeof(UDamageCollisionComponent) == 0x000270, "Wrong size on UDamageCollisionComponent");
static_assert(offsetof(UDamageCollisionComponent, taskList) == 0x000200, "Member 'UDamageCollisionComponent::taskList' has a wrong offset!");

// Class DarwinGame.UIWinBrightness
// 0x0078 (0x0648 - 0x05D0)
class UUIWinBrightness : public UUIScrollMenuBase
{
public:
	class UUIVolume_01*                           BrightnessVolume;                                  // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x70];                                     // 0x05D8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinBrightness">();
	}
	static class UUIWinBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinBrightness>();
	}
};
static_assert(alignof(UUIWinBrightness) == 0x000008, "Wrong alignment on UUIWinBrightness");
static_assert(sizeof(UUIWinBrightness) == 0x000648, "Wrong size on UUIWinBrightness");
static_assert(offsetof(UUIWinBrightness, BrightnessVolume) == 0x0005D0, "Member 'UUIWinBrightness::BrightnessVolume' has a wrong offset!");

// Class DarwinGame.DamageCollisionTask
// 0x0040 (0x0070 - 0x0030)
class UDamageCollisionTask final : public UObject
{
public:
	class AActor*                                 Target;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHitEventData*>                  eventList;                                         // 0x0050(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCollisionTask">();
	}
	static class UDamageCollisionTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageCollisionTask>();
	}
};
static_assert(alignof(UDamageCollisionTask) == 0x000008, "Wrong alignment on UDamageCollisionTask");
static_assert(sizeof(UDamageCollisionTask) == 0x000070, "Wrong size on UDamageCollisionTask");
static_assert(offsetof(UDamageCollisionTask, Target) == 0x000030, "Member 'UDamageCollisionTask::Target' has a wrong offset!");
static_assert(offsetof(UDamageCollisionTask, eventList) == 0x000050, "Member 'UDamageCollisionTask::eventList' has a wrong offset!");

// Class DarwinGame.DamageElementInterface
// 0x0000 (0x0030 - 0x0030)
class IDamageElementInterface final : public IInterface
{
public:
	bool IsTypeHide(ECollisionHiddenType Type);
	void SetEnableWeakPoint(bool enable);
	void SetHide(ECollisionHiddenType Type, bool hide);

	float GetAimWeight() const;
	float GetDamageRate() const;
	bool IsCenterPoint() const;
	bool IsEnableWeakPoint() const;
	bool IsIgnoreAimSelectableList() const;
	bool IsMustAimed() const;
	bool IsNeverTargeted() const;
	bool IsNotAbleToPenetrate() const;
	bool IsWeakPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageElementInterface">();
	}
	static class IDamageElementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageElementInterface>();
	}
};
static_assert(alignof(IDamageElementInterface) == 0x000008, "Wrong alignment on IDamageElementInterface");
static_assert(sizeof(IDamageElementInterface) == 0x000030, "Wrong size on IDamageElementInterface");

// Class DarwinGame.AttributeDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UAttributeDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeDamageExecution">();
	}
	static class UAttributeDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeDamageExecution>();
	}
};
static_assert(alignof(UAttributeDamageExecution) == 0x000008, "Wrong alignment on UAttributeDamageExecution");
static_assert(sizeof(UAttributeDamageExecution) == 0x000048, "Wrong size on UAttributeDamageExecution");

// Class DarwinGame.DeathDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UDeathDamageExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathDamageExecution">();
	}
	static class UDeathDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathDamageExecution>();
	}
};
static_assert(alignof(UDeathDamageExecution) == 0x000008, "Wrong alignment on UDeathDamageExecution");
static_assert(sizeof(UDeathDamageExecution) == 0x000048, "Wrong size on UDeathDamageExecution");

// Class DarwinGame.StunExecution
// 0x0000 (0x0048 - 0x0048)
class UStunExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunExecution">();
	}
	static class UStunExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStunExecution>();
	}
};
static_assert(alignof(UStunExecution) == 0x000008, "Wrong alignment on UStunExecution");
static_assert(sizeof(UStunExecution) == 0x000048, "Wrong size on UStunExecution");

// Class DarwinGame.UIMonsterDict_ContentBase
// 0x0010 (0x04A0 - 0x0490)
class UUIMonsterDict_ContentBase : public UDarwinUserWidget
{
public:
	class UTexture2D*                             TitleIconTexture;                                  // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TitleIconWidget;                                   // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_ContentBase">();
	}
	static class UUIMonsterDict_ContentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_ContentBase>();
	}
};
static_assert(alignof(UUIMonsterDict_ContentBase) == 0x000008, "Wrong alignment on UUIMonsterDict_ContentBase");
static_assert(sizeof(UUIMonsterDict_ContentBase) == 0x0004A0, "Wrong size on UUIMonsterDict_ContentBase");
static_assert(offsetof(UUIMonsterDict_ContentBase, TitleIconTexture) == 0x000490, "Member 'UUIMonsterDict_ContentBase::TitleIconTexture' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_ContentBase, TitleIconWidget) == 0x000498, "Member 'UUIMonsterDict_ContentBase::TitleIconWidget' has a wrong offset!");

// Class DarwinGame.UITreasureDetails_Content01
// 0x0000 (0x04A0 - 0x04A0)
class UUITreasureDetails_Content01 : public UUIMonsterDict_ContentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureDetails_Content01">();
	}
	static class UUITreasureDetails_Content01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureDetails_Content01>();
	}
};
static_assert(alignof(UUITreasureDetails_Content01) == 0x000008, "Wrong alignment on UUITreasureDetails_Content01");
static_assert(sizeof(UUITreasureDetails_Content01) == 0x0004A0, "Wrong size on UUITreasureDetails_Content01");

// Class DarwinGame.PassedFoodExecution
// 0x0000 (0x0048 - 0x0048)
class UPassedFoodExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassedFoodExecution">();
	}
	static class UPassedFoodExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassedFoodExecution>();
	}
};
static_assert(alignof(UPassedFoodExecution) == 0x000008, "Wrong alignment on UPassedFoodExecution");
static_assert(sizeof(UPassedFoodExecution) == 0x000048, "Wrong size on UPassedFoodExecution");

// Class DarwinGame.UITopbar_Base
// 0x0038 (0x04F8 - 0x04C0)
class UUITopbar_Base : public UUITabLRBase
{
public:
	TArray<class FText>                           TabNameArray;                                      // 0x04C0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             OldText;                                           // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             NextText;                                          // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITopbar_Base">();
	}
	static class UUITopbar_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITopbar_Base>();
	}
};
static_assert(alignof(UUITopbar_Base) == 0x000008, "Wrong alignment on UUITopbar_Base");
static_assert(sizeof(UUITopbar_Base) == 0x0004F8, "Wrong size on UUITopbar_Base");
static_assert(offsetof(UUITopbar_Base, TabNameArray) == 0x0004C0, "Member 'UUITopbar_Base::TabNameArray' has a wrong offset!");
static_assert(offsetof(UUITopbar_Base, OldText) == 0x0004E0, "Member 'UUITopbar_Base::OldText' has a wrong offset!");
static_assert(offsetof(UUITopbar_Base, NextText) == 0x0004E8, "Member 'UUITopbar_Base::NextText' has a wrong offset!");

// Class DarwinGame.UITopbar_01
// 0x0000 (0x04F8 - 0x04F8)
class UUITopbar_01 : public UUITopbar_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITopbar_01">();
	}
	static class UUITopbar_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITopbar_01>();
	}
};
static_assert(alignof(UUITopbar_01) == 0x000008, "Wrong alignment on UUITopbar_01");
static_assert(sizeof(UUITopbar_01) == 0x0004F8, "Wrong size on UUITopbar_01");

// Class DarwinGame.DarwinEventFlagDefinition
// 0x0000 (0x0030 - 0x0030)
class UDarwinEventFlagDefinition final : public UObject
{
public:
	static bool IsDebugEventEnableFlag();
	static void SetDebugEventEnableFlag(bool flg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinEventFlagDefinition">();
	}
	static class UDarwinEventFlagDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinEventFlagDefinition>();
	}
};
static_assert(alignof(UDarwinEventFlagDefinition) == 0x000008, "Wrong alignment on UDarwinEventFlagDefinition");
static_assert(sizeof(UDarwinEventFlagDefinition) == 0x000030, "Wrong size on UDarwinEventFlagDefinition");

// Class DarwinGame.DarwinLevelSequenceDirector
// 0x0090 (0x00C8 - 0x0038)
class UDarwinLevelSequenceDirector : public ULevelSequenceDirector
{
public:
	TArray<class UDarwinUserWidget*>              OpenUI;                                            // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 KamyuTag;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MayaTag;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsAutoCreateTextID;                                // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoCreateTextIDNum;                               // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AutoCreateTextIDBase;                              // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEmoteVocalizeOverwriteOption*          EmoteVocalizeOverwriteOption;                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEmoteBlinkOverwriteOption*             EmoteBlinkOverwriteOption;                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGameCharacter*                         SyncDrawTextVocalizeCharacter;                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICharAdd_Base*                        NpcNickNameWidget;                                 // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGameCharacter*>                 LookAtTargets;                                     // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentPictureID;                                  // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEvent_FullScreenImageBase*           FullScreenImageWidget;                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SkipUIDisplayTimer;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetCharacterCustomEquip(class AGPACharacter* GPACharacter, const class FName KindId, const ECustomEquipmentKind CustomKind, const bool AdditionalEquipment, const bool AdditionalMaterial, const ERivalTeamForce RivalTeamForce, const bool IsLeader);

	void AddLookAtTarget(class AGameCharacter* Character);
	void ChangeFacial(class AGameCharacter* Character, EEmoteType Type);
	bool CheckAndOpenTips(const class FName ItemId);
	bool CheckBonFireIsActive(const class FName ItemId);
	void ClearNpcNickName();
	void CloseAllMovie();
	void CloseAllOpenUI();
	void CloseBoardMenuMessageWindow();
	void CloseMovie();
	void CloseNetworkReturnMessageWindow();
	void CloseSubTitleLogo();
	void CloseWaitUI();
	struct FDrawTextInfo CreateTextID();
	void DarwinResetBindings(class ALevelSequenceActor* LevelSequenceActor);
	void DisplayMovie(class FName movieName, bool IsLoop);
	void DisplayNpcNickName(const class FName NpcID, bool IsAnotherLayout);
	void DisplayPicture(const class FName PictureID, bool IsOverMovieUI);
	void FadeInMovie(float second);
	void FadeOutMovie(float second);
	void FinishLookAtAllTrackCharacters();
	void HideCharactersForPlayer(class ALevelSequenceActor* rootActor);
	void HideDefaultRebindCharacters(class ALevelSequenceActor* rootActor, const TMap<class FString, struct FST_SequencerRebindOrder>& rebindOders);
	void InitLookAtTargets();
	bool IsFindBindingTag(class ALevelSequenceActor* rootActor, const class FString& CheckTag);
	bool IsOpenWaitUI();
	void JumpToMarkedFrame(const class FString& InLabel);
	void OpenArtifactRepository();
	void OpenArtifactTomasonUI();
	void OpenBoardMenuMessageWindow();
	void OpenLithographyUI(const class FName MessageID);
	void OpenNetworkReturnMessageWindow();
	void OpenPressAnyButton();
	void OpenQuestRewardWindow(const class FName QuestID);
	void OpenSubTitleLogo();
	void OpenTitleLogo();
	void OpenTreasureAppraise();
	void PauseCharacters(float blendFrame);
	void PlayBlink(class AGameCharacter* Character, EEmoteBlinkType Type, float BlendTime);
	void PlayEmoteBody(class AGameCharacter* Character, EEmoteType Type);
	bool PlayUIOneShot(class FName EventID, class FName UIName, float FadeTime);
	void PlayVocalize(class AGameCharacter* Character, EEmoteVocalizeType Type, float BlendTime);
	void PlayVocalizeSyncDrawText();
	void PrepareMovie(class FName movieName, bool IsLoop);
	void RebindCharacters(class ALevelSequenceActor* rootActor, const TMap<class FString, struct FST_SequencerRebindOrder>& rebindOders);
	void ReleaseLookAtTargets();
	void RemovePicture();
	void RemoveSkipUI();
	void ResumeCharacters(float blendFrame);
	void SetEnableFootIK(class AGameCharacter* TargetCharacter, bool bSetFlag);
	void SetEnableFootIKAll(bool bSetFlag);
	void SetLastBattleSevenStoneVisiblity();
	void SetRendringMode(bool Flag);
	void SetVocalizeSyncDrawText(class AGameCharacter* Character);
	void StopBlink(class AGameCharacter* Character);
	void StopEmoteBody(class AGameCharacter* Character);
	void StopEmoteBodyOfAllFriend();
	void StopVocalize(class AGameCharacter* Character);
	void StopVocalizeSyncDrawText();
	void UpdateAnimTrack(const class AGameCharacter* Character, const class FName ActorName);
	void UpdateAnimTrackFromMesh(const class USkeletalMeshComponent* Mesh, const class FName ActorName);

	int32 FrameRate() const;
	bool IsOpenBoardMenuMessageWindow() const;
	bool IsOpenNetworkReturnMessageWindow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinLevelSequenceDirector">();
	}
	static class UDarwinLevelSequenceDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinLevelSequenceDirector>();
	}
};
static_assert(alignof(UDarwinLevelSequenceDirector) == 0x000008, "Wrong alignment on UDarwinLevelSequenceDirector");
static_assert(sizeof(UDarwinLevelSequenceDirector) == 0x0000C8, "Wrong size on UDarwinLevelSequenceDirector");
static_assert(offsetof(UDarwinLevelSequenceDirector, OpenUI) == 0x000038, "Member 'UDarwinLevelSequenceDirector::OpenUI' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, KamyuTag) == 0x000048, "Member 'UDarwinLevelSequenceDirector::KamyuTag' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, MayaTag) == 0x000058, "Member 'UDarwinLevelSequenceDirector::MayaTag' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, IsAutoCreateTextID) == 0x000068, "Member 'UDarwinLevelSequenceDirector::IsAutoCreateTextID' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, AutoCreateTextIDNum) == 0x00006C, "Member 'UDarwinLevelSequenceDirector::AutoCreateTextIDNum' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, AutoCreateTextIDBase) == 0x000070, "Member 'UDarwinLevelSequenceDirector::AutoCreateTextIDBase' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, EmoteVocalizeOverwriteOption) == 0x000080, "Member 'UDarwinLevelSequenceDirector::EmoteVocalizeOverwriteOption' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, EmoteBlinkOverwriteOption) == 0x000088, "Member 'UDarwinLevelSequenceDirector::EmoteBlinkOverwriteOption' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, SyncDrawTextVocalizeCharacter) == 0x000090, "Member 'UDarwinLevelSequenceDirector::SyncDrawTextVocalizeCharacter' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, NpcNickNameWidget) == 0x000098, "Member 'UDarwinLevelSequenceDirector::NpcNickNameWidget' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, LookAtTargets) == 0x0000A0, "Member 'UDarwinLevelSequenceDirector::LookAtTargets' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, CurrentPictureID) == 0x0000B0, "Member 'UDarwinLevelSequenceDirector::CurrentPictureID' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, FullScreenImageWidget) == 0x0000B8, "Member 'UDarwinLevelSequenceDirector::FullScreenImageWidget' has a wrong offset!");
static_assert(offsetof(UDarwinLevelSequenceDirector, SkipUIDisplayTimer) == 0x0000C0, "Member 'UDarwinLevelSequenceDirector::SkipUIDisplayTimer' has a wrong offset!");

// Class DarwinGame.DarwinPhysicalMaterial
// 0x0008 (0x0090 - 0x0088)
class UDarwinPhysicalMaterial final : public UPhysicalMaterial
{
public:
	float                                         SampleParam;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinPhysicalMaterial">();
	}
	static class UDarwinPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinPhysicalMaterial>();
	}
};
static_assert(alignof(UDarwinPhysicalMaterial) == 0x000008, "Wrong alignment on UDarwinPhysicalMaterial");
static_assert(sizeof(UDarwinPhysicalMaterial) == 0x000090, "Wrong size on UDarwinPhysicalMaterial");
static_assert(offsetof(UDarwinPhysicalMaterial, SampleParam) == 0x000088, "Member 'UDarwinPhysicalMaterial::SampleParam' has a wrong offset!");

// Class DarwinGame.DarwinTwoSceneCaptureImage
// 0x0010 (0x0298 - 0x0288)
class UDarwinTwoSceneCaptureImage final : public UDarwinSceneCaptureImage
{
public:
	class UTextureRenderTarget2D*                 FinalColorRenderTarget;                            // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 FinalColorRenderTarget_High;                       // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinTwoSceneCaptureImage">();
	}
	static class UDarwinTwoSceneCaptureImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinTwoSceneCaptureImage>();
	}
};
static_assert(alignof(UDarwinTwoSceneCaptureImage) == 0x000008, "Wrong alignment on UDarwinTwoSceneCaptureImage");
static_assert(sizeof(UDarwinTwoSceneCaptureImage) == 0x000298, "Wrong size on UDarwinTwoSceneCaptureImage");
static_assert(offsetof(UDarwinTwoSceneCaptureImage, FinalColorRenderTarget) == 0x000288, "Member 'UDarwinTwoSceneCaptureImage::FinalColorRenderTarget' has a wrong offset!");
static_assert(offsetof(UDarwinTwoSceneCaptureImage, FinalColorRenderTarget_High) == 0x000290, "Member 'UDarwinTwoSceneCaptureImage::FinalColorRenderTarget_High' has a wrong offset!");

// Class DarwinGame.DarwinWidgetComponent
// 0x0010 (0x0570 - 0x0560)
class UDarwinWidgetComponent final : public UWidgetComponent
{
public:
	class UDarwinUserWidget*                      DarwinWidget;                                      // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void open();
	void Remove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarwinWidgetComponent">();
	}
	static class UDarwinWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarwinWidgetComponent>();
	}
};
static_assert(alignof(UDarwinWidgetComponent) == 0x000010, "Wrong alignment on UDarwinWidgetComponent");
static_assert(sizeof(UDarwinWidgetComponent) == 0x000570, "Wrong size on UDarwinWidgetComponent");
static_assert(offsetof(UDarwinWidgetComponent, DarwinWidget) == 0x000560, "Member 'UDarwinWidgetComponent::DarwinWidget' has a wrong offset!");

// Class DarwinGame.DayNightOnOffSwitchComponentBase
// 0x0050 (0x0108 - 0x00B8)
class UDayNightOnOffSwitchComponentBase final : public UFieldObjectComponentBase
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DayNightOnOffSwitchComponentBase">();
	}
	static class UDayNightOnOffSwitchComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDayNightOnOffSwitchComponentBase>();
	}
};
static_assert(alignof(UDayNightOnOffSwitchComponentBase) == 0x000008, "Wrong alignment on UDayNightOnOffSwitchComponentBase");
static_assert(sizeof(UDayNightOnOffSwitchComponentBase) == 0x000108, "Wrong size on UDayNightOnOffSwitchComponentBase");

// Class DarwinGame.DebugEventRectActor
// 0x0008 (0x0230 - 0x0228)
class ADebugEventRectActor final : public AActor
{
public:
	class UStaticMeshComponent*                   mBoxMesh;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetMaterialColorToEventType(const bool IsActive, const bool IsMoveForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugEventRectActor">();
	}
	static class ADebugEventRectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugEventRectActor>();
	}
};
static_assert(alignof(ADebugEventRectActor) == 0x000008, "Wrong alignment on ADebugEventRectActor");
static_assert(sizeof(ADebugEventRectActor) == 0x000230, "Wrong size on ADebugEventRectActor");
static_assert(offsetof(ADebugEventRectActor, mBoxMesh) == 0x000228, "Member 'ADebugEventRectActor::mBoxMesh' has a wrong offset!");

// Class DarwinGame.DebugLauncherGameMode
// 0x0000 (0x02C8 - 0x02C8)
class ADebugLauncherGameMode final : public AAppGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugLauncherGameMode">();
	}
	static class ADebugLauncherGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugLauncherGameMode>();
	}
};
static_assert(alignof(ADebugLauncherGameMode) == 0x000008, "Wrong alignment on ADebugLauncherGameMode");
static_assert(sizeof(ADebugLauncherGameMode) == 0x0002C8, "Wrong size on ADebugLauncherGameMode");

// Class DarwinGame.ParamDataAsset
// 0x0050 (0x0088 - 0x0038)
class UParamDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FDebugParamList>     Lists;                                             // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	float AddParamValue(class FName ListName, class FName IndexName, class FName ParamName, float AddValue);
	float GetParamValue(class FName ListName, class FName IndexName, class FName ParamName);
	void Import();
	void ResetList();
	float ResetValue(class FName ListName, class FName IndexName, class FName ParamName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParamDataAsset">();
	}
	static class UParamDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParamDataAsset>();
	}
};
static_assert(alignof(UParamDataAsset) == 0x000008, "Wrong alignment on UParamDataAsset");
static_assert(sizeof(UParamDataAsset) == 0x000088, "Wrong size on UParamDataAsset");
static_assert(offsetof(UParamDataAsset, Lists) == 0x000038, "Member 'UParamDataAsset::Lists' has a wrong offset!");

// Class DarwinGame.DebugWarpListData
// 0x0050 (0x0080 - 0x0030)
class UDebugWarpListData final : public UObject
{
public:
	TMap<class FString, class UObject*>           mWarpMap;                                          // 0x0030(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void SortList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugWarpListData">();
	}
	static class UDebugWarpListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugWarpListData>();
	}
};
static_assert(alignof(UDebugWarpListData) == 0x000008, "Wrong alignment on UDebugWarpListData");
static_assert(sizeof(UDebugWarpListData) == 0x000080, "Wrong size on UDebugWarpListData");
static_assert(offsetof(UDebugWarpListData, mWarpMap) == 0x000030, "Member 'UDebugWarpListData::mWarpMap' has a wrong offset!");

// Class DarwinGame.UICoinMenu_Top
// 0x0018 (0x0520 - 0x0508)
class UUICoinMenu_Top : public UUIStatusBase
{
public:
	class UUIPartyMenu_BG*                        BackImage;                                         // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_06_Set*           CoinInfomation;                                    // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Refresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_Top">();
	}
	static class UUICoinMenu_Top* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_Top>();
	}
};
static_assert(alignof(UUICoinMenu_Top) == 0x000008, "Wrong alignment on UUICoinMenu_Top");
static_assert(sizeof(UUICoinMenu_Top) == 0x000520, "Wrong size on UUICoinMenu_Top");
static_assert(offsetof(UUICoinMenu_Top, BackImage) == 0x000508, "Member 'UUICoinMenu_Top::BackImage' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_Top, CoinInfomation) == 0x000510, "Member 'UUICoinMenu_Top::CoinInfomation' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_Top, UIUnderButton) == 0x000518, "Member 'UUICoinMenu_Top::UIUnderButton' has a wrong offset!");

// Class DarwinGame.DefaultArtifactCapture
// 0x0000 (0x0370 - 0x0370)
class ADefaultArtifactCapture final : public ASceneCaptureBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultArtifactCapture">();
	}
	static class ADefaultArtifactCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADefaultArtifactCapture>();
	}
};
static_assert(alignof(ADefaultArtifactCapture) == 0x000010, "Wrong alignment on ADefaultArtifactCapture");
static_assert(sizeof(ADefaultArtifactCapture) == 0x000370, "Wrong size on ADefaultArtifactCapture");

// Class DarwinGame.DefenceBattleIdDataTable
// 0x0000 (0x0030 - 0x0030)
class UDefenceBattleIdDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefenceBattleIdDataTable">();
	}
	static class UDefenceBattleIdDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefenceBattleIdDataTable>();
	}
};
static_assert(alignof(UDefenceBattleIdDataTable) == 0x000008, "Wrong alignment on UDefenceBattleIdDataTable");
static_assert(sizeof(UDefenceBattleIdDataTable) == 0x000030, "Wrong size on UDefenceBattleIdDataTable");

// Class DarwinGame.DesertGimmick
// 0x0098 (0x0358 - 0x02C0)
class ADesertGimmick : public ABreakObjectBase
{
public:
	bool                                          mNohit;                                            // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x97];                                     // 0x02C1(0x0097)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BossHit(class AMonsterBoss* Boss, const struct FHitResult& Result);
	struct FHitResult GetBossHitResult();
	class AMonsterBoss* GetHitBoss();
	void GimmickBreakEffect(bool destroy);
	void GimmickRevive();
	bool HitCheckCylindrical(const struct FVector& attacklocation, float attackradius, float attackhalfheight, const struct FVector& TargetLocation, float targetradius, float targethalfheight);
	bool HitCheckUnderGround(const struct FVector& attacklocation, float attackradius, const struct FVector& TargetLocation, float targetradius);
	bool IsBossHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DesertGimmick">();
	}
	static class ADesertGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADesertGimmick>();
	}
};
static_assert(alignof(ADesertGimmick) == 0x000008, "Wrong alignment on ADesertGimmick");
static_assert(sizeof(ADesertGimmick) == 0x000358, "Wrong size on ADesertGimmick");
static_assert(offsetof(ADesertGimmick, mNohit) == 0x0002C0, "Member 'ADesertGimmick::mNohit' has a wrong offset!");

// Class DarwinGame.UIFieldActionGauge
// 0x0088 (0x0518 - 0x0490)
class UUIFieldActionGauge : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_ActionGaugeInfo>            ActionGaugeInfo;                                   // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x58];                                     // 0x04B0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         AtomComp;                                          // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       SuccessAnim;                                       // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlaySuccessAnim();
	void SetGuideType(EInputGuideType GuideType);
	void SetPercent(float Percent, bool HasInput);
	void SuccessAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldActionGauge">();
	}
	static class UUIFieldActionGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldActionGauge>();
	}
};
static_assert(alignof(UUIFieldActionGauge) == 0x000008, "Wrong alignment on UUIFieldActionGauge");
static_assert(sizeof(UUIFieldActionGauge) == 0x000518, "Wrong size on UUIFieldActionGauge");
static_assert(offsetof(UUIFieldActionGauge, ActionGaugeInfo) == 0x0004A0, "Member 'UUIFieldActionGauge::ActionGaugeInfo' has a wrong offset!");
static_assert(offsetof(UUIFieldActionGauge, AtomComp) == 0x000508, "Member 'UUIFieldActionGauge::AtomComp' has a wrong offset!");
static_assert(offsetof(UUIFieldActionGauge, SuccessAnim) == 0x000510, "Member 'UUIFieldActionGauge::SuccessAnim' has a wrong offset!");

// Class DarwinGame.DialogDataTable
// 0x0000 (0x0030 - 0x0030)
class UDialogDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogDataTable">();
	}
	static class UDialogDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogDataTable>();
	}
};
static_assert(alignof(UDialogDataTable) == 0x000008, "Wrong alignment on UDialogDataTable");
static_assert(sizeof(UDialogDataTable) == 0x000030, "Wrong size on UDialogDataTable");

// Class DarwinGame.UICommonmenu_04
// 0x00C0 (0x0690 - 0x05D0)
class alignas(0x10) UUICommonmenu_04 : public UUIScrollMenuBase
{
public:
	bool                                          IsEmptyIconVisible;                                // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x37];                                     // 0x05D1(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICommonmenu_Sentence*                 DetailSentence;                                    // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICommonmenu_ItemName*                 DetailItemName;                                    // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICommonmenu_SortIcon*                 SortIcon;                                          // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           PanelSet;                                          // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x68];                                     // 0x0628(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_04">();
	}
	static class UUICommonmenu_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_04>();
	}
};
static_assert(alignof(UUICommonmenu_04) == 0x000010, "Wrong alignment on UUICommonmenu_04");
static_assert(sizeof(UUICommonmenu_04) == 0x000690, "Wrong size on UUICommonmenu_04");
static_assert(offsetof(UUICommonmenu_04, IsEmptyIconVisible) == 0x0005D0, "Member 'UUICommonmenu_04::IsEmptyIconVisible' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_04, DetailSentence) == 0x000608, "Member 'UUICommonmenu_04::DetailSentence' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_04, DetailItemName) == 0x000610, "Member 'UUICommonmenu_04::DetailItemName' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_04, SortIcon) == 0x000618, "Member 'UUICommonmenu_04::SortIcon' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_04, PanelSet) == 0x000620, "Member 'UUICommonmenu_04::PanelSet' has a wrong offset!");

// Class DarwinGame.DispatchDataAsset
// 0x00F0 (0x0128 - 0x0038)
class UDispatchDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_DispatchStationData> list;                                              // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         TreasureMapLottery;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDispatchRarityLotteryData>     RarityLotteryDataList;                             // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDispatchCoinLotteryData               CoinLotteryData;                                   // 0x00A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDispatchMaterialLotteryData           MaterialLotteryData;                               // 0x00AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDispatchTimeData                      TimeData;                                          // 0x00B4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDispatchLotteryData                   LotteryData;                                       // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPrivate)
	struct FDispatchDirectingData                 DirectingData;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DispatchDataAsset">();
	}
	static class UDispatchDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDispatchDataAsset>();
	}
};
static_assert(alignof(UDispatchDataAsset) == 0x000008, "Wrong alignment on UDispatchDataAsset");
static_assert(sizeof(UDispatchDataAsset) == 0x000128, "Wrong size on UDispatchDataAsset");
static_assert(offsetof(UDispatchDataAsset, list) == 0x000038, "Member 'UDispatchDataAsset::list' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, TreasureMapLottery) == 0x000088, "Member 'UDispatchDataAsset::TreasureMapLottery' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, RarityLotteryDataList) == 0x000090, "Member 'UDispatchDataAsset::RarityLotteryDataList' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, CoinLotteryData) == 0x0000A0, "Member 'UDispatchDataAsset::CoinLotteryData' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, MaterialLotteryData) == 0x0000AC, "Member 'UDispatchDataAsset::MaterialLotteryData' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, TimeData) == 0x0000B4, "Member 'UDispatchDataAsset::TimeData' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, LotteryData) == 0x0000C0, "Member 'UDispatchDataAsset::LotteryData' has a wrong offset!");
static_assert(offsetof(UDispatchDataAsset, DirectingData) == 0x000120, "Member 'UDispatchDataAsset::DirectingData' has a wrong offset!");

// Class DarwinGame.DispatchFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UDispatchFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DispatchFunctionLibrary">();
	}
	static class UDispatchFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDispatchFunctionLibrary>();
	}
};
static_assert(alignof(UDispatchFunctionLibrary) == 0x000008, "Wrong alignment on UDispatchFunctionLibrary");
static_assert(sizeof(UDispatchFunctionLibrary) == 0x000030, "Wrong size on UDispatchFunctionLibrary");

// Class DarwinGame.DispatchSceneCapture
// 0x0010 (0x0380 - 0x0370)
class ADispatchSceneCapture final : public ASceneCaptureBase
{
public:
	TArray<class FName>                           TagNames;                                          // 0x0370(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EndSequencer();
	void StartSequencer();
	void UpdateTagNames();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DispatchSceneCapture">();
	}
	static class ADispatchSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADispatchSceneCapture>();
	}
};
static_assert(alignof(ADispatchSceneCapture) == 0x000010, "Wrong alignment on ADispatchSceneCapture");
static_assert(sizeof(ADispatchSceneCapture) == 0x000380, "Wrong size on ADispatchSceneCapture");
static_assert(offsetof(ADispatchSceneCapture, TagNames) == 0x000370, "Member 'ADispatchSceneCapture::TagNames' has a wrong offset!");

// Class DarwinGame.DitherInfoManager
// 0x0038 (0x0068 - 0x0030)
class UDitherInfoManager final : public UObject
{
public:
	TArray<class UCameraDitheringComponent*>      DitherCompList;                                    // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCameraDitheringComponent*>      EndingDitherCompList;                              // 0x0040(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0058(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitherInfoManager">();
	}
	static class UDitherInfoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitherInfoManager>();
	}
};
static_assert(alignof(UDitherInfoManager) == 0x000008, "Wrong alignment on UDitherInfoManager");
static_assert(sizeof(UDitherInfoManager) == 0x000068, "Wrong size on UDitherInfoManager");
static_assert(offsetof(UDitherInfoManager, DitherCompList) == 0x000030, "Member 'UDitherInfoManager::DitherCompList' has a wrong offset!");
static_assert(offsetof(UDitherInfoManager, EndingDitherCompList) == 0x000040, "Member 'UDitherInfoManager::EndingDitherCompList' has a wrong offset!");
static_assert(offsetof(UDitherInfoManager, ObjectTypes) == 0x000058, "Member 'UDitherInfoManager::ObjectTypes' has a wrong offset!");

// Class DarwinGame.UIWinMenuTwoChoices
// 0x0040 (0x0610 - 0x05D0)
class UUIWinMenuTwoChoices : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextDescription;                                   // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIIconChoice*                          ButtonTwo[0x2];                                    // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x18];                                     // 0x05F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenuTwoChoices">();
	}
	static class UUIWinMenuTwoChoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenuTwoChoices>();
	}
};
static_assert(alignof(UUIWinMenuTwoChoices) == 0x000008, "Wrong alignment on UUIWinMenuTwoChoices");
static_assert(sizeof(UUIWinMenuTwoChoices) == 0x000610, "Wrong size on UUIWinMenuTwoChoices");
static_assert(offsetof(UUIWinMenuTwoChoices, TextDescription) == 0x0005E0, "Member 'UUIWinMenuTwoChoices::TextDescription' has a wrong offset!");
static_assert(offsetof(UUIWinMenuTwoChoices, ButtonTwo) == 0x0005E8, "Member 'UUIWinMenuTwoChoices::ButtonTwo' has a wrong offset!");

// Class DarwinGame.UIWinMenuSimple
// 0x0010 (0x0620 - 0x0610)
class UUIWinMenuSimple : public UUIWinMenuTwoChoices
{
public:
	class UUIIconChoice*                          ButtonOne;                                         // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenuSimple">();
	}
	static class UUIWinMenuSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenuSimple>();
	}
};
static_assert(alignof(UUIWinMenuSimple) == 0x000008, "Wrong alignment on UUIWinMenuSimple");
static_assert(sizeof(UUIWinMenuSimple) == 0x000620, "Wrong size on UUIWinMenuSimple");
static_assert(offsetof(UUIWinMenuSimple, ButtonOne) == 0x000610, "Member 'UUIWinMenuSimple::ButtonOne' has a wrong offset!");

// Class DarwinGame.UIWinMenu_S_07
// 0x0000 (0x0620 - 0x0620)
class UUIWinMenu_S_07 final : public UUIWinMenuSimple
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_07">();
	}
	static class UUIWinMenu_S_07* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_07>();
	}
};
static_assert(alignof(UUIWinMenu_S_07) == 0x000008, "Wrong alignment on UUIWinMenu_S_07");
static_assert(sizeof(UUIWinMenu_S_07) == 0x000620, "Wrong size on UUIWinMenu_S_07");

// Class DarwinGame.DitheringMarkerSettingAssetUserData
// 0x0050 (0x0080 - 0x0030)
class UDitheringMarkerSettingAssetUserData final : public UAssetUserData
{
public:
	float                                         CapsuleHalfHeight;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSocket;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachOffset;                                      // 0x0040(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitheringMarkerSettingAssetUserData">();
	}
	static class UDitheringMarkerSettingAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitheringMarkerSettingAssetUserData>();
	}
};
static_assert(alignof(UDitheringMarkerSettingAssetUserData) == 0x000010, "Wrong alignment on UDitheringMarkerSettingAssetUserData");
static_assert(sizeof(UDitheringMarkerSettingAssetUserData) == 0x000080, "Wrong size on UDitheringMarkerSettingAssetUserData");
static_assert(offsetof(UDitheringMarkerSettingAssetUserData, CapsuleHalfHeight) == 0x000030, "Member 'UDitheringMarkerSettingAssetUserData::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UDitheringMarkerSettingAssetUserData, CapsuleRadius) == 0x000034, "Member 'UDitheringMarkerSettingAssetUserData::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(UDitheringMarkerSettingAssetUserData, bUseSocket) == 0x000038, "Member 'UDitheringMarkerSettingAssetUserData::bUseSocket' has a wrong offset!");
static_assert(offsetof(UDitheringMarkerSettingAssetUserData, AttachOffset) == 0x000040, "Member 'UDitheringMarkerSettingAssetUserData::AttachOffset' has a wrong offset!");
static_assert(offsetof(UDitheringMarkerSettingAssetUserData, AttachSocketName) == 0x000070, "Member 'UDitheringMarkerSettingAssetUserData::AttachSocketName' has a wrong offset!");

// Class DarwinGame.DitheringSyncControl
// 0x0018 (0x0080 - 0x0068)
class UDitheringSyncControl final : public UDitheringSyncControlBase
{
public:
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitheringSyncControl">();
	}
	static class UDitheringSyncControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitheringSyncControl>();
	}
};
static_assert(alignof(UDitheringSyncControl) == 0x000008, "Wrong alignment on UDitheringSyncControl");
static_assert(sizeof(UDitheringSyncControl) == 0x000080, "Wrong size on UDitheringSyncControl");

// Class DarwinGame.DropMoveParameterDataTable
// 0x0000 (0x0030 - 0x0030)
class UDropMoveParameterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropMoveParameterDataTable">();
	}
	static class UDropMoveParameterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropMoveParameterDataTable>();
	}
};
static_assert(alignof(UDropMoveParameterDataTable) == 0x000008, "Wrong alignment on UDropMoveParameterDataTable");
static_assert(sizeof(UDropMoveParameterDataTable) == 0x000030, "Wrong size on UDropMoveParameterDataTable");

// Class DarwinGame.UIWinMenu_S_02
// 0x0000 (0x0620 - 0x0620)
class UUIWinMenu_S_02 : public UUIWinMenuSimple
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_02">();
	}
	static class UUIWinMenu_S_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_02>();
	}
};
static_assert(alignof(UUIWinMenu_S_02) == 0x000008, "Wrong alignment on UUIWinMenu_S_02");
static_assert(sizeof(UUIWinMenu_S_02) == 0x000620, "Wrong size on UUIWinMenu_S_02");

// Class DarwinGame.DungeonDataAsset
// 0x0398 (0x03D0 - 0x0038)
class UDungeonDataAsset final : public UDataAsset
{
public:
	int32                                         LevelCount;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDungeonType, struct FST_DungeonLevelLotteryData> RoomLotteryList;                                   // 0x0040(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FST_DungeonEventEffectProbabilityData> EventEffectProbabilityList;                        // 0x0090(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FST_DungeonMazeHierarchyReleaseConditionData> HierarchyReleaseConditionList;                     // 0x00E0(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EMonsterBossType, int32>                 BigStarScarBossWeightList;                         // 0x0130(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      CampRoomNPCLotteryList;                            // 0x0180(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EDungeonType, struct FST_DungeonFastTravelIDData> FastTravelIDList;                                  // 0x01D0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FST_DungeonSettingData> DungeonSettingList;                                // 0x0220(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<EDungeonType, struct FST_DungeonSettingIDData> DungeonSettingID;                                  // 0x0270(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EDungeonRoomType, float>                 ResultWaitTimeList;                                // 0x02C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EMonsterBossType, struct FST_DungeonBigStarScarBossEvent> BigStarScarBossEventList;                          // 0x0310(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FST_DungeonAreaNameSetting             DungeonAreaNameSetting;                            // 0x0360(0x0058)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FST_DungeonTreasureBoxRoomSetting      TreasureBoxRoomSetting;                            // 0x03B8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonDataAsset">();
	}
	static class UDungeonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonDataAsset>();
	}
};
static_assert(alignof(UDungeonDataAsset) == 0x000008, "Wrong alignment on UDungeonDataAsset");
static_assert(sizeof(UDungeonDataAsset) == 0x0003D0, "Wrong size on UDungeonDataAsset");
static_assert(offsetof(UDungeonDataAsset, LevelCount) == 0x000038, "Member 'UDungeonDataAsset::LevelCount' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, RoomLotteryList) == 0x000040, "Member 'UDungeonDataAsset::RoomLotteryList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, EventEffectProbabilityList) == 0x000090, "Member 'UDungeonDataAsset::EventEffectProbabilityList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, HierarchyReleaseConditionList) == 0x0000E0, "Member 'UDungeonDataAsset::HierarchyReleaseConditionList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, BigStarScarBossWeightList) == 0x000130, "Member 'UDungeonDataAsset::BigStarScarBossWeightList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, CampRoomNPCLotteryList) == 0x000180, "Member 'UDungeonDataAsset::CampRoomNPCLotteryList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, FastTravelIDList) == 0x0001D0, "Member 'UDungeonDataAsset::FastTravelIDList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, DungeonSettingList) == 0x000220, "Member 'UDungeonDataAsset::DungeonSettingList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, DungeonSettingID) == 0x000270, "Member 'UDungeonDataAsset::DungeonSettingID' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, ResultWaitTimeList) == 0x0002C0, "Member 'UDungeonDataAsset::ResultWaitTimeList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, BigStarScarBossEventList) == 0x000310, "Member 'UDungeonDataAsset::BigStarScarBossEventList' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, DungeonAreaNameSetting) == 0x000360, "Member 'UDungeonDataAsset::DungeonAreaNameSetting' has a wrong offset!");
static_assert(offsetof(UDungeonDataAsset, TreasureBoxRoomSetting) == 0x0003B8, "Member 'UDungeonDataAsset::TreasureBoxRoomSetting' has a wrong offset!");

// Class DarwinGame.DungeonGimmickBigStarScarBoss
// 0x0010 (0x02C8 - 0x02B8)
class ADungeonGimmickBigStarScarBoss final : public ADungeonGimmickObjectBase
{
public:
	class AActor*                                 mEnemySpawnGeneratorActor;                         // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickBigStarScarBoss">();
	}
	static class ADungeonGimmickBigStarScarBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickBigStarScarBoss>();
	}
};
static_assert(alignof(ADungeonGimmickBigStarScarBoss) == 0x000008, "Wrong alignment on ADungeonGimmickBigStarScarBoss");
static_assert(sizeof(ADungeonGimmickBigStarScarBoss) == 0x0002C8, "Wrong size on ADungeonGimmickBigStarScarBoss");
static_assert(offsetof(ADungeonGimmickBigStarScarBoss, mEnemySpawnGeneratorActor) == 0x0002B8, "Member 'ADungeonGimmickBigStarScarBoss::mEnemySpawnGeneratorActor' has a wrong offset!");

// Class DarwinGame.DungeonGimmickBonfire
// 0x0000 (0x02B8 - 0x02B8)
class ADungeonGimmickBonfire final : public ADungeonGimmickObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickBonfire">();
	}
	static class ADungeonGimmickBonfire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickBonfire>();
	}
};
static_assert(alignof(ADungeonGimmickBonfire) == 0x000008, "Wrong alignment on ADungeonGimmickBonfire");
static_assert(sizeof(ADungeonGimmickBonfire) == 0x0002B8, "Wrong size on ADungeonGimmickBonfire");

// Class DarwinGame.DungeonGimmickLobby
// 0x0000 (0x02B8 - 0x02B8)
class ADungeonGimmickLobby final : public ADungeonGimmickObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickLobby">();
	}
	static class ADungeonGimmickLobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickLobby>();
	}
};
static_assert(alignof(ADungeonGimmickLobby) == 0x000008, "Wrong alignment on ADungeonGimmickLobby");
static_assert(sizeof(ADungeonGimmickLobby) == 0x0002B8, "Wrong size on ADungeonGimmickLobby");

// Class DarwinGame.DungeonGimmickNPC
// 0x0018 (0x02D0 - 0x02B8)
class ADungeonGimmickNPC final : public ADungeonGimmickObjectBase
{
public:
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitNPC(class ANPCBase* NpcObj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickNPC">();
	}
	static class ADungeonGimmickNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickNPC>();
	}
};
static_assert(alignof(ADungeonGimmickNPC) == 0x000008, "Wrong alignment on ADungeonGimmickNPC");
static_assert(sizeof(ADungeonGimmickNPC) == 0x0002D0, "Wrong size on ADungeonGimmickNPC");

// Class DarwinGame.DungeonGimmickStarScar
// 0x0030 (0x02E8 - 0x02B8)
class ADungeonGimmickStarScar final : public ADungeonGimmickObjectBase
{
public:
	uint8                                         Pad_2B8[0x30];                                     // 0x02B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MonserDefeatCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonGimmickStarScar">();
	}
	static class ADungeonGimmickStarScar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonGimmickStarScar>();
	}
};
static_assert(alignof(ADungeonGimmickStarScar) == 0x000008, "Wrong alignment on ADungeonGimmickStarScar");
static_assert(sizeof(ADungeonGimmickStarScar) == 0x0002E8, "Wrong size on ADungeonGimmickStarScar");

// Class DarwinGame.DungeonManager
// 0x0028 (0x0058 - 0x0030)
class UDungeonManager : public UObject
{
public:
	TArray<class ADungeonGimmickObjectBase*>      mGimmickObjects;                                   // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ADungeonWarpPointTarget*>        mWarpPointTargets;                                 // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonManager">();
	}
	static class UDungeonManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDungeonManager>();
	}
};
static_assert(alignof(UDungeonManager) == 0x000008, "Wrong alignment on UDungeonManager");
static_assert(sizeof(UDungeonManager) == 0x000058, "Wrong size on UDungeonManager");
static_assert(offsetof(UDungeonManager, mGimmickObjects) == 0x000030, "Member 'UDungeonManager::mGimmickObjects' has a wrong offset!");
static_assert(offsetof(UDungeonManager, mWarpPointTargets) == 0x000040, "Member 'UDungeonManager::mWarpPointTargets' has a wrong offset!");

// Class DarwinGame.DungeonPiller
// 0x0058 (0x0308 - 0x02B0)
class ADungeonPiller final : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDungeonEventEffectType, class FName>    EffectTextID;                                      // 0x02B8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonPiller">();
	}
	static class ADungeonPiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonPiller>();
	}
};
static_assert(alignof(ADungeonPiller) == 0x000008, "Wrong alignment on ADungeonPiller");
static_assert(sizeof(ADungeonPiller) == 0x000308, "Wrong size on ADungeonPiller");
static_assert(offsetof(ADungeonPiller, EffectTextID) == 0x0002B8, "Member 'ADungeonPiller::EffectTextID' has a wrong offset!");

// Class DarwinGame.DungeonStarScar
// 0x0018 (0x02C8 - 0x02B0)
class ADungeonStarScar final : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStaticMeshComponent* GetCoreStaticMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonStarScar">();
	}
	static class ADungeonStarScar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonStarScar>();
	}
};
static_assert(alignof(ADungeonStarScar) == 0x000008, "Wrong alignment on ADungeonStarScar");
static_assert(sizeof(ADungeonStarScar) == 0x0002C8, "Wrong size on ADungeonStarScar");

// Class DarwinGame.DungeonTreasureBox
// 0x0028 (0x0310 - 0x02E8)
class ADungeonTreasureBox : public ATreasureBoxBase
{
public:
	uint8                                         Pad_2E8[0x20];                                     // 0x02E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        mBoxPosition;                                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonTreasureBox">();
	}
	static class ADungeonTreasureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonTreasureBox>();
	}
};
static_assert(alignof(ADungeonTreasureBox) == 0x000008, "Wrong alignment on ADungeonTreasureBox");
static_assert(sizeof(ADungeonTreasureBox) == 0x000310, "Wrong size on ADungeonTreasureBox");
static_assert(offsetof(ADungeonTreasureBox, mBoxPosition) == 0x000308, "Member 'ADungeonTreasureBox::mBoxPosition' has a wrong offset!");

// Class DarwinGame.UIHub_PointCount02
// 0x0000 (0x0498 - 0x0498)
class UUIHub_PointCount02 : public UUICountBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_PointCount02">();
	}
	static class UUIHub_PointCount02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_PointCount02>();
	}
};
static_assert(alignof(UUIHub_PointCount02) == 0x000008, "Wrong alignment on UUIHub_PointCount02");
static_assert(sizeof(UUIHub_PointCount02) == 0x000498, "Wrong size on UUIHub_PointCount02");

// Class DarwinGame.DungeonWarpPointBase
// 0x0060 (0x0310 - 0x02B0)
class ADungeonWarpPointBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ChoiceTextID;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDungeonNestType, class FName>           ChoiceTextID_BossRoom;                             // 0x02C0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonWarpPointBase">();
	}
	static class ADungeonWarpPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonWarpPointBase>();
	}
};
static_assert(alignof(ADungeonWarpPointBase) == 0x000008, "Wrong alignment on ADungeonWarpPointBase");
static_assert(sizeof(ADungeonWarpPointBase) == 0x000310, "Wrong size on ADungeonWarpPointBase");
static_assert(offsetof(ADungeonWarpPointBase, ChoiceTextID) == 0x0002B8, "Member 'ADungeonWarpPointBase::ChoiceTextID' has a wrong offset!");
static_assert(offsetof(ADungeonWarpPointBase, ChoiceTextID_BossRoom) == 0x0002C0, "Member 'ADungeonWarpPointBase::ChoiceTextID_BossRoom' has a wrong offset!");

// Class DarwinGame.DungeonWarpPointTarget
// 0x0008 (0x02B8 - 0x02B0)
class ADungeonWarpPointTarget final : public AFieldObjectBase
{
public:
	class AFieldObjectBase*                       mWarpPoint;                                        // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DungeonWarpPointTarget">();
	}
	static class ADungeonWarpPointTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADungeonWarpPointTarget>();
	}
};
static_assert(alignof(ADungeonWarpPointTarget) == 0x000008, "Wrong alignment on ADungeonWarpPointTarget");
static_assert(sizeof(ADungeonWarpPointTarget) == 0x0002B8, "Wrong size on ADungeonWarpPointTarget");
static_assert(offsetof(ADungeonWarpPointTarget, mWarpPoint) == 0x0002B0, "Member 'ADungeonWarpPointTarget::mWarpPoint' has a wrong offset!");

// Class DarwinGame.EffectBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UEffectBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SetAutoDestory(class UParticleSystemComponent* Component, bool isAutoDestory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBlueprintFunctionLibrary">();
	}
	static class UEffectBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UEffectBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UEffectBlueprintFunctionLibrary");
static_assert(sizeof(UEffectBlueprintFunctionLibrary) == 0x000030, "Wrong size on UEffectBlueprintFunctionLibrary");

// Class DarwinGame.EffectManager
// 0x0118 (0x0150 - 0x0038)
class UEffectManager : public UManagerBase
{
public:
	class UDataTable*                             mEffectTable;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EEffectDataTableID, class UDataTable*>   mEffectTableList;                                  // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x78];                                      // 0x0090(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        mReferenceEffect;                                  // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_MonsterSkillEffectToComponentInfo> mMonsterSkillEffectToComponentLists;               // 0x0128(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEffectManager* GetInstance();

	void ReturnEffect(class AEffectBase* Effect);
	TSoftClassPtr<class UClass> SearchEffectClass(const class FName& ID);
	int32 SearchPresetCount(const class FName& ID);
	void SetMonsterEffect(class AEffectBase* monsterEffect, EEffectDataTableID EffectType, EMonsterRegisterType MonsterType, bool leave);
	class AEffectBase* SpawnAttachActor(class FName ID, class AActor* Parent, class FName socket, const struct FVector& local_location, const struct FRotator& local_rotation, const struct FVector& local_scale);
	class AEffectBase* SpawnAttachComponent(class FName ID, class USceneComponent* Parent, class FName socket, const struct FVector& local_location, const struct FRotator& local_rotation, const struct FVector& local_scale);
	class AEffectBase* SpawnAttackMagic(EAttackMagicEffectID Type, EMagicGradeEffectID Gragde, EMagicShotPhaseEffectID phase);
	class AEffectBase* SpawnBattleCommon(EBattleCommonEffectID Type, EEffectSizeID Size);
	class AEffectBase* SpawnBlessMove(EBlessMoveEffectID Type, EMagicGradeEffectID Gragde, EBlessMovePhaseEffectID phase);
	class AEffectBase* SpawnBoss(EBossEffectID Type, EKindEffectID Kind);
	class AEffectBase* SpawnCharacterCommon(ECharacterCommonEffectID Type, EEffectSizeID Size);
	class AEffectBase* SpawnDamage(EDamageEffectID Type, EEffectSizeID Size);
	class AEffectBase* SpawnEffect(class FName ID, const struct FVector& world_location, const struct FRotator& world_rotation, const struct FVector& world_scale);
	class AEffectBase* SpawnEmotion(EEmotionEffectID Type, EEffectSizeID Size);
	class AEffectBase* SpawnFootSmoke(EPhysicalSurfaceEffectTypeID SurfaceType, EFootSmokeActionEffectTypeID Pattern);
	class AEffectBase* SpawnFootTerrain(EFootTerrainTypeID Type, EFootSmokeActionEffectTypeID Pattern);
	class AEffectBase* SpawnObjectBreak(EObjectBreakEffectID Type);
	class AEffectBase* SpawnObjectCommon(EObjectCommonEffectID Type, EEffectPatternID Pattern);
	class AEffectBase* SpawnSelfBuff(ESelfBuffEffectID Type, EEffectSizeID Size);
	class AEffectBase* SpawnSkill(ESkillEffectID Type, EKindEffectID Kind, EMagicShotPhaseEffectID phase);
	class AEffectBase* SpawnSkillChain(ESkillChainEffectID Type, ESkillChainPhaseEffectID phase);
	class AEffectBase* SpawnSlingshot(ESlingshotEffectID Type, EMagicGradeEffectID Gragde);
	class AEffectBase* SpawnStatus(EStatusEffectID Type, EEffectSizeID Size);
	class AEffectBase* SpawnSupportMagic(ESupportMagicEffectID Type, EMagicGradeEffectID Gragde, EMagicShotPhaseEffectID phase);
	class AEffectBase* SpawnSupportMagicHit(ESupportMagicEffectID Type, EMagicGradeEffectID Gragde, EMagicShotPhaseEffectID phase, EEffectSizeID SizeID);

	TArray<class FName> GetKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectManager">();
	}
	static class UEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectManager>();
	}
};
static_assert(alignof(UEffectManager) == 0x000008, "Wrong alignment on UEffectManager");
static_assert(sizeof(UEffectManager) == 0x000150, "Wrong size on UEffectManager");
static_assert(offsetof(UEffectManager, mEffectTable) == 0x000038, "Member 'UEffectManager::mEffectTable' has a wrong offset!");
static_assert(offsetof(UEffectManager, mEffectTableList) == 0x000040, "Member 'UEffectManager::mEffectTableList' has a wrong offset!");
static_assert(offsetof(UEffectManager, mReferenceEffect) == 0x000108, "Member 'UEffectManager::mReferenceEffect' has a wrong offset!");
static_assert(offsetof(UEffectManager, mMonsterSkillEffectToComponentLists) == 0x000128, "Member 'UEffectManager::mMonsterSkillEffectToComponentLists' has a wrong offset!");

// Class DarwinGame.EmoteFaceComponent
// 0x0148 (0x0200 - 0x00B8)
class UEmoteFaceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x109];                                     // 0x00B8(0x0109)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDefaultSetting;                                // 0x01C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C2[0x3E];                                     // 0x01C2(0x003E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelEmoteBlink();
	void CancelEmoteFace();
	void CancelEmoteVocalize();
	bool IsPlayEmoteBlink(bool bCheckApplyRate);
	bool IsPlayEmoteVocalize(bool bCheckApplyRate);
	void PlayEmoteBlink(const struct FEmoteBlinkSetting& BlinkType);
	void PlayEmoteFace(EEmoteFaceType Type, class UEmoteFaceOverwriteOption* Option);
	void PlayEmoteVocalize(const struct FEmoteVocalizeSetting& BlinkType);
	void SetEnableApplyEmoteFace(bool enable);
	void StopEmoteBlink();
	void StopEmoteFace();
	void StopEmoteVocalize();

	bool IsPlayEmoteFace(bool bCheckApplyRate) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteFaceComponent">();
	}
	static class UEmoteFaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteFaceComponent>();
	}
};
static_assert(alignof(UEmoteFaceComponent) == 0x000008, "Wrong alignment on UEmoteFaceComponent");
static_assert(sizeof(UEmoteFaceComponent) == 0x000200, "Wrong size on UEmoteFaceComponent");
static_assert(offsetof(UEmoteFaceComponent, bUseDefaultSetting) == 0x0001C1, "Member 'UEmoteFaceComponent::bUseDefaultSetting' has a wrong offset!");

// Class DarwinGame.EmoteInterfaceForABP
// 0x0000 (0x0030 - 0x0030)
class IEmoteInterfaceForABP final : public IInterface
{
public:
	void CancelEmoteBody();
	void EndEmoteBody();
	struct FEmoteBodyMotionRequest GetCurrentEmoteBodyRequest();
	bool GetEnableApplyEmoteFace();
	void RequestEmoteBody(const struct FEmoteBodyMotionRequest& Request);
	void SetEmoteBlinkBlendRate(float BlendRate);
	void SetEmoteBlinkNextData(const struct FEmoteBlinkData& BlinkData);
	void SetEmoteBlinkNextRate(float BlinkRate);
	void SetEmoteBlinkNowData(const struct FEmoteBlinkData& BlinkData);
	void SetEmoteBlinkNowRate(float BlinkRate);
	void SetEmoteFaceApplyRate(float Rate);
	void SetEmoteFacialAnim(class UAnimSequence* FacialAnim);
	void SetEmoteFacialBlendRate(float BlendRate);
	void SetEmoteFacialNextData(const struct FEmoteFacialRequestData& FacialData);
	void SetEmoteFacialNowData(const struct FEmoteFacialRequestData& FacialData);
	void SetEmoteVocalizeBlendRate(float BlendRate);
	void SetEmoteVocalizeNextData(const struct FEmoteVocalizeAnimData& VocalizeData);
	void SetEmoteVocalizeNextRate(float VocalizeRate);
	void SetEmoteVocalizeNowData(const struct FEmoteVocalizeAnimData& VocalizeData);
	void SetEmoteVocalizeNowRate(float VocalizeRate);
	void SetEnableApplyEmoteFace(bool enable);

	bool HasEmoteFacialAnimData() const;
	EEmoteFaceValidType HasValidEmoteFacialAnim(EEmoteFaceType FaceType) const;
	bool IsPlayEmoteBody() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteInterfaceForABP">();
	}
	static class IEmoteInterfaceForABP* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEmoteInterfaceForABP>();
	}
};
static_assert(alignof(IEmoteInterfaceForABP) == 0x000008, "Wrong alignment on IEmoteInterfaceForABP");
static_assert(sizeof(IEmoteInterfaceForABP) == 0x000030, "Wrong size on IEmoteInterfaceForABP");

// Class DarwinGame.UISkillPop_Count_00_Add
// 0x0018 (0x04A8 - 0x0490)
class UUISkillPop_Count_00_Add : public UDarwinUserWidget
{
public:
	class UMaterialInstanceDynamic*               ImageMaterial;                                     // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISkillPop_Count_00_Add">();
	}
	static class UUISkillPop_Count_00_Add* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISkillPop_Count_00_Add>();
	}
};
static_assert(alignof(UUISkillPop_Count_00_Add) == 0x000008, "Wrong alignment on UUISkillPop_Count_00_Add");
static_assert(sizeof(UUISkillPop_Count_00_Add) == 0x0004A8, "Wrong size on UUISkillPop_Count_00_Add");
static_assert(offsetof(UUISkillPop_Count_00_Add, ImageMaterial) == 0x000490, "Member 'UUISkillPop_Count_00_Add::ImageMaterial' has a wrong offset!");

// Class DarwinGame.EmoteStampOverwriteOption
// 0x0008 (0x0038 - 0x0030)
class UEmoteStampOverwriteOption final : public UObject
{
public:
	struct FEmoteStampSetting                     OverwriteParam;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteStampOverwriteOption">();
	}
	static class UEmoteStampOverwriteOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteStampOverwriteOption>();
	}
};
static_assert(alignof(UEmoteStampOverwriteOption) == 0x000008, "Wrong alignment on UEmoteStampOverwriteOption");
static_assert(sizeof(UEmoteStampOverwriteOption) == 0x000038, "Wrong size on UEmoteStampOverwriteOption");
static_assert(offsetof(UEmoteStampOverwriteOption, OverwriteParam) == 0x000030, "Member 'UEmoteStampOverwriteOption::OverwriteParam' has a wrong offset!");

// Class DarwinGame.UISign_IconQuest_Distance
// 0x0020 (0x05D0 - 0x05B0)
class UUISign_IconQuest_Distance : public UUI3DBase
{
public:
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       NowAnim;                                           // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       InAnim;                                            // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OutAnim;                                           // 0x05C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconQuest_Distance">();
	}
	static class UUISign_IconQuest_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconQuest_Distance>();
	}
};
static_assert(alignof(UUISign_IconQuest_Distance) == 0x000010, "Wrong alignment on UUISign_IconQuest_Distance");
static_assert(sizeof(UUISign_IconQuest_Distance) == 0x0005D0, "Wrong size on UUISign_IconQuest_Distance");
static_assert(offsetof(UUISign_IconQuest_Distance, NowAnim) == 0x0005B0, "Member 'UUISign_IconQuest_Distance::NowAnim' has a wrong offset!");
static_assert(offsetof(UUISign_IconQuest_Distance, InAnim) == 0x0005B8, "Member 'UUISign_IconQuest_Distance::InAnim' has a wrong offset!");
static_assert(offsetof(UUISign_IconQuest_Distance, OutAnim) == 0x0005C0, "Member 'UUISign_IconQuest_Distance::OutAnim' has a wrong offset!");

// Class DarwinGame.EmoteFaceOverwriteOption
// 0x0008 (0x0038 - 0x0030)
class UEmoteFaceOverwriteOption final : public UObject
{
public:
	EEmoteFaceType                                FaceType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverwriteFaceType;                                // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendTime;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteFaceOverwriteOption">();
	}
	static class UEmoteFaceOverwriteOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteFaceOverwriteOption>();
	}
};
static_assert(alignof(UEmoteFaceOverwriteOption) == 0x000008, "Wrong alignment on UEmoteFaceOverwriteOption");
static_assert(sizeof(UEmoteFaceOverwriteOption) == 0x000038, "Wrong size on UEmoteFaceOverwriteOption");
static_assert(offsetof(UEmoteFaceOverwriteOption, FaceType) == 0x000030, "Member 'UEmoteFaceOverwriteOption::FaceType' has a wrong offset!");
static_assert(offsetof(UEmoteFaceOverwriteOption, bOverwriteFaceType) == 0x000031, "Member 'UEmoteFaceOverwriteOption::bOverwriteFaceType' has a wrong offset!");
static_assert(offsetof(UEmoteFaceOverwriteOption, BlendTime) == 0x000034, "Member 'UEmoteFaceOverwriteOption::BlendTime' has a wrong offset!");

// Class DarwinGame.EmoteVocalizeOverwriteOption
// 0x0008 (0x0038 - 0x0030)
class UEmoteVocalizeOverwriteOption final : public UObject
{
public:
	struct FEmoteVocalizeSetting                  OverwriteParam;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteVocalizeOverwriteOption">();
	}
	static class UEmoteVocalizeOverwriteOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteVocalizeOverwriteOption>();
	}
};
static_assert(alignof(UEmoteVocalizeOverwriteOption) == 0x000008, "Wrong alignment on UEmoteVocalizeOverwriteOption");
static_assert(sizeof(UEmoteVocalizeOverwriteOption) == 0x000038, "Wrong size on UEmoteVocalizeOverwriteOption");
static_assert(offsetof(UEmoteVocalizeOverwriteOption, OverwriteParam) == 0x000030, "Member 'UEmoteVocalizeOverwriteOption::OverwriteParam' has a wrong offset!");

// Class DarwinGame.EnemyPlacementDataTable
// 0x0000 (0x0030 - 0x0030)
class UEnemyPlacementDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyPlacementDataTable">();
	}
	static class UEnemyPlacementDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyPlacementDataTable>();
	}
};
static_assert(alignof(UEnemyPlacementDataTable) == 0x000008, "Wrong alignment on UEnemyPlacementDataTable");
static_assert(sizeof(UEnemyPlacementDataTable) == 0x000030, "Wrong size on UEnemyPlacementDataTable");

// Class DarwinGame.EnemySpawnGeneratorAssetParent
// 0x0030 (0x00E8 - 0x00B8)
class UEnemySpawnGeneratorAssetParent final : public UActorComponent
{
public:
	TArray<class FString>                         mChildsLabel;                                      // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           mChildsID;                                         // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           mChildsNames;                                      // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetGeneratorsID();
	void UpdateProperty();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorAssetParent">();
	}
	static class UEnemySpawnGeneratorAssetParent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorAssetParent>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorAssetParent) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorAssetParent");
static_assert(sizeof(UEnemySpawnGeneratorAssetParent) == 0x0000E8, "Wrong size on UEnemySpawnGeneratorAssetParent");
static_assert(offsetof(UEnemySpawnGeneratorAssetParent, mChildsLabel) == 0x0000B8, "Member 'UEnemySpawnGeneratorAssetParent::mChildsLabel' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorAssetParent, mChildsID) == 0x0000C8, "Member 'UEnemySpawnGeneratorAssetParent::mChildsID' has a wrong offset!");
static_assert(offsetof(UEnemySpawnGeneratorAssetParent, mChildsNames) == 0x0000D8, "Member 'UEnemySpawnGeneratorAssetParent::mChildsNames' has a wrong offset!");

// Class DarwinGame.EnemySpawnGeneratorForStar
// 0x0018 (0x01C0 - 0x01A8)
class UEnemySpawnGeneratorForStar final : public UEnemySpawnGeneratorDirect
{
public:
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStarID(const class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnGeneratorForStar">();
	}
	static class UEnemySpawnGeneratorForStar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnGeneratorForStar>();
	}
};
static_assert(alignof(UEnemySpawnGeneratorForStar) == 0x000008, "Wrong alignment on UEnemySpawnGeneratorForStar");
static_assert(sizeof(UEnemySpawnGeneratorForStar) == 0x0001C0, "Wrong size on UEnemySpawnGeneratorForStar");

// Class DarwinGame.EnemySpawnManager
// 0x00C8 (0x00F8 - 0x0030)
class UEnemySpawnManager final : public UObject
{
public:
	TMap<class FName, class UEnemySpawnGeneratorBase*> Generators;                                        // 0x0030(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          mEnableBoxVisible;                                 // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mSpawnSkipFlag;                                    // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mBetweenRevengeBattle;                             // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mEnableSpawnRivalTeam;                             // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mCurrentAlertPoint;                                // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         mPreviousAlertPoint;                               // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         mAdditionalAlertPoint;                             // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         mAlertLevel;                                       // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mAlertUIOn;                                        // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERivalTeamForce                               mCurrentRivalTeamForce;                            // 0x009D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          mIsLoadedSaveData;                                 // 0x009E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F[0x59];                                      // 0x009F(0x0059)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGenerator(class UEnemySpawnGeneratorBase* Generator);
	void ChangeEventFlagCallBack(bool bEnable, bool bIsChanged);
	void FreeGenerators();
	void NoticeDead(const class FName SpawnPointID);
	void RemoveGenerator(const class UEnemySpawnGeneratorBase* Generator);
	void RequestSpawnDefenceBattleMonsters(const struct FVector& spawnPoint, int32 SpawnRadius, ERivalTeamForce Force, int32 weaveCount, int32 maxWeaveCount, TDelegate<void(class AMonsterBase* deaded)> end_func);
	void RequestSpawnRevengeMonster(const struct FVector& spawnPoint, int32 SpawnRadius, class FName BattleID, int32 Subtract, TDelegate<void(class AMonsterBase* spawned)> begin_func, TDelegate<void(class AMonsterBase* deaded)> end_func);
	void SetSpawnAndDistanceCheckSkip(const bool skipFlag);
	void SetSpawnSkip(const bool skipFlag);
	void SpawnImmediately(class FName SpawnPointID, bool enable);

	bool HasActiveMonsters(class FName SpawnPointID) const;
	bool IsSpawnSkip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawnManager">();
	}
	static class UEnemySpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemySpawnManager>();
	}
};
static_assert(alignof(UEnemySpawnManager) == 0x000008, "Wrong alignment on UEnemySpawnManager");
static_assert(sizeof(UEnemySpawnManager) == 0x0000F8, "Wrong size on UEnemySpawnManager");
static_assert(offsetof(UEnemySpawnManager, Generators) == 0x000030, "Member 'UEnemySpawnManager::Generators' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mEnableBoxVisible) == 0x000080, "Member 'UEnemySpawnManager::mEnableBoxVisible' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mSpawnSkipFlag) == 0x000081, "Member 'UEnemySpawnManager::mSpawnSkipFlag' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mBetweenRevengeBattle) == 0x000088, "Member 'UEnemySpawnManager::mBetweenRevengeBattle' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mEnableSpawnRivalTeam) == 0x000089, "Member 'UEnemySpawnManager::mEnableSpawnRivalTeam' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mCurrentAlertPoint) == 0x00008C, "Member 'UEnemySpawnManager::mCurrentAlertPoint' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mPreviousAlertPoint) == 0x000090, "Member 'UEnemySpawnManager::mPreviousAlertPoint' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mAdditionalAlertPoint) == 0x000094, "Member 'UEnemySpawnManager::mAdditionalAlertPoint' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mAlertLevel) == 0x000098, "Member 'UEnemySpawnManager::mAlertLevel' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mAlertUIOn) == 0x00009C, "Member 'UEnemySpawnManager::mAlertUIOn' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mCurrentRivalTeamForce) == 0x00009D, "Member 'UEnemySpawnManager::mCurrentRivalTeamForce' has a wrong offset!");
static_assert(offsetof(UEnemySpawnManager, mIsLoadedSaveData) == 0x00009E, "Member 'UEnemySpawnManager::mIsLoadedSaveData' has a wrong offset!");

// Class DarwinGame.UITreasurePanel
// 0x0040 (0x0070 - 0x0030)
class UUITreasurePanel final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                TreasureCapturePanel;                              // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITreasureHidePanel*                   TreasureHidePanel;                                 // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Shadow;                                            // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                NoSettinngText;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasurePanel">();
	}
	static class UUITreasurePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasurePanel>();
	}
};
static_assert(alignof(UUITreasurePanel) == 0x000008, "Wrong alignment on UUITreasurePanel");
static_assert(sizeof(UUITreasurePanel) == 0x000070, "Wrong size on UUITreasurePanel");
static_assert(offsetof(UUITreasurePanel, TreasureCapturePanel) == 0x000048, "Member 'UUITreasurePanel::TreasureCapturePanel' has a wrong offset!");
static_assert(offsetof(UUITreasurePanel, TreasureHidePanel) == 0x000050, "Member 'UUITreasurePanel::TreasureHidePanel' has a wrong offset!");
static_assert(offsetof(UUITreasurePanel, Shadow) == 0x000058, "Member 'UUITreasurePanel::Shadow' has a wrong offset!");
static_assert(offsetof(UUITreasurePanel, NoSettinngText) == 0x000060, "Member 'UUITreasurePanel::NoSettinngText' has a wrong offset!");

// Class DarwinGame.EnvironmentBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UEnvironmentBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FLinearColor EaseLinearColor(const struct FLinearColor& ParamA, const struct FLinearColor& ParamB, float Alpha, EEasingFunc EasingFunc);
	static struct FVector4 EaseVector4(const struct FVector4& ParamA, const struct FVector4& ParamB, float Alpha, EEasingFunc EasingFunc);
	static struct FLinearColor GetCurveColorValue(float Alpha, class UCurveLinearColor* CurveFloat);
	static float GetCurveFloatValue(float Alpha, class UCurveFloat* CurveFloat);
	static struct FVector GetCurveVectorValue(float Alpha, class UCurveVector* CurveFloat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentBlueprintFunctionLibrary">();
	}
	static class UEnvironmentBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UEnvironmentBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UEnvironmentBlueprintFunctionLibrary");
static_assert(sizeof(UEnvironmentBlueprintFunctionLibrary) == 0x000030, "Wrong size on UEnvironmentBlueprintFunctionLibrary");

// Class DarwinGame.UITreasureDetails_Page03
// 0x0000 (0x04F0 - 0x04F0)
class UUITreasureDetails_Page03 : public UUIFreeScrollBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureDetails_Page03">();
	}
	static class UUITreasureDetails_Page03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureDetails_Page03>();
	}
};
static_assert(alignof(UUITreasureDetails_Page03) == 0x000008, "Wrong alignment on UUITreasureDetails_Page03");
static_assert(sizeof(UUITreasureDetails_Page03) == 0x0004F0, "Wrong size on UUITreasureDetails_Page03");

// Class DarwinGame.EnvironmentManager
// 0x0018 (0x0048 - 0x0030)
class UEnvironmentManager : public UObject
{
public:
	class AEnvironmentObject*                     EnvironmentObject;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnvironmentSettingsDataAsset*          EnvironmentSettingsAsset;                          // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeEnvironment(class FName EnvironmentID);
	void ChangeEnvironmentFromEvent(class FName EnvironmentID);
	class AEnvironmentObject* GetEnvironmentObject();
	void ReturnEnvironmentFromEvent();
	void SetSkyEnable(bool Flag);

	EEnvironmentType GetEnvironmentType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentManager">();
	}
	static class UEnvironmentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentManager>();
	}
};
static_assert(alignof(UEnvironmentManager) == 0x000008, "Wrong alignment on UEnvironmentManager");
static_assert(sizeof(UEnvironmentManager) == 0x000048, "Wrong size on UEnvironmentManager");
static_assert(offsetof(UEnvironmentManager, EnvironmentObject) == 0x000030, "Member 'UEnvironmentManager::EnvironmentObject' has a wrong offset!");
static_assert(offsetof(UEnvironmentManager, EnvironmentSettingsAsset) == 0x000038, "Member 'UEnvironmentManager::EnvironmentSettingsAsset' has a wrong offset!");

// Class DarwinGame.EnvironmentSettingsDataAsset
// 0x00A8 (0x00E0 - 0x0038)
class UEnvironmentSettingsDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FEnvironmentSettings> list;                                              // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      mStartEffectRate;                                  // 0x0088(0x0050)(Edit, NativeAccessSpecifierPrivate)
	float                                         mStartReflectFogRate;                              // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentSettingsDataAsset">();
	}
	static class UEnvironmentSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentSettingsDataAsset>();
	}
};
static_assert(alignof(UEnvironmentSettingsDataAsset) == 0x000008, "Wrong alignment on UEnvironmentSettingsDataAsset");
static_assert(sizeof(UEnvironmentSettingsDataAsset) == 0x0000E0, "Wrong size on UEnvironmentSettingsDataAsset");
static_assert(offsetof(UEnvironmentSettingsDataAsset, list) == 0x000038, "Member 'UEnvironmentSettingsDataAsset::list' has a wrong offset!");
static_assert(offsetof(UEnvironmentSettingsDataAsset, mStartEffectRate) == 0x000088, "Member 'UEnvironmentSettingsDataAsset::mStartEffectRate' has a wrong offset!");
static_assert(offsetof(UEnvironmentSettingsDataAsset, mStartReflectFogRate) == 0x0000D8, "Member 'UEnvironmentSettingsDataAsset::mStartReflectFogRate' has a wrong offset!");

// Class DarwinGame.UICommonmenu_OptionChoiceBase_01
// 0x0008 (0x0558 - 0x0550)
class UUICommonmenu_OptionChoiceBase_01 final : public UUICommonmenu_OptionChoiceBase_Base
{
public:
	int32                                         DefaultButtonValue;                                // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_OptionChoiceBase_01">();
	}
	static class UUICommonmenu_OptionChoiceBase_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_OptionChoiceBase_01>();
	}
};
static_assert(alignof(UUICommonmenu_OptionChoiceBase_01) == 0x000008, "Wrong alignment on UUICommonmenu_OptionChoiceBase_01");
static_assert(sizeof(UUICommonmenu_OptionChoiceBase_01) == 0x000558, "Wrong size on UUICommonmenu_OptionChoiceBase_01");
static_assert(offsetof(UUICommonmenu_OptionChoiceBase_01, DefaultButtonValue) == 0x000550, "Member 'UUICommonmenu_OptionChoiceBase_01::DefaultButtonValue' has a wrong offset!");

// Class DarwinGame.EQT_MakeAttackLocationData
// 0x0000 (0x0200 - 0x0200)
class UEQT_MakeAttackLocationData final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQT_MakeAttackLocationData">();
	}
	static class UEQT_MakeAttackLocationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQT_MakeAttackLocationData>();
	}
};
static_assert(alignof(UEQT_MakeAttackLocationData) == 0x000008, "Wrong alignment on UEQT_MakeAttackLocationData");
static_assert(sizeof(UEQT_MakeAttackLocationData) == 0x000200, "Wrong size on UEQT_MakeAttackLocationData");

// Class DarwinGame.EscapeTimer
// 0x0008 (0x0040 - 0x0038)
class UEscapeTimer final : public UMonsterService
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeTimer">();
	}
	static class UEscapeTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeTimer>();
	}
};
static_assert(alignof(UEscapeTimer) == 0x000008, "Wrong alignment on UEscapeTimer");
static_assert(sizeof(UEscapeTimer) == 0x000040, "Wrong size on UEscapeTimer");

// Class DarwinGame.UIGlutGauge10XBase
// 0x0030 (0x04C0 - 0x0490)
class UUIGlutGauge10XBase : public UDarwinUserWidget
{
public:
	class UMaterialInstanceDynamic*               ImageMaterial;                                     // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 KiraImage;                                         // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWidgetAnimation*>               Animations;                                        // 0x04B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlutGauge10XBase">();
	}
	static class UUIGlutGauge10XBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlutGauge10XBase>();
	}
};
static_assert(alignof(UUIGlutGauge10XBase) == 0x000008, "Wrong alignment on UUIGlutGauge10XBase");
static_assert(sizeof(UUIGlutGauge10XBase) == 0x0004C0, "Wrong size on UUIGlutGauge10XBase");
static_assert(offsetof(UUIGlutGauge10XBase, ImageMaterial) == 0x000490, "Member 'UUIGlutGauge10XBase::ImageMaterial' has a wrong offset!");
static_assert(offsetof(UUIGlutGauge10XBase, KiraImage) == 0x0004A8, "Member 'UUIGlutGauge10XBase::KiraImage' has a wrong offset!");
static_assert(offsetof(UUIGlutGauge10XBase, Animations) == 0x0004B0, "Member 'UUIGlutGauge10XBase::Animations' has a wrong offset!");

// Class DarwinGame.EstimateBonusDataTable
// 0x0000 (0x0030 - 0x0030)
class UEstimateBonusDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateBonusDataTable">();
	}
	static class UEstimateBonusDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEstimateBonusDataTable>();
	}
};
static_assert(alignof(UEstimateBonusDataTable) == 0x000008, "Wrong alignment on UEstimateBonusDataTable");
static_assert(sizeof(UEstimateBonusDataTable) == 0x000030, "Wrong size on UEstimateBonusDataTable");

// Class DarwinGame.EstimateSequenceSceneCapture
// 0x0050 (0x03C0 - 0x0370)
class AEstimateSequenceSceneCapture final : public ASceneCaptureBase
{
public:
	TSubclassOf<class AEstimateLighting>          LightRes;                                          // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     CoinsRes;                                          // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                FlashEffectRes;                                    // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEstimateLighting*                      LightActor;                                        // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CoinsActor;                                        // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEffectBase*>                    FlashEffect;                                       // 0x0398(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FST_EstimateSequenceData>       SequenceDataList;                                  // 0x03A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSequencer();
	class AActor* GetCoinsActor();
	class USceneCaptureComponent2D* GetEstimateCaptureComponent();
	class AStaticMeshActor* GetPanelActor();
	TArray<struct FST_EstimateSequenceData> GetSequenceData();
	void StartFlySequencer();
	void StartSequencer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateSequenceSceneCapture">();
	}
	static class AEstimateSequenceSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimateSequenceSceneCapture>();
	}
};
static_assert(alignof(AEstimateSequenceSceneCapture) == 0x000010, "Wrong alignment on AEstimateSequenceSceneCapture");
static_assert(sizeof(AEstimateSequenceSceneCapture) == 0x0003C0, "Wrong size on AEstimateSequenceSceneCapture");
static_assert(offsetof(AEstimateSequenceSceneCapture, LightRes) == 0x000370, "Member 'AEstimateSequenceSceneCapture::LightRes' has a wrong offset!");
static_assert(offsetof(AEstimateSequenceSceneCapture, CoinsRes) == 0x000378, "Member 'AEstimateSequenceSceneCapture::CoinsRes' has a wrong offset!");
static_assert(offsetof(AEstimateSequenceSceneCapture, FlashEffectRes) == 0x000380, "Member 'AEstimateSequenceSceneCapture::FlashEffectRes' has a wrong offset!");
static_assert(offsetof(AEstimateSequenceSceneCapture, LightActor) == 0x000388, "Member 'AEstimateSequenceSceneCapture::LightActor' has a wrong offset!");
static_assert(offsetof(AEstimateSequenceSceneCapture, CoinsActor) == 0x000390, "Member 'AEstimateSequenceSceneCapture::CoinsActor' has a wrong offset!");
static_assert(offsetof(AEstimateSequenceSceneCapture, FlashEffect) == 0x000398, "Member 'AEstimateSequenceSceneCapture::FlashEffect' has a wrong offset!");
static_assert(offsetof(AEstimateSequenceSceneCapture, SequenceDataList) == 0x0003A8, "Member 'AEstimateSequenceSceneCapture::SequenceDataList' has a wrong offset!");

// Class DarwinGame.EstimateTreasureObjectBase
// 0x0038 (0x0260 - 0x0228)
class AEstimateTreasureObjectBase final : public AActor
{
public:
	class UMaterialInterface*                     SilhouetteMaterial;                                // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 MainMeshList;                                      // 0x0230(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 SubMeshList;                                       // 0x0240(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDefaultMaterial();
	void SetSilhouetteMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EstimateTreasureObjectBase">();
	}
	static class AEstimateTreasureObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEstimateTreasureObjectBase>();
	}
};
static_assert(alignof(AEstimateTreasureObjectBase) == 0x000008, "Wrong alignment on AEstimateTreasureObjectBase");
static_assert(sizeof(AEstimateTreasureObjectBase) == 0x000260, "Wrong size on AEstimateTreasureObjectBase");
static_assert(offsetof(AEstimateTreasureObjectBase, SilhouetteMaterial) == 0x000228, "Member 'AEstimateTreasureObjectBase::SilhouetteMaterial' has a wrong offset!");
static_assert(offsetof(AEstimateTreasureObjectBase, MainMeshList) == 0x000230, "Member 'AEstimateTreasureObjectBase::MainMeshList' has a wrong offset!");
static_assert(offsetof(AEstimateTreasureObjectBase, SubMeshList) == 0x000240, "Member 'AEstimateTreasureObjectBase::SubMeshList' has a wrong offset!");

// Class DarwinGame.EventCrashableComponent
// 0x0008 (0x00D0 - 0x00C8)
class UEventCrashableComponent final : public UFieldEventComponentBase
{
public:
	float                                         LifeTime;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ComponentOnReceiveEventBP(const struct FEventStruct& Info, class AFieldObjectBase* Parent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCrashableComponent">();
	}
	static class UEventCrashableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCrashableComponent>();
	}
};
static_assert(alignof(UEventCrashableComponent) == 0x000008, "Wrong alignment on UEventCrashableComponent");
static_assert(sizeof(UEventCrashableComponent) == 0x0000D0, "Wrong size on UEventCrashableComponent");
static_assert(offsetof(UEventCrashableComponent, LifeTime) == 0x0000C8, "Member 'UEventCrashableComponent::LifeTime' has a wrong offset!");

// Class DarwinGame.EventExecuter
// 0x0060 (0x0118 - 0x00B8)
class UEventExecuter : public UActorComponent
{
public:
	TMap<class FName, class AScriptEventBase*>    SpawnScriptEventList;                              // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	class FName                                   PlayingScriptEventID;                              // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AScriptEventBase*                       PlayingScriptEvent;                                // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CallEndEvent();
	void DestoryScriptEvent(const class FName& ScriptEventID);
	void EndScriptEvent();
	void ExecuteEvent(const struct FST_EventData& EventData);
	void ExecuteHubReception();
	EEventType GetCurrentEventType();
	void PlayScriptEvent(const class FName& EventID);
	void ReceiveCloseTalkWindow();
	void ReceiveSelectResult(int32 SelectIndex);
	void SkipSequencer();

	class AScriptEventBase* GetPlayingScriptEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventExecuter">();
	}
	static class UEventExecuter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventExecuter>();
	}
};
static_assert(alignof(UEventExecuter) == 0x000008, "Wrong alignment on UEventExecuter");
static_assert(sizeof(UEventExecuter) == 0x000118, "Wrong size on UEventExecuter");
static_assert(offsetof(UEventExecuter, SpawnScriptEventList) == 0x0000B8, "Member 'UEventExecuter::SpawnScriptEventList' has a wrong offset!");
static_assert(offsetof(UEventExecuter, PlayingScriptEventID) == 0x000108, "Member 'UEventExecuter::PlayingScriptEventID' has a wrong offset!");
static_assert(offsetof(UEventExecuter, PlayingScriptEvent) == 0x000110, "Member 'UEventExecuter::PlayingScriptEvent' has a wrong offset!");

// Class DarwinGame.EventLoader
// 0x00D0 (0x0100 - 0x0030)
class UEventLoader : public UObject
{
public:
	TArray<class FName>                           LoadPlanEventList;                                 // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FEventLoadAsset>     EventLoadAssetList;                                // 0x0058(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsLoadCompleteLevelSequence;                       // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsLoadCompleteEventLevel;                          // 0x00F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsLoadFailed;                                      // 0x00FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAlredyAddLoadPlanEventList(const class FName& EventID);
	void OnLoadLevelSequenceComplete();
	void StackLoadPlanEvent(const class FName& EventID);
	void UnLoadEventAsset(const class FName& EventID);
	void UnLoadEventAssetAll();

	TArray<class ALevelSequenceActor*> GetCreateLevelSequence(const class FName& EventID) const;
	int32 GetUIOneShotID(class FName EventID, class FName UIName) const;
	bool IsLoadCompleteEventAsset(const class FName& EventID) const;
	bool IsLoadSuccessEventAsset(const class FName& EventID) const;
	void LogUIOneShotData(const class FName& EventID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventLoader">();
	}
	static class UEventLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventLoader>();
	}
};
static_assert(alignof(UEventLoader) == 0x000008, "Wrong alignment on UEventLoader");
static_assert(sizeof(UEventLoader) == 0x000100, "Wrong size on UEventLoader");
static_assert(offsetof(UEventLoader, LoadPlanEventList) == 0x000030, "Member 'UEventLoader::LoadPlanEventList' has a wrong offset!");
static_assert(offsetof(UEventLoader, EventLoadAssetList) == 0x000058, "Member 'UEventLoader::EventLoadAssetList' has a wrong offset!");
static_assert(offsetof(UEventLoader, IsLoadCompleteLevelSequence) == 0x0000F8, "Member 'UEventLoader::IsLoadCompleteLevelSequence' has a wrong offset!");
static_assert(offsetof(UEventLoader, IsLoadCompleteEventLevel) == 0x0000F9, "Member 'UEventLoader::IsLoadCompleteEventLevel' has a wrong offset!");
static_assert(offsetof(UEventLoader, IsLoadFailed) == 0x0000FA, "Member 'UEventLoader::IsLoadFailed' has a wrong offset!");

// Class DarwinGame.EventMonsterSpawnedCallback
// 0x0000 (0x0228 - 0x0228)
class AEventMonsterSpawnedCallback final : public AActor
{
public:
	void OnSpawnedMonster(class AMonsterBase* spawned);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventMonsterSpawnedCallback">();
	}
	static class AEventMonsterSpawnedCallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventMonsterSpawnedCallback>();
	}
};
static_assert(alignof(AEventMonsterSpawnedCallback) == 0x000008, "Wrong alignment on AEventMonsterSpawnedCallback");
static_assert(sizeof(AEventMonsterSpawnedCallback) == 0x000228, "Wrong size on AEventMonsterSpawnedCallback");

// Class DarwinGame.EventSender
// 0x0010 (0x00C8 - 0x00B8)
class UEventSender : public UActorComponent
{
public:
	bool                                          IsPlayEvent;                                       // 0x00B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActiveEvent;                                     // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventID;                                           // 0x00BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInit;                                            // 0x00C4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallForceMoveEvent(const class FName& CallEventID, const struct FVector& MovePostion, const float& MoveTime);
	void CallSendEvent();
	class FName GetEventID();
	void Init();
	void SetActiveEvent(bool Active);
	void SetEventID(class FName event_id);
	void SetSendEventID(class FName SendEventID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSender">();
	}
	static class UEventSender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSender>();
	}
};
static_assert(alignof(UEventSender) == 0x000008, "Wrong alignment on UEventSender");
static_assert(sizeof(UEventSender) == 0x0000C8, "Wrong size on UEventSender");
static_assert(offsetof(UEventSender, IsPlayEvent) == 0x0000B8, "Member 'UEventSender::IsPlayEvent' has a wrong offset!");
static_assert(offsetof(UEventSender, IsActiveEvent) == 0x0000B9, "Member 'UEventSender::IsActiveEvent' has a wrong offset!");
static_assert(offsetof(UEventSender, EventID) == 0x0000BC, "Member 'UEventSender::EventID' has a wrong offset!");
static_assert(offsetof(UEventSender, IsInit) == 0x0000C4, "Member 'UEventSender::IsInit' has a wrong offset!");

// Class DarwinGame.UISign_IconChoice
// 0x0000 (0x0490 - 0x0490)
class UUISign_IconChoice final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconChoice">();
	}
	static class UUISign_IconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconChoice>();
	}
};
static_assert(alignof(UUISign_IconChoice) == 0x000008, "Wrong alignment on UUISign_IconChoice");
static_assert(sizeof(UUISign_IconChoice) == 0x000490, "Wrong size on UUISign_IconChoice");

// Class DarwinGame.EventSystemManager
// 0x0158 (0x0190 - 0x0038)
class UEventSystemManager : public UManagerBase
{
public:
	TSoftClassPtr<class UClass>                   EventSystemManagerActorRef;                        // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EventDataBaseRef;                                  // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GameProgressRef;                                   // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EventLoaderRef;                                    // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TalkEventSystemRef;                                // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              PCChangeBeforeTalkDataRef;                         // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              PCChangeTalkDataRef;                               // 0x0128(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEventSystemManagerActor*               EventSystemManagerActor;                           // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventDataBase*                         EventDataBase;                                     // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameProgress*                          GameProgress;                                      // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventLoader*                           EventLoader;                                       // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTalkEventSystem*                       TalkEventSystem;                                   // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_PCChangeBeforeTalkEventData;                    // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_PCChangeTalkEventData;                          // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsPlayingEvent;                                    // 0x0188(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEventSystemManager* GetInstance();

	void DestoryEventSystemManager();
	void DestoryEventSystemManagerActor();
	class UEventExecuter* GetEventExecuter();
	class UEventManager* GetEventManager();
	class AEventSystemManagerActor* GetEventSystemManagerActor();
	class USequencerController* GetSequencerController();
	void ResetCSSkipState();
	void SetCSSkipDone(const bool Flag);
	void SetCSSkipVisible(const bool Flag);
	void SetPlayEvent(bool Play);

	class UEventDataBase* GetEventDataBase() const;
	class UEventLoader* GetEventLoader() const;
	class UGameProgress* GetGameProgress() const;
	class UDataTable* GetPCChangeBeforeTalkEventData() const;
	class UDataTable* GetPCChangeTalkEventData() const;
	class UTalkEventSystem* GetTalkEventSystem() const;
	bool IsCSSkipDone() const;
	bool IsCSSkipVisible() const;
	bool IsPlayEvent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSystemManager">();
	}
	static class UEventSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventSystemManager>();
	}
};
static_assert(alignof(UEventSystemManager) == 0x000008, "Wrong alignment on UEventSystemManager");
static_assert(sizeof(UEventSystemManager) == 0x000190, "Wrong size on UEventSystemManager");
static_assert(offsetof(UEventSystemManager, EventSystemManagerActorRef) == 0x000038, "Member 'UEventSystemManager::EventSystemManagerActorRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, EventDataBaseRef) == 0x000060, "Member 'UEventSystemManager::EventDataBaseRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, GameProgressRef) == 0x000088, "Member 'UEventSystemManager::GameProgressRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, EventLoaderRef) == 0x0000B0, "Member 'UEventSystemManager::EventLoaderRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, TalkEventSystemRef) == 0x0000D8, "Member 'UEventSystemManager::TalkEventSystemRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, PCChangeBeforeTalkDataRef) == 0x000100, "Member 'UEventSystemManager::PCChangeBeforeTalkDataRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, PCChangeTalkDataRef) == 0x000128, "Member 'UEventSystemManager::PCChangeTalkDataRef' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, EventSystemManagerActor) == 0x000150, "Member 'UEventSystemManager::EventSystemManagerActor' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, EventDataBase) == 0x000158, "Member 'UEventSystemManager::EventDataBase' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, GameProgress) == 0x000160, "Member 'UEventSystemManager::GameProgress' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, EventLoader) == 0x000168, "Member 'UEventSystemManager::EventLoader' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, TalkEventSystem) == 0x000170, "Member 'UEventSystemManager::TalkEventSystem' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, DT_PCChangeBeforeTalkEventData) == 0x000178, "Member 'UEventSystemManager::DT_PCChangeBeforeTalkEventData' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, DT_PCChangeTalkEventData) == 0x000180, "Member 'UEventSystemManager::DT_PCChangeTalkEventData' has a wrong offset!");
static_assert(offsetof(UEventSystemManager, IsPlayingEvent) == 0x000188, "Member 'UEventSystemManager::IsPlayingEvent' has a wrong offset!");

// Class DarwinGame.EventWhileWaiting
// 0x0000 (0x0038 - 0x0038)
class UEventWhileWaiting final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventWhileWaiting">();
	}
	static class UEventWhileWaiting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventWhileWaiting>();
	}
};
static_assert(alignof(UEventWhileWaiting) == 0x000008, "Wrong alignment on UEventWhileWaiting");
static_assert(sizeof(UEventWhileWaiting) == 0x000038, "Wrong size on UEventWhileWaiting");

// Class DarwinGame.UIShot_WinStatus
// 0x00B8 (0x0688 - 0x05D0)
class UUIShot_WinStatus : public UUIScrollMenuBase
{
public:
	TMulticastInlineDelegate<void()>              BulletsSelectClosedEventDispatcher;                // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIShot_IconRange*                      GroupSelectMenu;                                   // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIButtonArrow*>                 ArrowArray;                                        // 0x05F0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_SlingShotCategory>          CategoryArray;                                     // 0x0600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIShot_Detail*                         BulletDetail;                                      // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         CmdOnSe;                                           // 0x0618(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIShot_IconReticle*                    IconReticle;                                       // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x60];                                     // 0x0628(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetListIndexFunc(int32* OutCategoryIndex, int32* OutGroupIndex);
	void InitSlingShotListFunc();
	void OpenBulletsSelect();
	void SetDataFunc();
	void SetNameFunc();
	void SetSelectIndex(int32 InIndex);
	void SetSelectModeFunc(bool bInIsSelectMode);
	void UpdateClipFunc();
	void UpdateDataFunc();
	void UpdateDestinationArrowFunc();

	const int32 GetSelectIndex() const;
	const bool GetSelectMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShot_WinStatus">();
	}
	static class UUIShot_WinStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShot_WinStatus>();
	}
};
static_assert(alignof(UUIShot_WinStatus) == 0x000008, "Wrong alignment on UUIShot_WinStatus");
static_assert(sizeof(UUIShot_WinStatus) == 0x000688, "Wrong size on UUIShot_WinStatus");
static_assert(offsetof(UUIShot_WinStatus, BulletsSelectClosedEventDispatcher) == 0x0005D0, "Member 'UUIShot_WinStatus::BulletsSelectClosedEventDispatcher' has a wrong offset!");
static_assert(offsetof(UUIShot_WinStatus, GroupSelectMenu) == 0x0005E8, "Member 'UUIShot_WinStatus::GroupSelectMenu' has a wrong offset!");
static_assert(offsetof(UUIShot_WinStatus, ArrowArray) == 0x0005F0, "Member 'UUIShot_WinStatus::ArrowArray' has a wrong offset!");
static_assert(offsetof(UUIShot_WinStatus, CategoryArray) == 0x000600, "Member 'UUIShot_WinStatus::CategoryArray' has a wrong offset!");
static_assert(offsetof(UUIShot_WinStatus, BulletDetail) == 0x000610, "Member 'UUIShot_WinStatus::BulletDetail' has a wrong offset!");
static_assert(offsetof(UUIShot_WinStatus, CmdOnSe) == 0x000618, "Member 'UUIShot_WinStatus::CmdOnSe' has a wrong offset!");
static_assert(offsetof(UUIShot_WinStatus, IconReticle) == 0x000620, "Member 'UUIShot_WinStatus::IconReticle' has a wrong offset!");

// Class DarwinGame.ExtendParticleComponent
// 0x0010 (0x0690 - 0x0680)
class UExtendParticleComponent final : public UParticleSystemComponent
{
public:
	struct FEffectComponentInfo                   CommonInfo;                                        // 0x0678(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendParticleComponent">();
	}
	static class UExtendParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendParticleComponent>();
	}
};
static_assert(alignof(UExtendParticleComponent) == 0x000010, "Wrong alignment on UExtendParticleComponent");
static_assert(sizeof(UExtendParticleComponent) == 0x000690, "Wrong size on UExtendParticleComponent");
static_assert(offsetof(UExtendParticleComponent, CommonInfo) == 0x000678, "Member 'UExtendParticleComponent::CommonInfo' has a wrong offset!");

// Class DarwinGame.UIStationPartyPanel
// 0x0010 (0x04A0 - 0x0490)
class UUIStationPartyPanel final : public UDarwinUserWidget
{
public:
	TArray<class UUIStation_Member*>              MemberPanels;                                      // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationPartyPanel">();
	}
	static class UUIStationPartyPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationPartyPanel>();
	}
};
static_assert(alignof(UUIStationPartyPanel) == 0x000008, "Wrong alignment on UUIStationPartyPanel");
static_assert(sizeof(UUIStationPartyPanel) == 0x0004A0, "Wrong size on UUIStationPartyPanel");
static_assert(offsetof(UUIStationPartyPanel, MemberPanels) == 0x000490, "Member 'UUIStationPartyPanel::MemberPanels' has a wrong offset!");

// Class DarwinGame.FallDamageExecution
// 0x0000 (0x0048 - 0x0048)
class UFallDamageExecution final : public UDamageExecutionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallDamageExecution">();
	}
	static class UFallDamageExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallDamageExecution>();
	}
};
static_assert(alignof(UFallDamageExecution) == 0x000008, "Wrong alignment on UFallDamageExecution");
static_assert(sizeof(UFallDamageExecution) == 0x000048, "Wrong size on UFallDamageExecution");

// Class DarwinGame.FastTravelComponent
// 0x0000 (0x00B8 - 0x00B8)
class UFastTravelComponent : public UActorComponent
{
public:
	void OnMove(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FastTravelComponent">();
	}
	static class UFastTravelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFastTravelComponent>();
	}
};
static_assert(alignof(UFastTravelComponent) == 0x000008, "Wrong alignment on UFastTravelComponent");
static_assert(sizeof(UFastTravelComponent) == 0x0000B8, "Wrong size on UFastTravelComponent");

// Class DarwinGame.UIDelivery_List
// 0x0010 (0x0500 - 0x04F0)
class UUIDelivery_List final : public UUIFreeScrollBase
{
public:
	TArray<class UUIDelivery_ItemListPanel*>      Items;                                             // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_List">();
	}
	static class UUIDelivery_List* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_List>();
	}
};
static_assert(alignof(UUIDelivery_List) == 0x000008, "Wrong alignment on UUIDelivery_List");
static_assert(sizeof(UUIDelivery_List) == 0x000500, "Wrong size on UUIDelivery_List");
static_assert(offsetof(UUIDelivery_List, Items) == 0x0004F0, "Member 'UUIDelivery_List::Items' has a wrong offset!");

// Class DarwinGame.FastTravelDataTable
// 0x0000 (0x0030 - 0x0030)
class UFastTravelDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FastTravelDataTable">();
	}
	static class UFastTravelDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFastTravelDataTable>();
	}
};
static_assert(alignof(UFastTravelDataTable) == 0x000008, "Wrong alignment on UFastTravelDataTable");
static_assert(sizeof(UFastTravelDataTable) == 0x000030, "Wrong size on UFastTravelDataTable");

// Class DarwinGame.FastTravelPoint
// 0x0048 (0x0270 - 0x0228)
class AFastTravelPoint final : public AActor
{
public:
	class UDataTable*                             mFastTravelDataTable;                              // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFastTravelInfo                        mFastTravelInfo;                                   // 0x0230(0x0040)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void RegisterForDataTable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FastTravelPoint">();
	}
	static class AFastTravelPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFastTravelPoint>();
	}
};
static_assert(alignof(AFastTravelPoint) == 0x000008, "Wrong alignment on AFastTravelPoint");
static_assert(sizeof(AFastTravelPoint) == 0x000270, "Wrong size on AFastTravelPoint");
static_assert(offsetof(AFastTravelPoint, mFastTravelDataTable) == 0x000228, "Member 'AFastTravelPoint::mFastTravelDataTable' has a wrong offset!");
static_assert(offsetof(AFastTravelPoint, mFastTravelInfo) == 0x000230, "Member 'AFastTravelPoint::mFastTravelInfo' has a wrong offset!");

// Class DarwinGame.FeatureBuffGameplayEffect
// 0x0000 (0x07C0 - 0x07C0)
class UFeatureBuffGameplayEffect : public UDarwinGameplayEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureBuffGameplayEffect">();
	}
	static class UFeatureBuffGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureBuffGameplayEffect>();
	}
};
static_assert(alignof(UFeatureBuffGameplayEffect) == 0x000008, "Wrong alignment on UFeatureBuffGameplayEffect");
static_assert(sizeof(UFeatureBuffGameplayEffect) == 0x0007C0, "Wrong size on UFeatureBuffGameplayEffect");

// Class DarwinGame.UITitle_WinStatus
// 0x0050 (0x0620 - 0x05D0)
class UUITitle_WinStatus final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStartup_Screen*                      LogoScreen;                                        // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle_WinAutoSave*                   AutoSave;                                          // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITitle_Load*                          LoadWindow;                                        // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x30];                                     // 0x05F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_WinStatus">();
	}
	static class UUITitle_WinStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_WinStatus>();
	}
};
static_assert(alignof(UUITitle_WinStatus) == 0x000008, "Wrong alignment on UUITitle_WinStatus");
static_assert(sizeof(UUITitle_WinStatus) == 0x000620, "Wrong size on UUITitle_WinStatus");
static_assert(offsetof(UUITitle_WinStatus, LogoScreen) == 0x0005D8, "Member 'UUITitle_WinStatus::LogoScreen' has a wrong offset!");
static_assert(offsetof(UUITitle_WinStatus, AutoSave) == 0x0005E0, "Member 'UUITitle_WinStatus::AutoSave' has a wrong offset!");
static_assert(offsetof(UUITitle_WinStatus, LoadWindow) == 0x0005E8, "Member 'UUITitle_WinStatus::LoadWindow' has a wrong offset!");

// Class DarwinGame.FeatureDataTable
// 0x0000 (0x0030 - 0x0030)
class UFeatureDataTable final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckEffectValue(class FName ID, int32 Level, float* outputValue);
	static EFeaturePositionType GetEffectPositionType(class FName ID);
	static EStatusParamType GetEffectStatusParamType(class FName ID);
	static float GetEffectValue(class FName ID, int32 Level);
	static void GetFeatureCondition(class FName ID, struct FST_Condition* Condition);
	static bool GetFeatureEffect(class FName ID, struct FST_FeatureEffect* Output);
	static EFeatureEffectType GetFeatureEffectType(class FName ID);
	static EFeatureSystemType GetFeatureSystemType(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureDataTable">();
	}
	static class UFeatureDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureDataTable>();
	}
};
static_assert(alignof(UFeatureDataTable) == 0x000008, "Wrong alignment on UFeatureDataTable");
static_assert(sizeof(UFeatureDataTable) == 0x000030, "Wrong size on UFeatureDataTable");

// Class DarwinGame.UIDictMenu
// 0x0038 (0x0508 - 0x04D0)
class UUIDictMenu : public UUILeftMenuUseBase
{
public:
	TArray<struct FST_DictMenu>                   DictCategoryList;                                  // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_BG*                        BackImage;                                         // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E8[0x20];                                     // 0x04E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDictMenu">();
	}
	static class UUIDictMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDictMenu>();
	}
};
static_assert(alignof(UUIDictMenu) == 0x000008, "Wrong alignment on UUIDictMenu");
static_assert(sizeof(UUIDictMenu) == 0x000508, "Wrong size on UUIDictMenu");
static_assert(offsetof(UUIDictMenu, DictCategoryList) == 0x0004D0, "Member 'UUIDictMenu::DictCategoryList' has a wrong offset!");
static_assert(offsetof(UUIDictMenu, BackImage) == 0x0004E0, "Member 'UUIDictMenu::BackImage' has a wrong offset!");

// Class DarwinGame.FeatureFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UFeatureFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureFunctionLibrary">();
	}
	static class UFeatureFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureFunctionLibrary>();
	}
};
static_assert(alignof(UFeatureFunctionLibrary) == 0x000008, "Wrong alignment on UFeatureFunctionLibrary");
static_assert(sizeof(UFeatureFunctionLibrary) == 0x000030, "Wrong size on UFeatureFunctionLibrary");

// Class DarwinGame.UITitle_Select_Set_Base
// 0x0018 (0x0548 - 0x0530)
class UUITitle_Select_Set_Base : public UUIScrollMenuItemBase
{
public:
	class UWidgetAnimation*                       InAnim;                                            // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayWaitAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_Select_Set_Base">();
	}
	static class UUITitle_Select_Set_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_Select_Set_Base>();
	}
};
static_assert(alignof(UUITitle_Select_Set_Base) == 0x000008, "Wrong alignment on UUITitle_Select_Set_Base");
static_assert(sizeof(UUITitle_Select_Set_Base) == 0x000548, "Wrong size on UUITitle_Select_Set_Base");
static_assert(offsetof(UUITitle_Select_Set_Base, InAnim) == 0x000530, "Member 'UUITitle_Select_Set_Base::InAnim' has a wrong offset!");

// Class DarwinGame.UIOption_Set
// 0x0000 (0x0548 - 0x0548)
class UUIOption_Set final : public UUITitle_Select_Set_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOption_Set">();
	}
	static class UUIOption_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOption_Set>();
	}
};
static_assert(alignof(UUIOption_Set) == 0x000008, "Wrong alignment on UUIOption_Set");
static_assert(sizeof(UUIOption_Set) == 0x000548, "Wrong size on UUIOption_Set");

// Class DarwinGame.FeatureHealExecution
// 0x0000 (0x0048 - 0x0048)
class UFeatureHealExecution final : public UNonActionHealExecutionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeatureHealExecution">();
	}
	static class UFeatureHealExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeatureHealExecution>();
	}
};
static_assert(alignof(UFeatureHealExecution) == 0x000008, "Wrong alignment on UFeatureHealExecution");
static_assert(sizeof(UFeatureHealExecution) == 0x000048, "Wrong size on UFeatureHealExecution");

// Class DarwinGame.FieldAreaManager
// 0x0040 (0x0070 - 0x0030)
class UFieldAreaManager : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AEnvironmentEffectBase*                 EnvEffect;                                         // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldAreaManager">();
	}
	static class UFieldAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldAreaManager>();
	}
};
static_assert(alignof(UFieldAreaManager) == 0x000008, "Wrong alignment on UFieldAreaManager");
static_assert(sizeof(UFieldAreaManager) == 0x000070, "Wrong size on UFieldAreaManager");
static_assert(offsetof(UFieldAreaManager, EnvEffect) == 0x000060, "Member 'UFieldAreaManager::EnvEffect' has a wrong offset!");

// Class DarwinGame.UIField_ActionIcon_DivePoint
// 0x0000 (0x05B0 - 0x05B0)
class UUIField_ActionIcon_DivePoint : public UUIField_ActionIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_ActionIcon_DivePoint">();
	}
	static class UUIField_ActionIcon_DivePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_ActionIcon_DivePoint>();
	}
};
static_assert(alignof(UUIField_ActionIcon_DivePoint) == 0x000010, "Wrong alignment on UUIField_ActionIcon_DivePoint");
static_assert(sizeof(UUIField_ActionIcon_DivePoint) == 0x0005B0, "Wrong size on UUIField_ActionIcon_DivePoint");

// Class DarwinGame.FieldBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UFieldBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UHierarchicalInstancedStaticMeshComponent* AddHISMComponent(class AActor* Actor);
	static class FName GetLevelNameWithActor(class AActor* TargetActor, bool* isGet);
	static struct FVector GetViewportLocation(class UObject* WorldContextObject);
	static void OnFieldReset();
	static void OnFieldResetWhenTimeZoneChanges();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldBlueprintFunctionLibrary">();
	}
	static class UFieldBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UFieldBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UFieldBlueprintFunctionLibrary");
static_assert(sizeof(UFieldBlueprintFunctionLibrary) == 0x000030, "Wrong size on UFieldBlueprintFunctionLibrary");

// Class DarwinGame.FieldComment
// 0x0040 (0x0268 - 0x0228)
class AFieldComment final : public AActor
{
public:
	bool                                          IsHidden;                                          // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECommentCategory                              Category;                                          // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextVisibility                               VisibilityType;                                    // 0x022A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B[0x1];                                      // 0x022B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextSize;                                          // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Text;                                              // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Margin;                                            // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PlaneScale;                                        // 0x0244(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUseCustomColor;                                  // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_CommentColor                       CustomCommentColor;                                // 0x0254(0x0014)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	void UpdateText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldComment">();
	}
	static class AFieldComment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldComment>();
	}
};
static_assert(alignof(AFieldComment) == 0x000008, "Wrong alignment on AFieldComment");
static_assert(sizeof(AFieldComment) == 0x000268, "Wrong size on AFieldComment");
static_assert(offsetof(AFieldComment, IsHidden) == 0x000228, "Member 'AFieldComment::IsHidden' has a wrong offset!");
static_assert(offsetof(AFieldComment, Category) == 0x000229, "Member 'AFieldComment::Category' has a wrong offset!");
static_assert(offsetof(AFieldComment, VisibilityType) == 0x00022A, "Member 'AFieldComment::VisibilityType' has a wrong offset!");
static_assert(offsetof(AFieldComment, TextSize) == 0x00022C, "Member 'AFieldComment::TextSize' has a wrong offset!");
static_assert(offsetof(AFieldComment, Text) == 0x000230, "Member 'AFieldComment::Text' has a wrong offset!");
static_assert(offsetof(AFieldComment, Margin) == 0x000240, "Member 'AFieldComment::Margin' has a wrong offset!");
static_assert(offsetof(AFieldComment, PlaneScale) == 0x000244, "Member 'AFieldComment::PlaneScale' has a wrong offset!");
static_assert(offsetof(AFieldComment, IsUseCustomColor) == 0x000250, "Member 'AFieldComment::IsUseCustomColor' has a wrong offset!");
static_assert(offsetof(AFieldComment, CustomCommentColor) == 0x000254, "Member 'AFieldComment::CustomCommentColor' has a wrong offset!");

// Class DarwinGame.UISign_IconMiss
// 0x0000 (0x05B0 - 0x05B0)
class UUISign_IconMiss : public UUI3DBase
{
public:
	void PlayOneshotMiss();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconMiss">();
	}
	static class UUISign_IconMiss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconMiss>();
	}
};
static_assert(alignof(UUISign_IconMiss) == 0x000010, "Wrong alignment on UUISign_IconMiss");
static_assert(sizeof(UUISign_IconMiss) == 0x0005B0, "Wrong size on UUISign_IconMiss");

// Class DarwinGame.FieldIntervalPopUpEffectBase
// 0x0010 (0x0248 - 0x0238)
class AFieldIntervalPopUpEffectBase : public AEnvironmentEffectBase
{
public:
	float                                         mPopUpInterval;                                    // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mRadius;                                           // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mAdjustHight;                                      // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldIntervalPopUpEffectBase">();
	}
	static class AFieldIntervalPopUpEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldIntervalPopUpEffectBase>();
	}
};
static_assert(alignof(AFieldIntervalPopUpEffectBase) == 0x000008, "Wrong alignment on AFieldIntervalPopUpEffectBase");
static_assert(sizeof(AFieldIntervalPopUpEffectBase) == 0x000248, "Wrong size on AFieldIntervalPopUpEffectBase");
static_assert(offsetof(AFieldIntervalPopUpEffectBase, mPopUpInterval) == 0x000238, "Member 'AFieldIntervalPopUpEffectBase::mPopUpInterval' has a wrong offset!");
static_assert(offsetof(AFieldIntervalPopUpEffectBase, mRadius) == 0x00023C, "Member 'AFieldIntervalPopUpEffectBase::mRadius' has a wrong offset!");
static_assert(offsetof(AFieldIntervalPopUpEffectBase, mAdjustHight) == 0x000240, "Member 'AFieldIntervalPopUpEffectBase::mAdjustHight' has a wrong offset!");

// Class DarwinGame.UIField_IconQuestLine
// 0x0048 (0x04D8 - 0x0490)
class UUIField_IconQuestLine : public UDarwinUserWidget
{
public:
	class UDataTable*                             QuestCategoryTable;                                // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GuideStartSeconds;                                 // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GuideEndSeconds;                                   // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x28];                                     // 0x04B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearQuest();
	void EndClearAnimExec();
	void PauseClearAnim();
	void PlayClearAnim();
	void PlayClearAnimFirstHalf();
	void PlayClearStampAnim();
	void SetData(const class FText& InQuestName, const class FText& InQuestTypeName);
	void SetQuestID(class FName InQuestID);
	void StartQuest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_IconQuestLine">();
	}
	static class UUIField_IconQuestLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_IconQuestLine>();
	}
};
static_assert(alignof(UUIField_IconQuestLine) == 0x000008, "Wrong alignment on UUIField_IconQuestLine");
static_assert(sizeof(UUIField_IconQuestLine) == 0x0004D8, "Wrong size on UUIField_IconQuestLine");
static_assert(offsetof(UUIField_IconQuestLine, QuestCategoryTable) == 0x000490, "Member 'UUIField_IconQuestLine::QuestCategoryTable' has a wrong offset!");
static_assert(offsetof(UUIField_IconQuestLine, GuideStartSeconds) == 0x0004A8, "Member 'UUIField_IconQuestLine::GuideStartSeconds' has a wrong offset!");
static_assert(offsetof(UUIField_IconQuestLine, GuideEndSeconds) == 0x0004AC, "Member 'UUIField_IconQuestLine::GuideEndSeconds' has a wrong offset!");

// Class DarwinGame.FieldLinkBase
// 0x0018 (0x0148 - 0x0130)
class UFieldLinkBase : public UActionStateBase
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAttachmentRule                               mLocationRule;                                     // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               mRotationRule;                                     // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentRule                               mScaleRule;                                        // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeldSimulatedBodies;                              // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        LinkTargetMoveComponent;                           // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldLinkBase">();
	}
	static class UFieldLinkBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldLinkBase>();
	}
};
static_assert(alignof(UFieldLinkBase) == 0x000008, "Wrong alignment on UFieldLinkBase");
static_assert(sizeof(UFieldLinkBase) == 0x000148, "Wrong size on UFieldLinkBase");
static_assert(offsetof(UFieldLinkBase, mLocationRule) == 0x000138, "Member 'UFieldLinkBase::mLocationRule' has a wrong offset!");
static_assert(offsetof(UFieldLinkBase, mRotationRule) == 0x000139, "Member 'UFieldLinkBase::mRotationRule' has a wrong offset!");
static_assert(offsetof(UFieldLinkBase, mScaleRule) == 0x00013A, "Member 'UFieldLinkBase::mScaleRule' has a wrong offset!");
static_assert(offsetof(UFieldLinkBase, bWeldSimulatedBodies) == 0x00013B, "Member 'UFieldLinkBase::bWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(UFieldLinkBase, LinkTargetMoveComponent) == 0x000140, "Member 'UFieldLinkBase::LinkTargetMoveComponent' has a wrong offset!");

// Class DarwinGame.UISign_IconDamageComposite
// 0x0010 (0x05C0 - 0x05B0)
class UUISign_IconDamageComposite : public UUI3DBase
{
public:
	class UUISign_IconDamageBase*                 DamageIcon;                                        // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DamageIconDataTable;                               // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBelongType(const struct FGameplayTag& Belong);
	void SetCriticalType(EDamageCriticalType CriticalType);
	void SetDamageValue(float Value);
	void SetData(float Value, const struct FGameplayTag& Belong, const struct FVector& TargetLocation, EDamageCriticalType CriticalType, EDamageSizeType SizeType);
	void SetSizeType(EDamageSizeType SizeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconDamageComposite">();
	}
	static class UUISign_IconDamageComposite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconDamageComposite>();
	}
};
static_assert(alignof(UUISign_IconDamageComposite) == 0x000010, "Wrong alignment on UUISign_IconDamageComposite");
static_assert(sizeof(UUISign_IconDamageComposite) == 0x0005C0, "Wrong size on UUISign_IconDamageComposite");
static_assert(offsetof(UUISign_IconDamageComposite, DamageIcon) == 0x0005A8, "Member 'UUISign_IconDamageComposite::DamageIcon' has a wrong offset!");
static_assert(offsetof(UUISign_IconDamageComposite, DamageIconDataTable) == 0x0005B0, "Member 'UUISign_IconDamageComposite::DamageIconDataTable' has a wrong offset!");

// Class DarwinGame.FieldLinkMenu
// 0x0000 (0x0198 - 0x0198)
class UFieldLinkMenu final : public ULinkMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldLinkMenu">();
	}
	static class UFieldLinkMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldLinkMenu>();
	}
};
static_assert(alignof(UFieldLinkMenu) == 0x000008, "Wrong alignment on UFieldLinkMenu");
static_assert(sizeof(UFieldLinkMenu) == 0x000198, "Wrong size on UFieldLinkMenu");

// Class DarwinGame.FieldObjectActiveSwitchComponent
// 0x00B0 (0x0168 - 0x00B8)
class UFieldObjectActiveSwitchComponent final : public UFieldObjectComponentBase
{
public:
	TArray<struct FActiveSwitchInfo>              mInfo;                                             // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0xA0];                                      // 0x00C8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectActiveSwitchComponent">();
	}
	static class UFieldObjectActiveSwitchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldObjectActiveSwitchComponent>();
	}
};
static_assert(alignof(UFieldObjectActiveSwitchComponent) == 0x000008, "Wrong alignment on UFieldObjectActiveSwitchComponent");
static_assert(sizeof(UFieldObjectActiveSwitchComponent) == 0x000168, "Wrong size on UFieldObjectActiveSwitchComponent");
static_assert(offsetof(UFieldObjectActiveSwitchComponent, mInfo) == 0x0000B8, "Member 'UFieldObjectActiveSwitchComponent::mInfo' has a wrong offset!");

// Class DarwinGame.UIField_Pointreader
// 0x0000 (0x0490 - 0x0490)
class UUIField_Pointreader : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_Pointreader">();
	}
	static class UUIField_Pointreader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_Pointreader>();
	}
};
static_assert(alignof(UUIField_Pointreader) == 0x000008, "Wrong alignment on UUIField_Pointreader");
static_assert(sizeof(UUIField_Pointreader) == 0x000490, "Wrong size on UUIField_Pointreader");

// Class DarwinGame.FieldObjectBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UFieldObjectBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalcDropLaunchVelocity(int32 min_dis, int32 max_dis, int32 min_height, int32 max_height, int32 Range, const struct FRotator& base_rotator);
	static struct FVector CalcDropLaunchVelocityFromAngle(float Strength, float Azimuth, float AzimuthRange, float Elevation, float ElevationRange);
	static bool CheckEventClearFromEventID(const class FName& EventID, bool IsCheckOR);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectBlueprintFunctionLibrary">();
	}
	static class UFieldObjectBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldObjectBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UFieldObjectBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UFieldObjectBlueprintFunctionLibrary");
static_assert(sizeof(UFieldObjectBlueprintFunctionLibrary) == 0x000030, "Wrong size on UFieldObjectBlueprintFunctionLibrary");

// Class DarwinGame.WarpGate
// 0x0018 (0x02C8 - 0x02B0)
class AWarpGate final : public AFieldObjectBase
{
public:
	class FName                                   TextID;                                            // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FastTravelID;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarpGate">();
	}
	static class AWarpGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWarpGate>();
	}
};
static_assert(alignof(AWarpGate) == 0x000008, "Wrong alignment on AWarpGate");
static_assert(sizeof(AWarpGate) == 0x0002C8, "Wrong size on AWarpGate");
static_assert(offsetof(AWarpGate, TextID) == 0x0002B0, "Member 'AWarpGate::TextID' has a wrong offset!");
static_assert(offsetof(AWarpGate, FastTravelID) == 0x0002B8, "Member 'AWarpGate::FastTravelID' has a wrong offset!");

// Class DarwinGame.FieldObjectGetItemDataTable
// 0x0000 (0x0030 - 0x0030)
class UFieldObjectGetItemDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectGetItemDataTable">();
	}
	static class UFieldObjectGetItemDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldObjectGetItemDataTable>();
	}
};
static_assert(alignof(UFieldObjectGetItemDataTable) == 0x000008, "Wrong alignment on UFieldObjectGetItemDataTable");
static_assert(sizeof(UFieldObjectGetItemDataTable) == 0x000030, "Wrong size on UFieldObjectGetItemDataTable");

// Class DarwinGame.UIField_SkillChainPanel
// 0x0088 (0x0518 - 0x0490)
class UUIField_SkillChainPanel : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UComputeTextBlock*                      SkillNameText;                                     // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FaceImage;                                         // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ResistanceImage;                                   // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PanelImage;                                        // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PanelImage_B;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x10];                                     // 0x0508(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_SkillChainPanel">();
	}
	static class UUIField_SkillChainPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_SkillChainPanel>();
	}
};
static_assert(alignof(UUIField_SkillChainPanel) == 0x000008, "Wrong alignment on UUIField_SkillChainPanel");
static_assert(sizeof(UUIField_SkillChainPanel) == 0x000518, "Wrong size on UUIField_SkillChainPanel");
static_assert(offsetof(UUIField_SkillChainPanel, SkillNameText) == 0x0004E0, "Member 'UUIField_SkillChainPanel::SkillNameText' has a wrong offset!");
static_assert(offsetof(UUIField_SkillChainPanel, FaceImage) == 0x0004E8, "Member 'UUIField_SkillChainPanel::FaceImage' has a wrong offset!");
static_assert(offsetof(UUIField_SkillChainPanel, ResistanceImage) == 0x0004F0, "Member 'UUIField_SkillChainPanel::ResistanceImage' has a wrong offset!");
static_assert(offsetof(UUIField_SkillChainPanel, PanelImage) == 0x0004F8, "Member 'UUIField_SkillChainPanel::PanelImage' has a wrong offset!");
static_assert(offsetof(UUIField_SkillChainPanel, PanelImage_B) == 0x000500, "Member 'UUIField_SkillChainPanel::PanelImage_B' has a wrong offset!");

// Class DarwinGame.FieldObjectManager
// 0x01D8 (0x0208 - 0x0030)
class UFieldObjectManager : public UObject
{
public:
	TMap<class AItemObjectBase*, float>           mItemObjectList;                                   // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class AFieldObjectBase*>               mSpawnFieldObjectList;                             // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class AFieldObjectBase*>    mObjectList;                                       // 0x0090(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class AFieldObjectBase*>               mHasDayNightSwitchingComponetObjectList;           // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESpawnFieldObjectID, TSoftClassPtr<class UClass>> mLoadClassList;                                    // 0x0140(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x24];                                     // 0x0190(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemObjectRegistMax;                               // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemObjectLifeTime;                                // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemObjectDeleteDistance;                          // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             mSpawnFieldObjectTable;                            // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATrainBase*                             TrainObject;                                       // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   mSimpleDisplayBoxCollisionClass;                   // 0x01E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ACoinObjectBase* DropCoinFromCoinParamAttachActor(const struct FST_CoinParam& CoinData, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* DropCoinFromCoinParamAttachComponent(const struct FST_CoinParam& CoinData, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* DropCoinFromMonsterInfo(int32 Level, int32 KindId, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ACoinObjectBase* DropCoinFromMonsterInfoAttachActor(int32 Level, int32 KindId, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* DropCoinFromMonsterInfoAttachComponent(int32 Level, int32 KindId, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ADropItemObject* DropItem(const class FName ItemId, const int32 ItemCount, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ADropItemObject* DropItemAttachActor(const class FName ItemId, const int32 ItemCount, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ADropItemObject* DropItemAttachComponent(const class FName ItemId, const int32 ItemCount, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ATreasureMapObjectBase* DropTreasureMap(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ATreasureMapObjectBase* DropTreasureMapAttachActor(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ATreasureMapObjectBase* DropTreasureMapAttachComponent(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	TSoftClassPtr<class UClass> GetActorClass(const ESpawnFieldObjectID ID);
	TArray<class AArtifactObjectBase*> GetSpawnArtifactList();
	class ATrainBase* GetTrainObject();
	void HideAllItemObject();
	void ReflectionReleaseStatus(const class FName& ID, bool IsRelease, bool IsSkip, bool IsOtherSkip);
	void ShowAllItemObject();
	class AFieldObjectBase* SpawnAttachActor(const ESpawnFieldObjectID ID, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class AFieldObjectBase* SpawnAttachComponent(const ESpawnFieldObjectID ID, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* SpawnCoinFromCoinParam(const struct FST_CoinParam& CoinData, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ACoinObjectBase* SpawnCoinFromCoinParamAttachActor(const struct FST_CoinParam& CoinData, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* SpawnCoinFromCoinParamAttachComponent(const struct FST_CoinParam& CoinData, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* SpawnCoinFromMonsterInfo(int32 Level, int32 KindId, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ACoinObjectBase* SpawnCoinFromMonsterInfoAttachActor(int32 Level, int32 KindId, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ACoinObjectBase* SpawnCoinFromMonsterInfoAttachComponent(int32 Level, int32 KindId, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class AFieldObjectBase* SpawnFieldObject(const ESpawnFieldObjectID ID, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class AItemObjectBase* SpawnItem(const class FName ItemId, const int32 ItemCount, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class AItemObjectBase* SpawnItemAttachActor(const class FName ItemId, const int32 ItemCount, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class AItemObjectBase* SpawnItemAttachComponent(const class FName ItemId, const int32 ItemCount, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class APushWaveBase* SpawnPushWave(const struct FVector& Size, int32 SplitNum, float Speed, float Distance, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ATreasureMapObjectBase* SpawnTreasureMap(const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale);
	class ATreasureMapObjectBase* SpawnTreasureMapAttachActor(class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);
	class ATreasureMapObjectBase* SpawnTreasureMapAttachComponent(class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale);

	class AFieldObjectBase* FindObject(const class FName& ID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldObjectManager">();
	}
	static class UFieldObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldObjectManager>();
	}
};
static_assert(alignof(UFieldObjectManager) == 0x000008, "Wrong alignment on UFieldObjectManager");
static_assert(sizeof(UFieldObjectManager) == 0x000208, "Wrong size on UFieldObjectManager");
static_assert(offsetof(UFieldObjectManager, mItemObjectList) == 0x000030, "Member 'UFieldObjectManager::mItemObjectList' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, mSpawnFieldObjectList) == 0x000080, "Member 'UFieldObjectManager::mSpawnFieldObjectList' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, mObjectList) == 0x000090, "Member 'UFieldObjectManager::mObjectList' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, mHasDayNightSwitchingComponetObjectList) == 0x0000E0, "Member 'UFieldObjectManager::mHasDayNightSwitchingComponetObjectList' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, mLoadClassList) == 0x000140, "Member 'UFieldObjectManager::mLoadClassList' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, ItemObjectRegistMax) == 0x0001B4, "Member 'UFieldObjectManager::ItemObjectRegistMax' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, ItemObjectLifeTime) == 0x0001B8, "Member 'UFieldObjectManager::ItemObjectLifeTime' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, ItemObjectDeleteDistance) == 0x0001BC, "Member 'UFieldObjectManager::ItemObjectDeleteDistance' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, mSpawnFieldObjectTable) == 0x0001C0, "Member 'UFieldObjectManager::mSpawnFieldObjectTable' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, TrainObject) == 0x0001C8, "Member 'UFieldObjectManager::TrainObject' has a wrong offset!");
static_assert(offsetof(UFieldObjectManager, mSimpleDisplayBoxCollisionClass) == 0x0001E0, "Member 'UFieldObjectManager::mSimpleDisplayBoxCollisionClass' has a wrong offset!");

// Class DarwinGame.UserWidgetArray
// 0x0018 (0x0048 - 0x0030)
class UUserWidgetArray final : public UObject
{
public:
	TArray<class UDarwinUserWidget*>              Data;                                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidgetArray">();
	}
	static class UUserWidgetArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidgetArray>();
	}
};
static_assert(alignof(UUserWidgetArray) == 0x000008, "Wrong alignment on UUserWidgetArray");
static_assert(sizeof(UUserWidgetArray) == 0x000048, "Wrong size on UUserWidgetArray");
static_assert(offsetof(UUserWidgetArray, Data) == 0x000030, "Member 'UUserWidgetArray::Data' has a wrong offset!");

// Class DarwinGame.FieldRiverBase
// 0x0030 (0x0320 - 0x02F0)
class AFieldRiverBase final : public ASplineMeshObject
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFieldTerrainType                             TerrainType;                                       // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsWork;                                            // 0x02F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceMove;                                        // 0x02FA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FB[0x1];                                      // 0x02FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceSpeed;                                        // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSink;                                             // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSinkValue;                                      // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SinkSpeed;                                         // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SinkCorrectedRange;                                // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyDamage;                                      // 0x0310(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EResistanceType                               Type;                                              // 0x0311(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFieldTerrainEffectType                       EffectType;                                        // 0x0312(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_313[0x1];                                      // 0x0313(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Interval;                                          // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         damageRate;                                        // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoolTime;                                          // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldRiverBase">();
	}
	static class AFieldRiverBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldRiverBase>();
	}
};
static_assert(alignof(AFieldRiverBase) == 0x000008, "Wrong alignment on AFieldRiverBase");
static_assert(sizeof(AFieldRiverBase) == 0x000320, "Wrong size on AFieldRiverBase");
static_assert(offsetof(AFieldRiverBase, TerrainType) == 0x0002F8, "Member 'AFieldRiverBase::TerrainType' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, IsWork) == 0x0002F9, "Member 'AFieldRiverBase::IsWork' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, bForceMove) == 0x0002FA, "Member 'AFieldRiverBase::bForceMove' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, ForceSpeed) == 0x0002FC, "Member 'AFieldRiverBase::ForceSpeed' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, bSink) == 0x000300, "Member 'AFieldRiverBase::bSink' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, MaxSinkValue) == 0x000304, "Member 'AFieldRiverBase::MaxSinkValue' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, SinkSpeed) == 0x000308, "Member 'AFieldRiverBase::SinkSpeed' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, SinkCorrectedRange) == 0x00030C, "Member 'AFieldRiverBase::SinkCorrectedRange' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, bApplyDamage) == 0x000310, "Member 'AFieldRiverBase::bApplyDamage' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, Type) == 0x000311, "Member 'AFieldRiverBase::Type' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, EffectType) == 0x000312, "Member 'AFieldRiverBase::EffectType' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, Interval) == 0x000314, "Member 'AFieldRiverBase::Interval' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, damageRate) == 0x000318, "Member 'AFieldRiverBase::damageRate' has a wrong offset!");
static_assert(offsetof(AFieldRiverBase, CoolTime) == 0x00031C, "Member 'AFieldRiverBase::CoolTime' has a wrong offset!");

// Class DarwinGame.UIDispatch_Station_Root
// 0x0050 (0x0520 - 0x04D0)
class UUIDispatch_Station_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x50];                                     // 0x04D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Station_Root">();
	}
	static class UUIDispatch_Station_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Station_Root>();
	}
};
static_assert(alignof(UUIDispatch_Station_Root) == 0x000008, "Wrong alignment on UUIDispatch_Station_Root");
static_assert(sizeof(UUIDispatch_Station_Root) == 0x000520, "Wrong size on UUIDispatch_Station_Root");

// Class DarwinGame.FieldStuckPointCheckObject
// 0x0128 (0x0350 - 0x0228)
class AFieldStuckPointCheckObject final : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x60];                                     // 0x0230(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 mPlayerClass;                                      // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0xB8];                                     // 0x0298(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldStuckPointCheckObject">();
	}
	static class AFieldStuckPointCheckObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFieldStuckPointCheckObject>();
	}
};
static_assert(alignof(AFieldStuckPointCheckObject) == 0x000008, "Wrong alignment on AFieldStuckPointCheckObject");
static_assert(sizeof(AFieldStuckPointCheckObject) == 0x000350, "Wrong size on AFieldStuckPointCheckObject");
static_assert(offsetof(AFieldStuckPointCheckObject, RootComp) == 0x000228, "Member 'AFieldStuckPointCheckObject::RootComp' has a wrong offset!");
static_assert(offsetof(AFieldStuckPointCheckObject, mPlayerClass) == 0x000290, "Member 'AFieldStuckPointCheckObject::mPlayerClass' has a wrong offset!");

// Class DarwinGame.FieldStuntInterface
// 0x0000 (0x0030 - 0x0030)
class IFieldStuntInterface final : public IInterface
{
public:
	bool IsAllowClimbing() const;
	bool IsAllowParkour() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldStuntInterface">();
	}
	static class IFieldStuntInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFieldStuntInterface>();
	}
};
static_assert(alignof(IFieldStuntInterface) == 0x000008, "Wrong alignment on IFieldStuntInterface");
static_assert(sizeof(IFieldStuntInterface) == 0x000030, "Wrong size on IFieldStuntInterface");

// Class DarwinGame.UIStaff_Roll_Name_2
// 0x0000 (0x0490 - 0x0490)
class UUIStaff_Roll_Name_2 final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_Name_2">();
	}
	static class UUIStaff_Roll_Name_2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_Name_2>();
	}
};
static_assert(alignof(UUIStaff_Roll_Name_2) == 0x000008, "Wrong alignment on UUIStaff_Roll_Name_2");
static_assert(sizeof(UUIStaff_Roll_Name_2) == 0x000490, "Wrong size on UUIStaff_Roll_Name_2");

// Class DarwinGame.FieldTerrainInterface
// 0x0000 (0x0030 - 0x0030)
class IFieldTerrainInterface final : public IInterface
{
public:
	void OnReceiveHitByTerrain(class AActor* OtherActor, const struct FHitResult& Hit);
	void SetForceSpeed(float Speed);
	void SetWorking(bool State);

	EFieldTerrainType GetTerrainType() const;
	bool IsWorking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldTerrainInterface">();
	}
	static class IFieldTerrainInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFieldTerrainInterface>();
	}
};
static_assert(alignof(IFieldTerrainInterface) == 0x000008, "Wrong alignment on IFieldTerrainInterface");
static_assert(sizeof(IFieldTerrainInterface) == 0x000030, "Wrong size on IFieldTerrainInterface");

// Class DarwinGame.UIDrop_Panel_01
// 0x0000 (0x0490 - 0x0490)
class UUIDrop_Panel_01 : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDrop_Panel_01">();
	}
	static class UUIDrop_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDrop_Panel_01>();
	}
};
static_assert(alignof(UUIDrop_Panel_01) == 0x000008, "Wrong alignment on UUIDrop_Panel_01");
static_assert(sizeof(UUIDrop_Panel_01) == 0x000490, "Wrong size on UUIDrop_Panel_01");

// Class DarwinGame.FixCoinObjectBase
// 0x0020 (0x02D0 - 0x02B0)
class AFixCoinObjectBase final : public AFieldObjectBase
{
public:
	int32                                         CoinTableID;                                       // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoinRarity                                   Rarity;                                            // 0x02B4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_CoinParam>                  CoinParams;                                        // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsShowUI;                                          // 0x02C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixCoinObjectBase">();
	}
	static class AFixCoinObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFixCoinObjectBase>();
	}
};
static_assert(alignof(AFixCoinObjectBase) == 0x000008, "Wrong alignment on AFixCoinObjectBase");
static_assert(sizeof(AFixCoinObjectBase) == 0x0002D0, "Wrong size on AFixCoinObjectBase");
static_assert(offsetof(AFixCoinObjectBase, CoinTableID) == 0x0002B0, "Member 'AFixCoinObjectBase::CoinTableID' has a wrong offset!");
static_assert(offsetof(AFixCoinObjectBase, Rarity) == 0x0002B4, "Member 'AFixCoinObjectBase::Rarity' has a wrong offset!");
static_assert(offsetof(AFixCoinObjectBase, CoinParams) == 0x0002B8, "Member 'AFixCoinObjectBase::CoinParams' has a wrong offset!");
static_assert(offsetof(AFixCoinObjectBase, IsShowUI) == 0x0002C8, "Member 'AFixCoinObjectBase::IsShowUI' has a wrong offset!");

// Class DarwinGame.FlagMaterialDataAsset
// 0x00A0 (0x00D8 - 0x0038)
class UFlagMaterialDataAsset final : public UDataAsset
{
public:
	TMap<int32, struct FFlagMaterialRefByType>    mTeamFlagMaterialRefMap;                           // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<ERivalTeamForce, struct FFlagMaterialRefByType> mRivalTeamFlagMaterialRefMap;                      // 0x0088(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagMaterialDataAsset">();
	}
	static class UFlagMaterialDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagMaterialDataAsset>();
	}
};
static_assert(alignof(UFlagMaterialDataAsset) == 0x000008, "Wrong alignment on UFlagMaterialDataAsset");
static_assert(sizeof(UFlagMaterialDataAsset) == 0x0000D8, "Wrong size on UFlagMaterialDataAsset");
static_assert(offsetof(UFlagMaterialDataAsset, mTeamFlagMaterialRefMap) == 0x000038, "Member 'UFlagMaterialDataAsset::mTeamFlagMaterialRefMap' has a wrong offset!");
static_assert(offsetof(UFlagMaterialDataAsset, mRivalTeamFlagMaterialRefMap) == 0x000088, "Member 'UFlagMaterialDataAsset::mRivalTeamFlagMaterialRefMap' has a wrong offset!");

// Class DarwinGame.FlexibleDoorOpenAnimInstance
// 0x0000 (0x0270 - 0x0270)
class UFlexibleDoorOpenAnimInstance final : public UModeAnimInstance
{
public:
	void PlayBackOpen();
	void PlayClose();
	void PlayFrontOpen();
	void SetBackOpen();
	void SetClose();
	void SetFrontOpen();

	bool IsBackOpenAndPlayAnimation() const;
	bool IsBackOpenAndSkipAnimation() const;
	bool IsCloseAndPlayAnimation() const;
	bool IsCloseAndSkipAnimation() const;
	bool IsFrontOpenAndPlayAnimation() const;
	bool IsFrontOpenAndSkipAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlexibleDoorOpenAnimInstance">();
	}
	static class UFlexibleDoorOpenAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlexibleDoorOpenAnimInstance>();
	}
};
static_assert(alignof(UFlexibleDoorOpenAnimInstance) == 0x000010, "Wrong alignment on UFlexibleDoorOpenAnimInstance");
static_assert(sizeof(UFlexibleDoorOpenAnimInstance) == 0x000270, "Wrong size on UFlexibleDoorOpenAnimInstance");

// Class DarwinGame.FoodEffectDataTable
// 0x0000 (0x0030 - 0x0030)
class UFoodEffectDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoodEffectDataTable">();
	}
	static class UFoodEffectDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoodEffectDataTable>();
	}
};
static_assert(alignof(UFoodEffectDataTable) == 0x000008, "Wrong alignment on UFoodEffectDataTable");
static_assert(sizeof(UFoodEffectDataTable) == 0x000030, "Wrong size on UFoodEffectDataTable");

// Class DarwinGame.UIValueFlash_00
// 0x0000 (0x0490 - 0x0490)
class UUIValueFlash_00 final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIValueFlash_00">();
	}
	static class UUIValueFlash_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIValueFlash_00>();
	}
};
static_assert(alignof(UUIValueFlash_00) == 0x000008, "Wrong alignment on UUIValueFlash_00");
static_assert(sizeof(UUIValueFlash_00) == 0x000490, "Wrong size on UUIValueFlash_00");

// Class DarwinGame.FoodFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UFoodFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoodFunctionLibrary">();
	}
	static class UFoodFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoodFunctionLibrary>();
	}
};
static_assert(alignof(UFoodFunctionLibrary) == 0x000008, "Wrong alignment on UFoodFunctionLibrary");
static_assert(sizeof(UFoodFunctionLibrary) == 0x000030, "Wrong size on UFoodFunctionLibrary");

// Class DarwinGame.UIEstimate_FlavorText
// 0x0000 (0x0490 - 0x0490)
class UUIEstimate_FlavorText final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_FlavorText">();
	}
	static class UUIEstimate_FlavorText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_FlavorText>();
	}
};
static_assert(alignof(UUIEstimate_FlavorText) == 0x000008, "Wrong alignment on UUIEstimate_FlavorText");
static_assert(sizeof(UUIEstimate_FlavorText) == 0x000490, "Wrong size on UUIEstimate_FlavorText");

// Class DarwinGame.FoodHealExecution
// 0x0000 (0x0048 - 0x0048)
class UFoodHealExecution final : public UNonActionHealExecutionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoodHealExecution">();
	}
	static class UFoodHealExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoodHealExecution>();
	}
};
static_assert(alignof(UFoodHealExecution) == 0x000008, "Wrong alignment on UFoodHealExecution");
static_assert(sizeof(UFoodHealExecution) == 0x000048, "Wrong size on UFoodHealExecution");

// Class DarwinGame.UIUnknownArtifact_Hub
// 0x0008 (0x0498 - 0x0490)
class UUIUnknownArtifact_Hub : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUnknownArtifact_Hub">();
	}
	static class UUIUnknownArtifact_Hub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUnknownArtifact_Hub>();
	}
};
static_assert(alignof(UUIUnknownArtifact_Hub) == 0x000008, "Wrong alignment on UUIUnknownArtifact_Hub");
static_assert(sizeof(UUIUnknownArtifact_Hub) == 0x000498, "Wrong size on UUIUnknownArtifact_Hub");

// Class DarwinGame.FoodTimeTrigerCue
// 0x0030 (0x02C8 - 0x0298)
class AFoodTimeTrigerCue : public AGameplayCueNotify_Actor
{
public:
	float                                         mEmoteTime;                                        // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x2C];                                     // 0x029C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoodTimeTrigerCue">();
	}
	static class AFoodTimeTrigerCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoodTimeTrigerCue>();
	}
};
static_assert(alignof(AFoodTimeTrigerCue) == 0x000008, "Wrong alignment on AFoodTimeTrigerCue");
static_assert(sizeof(AFoodTimeTrigerCue) == 0x0002C8, "Wrong size on AFoodTimeTrigerCue");
static_assert(offsetof(AFoodTimeTrigerCue, mEmoteTime) == 0x000298, "Member 'AFoodTimeTrigerCue::mEmoteTime' has a wrong offset!");

// Class DarwinGame.UIContentMenu_Page05
// 0x0010 (0x0620 - 0x0610)
class UUIContentMenu_Page05 : public UUIPartyMenu_PMR_Page_Base
{
public:
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Page05">();
	}
	static class UUIContentMenu_Page05* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Page05>();
	}
};
static_assert(alignof(UUIContentMenu_Page05) == 0x000008, "Wrong alignment on UUIContentMenu_Page05");
static_assert(sizeof(UUIContentMenu_Page05) == 0x000620, "Wrong size on UUIContentMenu_Page05");

// Class DarwinGame.FootprintDataAsset
// 0x0050 (0x0088 - 0x0038)
class UFootprintDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<EPhysicalSurfaceEffectTypeID, struct FFootPrintResorce> FootPrintMatrials;                                 // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootprintDataAsset">();
	}
	static class UFootprintDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootprintDataAsset>();
	}
};
static_assert(alignof(UFootprintDataAsset) == 0x000008, "Wrong alignment on UFootprintDataAsset");
static_assert(sizeof(UFootprintDataAsset) == 0x000088, "Wrong size on UFootprintDataAsset");
static_assert(offsetof(UFootprintDataAsset, FootPrintMatrials) == 0x000038, "Member 'UFootprintDataAsset::FootPrintMatrials' has a wrong offset!");

// Class DarwinGame.ForcedBattleAreaDataAsset
// 0x0050 (0x0088 - 0x0038)
class UForcedBattleAreaDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_ForcedBattleAreaDataTable> list;                                              // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForcedBattleAreaDataAsset">();
	}
	static class UForcedBattleAreaDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForcedBattleAreaDataAsset>();
	}
};
static_assert(alignof(UForcedBattleAreaDataAsset) == 0x000008, "Wrong alignment on UForcedBattleAreaDataAsset");
static_assert(sizeof(UForcedBattleAreaDataAsset) == 0x000088, "Wrong size on UForcedBattleAreaDataAsset");
static_assert(offsetof(UForcedBattleAreaDataAsset, list) == 0x000038, "Member 'UForcedBattleAreaDataAsset::list' has a wrong offset!");

// Class DarwinGame.ForcedBattleAreaLibrary
// 0x0000 (0x0030 - 0x0030)
class UForcedBattleAreaLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForcedBattleAreaLibrary">();
	}
	static class UForcedBattleAreaLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForcedBattleAreaLibrary>();
	}
};
static_assert(alignof(UForcedBattleAreaLibrary) == 0x000008, "Wrong alignment on UForcedBattleAreaLibrary");
static_assert(sizeof(UForcedBattleAreaLibrary) == 0x000030, "Wrong size on UForcedBattleAreaLibrary");

// Class DarwinGame.UIStation_MonsterIconFrame
// 0x0068 (0x0560 - 0x04F8)
class UUIStation_MonsterIconFrame final : public UUIStartLoopAnimation
{
public:
	TMap<ECategoryMatchType, class UTexture2D*>   FrameDataList;                                     // 0x04F8(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ImageMaterial;                                     // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_MonsterIconFrame">();
	}
	static class UUIStation_MonsterIconFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_MonsterIconFrame>();
	}
};
static_assert(alignof(UUIStation_MonsterIconFrame) == 0x000008, "Wrong alignment on UUIStation_MonsterIconFrame");
static_assert(sizeof(UUIStation_MonsterIconFrame) == 0x000560, "Wrong size on UUIStation_MonsterIconFrame");
static_assert(offsetof(UUIStation_MonsterIconFrame, FrameDataList) == 0x0004F8, "Member 'UUIStation_MonsterIconFrame::FrameDataList' has a wrong offset!");
static_assert(offsetof(UUIStation_MonsterIconFrame, ImageMaterial) == 0x000548, "Member 'UUIStation_MonsterIconFrame::ImageMaterial' has a wrong offset!");

// Class DarwinGame.ForcedBattleAreaManager
// 0x0030 (0x0060 - 0x0030)
class UForcedBattleAreaManager : public UObject
{
public:
	TArray<class AForcedBattleAreaBase*>          AreaList;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABoxForcedBattleArea>       BoxForcedBattleAreaClass;                          // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACylinderForcedBattleArea>  CylinderForcedBattleAreaClass;                     // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AWallForcedBattleArea>      WallForcedBattleAreaClass;                         // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForcedBattleAreaDataAsset*             ForcedBattleAreaAsset;                             // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RemoveAll();
	class AForcedBattleAreaBase* Spawn(class FName ID, const struct FVector& Location, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForcedBattleAreaManager">();
	}
	static class UForcedBattleAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForcedBattleAreaManager>();
	}
};
static_assert(alignof(UForcedBattleAreaManager) == 0x000008, "Wrong alignment on UForcedBattleAreaManager");
static_assert(sizeof(UForcedBattleAreaManager) == 0x000060, "Wrong size on UForcedBattleAreaManager");
static_assert(offsetof(UForcedBattleAreaManager, AreaList) == 0x000030, "Member 'UForcedBattleAreaManager::AreaList' has a wrong offset!");
static_assert(offsetof(UForcedBattleAreaManager, BoxForcedBattleAreaClass) == 0x000040, "Member 'UForcedBattleAreaManager::BoxForcedBattleAreaClass' has a wrong offset!");
static_assert(offsetof(UForcedBattleAreaManager, CylinderForcedBattleAreaClass) == 0x000048, "Member 'UForcedBattleAreaManager::CylinderForcedBattleAreaClass' has a wrong offset!");
static_assert(offsetof(UForcedBattleAreaManager, WallForcedBattleAreaClass) == 0x000050, "Member 'UForcedBattleAreaManager::WallForcedBattleAreaClass' has a wrong offset!");
static_assert(offsetof(UForcedBattleAreaManager, ForcedBattleAreaAsset) == 0x000058, "Member 'UForcedBattleAreaManager::ForcedBattleAreaAsset' has a wrong offset!");

// Class DarwinGame.UICorrection_00
// 0x0028 (0x04B8 - 0x0490)
class UUICorrection_00 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBonus_Points_00*                     Points;                                            // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIAppraise_Popup*                      Popup;                                             // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BonusInFunction();
	void InAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICorrection_00">();
	}
	static class UUICorrection_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICorrection_00>();
	}
};
static_assert(alignof(UUICorrection_00) == 0x000008, "Wrong alignment on UUICorrection_00");
static_assert(sizeof(UUICorrection_00) == 0x0004B8, "Wrong size on UUICorrection_00");
static_assert(offsetof(UUICorrection_00, Points) == 0x0004A0, "Member 'UUICorrection_00::Points' has a wrong offset!");
static_assert(offsetof(UUICorrection_00, Popup) == 0x0004A8, "Member 'UUICorrection_00::Popup' has a wrong offset!");

// Class DarwinGame.UIStation_ContentWin
// 0x0068 (0x0528 - 0x04C0)
class UUIStation_ContentWin final : public UUITabLRBase
{
public:
	uint8                                         Pad_4C0[0x50];                                     // 0x04C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIStation_AffinityText*>        AffinityTextList;                                  // 0x0510(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x8];                                      // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(EAreaType InFocusArea, const TArray<int32>& PartyUids);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_ContentWin">();
	}
	static class UUIStation_ContentWin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_ContentWin>();
	}
};
static_assert(alignof(UUIStation_ContentWin) == 0x000008, "Wrong alignment on UUIStation_ContentWin");
static_assert(sizeof(UUIStation_ContentWin) == 0x000528, "Wrong size on UUIStation_ContentWin");
static_assert(offsetof(UUIStation_ContentWin, AffinityTextList) == 0x000510, "Member 'UUIStation_ContentWin::AffinityTextList' has a wrong offset!");

// Class DarwinGame.EndConditionOfWin
// 0x0008 (0x0248 - 0x0240)
class AEndConditionOfWin final : public AForcedBattleEndCondition
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndConditionOfWin">();
	}
	static class AEndConditionOfWin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndConditionOfWin>();
	}
};
static_assert(alignof(AEndConditionOfWin) == 0x000008, "Wrong alignment on AEndConditionOfWin");
static_assert(sizeof(AEndConditionOfWin) == 0x000248, "Wrong size on AEndConditionOfWin");

// Class DarwinGame.EndConditionOfLose
// 0x0008 (0x0248 - 0x0240)
class AEndConditionOfLose final : public AForcedBattleEndCondition
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndConditionOfLose">();
	}
	static class AEndConditionOfLose* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndConditionOfLose>();
	}
};
static_assert(alignof(AEndConditionOfLose) == 0x000008, "Wrong alignment on AEndConditionOfLose");
static_assert(sizeof(AEndConditionOfLose) == 0x000248, "Wrong size on AEndConditionOfLose");

// Class DarwinGame.UICursor_PartymenuFuelBase
// 0x0010 (0x05F8 - 0x05E8)
class UUICursor_PartymenuFuelBase : public UUICursor_PartymenuBase
{
public:
	bool                                          EnableFuel;                                        // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E9[0x7];                                      // 0x05E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIGlutGaugeBase*                       GlutGauge;                                         // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_PartymenuFuelBase">();
	}
	static class UUICursor_PartymenuFuelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_PartymenuFuelBase>();
	}
};
static_assert(alignof(UUICursor_PartymenuFuelBase) == 0x000008, "Wrong alignment on UUICursor_PartymenuFuelBase");
static_assert(sizeof(UUICursor_PartymenuFuelBase) == 0x0005F8, "Wrong size on UUICursor_PartymenuFuelBase");
static_assert(offsetof(UUICursor_PartymenuFuelBase, EnableFuel) == 0x0005E8, "Member 'UUICursor_PartymenuFuelBase::EnableFuel' has a wrong offset!");
static_assert(offsetof(UUICursor_PartymenuFuelBase, GlutGauge) == 0x0005F0, "Member 'UUICursor_PartymenuFuelBase::GlutGauge' has a wrong offset!");

// Class DarwinGame.UICursor_Partymenu_01
// 0x0000 (0x05F8 - 0x05F8)
class UUICursor_Partymenu_01 : public UUICursor_PartymenuFuelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_01">();
	}
	static class UUICursor_Partymenu_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_01>();
	}
};
static_assert(alignof(UUICursor_Partymenu_01) == 0x000008, "Wrong alignment on UUICursor_Partymenu_01");
static_assert(sizeof(UUICursor_Partymenu_01) == 0x0005F8, "Wrong size on UUICursor_Partymenu_01");

// Class DarwinGame.EndConditionOfGetItem
// 0x0010 (0x0250 - 0x0240)
class AEndConditionOfGetItem final : public AForcedBattleEndCondition
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndConditionOfGetItem">();
	}
	static class AEndConditionOfGetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndConditionOfGetItem>();
	}
};
static_assert(alignof(AEndConditionOfGetItem) == 0x000008, "Wrong alignment on AEndConditionOfGetItem");
static_assert(sizeof(AEndConditionOfGetItem) == 0x000250, "Wrong size on AEndConditionOfGetItem");

// Class DarwinGame.EndConditionOfEnemyDamage
// 0x0008 (0x0248 - 0x0240)
class AEndConditionOfEnemyDamage final : public AForcedBattleEndCondition
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndConditionOfEnemyDamage">();
	}
	static class AEndConditionOfEnemyDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndConditionOfEnemyDamage>();
	}
};
static_assert(alignof(AEndConditionOfEnemyDamage) == 0x000008, "Wrong alignment on AEndConditionOfEnemyDamage");
static_assert(sizeof(AEndConditionOfEnemyDamage) == 0x000248, "Wrong size on AEndConditionOfEnemyDamage");

// Class DarwinGame.UITalk_WinStatusBase
// 0x0080 (0x0510 - 0x0490)
class UUITalk_WinStatusBase : public UDarwinUserWidget
{
public:
	bool                                          bIsEnableInputEventAtOpen;                         // 0x0490(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            TextWidget;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITalk_Arrow*                          TalkArrow;                                         // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageSpeech;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              TalkFrameWinTexture;                               // 0x04B0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              TalkWinTexture;                                    // 0x04D8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidgetData*                        TextWidgetData;                                    // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITalk_WinStatusBase">();
	}
	static class UUITalk_WinStatusBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITalk_WinStatusBase>();
	}
};
static_assert(alignof(UUITalk_WinStatusBase) == 0x000008, "Wrong alignment on UUITalk_WinStatusBase");
static_assert(sizeof(UUITalk_WinStatusBase) == 0x000510, "Wrong size on UUITalk_WinStatusBase");
static_assert(offsetof(UUITalk_WinStatusBase, bIsEnableInputEventAtOpen) == 0x000490, "Member 'UUITalk_WinStatusBase::bIsEnableInputEventAtOpen' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatusBase, TextWidget) == 0x000498, "Member 'UUITalk_WinStatusBase::TextWidget' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatusBase, TalkArrow) == 0x0004A0, "Member 'UUITalk_WinStatusBase::TalkArrow' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatusBase, ImageSpeech) == 0x0004A8, "Member 'UUITalk_WinStatusBase::ImageSpeech' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatusBase, TalkFrameWinTexture) == 0x0004B0, "Member 'UUITalk_WinStatusBase::TalkFrameWinTexture' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatusBase, TalkWinTexture) == 0x0004D8, "Member 'UUITalk_WinStatusBase::TalkWinTexture' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatusBase, TextWidgetData) == 0x000500, "Member 'UUITalk_WinStatusBase::TextWidgetData' has a wrong offset!");

// Class DarwinGame.UITalk_WinStatus
// 0x01B0 (0x06C0 - 0x0510)
class UUITalk_WinStatus : public UUITalk_WinStatusBase
{
public:
	TMulticastInlineDelegate<void()>              LipSyncStartEventDispatcher;                       // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              LipSyncEndEventDispatcher;                         // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            TalkerImageIndexWithWidth;                         // 0x0540(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UImage*                                 ImageNarration;                                    // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageNoName;                                       // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           CanvasPanelTalker;                                 // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         TalkerFontInfo;                                    // 0x05B0(0x0050)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TalkerFontColor;                                   // 0x0600(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              TalkerShadowOffset;                                // 0x0610(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TalkerShadowColor;                                 // 0x0618(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x80];                                     // 0x0628(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageSpeech1;                                      // 0x06A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageSpeech2;                                      // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageSpeech3;                                      // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChoiceSetData(const struct FChoiceWindowData& Data, bool DirectMessage);
	void SetSystemTextDataFromBP(const class FString& messageText, bool InputReset);
	void VisibleChoiceWindow();
	void WriteSentence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITalk_WinStatus">();
	}
	static class UUITalk_WinStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITalk_WinStatus>();
	}
};
static_assert(alignof(UUITalk_WinStatus) == 0x000008, "Wrong alignment on UUITalk_WinStatus");
static_assert(sizeof(UUITalk_WinStatus) == 0x0006C0, "Wrong size on UUITalk_WinStatus");
static_assert(offsetof(UUITalk_WinStatus, LipSyncStartEventDispatcher) == 0x000510, "Member 'UUITalk_WinStatus::LipSyncStartEventDispatcher' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, LipSyncEndEventDispatcher) == 0x000520, "Member 'UUITalk_WinStatus::LipSyncEndEventDispatcher' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, TalkerImageIndexWithWidth) == 0x000540, "Member 'UUITalk_WinStatus::TalkerImageIndexWithWidth' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, ImageNarration) == 0x000590, "Member 'UUITalk_WinStatus::ImageNarration' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, ImageNoName) == 0x000598, "Member 'UUITalk_WinStatus::ImageNoName' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, CanvasPanelTalker) == 0x0005A0, "Member 'UUITalk_WinStatus::CanvasPanelTalker' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, TalkerFontInfo) == 0x0005B0, "Member 'UUITalk_WinStatus::TalkerFontInfo' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, TalkerFontColor) == 0x000600, "Member 'UUITalk_WinStatus::TalkerFontColor' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, TalkerShadowOffset) == 0x000610, "Member 'UUITalk_WinStatus::TalkerShadowOffset' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, TalkerShadowColor) == 0x000618, "Member 'UUITalk_WinStatus::TalkerShadowColor' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, ImageSpeech1) == 0x0006A8, "Member 'UUITalk_WinStatus::ImageSpeech1' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, ImageSpeech2) == 0x0006B0, "Member 'UUITalk_WinStatus::ImageSpeech2' has a wrong offset!");
static_assert(offsetof(UUITalk_WinStatus, ImageSpeech3) == 0x0006B8, "Member 'UUITalk_WinStatus::ImageSpeech3' has a wrong offset!");

// Class DarwinGame.ForcedBattlePlayer
// 0x00C8 (0x02F0 - 0x0228)
class AForcedBattlePlayer final : public AActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AForcedBattleAreaBase*>          mAreas;                                            // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, class AMonsterBase*>             mMonsterTemps;                                     // 0x0250(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class AForcedBattleEndCondition*>      mEndConditions;                                    // 0x02A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x40];                                     // 0x02B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForcedBattlePlayer">();
	}
	static class AForcedBattlePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AForcedBattlePlayer>();
	}
};
static_assert(alignof(AForcedBattlePlayer) == 0x000008, "Wrong alignment on AForcedBattlePlayer");
static_assert(sizeof(AForcedBattlePlayer) == 0x0002F0, "Wrong size on AForcedBattlePlayer");
static_assert(offsetof(AForcedBattlePlayer, mAreas) == 0x000238, "Member 'AForcedBattlePlayer::mAreas' has a wrong offset!");
static_assert(offsetof(AForcedBattlePlayer, mMonsterTemps) == 0x000250, "Member 'AForcedBattlePlayer::mMonsterTemps' has a wrong offset!");
static_assert(offsetof(AForcedBattlePlayer, mEndConditions) == 0x0002A0, "Member 'AForcedBattlePlayer::mEndConditions' has a wrong offset!");

// Class DarwinGame.UICursor_Partymenu_05
// 0x0040 (0x0628 - 0x05E8)
class UUICursor_Partymenu_05 final : public UUICursor_PartymenuBase
{
public:
	TArray<class UUICategory_Panel_00*>           CategoryPanels;                                    // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIArtifact_Panel_01*                   ArtifactPanel;                                     // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIDrop_Panel_01*                       DropPanel;                                         // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIDispatch_CategoryIcon_Effect*> CategoryEffectPanels;                              // 0x0608(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 FieldLinkIcon;                                     // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         EmptyTextBlock;                                    // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_05">();
	}
	static class UUICursor_Partymenu_05* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_05>();
	}
};
static_assert(alignof(UUICursor_Partymenu_05) == 0x000008, "Wrong alignment on UUICursor_Partymenu_05");
static_assert(sizeof(UUICursor_Partymenu_05) == 0x000628, "Wrong size on UUICursor_Partymenu_05");
static_assert(offsetof(UUICursor_Partymenu_05, CategoryPanels) == 0x0005E8, "Member 'UUICursor_Partymenu_05::CategoryPanels' has a wrong offset!");
static_assert(offsetof(UUICursor_Partymenu_05, ArtifactPanel) == 0x0005F8, "Member 'UUICursor_Partymenu_05::ArtifactPanel' has a wrong offset!");
static_assert(offsetof(UUICursor_Partymenu_05, DropPanel) == 0x000600, "Member 'UUICursor_Partymenu_05::DropPanel' has a wrong offset!");
static_assert(offsetof(UUICursor_Partymenu_05, CategoryEffectPanels) == 0x000608, "Member 'UUICursor_Partymenu_05::CategoryEffectPanels' has a wrong offset!");
static_assert(offsetof(UUICursor_Partymenu_05, FieldLinkIcon) == 0x000618, "Member 'UUICursor_Partymenu_05::FieldLinkIcon' has a wrong offset!");
static_assert(offsetof(UUICursor_Partymenu_05, EmptyTextBlock) == 0x000620, "Member 'UUICursor_Partymenu_05::EmptyTextBlock' has a wrong offset!");

// Class DarwinGame.FrameRateUtils
// 0x0000 (0x0030 - 0x0030)
class UFrameRateUtils final : public UObject
{
public:
	static float AdjustValueBasedOnFPS(float Value, float DeltaTime);
	static float GetFrameCountMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrameRateUtils">();
	}
	static class UFrameRateUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrameRateUtils>();
	}
};
static_assert(alignof(UFrameRateUtils) == 0x000008, "Wrong alignment on UFrameRateUtils");
static_assert(sizeof(UFrameRateUtils) == 0x000030, "Wrong size on UFrameRateUtils");

// Class DarwinGame.UISwapMenu_List
// 0x00E8 (0x06B8 - 0x05D0)
class UUISwapMenu_List final : public UUIScrollMenuBase
{
public:
	TArray<class FText>                           SortIconButtonText;                                // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           NetworkManagementSortIconButtonText;               // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x30];                                     // 0x05F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFacility_MonsterName*                MonsterName;                                       // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_SortIcon*                 SortIcon;                                          // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x20];                                     // 0x0630(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_MonsterIconTextures>        MonsterIconTextures;                               // 0x0650(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFacility_FieldStatus*                FieldStatus;                                       // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0x50];                                     // 0x0668(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISwapMenu_List">();
	}
	static class UUISwapMenu_List* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISwapMenu_List>();
	}
};
static_assert(alignof(UUISwapMenu_List) == 0x000008, "Wrong alignment on UUISwapMenu_List");
static_assert(sizeof(UUISwapMenu_List) == 0x0006B8, "Wrong size on UUISwapMenu_List");
static_assert(offsetof(UUISwapMenu_List, SortIconButtonText) == 0x0005D0, "Member 'UUISwapMenu_List::SortIconButtonText' has a wrong offset!");
static_assert(offsetof(UUISwapMenu_List, NetworkManagementSortIconButtonText) == 0x0005E0, "Member 'UUISwapMenu_List::NetworkManagementSortIconButtonText' has a wrong offset!");
static_assert(offsetof(UUISwapMenu_List, MonsterName) == 0x000620, "Member 'UUISwapMenu_List::MonsterName' has a wrong offset!");
static_assert(offsetof(UUISwapMenu_List, SortIcon) == 0x000628, "Member 'UUISwapMenu_List::SortIcon' has a wrong offset!");
static_assert(offsetof(UUISwapMenu_List, MonsterIconTextures) == 0x000650, "Member 'UUISwapMenu_List::MonsterIconTextures' has a wrong offset!");
static_assert(offsetof(UUISwapMenu_List, FieldStatus) == 0x000660, "Member 'UUISwapMenu_List::FieldStatus' has a wrong offset!");

// Class DarwinGame.FriendPositionManager
// 0x0010 (0x0048 - 0x0038)
class UFriendPositionManager final : public UManagerBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFriendPositionManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendPositionManager">();
	}
	static class UFriendPositionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendPositionManager>();
	}
};
static_assert(alignof(UFriendPositionManager) == 0x000008, "Wrong alignment on UFriendPositionManager");
static_assert(sizeof(UFriendPositionManager) == 0x000048, "Wrong size on UFriendPositionManager");

// Class DarwinGame.GameBelongingsCoinLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameBelongingsCoinLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBelongingsCoinLibrary">();
	}
	static class UGameBelongingsCoinLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBelongingsCoinLibrary>();
	}
};
static_assert(alignof(UGameBelongingsCoinLibrary) == 0x000008, "Wrong alignment on UGameBelongingsCoinLibrary");
static_assert(sizeof(UGameBelongingsCoinLibrary) == 0x000030, "Wrong size on UGameBelongingsCoinLibrary");

// Class DarwinGame.UIPCChange
// 0x0010 (0x04A0 - 0x0490)
class UUIPCChange : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Start();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPCChange">();
	}
	static class UUIPCChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPCChange>();
	}
};
static_assert(alignof(UUIPCChange) == 0x000008, "Wrong alignment on UUIPCChange");
static_assert(sizeof(UUIPCChange) == 0x0004A0, "Wrong size on UUIPCChange");

// Class DarwinGame.GameBelongingsItem
// 0x0058 (0x0088 - 0x0030)
class UGameBelongingsItem final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItem(const class FName& ItemId, int32 Num, bool bIsForceOpenItemGetUI);
	class UGameBelongingsItem* Clone();
	void Overwrite(class UGameBelongingsItem* game_data);
	void RemoveItem(const class FName& ItemId, int32 Num);

	int32 GetCapacity(const class FName& ItemId) const;
	int32 GetItem(const class FName& ItemId) const;
	const TMap<class FName, struct FGameDataItem> GetItemAll() const;
	int32 GetLimit(const class FName& ItemId) const;
	bool IsCollectedItem(const class FName& ItemId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBelongingsItem">();
	}
	static class UGameBelongingsItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBelongingsItem>();
	}
};
static_assert(alignof(UGameBelongingsItem) == 0x000008, "Wrong alignment on UGameBelongingsItem");
static_assert(sizeof(UGameBelongingsItem) == 0x000088, "Wrong size on UGameBelongingsItem");

// Class DarwinGame.GameBelongingsItemLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameBelongingsItemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBelongingsItemLibrary">();
	}
	static class UGameBelongingsItemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBelongingsItemLibrary>();
	}
};
static_assert(alignof(UGameBelongingsItemLibrary) == 0x000008, "Wrong alignment on UGameBelongingsItemLibrary");
static_assert(sizeof(UGameBelongingsItemLibrary) == 0x000030, "Wrong size on UGameBelongingsItemLibrary");

// Class DarwinGame.TextWidget
// 0x0210 (0x0448 - 0x0238)
class UTextWidget : public UUserWidget
{
public:
	int32                                         MainBlock;                                         // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         MainFontInfo;                                      // 0x0240(0x0050)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MainFontColor;                                     // 0x0290(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MainShadowOffset;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MainShadowColor;                                   // 0x02A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RubyBlock;                                         // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OtherLocaleRubyBlock;                              // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateFontInfo                         RubyFontInfo;                                      // 0x02C0(0x0050)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           RubyFontColor;                                     // 0x0310(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultOneStepIntervalTime;                        // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasOtherLocaleState;                               // 0x0324(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultLineHieght;                                 // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OtherLocaleDefaultLineHeight;                      // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultRubyHieght;                                 // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OtherLocaleDefaultRubyHeight;                      // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETextJustify                                  DefaultJustification;                              // 0x0338(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETextVerticalAlignment                        DefaultVerticalAlignment;                          // 0x0339(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33A[0x2];                                      // 0x033A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScrollStartLine;                                   // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OtherLocaleScrollStartLine;                        // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSizeToContent;                                    // 0x0344(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_345[0x7B];                                     // 0x0345(0x007B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTextWidgetData*>                WidgetDataArray;                                   // 0x03C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x18];                                     // 0x03D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         AtomComponentVoice;                                // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x50];                                     // 0x03F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const class FName GetWindowName(const ETextWindow& Window);

	void AddTextBlock(const ETextWindow& InWindow, class UCanvasPanel* InCanvasPanel, int32 InMainBlock, const struct FTextFontData& InMainFontData, int32 InRubyBlock, const struct FTextFontData& InRubyFontData);
	void ForcedUpdate();
	void InitChoice(int32 InItemNum);
	class UTexture2D* LoadIcon(const class FName& InName);
	void RollOut();
	void SetChoiceWindowData(struct FChoiceWindowData* InChoiceWindowData);
	void SetData(class UTextWidgetData* InTextEvent);
	void SetIndent(float InputIndent);
	void SetMainFontColor(const struct FLinearColor& InLinearColor);
	void SetMainShadowColor(const struct FLinearColor& InLinearColor);
	void SetMainShadowOffset(const struct FVector2D& InOffset);
	void SetOutlineColor(const struct FLinearColor& InLinearColor);
	void SetOutlineSize(int32 InSize);
	void SetPause(bool InPause);
	void SetRubyFontColor(const struct FLinearColor& InLinearColor);
	void StopVoice();
	void Update(float DeltaTime);
	void WriteSentence();

	bool CheckChoice() const;
	bool CheckUse(const class FName InName) const;
	struct FChoiceWindowData GetChoiceWindowData() const;
	class UTexture2D* GetIconTexture() const;
	bool GetIsSystemMessage() const;
	const struct FSlateFontInfo GetMainFontInfo() const;
	const struct FVector2D GetMainShadowOffset() const;
	const int32 GetRubyFontSize() const;
	const class FName GetTalkerID() const;
	struct FVector2D GetUsedTextAreaSize(const ETextWindow& InWindow) const;
	bool IsEndRollOut() const;
	bool IsLastPage() const;
	bool IsTextEventCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextWidget">();
	}
	static class UTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextWidget>();
	}
};
static_assert(alignof(UTextWidget) == 0x000008, "Wrong alignment on UTextWidget");
static_assert(sizeof(UTextWidget) == 0x000448, "Wrong size on UTextWidget");
static_assert(offsetof(UTextWidget, MainBlock) == 0x000238, "Member 'UTextWidget::MainBlock' has a wrong offset!");
static_assert(offsetof(UTextWidget, MainFontInfo) == 0x000240, "Member 'UTextWidget::MainFontInfo' has a wrong offset!");
static_assert(offsetof(UTextWidget, MainFontColor) == 0x000290, "Member 'UTextWidget::MainFontColor' has a wrong offset!");
static_assert(offsetof(UTextWidget, MainShadowOffset) == 0x0002A0, "Member 'UTextWidget::MainShadowOffset' has a wrong offset!");
static_assert(offsetof(UTextWidget, MainShadowColor) == 0x0002A8, "Member 'UTextWidget::MainShadowColor' has a wrong offset!");
static_assert(offsetof(UTextWidget, RubyBlock) == 0x0002B8, "Member 'UTextWidget::RubyBlock' has a wrong offset!");
static_assert(offsetof(UTextWidget, OtherLocaleRubyBlock) == 0x0002BC, "Member 'UTextWidget::OtherLocaleRubyBlock' has a wrong offset!");
static_assert(offsetof(UTextWidget, RubyFontInfo) == 0x0002C0, "Member 'UTextWidget::RubyFontInfo' has a wrong offset!");
static_assert(offsetof(UTextWidget, RubyFontColor) == 0x000310, "Member 'UTextWidget::RubyFontColor' has a wrong offset!");
static_assert(offsetof(UTextWidget, DefaultOneStepIntervalTime) == 0x000320, "Member 'UTextWidget::DefaultOneStepIntervalTime' has a wrong offset!");
static_assert(offsetof(UTextWidget, HasOtherLocaleState) == 0x000324, "Member 'UTextWidget::HasOtherLocaleState' has a wrong offset!");
static_assert(offsetof(UTextWidget, DefaultLineHieght) == 0x000328, "Member 'UTextWidget::DefaultLineHieght' has a wrong offset!");
static_assert(offsetof(UTextWidget, OtherLocaleDefaultLineHeight) == 0x00032C, "Member 'UTextWidget::OtherLocaleDefaultLineHeight' has a wrong offset!");
static_assert(offsetof(UTextWidget, DefaultRubyHieght) == 0x000330, "Member 'UTextWidget::DefaultRubyHieght' has a wrong offset!");
static_assert(offsetof(UTextWidget, OtherLocaleDefaultRubyHeight) == 0x000334, "Member 'UTextWidget::OtherLocaleDefaultRubyHeight' has a wrong offset!");
static_assert(offsetof(UTextWidget, DefaultJustification) == 0x000338, "Member 'UTextWidget::DefaultJustification' has a wrong offset!");
static_assert(offsetof(UTextWidget, DefaultVerticalAlignment) == 0x000339, "Member 'UTextWidget::DefaultVerticalAlignment' has a wrong offset!");
static_assert(offsetof(UTextWidget, ScrollStartLine) == 0x00033C, "Member 'UTextWidget::ScrollStartLine' has a wrong offset!");
static_assert(offsetof(UTextWidget, OtherLocaleScrollStartLine) == 0x000340, "Member 'UTextWidget::OtherLocaleScrollStartLine' has a wrong offset!");
static_assert(offsetof(UTextWidget, bSizeToContent) == 0x000344, "Member 'UTextWidget::bSizeToContent' has a wrong offset!");
static_assert(offsetof(UTextWidget, WidgetDataArray) == 0x0003C0, "Member 'UTextWidget::WidgetDataArray' has a wrong offset!");
static_assert(offsetof(UTextWidget, IconTexture) == 0x0003E8, "Member 'UTextWidget::IconTexture' has a wrong offset!");
static_assert(offsetof(UTextWidget, AtomComponentVoice) == 0x0003F0, "Member 'UTextWidget::AtomComponentVoice' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_06_Set
// 0x0048 (0x04D8 - 0x0490)
class UUIPartyMenu_PMR_Page_06_Set : public UDarwinUserWidget
{
public:
	class FName                                   AutoFlashAnimName;                                 // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_PMR_Page_12*               StatusPage;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_02*               CoinStatePage;                                     // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITopbar_00*                           TabNameBar;                                        // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICoinMenu_CoinPlate_Set*              CoinPlate;                                         // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_Base*             CurrentPage;                                       // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIPartyMenu_PMR_Page_Base*>     PageArray;                                         // 0x04C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_06_Set">();
	}
	static class UUIPartyMenu_PMR_Page_06_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_06_Set>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_06_Set) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_06_Set");
static_assert(sizeof(UUIPartyMenu_PMR_Page_06_Set) == 0x0004D8, "Wrong size on UUIPartyMenu_PMR_Page_06_Set");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, AutoFlashAnimName) == 0x000490, "Member 'UUIPartyMenu_PMR_Page_06_Set::AutoFlashAnimName' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, StatusPage) == 0x000498, "Member 'UUIPartyMenu_PMR_Page_06_Set::StatusPage' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, CoinStatePage) == 0x0004A0, "Member 'UUIPartyMenu_PMR_Page_06_Set::CoinStatePage' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, TabNameBar) == 0x0004A8, "Member 'UUIPartyMenu_PMR_Page_06_Set::TabNameBar' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, CoinPlate) == 0x0004B0, "Member 'UUIPartyMenu_PMR_Page_06_Set::CoinPlate' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, CurrentPage) == 0x0004B8, "Member 'UUIPartyMenu_PMR_Page_06_Set::CurrentPage' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_06_Set, PageArray) == 0x0004C0, "Member 'UUIPartyMenu_PMR_Page_06_Set::PageArray' has a wrong offset!");

// Class DarwinGame.GameDataAchievementLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataAchievementLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataAchievementLibrary">();
	}
	static class UGameDataAchievementLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataAchievementLibrary>();
	}
};
static_assert(alignof(UGameDataAchievementLibrary) == 0x000008, "Wrong alignment on UGameDataAchievementLibrary");
static_assert(sizeof(UGameDataAchievementLibrary) == 0x000030, "Wrong size on UGameDataAchievementLibrary");

// Class DarwinGame.GameDataAddOnContent
// 0x0018 (0x0048 - 0x0030)
class UGameDataAddOnContent final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataAddOnContent* Clone();
	void Overwrite(class UGameDataAddOnContent* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataAddOnContent">();
	}
	static class UGameDataAddOnContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataAddOnContent>();
	}
};
static_assert(alignof(UGameDataAddOnContent) == 0x000008, "Wrong alignment on UGameDataAddOnContent");
static_assert(sizeof(UGameDataAddOnContent) == 0x000048, "Wrong size on UGameDataAddOnContent");

// Class DarwinGame.TimerReportManager
// 0x0008 (0x0040 - 0x0038)
class UTimerReportManager : public UManagerBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTimerReportManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerReportManager">();
	}
	static class UTimerReportManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimerReportManager>();
	}
};
static_assert(alignof(UTimerReportManager) == 0x000008, "Wrong alignment on UTimerReportManager");
static_assert(sizeof(UTimerReportManager) == 0x000040, "Wrong size on UTimerReportManager");

// Class DarwinGame.GameDataAddOnContentLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataAddOnContentLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataAddOnContentLibrary">();
	}
	static class UGameDataAddOnContentLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataAddOnContentLibrary>();
	}
};
static_assert(alignof(UGameDataAddOnContentLibrary) == 0x000008, "Wrong alignment on UGameDataAddOnContentLibrary");
static_assert(sizeof(UGameDataAddOnContentLibrary) == 0x000030, "Wrong size on UGameDataAddOnContentLibrary");

// Class DarwinGame.GameDataArea
// 0x0120 (0x0150 - 0x0030)
class UGameDataArea final : public UObject
{
public:
	uint8                                         Pad_30[0x120];                                     // 0x0030(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddReleaseArea(const class FName& ID);
	void AddVisitArea(const class FName& ID);
	class UGameDataArea* Clone();
	void Overwrite(class UGameDataArea* GameData);
	void SetAreaType(const EAreaType Type);
	void SetDistrictID(const class FName& ID);
	void SetEnvironmentID(const class FName& ID);
	void SetPointID(const class FName& ID);
	void SetPrevDistrictID(const class FName& ID);
	void SetPrevPointID(const class FName& ID);
	void SetPrevRegionID(const class FName& ID);
	void SetPrevSectionID(const class FName& ID);
	void SetPrevZoneID(const class FName& ID);
	void SetRegionID(const class FName& ID);
	void SetSectionID(const class FName& ID);
	void SetZoneID(const class FName& ID);

	bool GetAreaState(const class FName& ID, struct FST_AreaState* State) const;
	EAreaType GetAreaType() const;
	const class FName GetDistrictID() const;
	class FName GetEnvironmentID() const;
	const struct FST_IndoorData GetIndoorData() const;
	const class FName GetPointID() const;
	const class FName GetPrevDistrictID() const;
	const class FName GetPrevPointID() const;
	const class FName GetPrevRegionID() const;
	const class FName GetPrevSectionID() const;
	const class FName GetPrevZoneID() const;
	const class FName GetRegionID() const;
	const class FName GetSectionID() const;
	const class FName GetStarScarID() const;
	const class FName GetZoneID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataArea">();
	}
	static class UGameDataArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataArea>();
	}
};
static_assert(alignof(UGameDataArea) == 0x000008, "Wrong alignment on UGameDataArea");
static_assert(sizeof(UGameDataArea) == 0x000150, "Wrong size on UGameDataArea");

// Class DarwinGame.UIPartyMenu_PMR_Page_03
// 0x0050 (0x0660 - 0x0610)
class UUIPartyMenu_PMR_Page_03 : public UUIPartyMenu_PMR_Page_Base
{
public:
	uint8                                         Pad_610[0x50];                                     // 0x0610(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_03">();
	}
	static class UUIPartyMenu_PMR_Page_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_03>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_03) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_03");
static_assert(sizeof(UUIPartyMenu_PMR_Page_03) == 0x000660, "Wrong size on UUIPartyMenu_PMR_Page_03");

// Class DarwinGame.GameDataAreaLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataAreaLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataAreaLibrary">();
	}
	static class UGameDataAreaLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataAreaLibrary>();
	}
};
static_assert(alignof(UGameDataAreaLibrary) == 0x000008, "Wrong alignment on UGameDataAreaLibrary");
static_assert(sizeof(UGameDataAreaLibrary) == 0x000030, "Wrong size on UGameDataAreaLibrary");

// Class DarwinGame.GameDataArtifact
// 0x0268 (0x0298 - 0x0030)
class UGameDataArtifact final : public UObject
{
public:
	uint8                                         Pad_30[0x268];                                     // 0x0030(0x0268)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBelongingsArtifact(int32 ArtifactID, int32 Num, int32 Quality);
	class UGameDataArtifact* Clone();
	int64 GetBelongingsArtifactEstimatedValue(int32 ArtifactID);
	void Overwrite(class UGameDataArtifact* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataArtifact">();
	}
	static class UGameDataArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataArtifact>();
	}
};
static_assert(alignof(UGameDataArtifact) == 0x000008, "Wrong alignment on UGameDataArtifact");
static_assert(sizeof(UGameDataArtifact) == 0x000298, "Wrong size on UGameDataArtifact");

// Class DarwinGame.TitleGameMode
// 0x0010 (0x02D8 - 0x02C8)
class ATitleGameMode final : public AAppGameModeBase
{
public:
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleGameMode">();
	}
	static class ATitleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATitleGameMode>();
	}
};
static_assert(alignof(ATitleGameMode) == 0x000008, "Wrong alignment on ATitleGameMode");
static_assert(sizeof(ATitleGameMode) == 0x0002D8, "Wrong size on ATitleGameMode");

// Class DarwinGame.UIQMR_Page_02
// 0x0018 (0x0508 - 0x04F0)
class UUIQMR_Page_02 : public UUIFreeScrollBase
{
public:
	TArray<class UUIQM_Panel_03*>                 Items;                                             // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQMR_Page_02">();
	}
	static class UUIQMR_Page_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQMR_Page_02>();
	}
};
static_assert(alignof(UUIQMR_Page_02) == 0x000008, "Wrong alignment on UUIQMR_Page_02");
static_assert(sizeof(UUIQMR_Page_02) == 0x000508, "Wrong size on UUIQMR_Page_02");
static_assert(offsetof(UUIQMR_Page_02, Items) == 0x0004F0, "Member 'UUIQMR_Page_02::Items' has a wrong offset!");

// Class DarwinGame.GameDataArtifactLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataArtifactLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataArtifactLibrary">();
	}
	static class UGameDataArtifactLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataArtifactLibrary>();
	}
};
static_assert(alignof(UGameDataArtifactLibrary) == 0x000008, "Wrong alignment on UGameDataArtifactLibrary");
static_assert(sizeof(UGameDataArtifactLibrary) == 0x000030, "Wrong size on UGameDataArtifactLibrary");

// Class DarwinGame.GameDataArtifactPoint
// 0x0058 (0x0088 - 0x0030)
class UGameDataArtifactPoint final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataArtifactPoint* Clone();
	void Overwrite(class UGameDataArtifactPoint* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataArtifactPoint">();
	}
	static class UGameDataArtifactPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataArtifactPoint>();
	}
};
static_assert(alignof(UGameDataArtifactPoint) == 0x000008, "Wrong alignment on UGameDataArtifactPoint");
static_assert(sizeof(UGameDataArtifactPoint) == 0x000088, "Wrong size on UGameDataArtifactPoint");

// Class DarwinGame.GameDataArtifactPointLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataArtifactPointLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataArtifactPointLibrary">();
	}
	static class UGameDataArtifactPointLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataArtifactPointLibrary>();
	}
};
static_assert(alignof(UGameDataArtifactPointLibrary) == 0x000008, "Wrong alignment on UGameDataArtifactPointLibrary");
static_assert(sizeof(UGameDataArtifactPointLibrary) == 0x000030, "Wrong size on UGameDataArtifactPointLibrary");

// Class DarwinGame.GameDatabase
// 0x0120 (0x0150 - 0x0030)
class UGameDatabase final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameDataHeader*                        mHeader;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataPlayer*                        mPlayer;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataParty*                         mParty;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataGuest*                         mGuest;                                            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameBelongingsItem*                    mBelongingsItem;                                   // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataFlag*                          mEventFlag;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataSavePoint*                     mSavePoint;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataTips*                          mTips;                                             // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataHistory*                       mHistory;                                          // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameBelongingsCoin*                    mBelongingsCoin;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataStockMonster*                  mStockMonster;                                     // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataDefeatedMonster*               mDefeatedMonster;                                  // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataFixTreasureBox*                mFixTreasureBox;                                   // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataArea*                          mArea;                                             // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataScenarioProgress*              mScenarioProgress;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataShop*                          mShop;                                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataStation*                       mStation;                                          // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataBonfire*                       mBonfire;                                          // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataQuest*                         mQuest;                                            // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataArtifact*                      mArtifact;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataArtifactPoint*                 mArtifactPoint;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataDispatch*                      mDispatch;                                         // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataDungeon*                       mDungeon;                                          // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataMyTeam*                        mMyTeam;                                           // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataAchievement*                   mAchievement;                                      // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataNetwork*                       mNetwork;                                          // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataUIMap*                         mUIMap;                                            // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataTargetObject*                  mTargetObject;                                     // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataDict*                          mDict;                                             // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataOption*                        mOption;                                           // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataBreakObject*                   mBreakObject;                                      // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataField*                         mField;                                            // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataNPC*                           mNPC;                                              // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataCollectionPoint*               mCollectionPoint;                                  // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameDataAddOnContent*                  mAOC;                                              // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UGameDatabase* Clone();
	class UGameDataAchievement* GetAchievement();
	class UGameDataAddOnContent* GetAOC();
	class UGameDataArea* GetArea();
	class UGameDataArtifact* GetArtifact();
	class UGameDataArtifactPoint* GetArtifactPoint();
	class UGameBelongingsCoin* GetBelongingsCoin();
	class UGameBelongingsItem* GetBelongingsItem();
	class UGameDataBonfire* GetBonfire();
	class UGameDataBreakObject* GetBreakObject();
	class UGameDataCollectionPoint* GetCollectionPoint();
	class UGameDataDefeatedMonster* GetDefeatedMonster();
	class UGameDataDict* GetDict();
	class UGameDataDispatch* GetDispatch();
	class UGameDataDungeon* GetDungeon();
	class UGameDataField* GetField();
	class UGameDataFixTreasureBox* GetFixTreasureBox();
	class UGameDataFlag* GetGameDataFlag();
	class UGameDataGuest* GetGuest();
	class UGameDataHeader* GetHeader();
	class UGameDataHistory* GetHistory();
	class UGameDataMyTeam* GetMyTeam();
	class UGameDataNetwork* GetNetwork();
	class UGameDataNPC* GetNPC();
	class UGameDataOption* GetOption();
	class UGameDataParty* GetParty();
	class UGameDataPlayer* GetPlayerData();
	class UGameDataQuest* GetQuest();
	class UGameDataSavePoint* GetSavePoint();
	class UGameDataScenarioProgress* GetScenarioProgress();
	class UGameDataShop* GetShop();
	class UGameDataStation* GetStation();
	class UGameDataStockMonster* GetStockMonster();
	class UGameDataTargetObject* GetTargetObject();
	class UGameDataTips* GetTips();
	class UGameDataUIMap* GetUIMap();
	void Overwrite(class UGameDatabase* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDatabase">();
	}
	static class UGameDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDatabase>();
	}
};
static_assert(alignof(UGameDatabase) == 0x000008, "Wrong alignment on UGameDatabase");
static_assert(sizeof(UGameDatabase) == 0x000150, "Wrong size on UGameDatabase");
static_assert(offsetof(UGameDatabase, mHeader) == 0x000038, "Member 'UGameDatabase::mHeader' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mPlayer) == 0x000040, "Member 'UGameDatabase::mPlayer' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mParty) == 0x000048, "Member 'UGameDatabase::mParty' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mGuest) == 0x000050, "Member 'UGameDatabase::mGuest' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mBelongingsItem) == 0x000058, "Member 'UGameDatabase::mBelongingsItem' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mEventFlag) == 0x000060, "Member 'UGameDatabase::mEventFlag' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mSavePoint) == 0x000068, "Member 'UGameDatabase::mSavePoint' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mTips) == 0x000070, "Member 'UGameDatabase::mTips' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mHistory) == 0x000078, "Member 'UGameDatabase::mHistory' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mBelongingsCoin) == 0x000080, "Member 'UGameDatabase::mBelongingsCoin' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mStockMonster) == 0x000088, "Member 'UGameDatabase::mStockMonster' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mDefeatedMonster) == 0x000090, "Member 'UGameDatabase::mDefeatedMonster' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mFixTreasureBox) == 0x000098, "Member 'UGameDatabase::mFixTreasureBox' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mArea) == 0x0000A0, "Member 'UGameDatabase::mArea' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mScenarioProgress) == 0x0000A8, "Member 'UGameDatabase::mScenarioProgress' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mShop) == 0x0000B0, "Member 'UGameDatabase::mShop' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mStation) == 0x0000B8, "Member 'UGameDatabase::mStation' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mBonfire) == 0x0000C0, "Member 'UGameDatabase::mBonfire' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mQuest) == 0x0000C8, "Member 'UGameDatabase::mQuest' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mArtifact) == 0x0000D0, "Member 'UGameDatabase::mArtifact' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mArtifactPoint) == 0x0000D8, "Member 'UGameDatabase::mArtifactPoint' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mDispatch) == 0x0000E0, "Member 'UGameDatabase::mDispatch' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mDungeon) == 0x0000E8, "Member 'UGameDatabase::mDungeon' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mMyTeam) == 0x0000F0, "Member 'UGameDatabase::mMyTeam' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mAchievement) == 0x0000F8, "Member 'UGameDatabase::mAchievement' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mNetwork) == 0x000100, "Member 'UGameDatabase::mNetwork' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mUIMap) == 0x000108, "Member 'UGameDatabase::mUIMap' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mTargetObject) == 0x000110, "Member 'UGameDatabase::mTargetObject' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mDict) == 0x000118, "Member 'UGameDatabase::mDict' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mOption) == 0x000120, "Member 'UGameDatabase::mOption' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mBreakObject) == 0x000128, "Member 'UGameDatabase::mBreakObject' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mField) == 0x000130, "Member 'UGameDatabase::mField' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mNPC) == 0x000138, "Member 'UGameDatabase::mNPC' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mCollectionPoint) == 0x000140, "Member 'UGameDatabase::mCollectionPoint' has a wrong offset!");
static_assert(offsetof(UGameDatabase, mAOC) == 0x000148, "Member 'UGameDatabase::mAOC' has a wrong offset!");

// Class DarwinGame.TreasureBoxAdditionDataAsset
// 0x0050 (0x0088 - 0x0038)
class UTreasureBoxAdditionDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_TreasureBoxToEventMatchData> mEventMatchData;                                   // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureBoxAdditionDataAsset">();
	}
	static class UTreasureBoxAdditionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTreasureBoxAdditionDataAsset>();
	}
};
static_assert(alignof(UTreasureBoxAdditionDataAsset) == 0x000008, "Wrong alignment on UTreasureBoxAdditionDataAsset");
static_assert(sizeof(UTreasureBoxAdditionDataAsset) == 0x000088, "Wrong size on UTreasureBoxAdditionDataAsset");
static_assert(offsetof(UTreasureBoxAdditionDataAsset, mEventMatchData) == 0x000038, "Member 'UTreasureBoxAdditionDataAsset::mEventMatchData' has a wrong offset!");

// Class DarwinGame.GameDataBonfire
// 0x0058 (0x0088 - 0x0030)
class UGameDataBonfire final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataBonfire* Clone();
	void Overwrite(class UGameDataBonfire* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataBonfire">();
	}
	static class UGameDataBonfire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataBonfire>();
	}
};
static_assert(alignof(UGameDataBonfire) == 0x000008, "Wrong alignment on UGameDataBonfire");
static_assert(sizeof(UGameDataBonfire) == 0x000088, "Wrong size on UGameDataBonfire");

// Class DarwinGame.UIQM_Panel_04
// 0x0000 (0x0490 - 0x0490)
class UUIQM_Panel_04 : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_04">();
	}
	static class UUIQM_Panel_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_04>();
	}
};
static_assert(alignof(UUIQM_Panel_04) == 0x000008, "Wrong alignment on UUIQM_Panel_04");
static_assert(sizeof(UUIQM_Panel_04) == 0x000490, "Wrong size on UUIQM_Panel_04");

// Class DarwinGame.UIQM_Panel_07
// 0x0000 (0x0490 - 0x0490)
class UUIQM_Panel_07 : public UUIQM_Panel_04
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_07">();
	}
	static class UUIQM_Panel_07* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_07>();
	}
};
static_assert(alignof(UUIQM_Panel_07) == 0x000008, "Wrong alignment on UUIQM_Panel_07");
static_assert(sizeof(UUIQM_Panel_07) == 0x000490, "Wrong size on UUIQM_Panel_07");

// Class DarwinGame.GameDataBreakObject
// 0x00A8 (0x00D8 - 0x0030)
class UGameDataBreakObject final : public UObject
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataBreakObject* Clone();
	void Overwrite(class UGameDataBreakObject* GameData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataBreakObject">();
	}
	static class UGameDataBreakObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataBreakObject>();
	}
};
static_assert(alignof(UGameDataBreakObject) == 0x000008, "Wrong alignment on UGameDataBreakObject");
static_assert(sizeof(UGameDataBreakObject) == 0x0000D8, "Wrong size on UGameDataBreakObject");

// Class DarwinGame.GameDataBreakObjectLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataBreakObjectLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataBreakObjectLibrary">();
	}
	static class UGameDataBreakObjectLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataBreakObjectLibrary>();
	}
};
static_assert(alignof(UGameDataBreakObjectLibrary) == 0x000008, "Wrong alignment on UGameDataBreakObjectLibrary");
static_assert(sizeof(UGameDataBreakObjectLibrary) == 0x000030, "Wrong size on UGameDataBreakObjectLibrary");

// Class DarwinGame.ShopFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UShopFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopFunctionLibrary">();
	}
	static class UShopFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopFunctionLibrary>();
	}
};
static_assert(alignof(UShopFunctionLibrary) == 0x000008, "Wrong alignment on UShopFunctionLibrary");
static_assert(sizeof(UShopFunctionLibrary) == 0x000030, "Wrong size on UShopFunctionLibrary");

// Class DarwinGame.UINetworkTreasureHide_Root
// 0x0040 (0x0510 - 0x04D0)
class UUINetworkTreasureHide_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x40];                                     // 0x04D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkTreasureHide_Root">();
	}
	static class UUINetworkTreasureHide_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkTreasureHide_Root>();
	}
};
static_assert(alignof(UUINetworkTreasureHide_Root) == 0x000008, "Wrong alignment on UUINetworkTreasureHide_Root");
static_assert(sizeof(UUINetworkTreasureHide_Root) == 0x000510, "Wrong size on UUINetworkTreasureHide_Root");

// Class DarwinGame.GameDataCollectionPoint
// 0x0058 (0x0088 - 0x0030)
class UGameDataCollectionPoint final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataCollectionPoint* Clone();
	void Overwrite(class UGameDataCollectionPoint* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataCollectionPoint">();
	}
	static class UGameDataCollectionPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataCollectionPoint>();
	}
};
static_assert(alignof(UGameDataCollectionPoint) == 0x000008, "Wrong alignment on UGameDataCollectionPoint");
static_assert(sizeof(UGameDataCollectionPoint) == 0x000088, "Wrong size on UGameDataCollectionPoint");

// Class DarwinGame.GameDataCollectionPointLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataCollectionPointLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataCollectionPointLibrary">();
	}
	static class UGameDataCollectionPointLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataCollectionPointLibrary>();
	}
};
static_assert(alignof(UGameDataCollectionPointLibrary) == 0x000008, "Wrong alignment on UGameDataCollectionPointLibrary");
static_assert(sizeof(UGameDataCollectionPointLibrary) == 0x000030, "Wrong size on UGameDataCollectionPointLibrary");

// Class DarwinGame.GameDataDefeatedMonster
// 0x0048 (0x0078 - 0x0030)
class UGameDataDefeatedMonster final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataDefeatedMonster* Clone();
	void Overwrite(class UGameDataDefeatedMonster* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDefeatedMonster">();
	}
	static class UGameDataDefeatedMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDefeatedMonster>();
	}
};
static_assert(alignof(UGameDataDefeatedMonster) == 0x000008, "Wrong alignment on UGameDataDefeatedMonster");
static_assert(sizeof(UGameDataDefeatedMonster) == 0x000078, "Wrong size on UGameDataDefeatedMonster");

// Class DarwinGame.GameDataDefeatedMonsterLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataDefeatedMonsterLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDefeatedMonsterLibrary">();
	}
	static class UGameDataDefeatedMonsterLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDefeatedMonsterLibrary>();
	}
};
static_assert(alignof(UGameDataDefeatedMonsterLibrary) == 0x000008, "Wrong alignment on UGameDataDefeatedMonsterLibrary");
static_assert(sizeof(UGameDataDefeatedMonsterLibrary) == 0x000030, "Wrong size on UGameDataDefeatedMonsterLibrary");

// Class DarwinGame.SimpleBreathMagicBase
// 0x0078 (0x0368 - 0x02F0)
class ASimpleBreathMagicBase final : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x70];                                     // 0x02F8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleBreathMagicBase">();
	}
	static class ASimpleBreathMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleBreathMagicBase>();
	}
};
static_assert(alignof(ASimpleBreathMagicBase) == 0x000008, "Wrong alignment on ASimpleBreathMagicBase");
static_assert(sizeof(ASimpleBreathMagicBase) == 0x000368, "Wrong size on ASimpleBreathMagicBase");
static_assert(offsetof(ASimpleBreathMagicBase, collision) == 0x0002F0, "Member 'ASimpleBreathMagicBase::collision' has a wrong offset!");

// Class DarwinGame.GameDataDict
// 0x0108 (0x0138 - 0x0030)
class UGameDataDict final : public UObject
{
public:
	uint8                                         Pad_30[0x108];                                     // 0x0030(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataDict* Clone();
	void Overwrite(class UGameDataDict* game_data);
	void UpdateKnowledgeDictReleaseInfo(const class FName& KnowledgeId);
	void UpdateQuestOverviewDictReleaseInfo(const class FName& KnowledgeId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDict">();
	}
	static class UGameDataDict* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDict>();
	}
};
static_assert(alignof(UGameDataDict) == 0x000008, "Wrong alignment on UGameDataDict");
static_assert(sizeof(UGameDataDict) == 0x000138, "Wrong size on UGameDataDict");

// Class DarwinGame.UINetworkTreasureHide
// 0x0120 (0x06F0 - 0x05D0)
class alignas(0x10) UUINetworkTreasureHide final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinArtifactCaptureImage*            Treasure_CaptureImage;                             // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         OnlineIDText;                                      // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UComputeTextBlock*                      TreasureNotSettingText;                            // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIIconChoice*                          SelectBtn;                                         // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHidePanel*                   TreasureHidePaneTreasure;                          // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHidePanel*                   TreasureHidePanePlace;                             // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHidePanel*                   TreasureHidePanePassword;                          // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasurePanel*                       TreasurePanel;                                     // 0x0610(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHidePlacePanel*                      PlacePanel;                                        // 0x0618(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPasswordPanel*                       PasswordPanel;                                     // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWinMenu_S_03*                        SavingDialog;                                      // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0xB8];                                     // 0x0638(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkTreasureHide">();
	}
	static class UUINetworkTreasureHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkTreasureHide>();
	}
};
static_assert(alignof(UUINetworkTreasureHide) == 0x000010, "Wrong alignment on UUINetworkTreasureHide");
static_assert(sizeof(UUINetworkTreasureHide) == 0x0006F0, "Wrong size on UUINetworkTreasureHide");
static_assert(offsetof(UUINetworkTreasureHide, Treasure_CaptureImage) == 0x0005D8, "Member 'UUINetworkTreasureHide::Treasure_CaptureImage' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, OnlineIDText) == 0x0005E0, "Member 'UUINetworkTreasureHide::OnlineIDText' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, TreasureNotSettingText) == 0x0005E8, "Member 'UUINetworkTreasureHide::TreasureNotSettingText' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, SelectBtn) == 0x0005F0, "Member 'UUINetworkTreasureHide::SelectBtn' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, TreasureHidePaneTreasure) == 0x0005F8, "Member 'UUINetworkTreasureHide::TreasureHidePaneTreasure' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, TreasureHidePanePlace) == 0x000600, "Member 'UUINetworkTreasureHide::TreasureHidePanePlace' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, TreasureHidePanePassword) == 0x000608, "Member 'UUINetworkTreasureHide::TreasureHidePanePassword' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, TreasurePanel) == 0x000610, "Member 'UUINetworkTreasureHide::TreasurePanel' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, PlacePanel) == 0x000618, "Member 'UUINetworkTreasureHide::PlacePanel' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, PasswordPanel) == 0x000620, "Member 'UUINetworkTreasureHide::PasswordPanel' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, SavingDialog) == 0x000628, "Member 'UUINetworkTreasureHide::SavingDialog' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHide, UIUnderButton) == 0x000630, "Member 'UUINetworkTreasureHide::UIUnderButton' has a wrong offset!");

// Class DarwinGame.GameDataDispatch
// 0x0018 (0x0048 - 0x0030)
class UGameDataDispatch final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataDispatch* Clone();
	void Overwrite(class UGameDataDispatch* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDispatch">();
	}
	static class UGameDataDispatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDispatch>();
	}
};
static_assert(alignof(UGameDataDispatch) == 0x000008, "Wrong alignment on UGameDataDispatch");
static_assert(sizeof(UGameDataDispatch) == 0x000048, "Wrong size on UGameDataDispatch");

// Class DarwinGame.GameDataDispatchLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataDispatchLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDispatchLibrary">();
	}
	static class UGameDataDispatchLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDispatchLibrary>();
	}
};
static_assert(alignof(UGameDataDispatchLibrary) == 0x000008, "Wrong alignment on UGameDataDispatchLibrary");
static_assert(sizeof(UGameDataDispatchLibrary) == 0x000030, "Wrong size on UGameDataDispatchLibrary");

// Class DarwinGame.SkillChainDamageRequirement
// 0x0000 (0x0030 - 0x0030)
class USkillChainDamageRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChainDamageRequirement">();
	}
	static class USkillChainDamageRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillChainDamageRequirement>();
	}
};
static_assert(alignof(USkillChainDamageRequirement) == 0x000008, "Wrong alignment on USkillChainDamageRequirement");
static_assert(sizeof(USkillChainDamageRequirement) == 0x000030, "Wrong size on USkillChainDamageRequirement");

// Class DarwinGame.GameDataDungeon
// 0x0098 (0x00C8 - 0x0030)
class UGameDataDungeon final : public UObject
{
public:
	uint8                                         Pad_30[0x98];                                      // 0x0030(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataDungeon* Clone();
	void Overwrite(class UGameDataDungeon* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDungeon">();
	}
	static class UGameDataDungeon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDungeon>();
	}
};
static_assert(alignof(UGameDataDungeon) == 0x000008, "Wrong alignment on UGameDataDungeon");
static_assert(sizeof(UGameDataDungeon) == 0x0000C8, "Wrong size on UGameDataDungeon");

// Class DarwinGame.GameDataDungeonLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataDungeonLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataDungeonLibrary">();
	}
	static class UGameDataDungeonLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataDungeonLibrary>();
	}
};
static_assert(alignof(UGameDataDungeonLibrary) == 0x000008, "Wrong alignment on UGameDataDungeonLibrary");
static_assert(sizeof(UGameDataDungeonLibrary) == 0x000030, "Wrong size on UGameDataDungeonLibrary");

// Class DarwinGame.GameDataField
// 0x0070 (0x00A0 - 0x0030)
class UGameDataField final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataField* Clone();
	void Overwrite(class UGameDataField* GameData);
	void SetTrainStopStationID(const class FName& ID);

	const class FName GetTrainStopStationID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataField">();
	}
	static class UGameDataField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataField>();
	}
};
static_assert(alignof(UGameDataField) == 0x000008, "Wrong alignment on UGameDataField");
static_assert(sizeof(UGameDataField) == 0x0000A0, "Wrong size on UGameDataField");

// Class DarwinGame.GameDataFieldLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataFieldLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFieldLibrary">();
	}
	static class UGameDataFieldLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFieldLibrary>();
	}
};
static_assert(alignof(UGameDataFieldLibrary) == 0x000008, "Wrong alignment on UGameDataFieldLibrary");
static_assert(sizeof(UGameDataFieldLibrary) == 0x000030, "Wrong size on UGameDataFieldLibrary");

// Class DarwinGame.WeaponBase
// 0x0000 (0x0258 - 0x0258)
class AWeaponBase : public AAttachObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponBase">();
	}
	static class AWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponBase>();
	}
};
static_assert(alignof(AWeaponBase) == 0x000008, "Wrong alignment on AWeaponBase");
static_assert(sizeof(AWeaponBase) == 0x000258, "Wrong size on AWeaponBase");

// Class DarwinGame.GameDataFixTreasureBox
// 0x0058 (0x0088 - 0x0030)
class UGameDataFixTreasureBox final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTreasureBoxState(const class FName& FiledObjectID, const bool IsOpen_0);
	class UGameDataFixTreasureBox* Clone();
	void Overwrite(class UGameDataFixTreasureBox* GameData);

	bool IsExistData(const class FName& FiledObjectID) const;
	bool IsOpen(const class FName& FiledObjectID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFixTreasureBox">();
	}
	static class UGameDataFixTreasureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFixTreasureBox>();
	}
};
static_assert(alignof(UGameDataFixTreasureBox) == 0x000008, "Wrong alignment on UGameDataFixTreasureBox");
static_assert(sizeof(UGameDataFixTreasureBox) == 0x000088, "Wrong size on UGameDataFixTreasureBox");

// Class DarwinGame.UIQuestOrder_Root
// 0x0048 (0x0518 - 0x04D0)
class UUIQuestOrder_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x48];                                     // 0x04D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestOrder_Root">();
	}
	static class UUIQuestOrder_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestOrder_Root>();
	}
};
static_assert(alignof(UUIQuestOrder_Root) == 0x000008, "Wrong alignment on UUIQuestOrder_Root");
static_assert(sizeof(UUIQuestOrder_Root) == 0x000518, "Wrong size on UUIQuestOrder_Root");

// Class DarwinGame.GameDataFlag
// 0x0068 (0x0098 - 0x0030)
class UGameDataFlag final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataFlag* Clone();
	void Overwrite(class UGameDataFlag* game_data);
	void SetFlag(const class FName& FlagName, bool SetFlag_0);

	bool GetFlag(const class FName& FlagName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFlag">();
	}
	static class UGameDataFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFlag>();
	}
};
static_assert(alignof(UGameDataFlag) == 0x000008, "Wrong alignment on UGameDataFlag");
static_assert(sizeof(UGameDataFlag) == 0x000098, "Wrong size on UGameDataFlag");

// Class DarwinGame.GameDataFlagLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataFlagLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFlagLibrary">();
	}
	static class UGameDataFlagLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFlagLibrary>();
	}
};
static_assert(alignof(UGameDataFlagLibrary) == 0x000008, "Wrong alignment on UGameDataFlagLibrary");
static_assert(sizeof(UGameDataFlagLibrary) == 0x000030, "Wrong size on UGameDataFlagLibrary");

// Class DarwinGame.PlayMonsterVoice
// 0x0008 (0x0048 - 0x0040)
class UPlayMonsterVoice final : public UAnimNotify
{
public:
	EVoiceTiming                                  Voice;                                             // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayMonsterVoice">();
	}
	static class UPlayMonsterVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayMonsterVoice>();
	}
};
static_assert(alignof(UPlayMonsterVoice) == 0x000008, "Wrong alignment on UPlayMonsterVoice");
static_assert(sizeof(UPlayMonsterVoice) == 0x000048, "Wrong size on UPlayMonsterVoice");
static_assert(offsetof(UPlayMonsterVoice, Voice) == 0x000040, "Member 'UPlayMonsterVoice::Voice' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_Content_02
// 0x0000 (0x04A0 - 0x04A0)
class UUIMonsterDict_Content_02 : public UUIMonsterDict_ContentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_02">();
	}
	static class UUIMonsterDict_Content_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_02>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_02) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_02");
static_assert(sizeof(UUIMonsterDict_Content_02) == 0x0004A0, "Wrong size on UUIMonsterDict_Content_02");

// Class DarwinGame.GameDataFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckFlagDefinition(const class FName& FlagName);
	static bool CheckFlagDefinitions(const TArray<class FName>& FlagNames, bool or_check);
	static bool CheckFlagMatch(const TMap<class FName, bool>& FlagNames);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataFunctionLibrary">();
	}
	static class UGameDataFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataFunctionLibrary>();
	}
};
static_assert(alignof(UGameDataFunctionLibrary) == 0x000008, "Wrong alignment on UGameDataFunctionLibrary");
static_assert(sizeof(UGameDataFunctionLibrary) == 0x000030, "Wrong size on UGameDataFunctionLibrary");

// Class DarwinGame.GameDataGuest
// 0x0070 (0x00A0 - 0x0030)
class UGameDataGuest final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataGuest* Clone();
	void GetConstValue_GuestMonsterLoopRange(EGuestType Type, int32* first, int32* last);
	int32 GetGuestMonsterHp(int32 globalGuestIndex);
	int32 GetGuestMonsterKindId(int32 globalGuestIndex);
	int32 GetGuestMonsterLevel(int32 globalGuestIndex);
	int32 GetGuestMonsterMp(int32 globalGuestIndex);
	class FText GetGuestMonsterNickName(int32 globalGuestIndex);
	bool IsMainGuestMonsterIndex(int32 globalGuestIndex);
	void Overwrite(class UGameDataGuest* game_data);
	int32 Remove(int32 globalGuestIndex);
	void SetGuestMonsterHp(int32 globalGuestIndex, int32 HP);
	void SetGuestMonsterKindId(int32 globalGuestIndex, int32 KindId);
	void SetGuestMonsterLevel(int32 globalGuestIndex, int32 Level);
	void SetGuestMonsterMp(int32 globalGuestIndex, int32 MP);
	void SetGuestMonsterNickName(int32 globalGuestIndex, const class FText& NickName);

	int32 GetMainGuestMax() const;
	int32 GetMax() const;
	int32 GetNumKind(int32 KindId, EGuestType guestType) const;
	bool IsEmptySlot(int32 globalGuestIndex) const;
	bool IsMax(EGuestType guestType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataGuest">();
	}
	static class UGameDataGuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataGuest>();
	}
};
static_assert(alignof(UGameDataGuest) == 0x000008, "Wrong alignment on UGameDataGuest");
static_assert(sizeof(UGameDataGuest) == 0x0000A0, "Wrong size on UGameDataGuest");

// Class DarwinGame.GameDataGuestLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataGuestLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataGuestLibrary">();
	}
	static class UGameDataGuestLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataGuestLibrary>();
	}
};
static_assert(alignof(UGameDataGuestLibrary) == 0x000008, "Wrong alignment on UGameDataGuestLibrary");
static_assert(sizeof(UGameDataGuestLibrary) == 0x000030, "Wrong size on UGameDataGuestLibrary");

// Class DarwinGame.GameDataHeader
// 0x0028 (0x0058 - 0x0030)
class UGameDataHeader final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataHeader* Clone();
	void Overwrite(class UGameDataHeader* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataHeader">();
	}
	static class UGameDataHeader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataHeader>();
	}
};
static_assert(alignof(UGameDataHeader) == 0x000008, "Wrong alignment on UGameDataHeader");
static_assert(sizeof(UGameDataHeader) == 0x000058, "Wrong size on UGameDataHeader");

// Class DarwinGame.GameDataHistoryLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataHistoryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataHistoryLibrary">();
	}
	static class UGameDataHistoryLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataHistoryLibrary>();
	}
};
static_assert(alignof(UGameDataHistoryLibrary) == 0x000008, "Wrong alignment on UGameDataHistoryLibrary");
static_assert(sizeof(UGameDataHistoryLibrary) == 0x000030, "Wrong size on UGameDataHistoryLibrary");

// Class DarwinGame.GameDataManager
// 0x0008 (0x0040 - 0x0038)
class UGameDataManager : public UManagerBase
{
public:
	class UGameDatabase*                          mGameDatabase;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGameDataManager* GetInstance();

	class UGameDatabase* GetGameDatabase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataManager">();
	}
	static class UGameDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataManager>();
	}
};
static_assert(alignof(UGameDataManager) == 0x000008, "Wrong alignment on UGameDataManager");
static_assert(sizeof(UGameDataManager) == 0x000040, "Wrong size on UGameDataManager");
static_assert(offsetof(UGameDataManager, mGameDatabase) == 0x000038, "Member 'UGameDataManager::mGameDatabase' has a wrong offset!");

// Class DarwinGame.ProjectHttpManager
// 0x00D0 (0x0108 - 0x0038)
class UProjectHttpManager final : public UManagerBase
{
public:
	uint8                                         Pad_38[0xD0];                                      // 0x0038(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UProjectHttpManager* GetInstance();

	bool IsTermsAccepted() const;
	bool IsTermsFirstLook() const;
	bool IsTermsLooked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectHttpManager">();
	}
	static class UProjectHttpManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectHttpManager>();
	}
};
static_assert(alignof(UProjectHttpManager) == 0x000008, "Wrong alignment on UProjectHttpManager");
static_assert(sizeof(UProjectHttpManager) == 0x000108, "Wrong size on UProjectHttpManager");

// Class DarwinGame.UIRivalBase
// 0x0040 (0x0538 - 0x04F8)
class UUIRivalBase : public UUIStartLoopAnimation
{
public:
	float                                         CloseTime;                                         // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WordInSound;                                       // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WordInVoice;                                       // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FlagDataTable;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImgFlag;                                           // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRivalBase">();
	}
	static class UUIRivalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRivalBase>();
	}
};
static_assert(alignof(UUIRivalBase) == 0x000008, "Wrong alignment on UUIRivalBase");
static_assert(sizeof(UUIRivalBase) == 0x000538, "Wrong size on UUIRivalBase");
static_assert(offsetof(UUIRivalBase, CloseTime) == 0x0004F8, "Member 'UUIRivalBase::CloseTime' has a wrong offset!");
static_assert(offsetof(UUIRivalBase, WordInSound) == 0x000500, "Member 'UUIRivalBase::WordInSound' has a wrong offset!");
static_assert(offsetof(UUIRivalBase, WordInVoice) == 0x000510, "Member 'UUIRivalBase::WordInVoice' has a wrong offset!");
static_assert(offsetof(UUIRivalBase, FlagDataTable) == 0x000520, "Member 'UUIRivalBase::FlagDataTable' has a wrong offset!");
static_assert(offsetof(UUIRivalBase, ImgFlag) == 0x000528, "Member 'UUIRivalBase::ImgFlag' has a wrong offset!");

// Class DarwinGame.UIRival_02
// 0x0000 (0x0538 - 0x0538)
class UUIRival_02 : public UUIRivalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRival_02">();
	}
	static class UUIRival_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRival_02>();
	}
};
static_assert(alignof(UUIRival_02) == 0x000008, "Wrong alignment on UUIRival_02");
static_assert(sizeof(UUIRival_02) == 0x000538, "Wrong size on UUIRival_02");

// Class DarwinGame.GameDataMyTeam
// 0x00A0 (0x00D0 - 0x0030)
class UGameDataMyTeam final : public UObject
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataMyTeam* Clone();
	void Overwrite(class UGameDataMyTeam* game_data);
	void SetTeamFlagID(int32 FlagId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataMyTeam">();
	}
	static class UGameDataMyTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataMyTeam>();
	}
};
static_assert(alignof(UGameDataMyTeam) == 0x000008, "Wrong alignment on UGameDataMyTeam");
static_assert(sizeof(UGameDataMyTeam) == 0x0000D0, "Wrong size on UGameDataMyTeam");

// Class DarwinGame.GameDataMyTeamLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataMyTeamLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataMyTeamLibrary">();
	}
	static class UGameDataMyTeamLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataMyTeamLibrary>();
	}
};
static_assert(alignof(UGameDataMyTeamLibrary) == 0x000008, "Wrong alignment on UGameDataMyTeamLibrary");
static_assert(sizeof(UGameDataMyTeamLibrary) == 0x000030, "Wrong size on UGameDataMyTeamLibrary");

// Class DarwinGame.GameDataNetwork
// 0x0770 (0x07A0 - 0x0030)
class UGameDataNetwork final : public UObject
{
public:
	uint8                                         Pad_30[0x770];                                     // 0x0030(0x0770)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataNetwork* Clone();
	void Overwrite(class UGameDataNetwork* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataNetwork">();
	}
	static class UGameDataNetwork* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataNetwork>();
	}
};
static_assert(alignof(UGameDataNetwork) == 0x000008, "Wrong alignment on UGameDataNetwork");
static_assert(sizeof(UGameDataNetwork) == 0x0007A0, "Wrong size on UGameDataNetwork");

// Class DarwinGame.GameDataNPCLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataNPCLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataNPCLibrary">();
	}
	static class UGameDataNPCLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataNPCLibrary>();
	}
};
static_assert(alignof(UGameDataNPCLibrary) == 0x000008, "Wrong alignment on UGameDataNPCLibrary");
static_assert(sizeof(UGameDataNPCLibrary) == 0x000030, "Wrong size on UGameDataNPCLibrary");

// Class DarwinGame.UIRival_00
// 0x0000 (0x0538 - 0x0538)
class UUIRival_00 : public UUIRivalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRival_00">();
	}
	static class UUIRival_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRival_00>();
	}
};
static_assert(alignof(UUIRival_00) == 0x000008, "Wrong alignment on UUIRival_00");
static_assert(sizeof(UUIRival_00) == 0x000538, "Wrong size on UUIRival_00");

// Class DarwinGame.GameDataOption
// 0x0040 (0x0070 - 0x0030)
class UGameDataOption final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataOption* Clone();
	void Overwrite(class UGameDataOption* game_data);
	void SetAmbientValue(const EOptionAmbient InAmbientValue);
	void SetAntialiasingValue(const EOptionAntialiasing InAntialiasingValue);
	void SetBGMVolume(const EOptionSoundVolume InBGMVolume);
	void SetBloomValue(const EOptionBloom InBloomValue);
	void SetBrightnessVolume(const EOptionBrightness InBrightnesVolum);
	void SetCameraLeftRightIsNormal(const bool InCameraLeftRightIsNormal);
	void SetCameraLeftRightSpeed(const ECameraYawRotateSpeedRatePolicy InCameraLeftRightSpeed);
	void SetCameraUpDownIsNormal(const bool InCameraUpDownIsNormal);
	void SetCameraUpDownSpeed(const ECameraPitchRotateSpeedRatePolicy InCameraUpDownSpeed);
	void SetControllerLayout(const ELayoutController InControllerLayout);
	void SetDensityValue(const EOptionDensity InDensityValue);
	void SetFpsValue(const float InFpsValue);
	void SetIsMouseAttackMode(const bool IsMouseAttackMode);
	void SetIsUsingAController(const bool IsUsingAController);
	void SetKeyboardLayout(const ELayoutKeyboard InKeyboardLayout);
	void SetLanguageVoiceType(const ELanguageVoiceType InLanguageVoiceType);
	void SetLODValue(const EOptionLOD InLODValue);
	void SetPresetValue(const EOptionPreset InPresetValue);
	void SetReflectionValue(const EOptionReflection InReflectionValue);
	void SetResolutionIndexValue(const EOptionResolutionIndex InResolutionIndexValue);
	void SetSEVolume(const EOptionSoundVolume InSEVolume);
	void SetShadowValue(const EOptionShadow InShadowValue);
	void SetSubtitlesIsVisible(const bool InSubtitlesIsVisible);
	void SetTextureDetailValue(const EOptionGraphicsQuality InTextureDetailValue);
	void SetTextureFilterValue(const EOptionGraphicsQuality InTextureFilterValue);
	void SetVoiceVolume(const EOptionSoundVolume InVoiceVolum);
	void SetVsyncIsEnabled(const bool InVysncIsEnabled);
	void SetWindowModeValue(const EOptionWindowMode InWindowModeValue);

	EOptionAmbient GetAmbientValue() const;
	EOptionAntialiasing GetAntialiasingValue() const;
	EOptionSoundVolume GetBGMVolume() const;
	float GetBGMVolumeRate() const;
	EOptionBloom GetBloomValue() const;
	EOptionBrightness GetBrightnessVolumeRate() const;
	bool GetCameraLeftRightIsNormal() const;
	ECameraYawRotateSpeedRatePolicy GetCameraLeftRightSpeed() const;
	bool GetCameraUpDownIsNormal() const;
	ECameraPitchRotateSpeedRatePolicy GetCameraUpDownSpeed() const;
	ELayoutController GetControllerLayout() const;
	EOptionDensity GetDensityValue() const;
	float GetFpsValue() const;
	bool GetIsMouseAttackMode() const;
	bool GetIsUsingAController() const;
	ELayoutKeyboard GetKeyboardLayout() const;
	ELanguageVoiceType GetLanguageVoiceType() const;
	EOptionLOD GetLODValue() const;
	EOptionPreset GetPresetValue() const;
	EOptionReflection GetReflectionValue() const;
	EOptionResolutionIndex GetResolutionIndexValue() const;
	EOptionSoundVolume GetSEVolume() const;
	float GetSEVolumeRate() const;
	EOptionShadow GetShadowValue() const;
	bool GetSubtitlesIsVisible() const;
	EOptionGraphicsQuality GetTextureDetailValue() const;
	EOptionGraphicsQuality GetTextureFilterValue() const;
	EOptionSoundVolume GetVoiceVolume() const;
	float GetVoiceVolumeRate() const;
	bool GetVsyncIsEnabled() const;
	EOptionWindowMode GetWindowModeValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataOption">();
	}
	static class UGameDataOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataOption>();
	}
};
static_assert(alignof(UGameDataOption) == 0x000008, "Wrong alignment on UGameDataOption");
static_assert(sizeof(UGameDataOption) == 0x000070, "Wrong size on UGameDataOption");

// Class DarwinGame.GameDataParty
// 0x0168 (0x0198 - 0x0030)
class UGameDataParty final : public UObject
{
public:
	uint8                                         Pad_30[0x168];                                     // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataParty* Clone();
	TArray<int32> GetClearPartyMonsterUIds();
	void GetConstValue_PartyMonsterLoopRange(EPartyType Type, int32* first, int32* last);
	int32 GetPartyMonsterHp(int32 globalPartyIndex);
	int32 GetPartyMonsterKindId(int32 globalPartyIndex);
	int32 GetPartyMonsterLevel(int32 globalPartyIndex);
	int32 GetPartyMonsterMp(int32 globalPartyIndex);
	class FText GetPartyMonsterNickName(int32 globalPartyIndex);
	void Overwrite(class UGameDataParty* game_data);
	int32 Remove(int32 globalPartyIndex);
	void SetClearPartyMonsterUIds(const TArray<int32>& clearPartyMonsterUids);
	void SetPartyMonsterHp(int32 globalPartyIndex, int32 HP);
	void SetPartyMonsterKindId(int32 globalPartyIndex, int32 KindId);
	void SetPartyMonsterLevel(int32 globalPartyIndex, int32 Level);
	void SetPartyMonsterMp(int32 globalPartyIndex, int32 MP);
	void SetPartyMonsterNickName(int32 globalPartyIndex, const class FText& NickName);
	void Swap(int32 firstGlobalPartyIndex, int32 secoundGlobalPartyIndex);

	int32 GetMainPartyMax() const;
	const TArray<int32> GetMatchArtifactMonsterList() const;
	int32 GetMax() const;
	int32 GetNumKind(int32 KindId, EPartyType partyType) const;
	bool IsEmptySlot(int32 globalPartyIndex) const;
	bool IsMainPartyMonsterIndex(int32 globalPartyIndex) const;
	bool IsMax(EPartyType partyType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataParty">();
	}
	static class UGameDataParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataParty>();
	}
};
static_assert(alignof(UGameDataParty) == 0x000008, "Wrong alignment on UGameDataParty");
static_assert(sizeof(UGameDataParty) == 0x000198, "Wrong size on UGameDataParty");

// Class DarwinGame.StationElevator
// 0x0078 (0x0328 - 0x02B0)
class AStationElevator final : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEffectBase>                mSmogEffectClass;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x68];                                     // 0x02C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeBottomElevatorState(EElevatorState State);
	void ChangeTopElevatorState(EElevatorState State);
	bool GetIsOpenDoor();
	void PlayCloseDoor();
	void PlayElevatorArrivalEventStart(const float StartOffset);
	void PlayElevatorMoveEventStart(bool bToTop);
	void PlayOpenDoor();
	void SetBottom();
	void SetTop();

	struct FVector getBottomPosition() const;
	struct FVector getTopPosition() const;
	bool IsBottom() const;
	bool IsEndedEvent() const;
	bool IsTop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationElevator">();
	}
	static class AStationElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStationElevator>();
	}
};
static_assert(alignof(AStationElevator) == 0x000008, "Wrong alignment on AStationElevator");
static_assert(sizeof(AStationElevator) == 0x000328, "Wrong size on AStationElevator");
static_assert(offsetof(AStationElevator, mSmogEffectClass) == 0x0002B8, "Member 'AStationElevator::mSmogEffectClass' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_BG
// 0x0010 (0x04A0 - 0x0490)
class UUIPartyMenu_BG : public UDarwinUserWidget
{
public:
	class UTexture2D*                             DefaultBackGroundTex;                              // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImgBG1;                                            // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_BG">();
	}
	static class UUIPartyMenu_BG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_BG>();
	}
};
static_assert(alignof(UUIPartyMenu_BG) == 0x000008, "Wrong alignment on UUIPartyMenu_BG");
static_assert(sizeof(UUIPartyMenu_BG) == 0x0004A0, "Wrong size on UUIPartyMenu_BG");
static_assert(offsetof(UUIPartyMenu_BG, DefaultBackGroundTex) == 0x000490, "Member 'UUIPartyMenu_BG::DefaultBackGroundTex' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_BG, ImgBG1) == 0x000498, "Member 'UUIPartyMenu_BG::ImgBG1' has a wrong offset!");

// Class DarwinGame.GameDataPartyLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataPartyLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataPartyLibrary">();
	}
	static class UGameDataPartyLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataPartyLibrary>();
	}
};
static_assert(alignof(UGameDataPartyLibrary) == 0x000008, "Wrong alignment on UGameDataPartyLibrary");
static_assert(sizeof(UGameDataPartyLibrary) == 0x000030, "Wrong size on UGameDataPartyLibrary");

// Class DarwinGame.GameDataPlayerLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataPlayerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataPlayerLibrary">();
	}
	static class UGameDataPlayerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataPlayerLibrary>();
	}
};
static_assert(alignof(UGameDataPlayerLibrary) == 0x000008, "Wrong alignment on UGameDataPlayerLibrary");
static_assert(sizeof(UGameDataPlayerLibrary) == 0x000030, "Wrong size on UGameDataPlayerLibrary");

// Class DarwinGame.GameDataSavePoint
// 0x0028 (0x0058 - 0x0030)
class UGameDataSavePoint final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataSavePoint* Clone();
	void Overwrite(class UGameDataSavePoint* game_data);
	void SetSavePointLocation(const struct FVector& save_location);
	void SetSavePointPersistentId(EPersistentLevelID persistent_id);
	void SetSavePointRotation(const struct FRotator& save_rotation);

	const struct FVector GetSavePointLocation() const;
	EPersistentLevelID GetSavePointPersistentId() const;
	const struct FRotator GetSavePointRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataSavePoint">();
	}
	static class UGameDataSavePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataSavePoint>();
	}
};
static_assert(alignof(UGameDataSavePoint) == 0x000008, "Wrong alignment on UGameDataSavePoint");
static_assert(sizeof(UGameDataSavePoint) == 0x000058, "Wrong size on UGameDataSavePoint");

// Class DarwinGame.UIPanelIconDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIPanelIconDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelIconDataTable">();
	}
	static class UUIPanelIconDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelIconDataTable>();
	}
};
static_assert(alignof(UUIPanelIconDataTable) == 0x000008, "Wrong alignment on UUIPanelIconDataTable");
static_assert(sizeof(UUIPanelIconDataTable) == 0x000030, "Wrong size on UUIPanelIconDataTable");

// Class DarwinGame.GameDataSavePointLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataSavePointLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataSavePointLibrary">();
	}
	static class UGameDataSavePointLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataSavePointLibrary>();
	}
};
static_assert(alignof(UGameDataSavePointLibrary) == 0x000008, "Wrong alignment on UGameDataSavePointLibrary");
static_assert(sizeof(UGameDataSavePointLibrary) == 0x000030, "Wrong size on UGameDataSavePointLibrary");

// Class DarwinGame.GameDataScenarioProgress
// 0x0058 (0x0088 - 0x0030)
class UGameDataScenarioProgress final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataScenarioProgress* Clone();
	void Overwrite(class UGameDataScenarioProgress* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataScenarioProgress">();
	}
	static class UGameDataScenarioProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataScenarioProgress>();
	}
};
static_assert(alignof(UGameDataScenarioProgress) == 0x000008, "Wrong alignment on UGameDataScenarioProgress");
static_assert(sizeof(UGameDataScenarioProgress) == 0x000088, "Wrong size on UGameDataScenarioProgress");

// Class DarwinGame.TargetArrowComponent
// 0x0060 (0x0118 - 0x00B8)
class UTargetArrowComponent final : public UActorComponent
{
public:
	float                                         mArrivalTime;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mLineSpace;                                        // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       mSpline;                                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x50];                                      // 0x00C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetRadius(float Radius);
	void TargetChange(class AActor* Target);
	void TargetEnd();
	void TargetStart(class AActor* Start, class AActor* Target);
	void TargetStartCount(class AActor* Start, class AActor* Target, int32 Count);

	bool IsFinish() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetArrowComponent">();
	}
	static class UTargetArrowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetArrowComponent>();
	}
};
static_assert(alignof(UTargetArrowComponent) == 0x000008, "Wrong alignment on UTargetArrowComponent");
static_assert(sizeof(UTargetArrowComponent) == 0x000118, "Wrong size on UTargetArrowComponent");
static_assert(offsetof(UTargetArrowComponent, mArrivalTime) == 0x0000B8, "Member 'UTargetArrowComponent::mArrivalTime' has a wrong offset!");
static_assert(offsetof(UTargetArrowComponent, mLineSpace) == 0x0000BC, "Member 'UTargetArrowComponent::mLineSpace' has a wrong offset!");
static_assert(offsetof(UTargetArrowComponent, mSpline) == 0x0000C0, "Member 'UTargetArrowComponent::mSpline' has a wrong offset!");

// Class DarwinGame.UIPossess_Win_01
// 0x0000 (0x05F0 - 0x05F0)
class UUIPossess_Win_01 : public UUIWinMenuCloseOnly
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPossess_Win_01">();
	}
	static class UUIPossess_Win_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPossess_Win_01>();
	}
};
static_assert(alignof(UUIPossess_Win_01) == 0x000008, "Wrong alignment on UUIPossess_Win_01");
static_assert(sizeof(UUIPossess_Win_01) == 0x0005F0, "Wrong size on UUIPossess_Win_01");

// Class DarwinGame.GameDataScenarioProgressLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataScenarioProgressLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataScenarioProgressLibrary">();
	}
	static class UGameDataScenarioProgressLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataScenarioProgressLibrary>();
	}
};
static_assert(alignof(UGameDataScenarioProgressLibrary) == 0x000008, "Wrong alignment on UGameDataScenarioProgressLibrary");
static_assert(sizeof(UGameDataScenarioProgressLibrary) == 0x000030, "Wrong size on UGameDataScenarioProgressLibrary");

// Class DarwinGame.GameDataShopLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataShopLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataShopLibrary">();
	}
	static class UGameDataShopLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataShopLibrary>();
	}
};
static_assert(alignof(UGameDataShopLibrary) == 0x000008, "Wrong alignment on UGameDataShopLibrary");
static_assert(sizeof(UGameDataShopLibrary) == 0x000030, "Wrong size on UGameDataShopLibrary");

// Class DarwinGame.GameDataStockMonster
// 0x0060 (0x0090 - 0x0030)
class UGameDataStockMonster final : public UObject
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataStockMonster* Clone();
	int32 GetStockMonsterKindNum(const class FName& KindId);
	void Overwrite(class UGameDataStockMonster* game_data);

	bool CanAddStockMonster() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataStockMonster">();
	}
	static class UGameDataStockMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataStockMonster>();
	}
};
static_assert(alignof(UGameDataStockMonster) == 0x000008, "Wrong alignment on UGameDataStockMonster");
static_assert(sizeof(UGameDataStockMonster) == 0x000090, "Wrong size on UGameDataStockMonster");

// Class DarwinGame.GameDataStockMonsterLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataStockMonsterLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataStockMonsterLibrary">();
	}
	static class UGameDataStockMonsterLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataStockMonsterLibrary>();
	}
};
static_assert(alignof(UGameDataStockMonsterLibrary) == 0x000008, "Wrong alignment on UGameDataStockMonsterLibrary");
static_assert(sizeof(UGameDataStockMonsterLibrary) == 0x000030, "Wrong size on UGameDataStockMonsterLibrary");

// Class DarwinGame.UIArtifactList_ArtifactIcon
// 0x0008 (0x0498 - 0x0490)
class UUIArtifactList_ArtifactIcon : public UDarwinUserWidget
{
public:
	class UImage*                                 Icon;                                              // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactList_ArtifactIcon">();
	}
	static class UUIArtifactList_ArtifactIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactList_ArtifactIcon>();
	}
};
static_assert(alignof(UUIArtifactList_ArtifactIcon) == 0x000008, "Wrong alignment on UUIArtifactList_ArtifactIcon");
static_assert(sizeof(UUIArtifactList_ArtifactIcon) == 0x000498, "Wrong size on UUIArtifactList_ArtifactIcon");
static_assert(offsetof(UUIArtifactList_ArtifactIcon, Icon) == 0x000490, "Member 'UUIArtifactList_ArtifactIcon::Icon' has a wrong offset!");

// Class DarwinGame.GameDataTargetObject
// 0x0058 (0x0088 - 0x0030)
class UGameDataTargetObject final : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameDataTargetObject* Clone();
	void Overwrite(class UGameDataTargetObject* game_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataTargetObject">();
	}
	static class UGameDataTargetObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataTargetObject>();
	}
};
static_assert(alignof(UGameDataTargetObject) == 0x000008, "Wrong alignment on UGameDataTargetObject");
static_assert(sizeof(UGameDataTargetObject) == 0x000088, "Wrong size on UGameDataTargetObject");

// Class DarwinGame.UIShot_IconRange
// 0x0020 (0x05F0 - 0x05D0)
class UUIShot_IconRange : public UUIScrollMenuBase
{
public:
	struct FST_SlingShotCategory                  CategoryData;                                      // 0x05D0(0x0020)(Protected, NativeAccessSpecifierProtected)

public:
	void SetData(const struct FST_SlingShotCategory& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShot_IconRange">();
	}
	static class UUIShot_IconRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShot_IconRange>();
	}
};
static_assert(alignof(UUIShot_IconRange) == 0x000008, "Wrong alignment on UUIShot_IconRange");
static_assert(sizeof(UUIShot_IconRange) == 0x0005F0, "Wrong size on UUIShot_IconRange");
static_assert(offsetof(UUIShot_IconRange, CategoryData) == 0x0005D0, "Member 'UUIShot_IconRange::CategoryData' has a wrong offset!");

// Class DarwinGame.GameDataTargetObjectLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataTargetObjectLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataTargetObjectLibrary">();
	}
	static class UGameDataTargetObjectLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataTargetObjectLibrary>();
	}
};
static_assert(alignof(UGameDataTargetObjectLibrary) == 0x000008, "Wrong alignment on UGameDataTargetObjectLibrary");
static_assert(sizeof(UGameDataTargetObjectLibrary) == 0x000030, "Wrong size on UGameDataTargetObjectLibrary");

// Class DarwinGame.GameDataTipsLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataTipsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataTipsLibrary">();
	}
	static class UGameDataTipsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataTipsLibrary>();
	}
};
static_assert(alignof(UGameDataTipsLibrary) == 0x000008, "Wrong alignment on UGameDataTipsLibrary");
static_assert(sizeof(UGameDataTipsLibrary) == 0x000030, "Wrong size on UGameDataTipsLibrary");

// Class DarwinGame.UIArtifactSortFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIArtifactSortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactSortFunctionLibrary">();
	}
	static class UUIArtifactSortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactSortFunctionLibrary>();
	}
};
static_assert(alignof(UUIArtifactSortFunctionLibrary) == 0x000008, "Wrong alignment on UUIArtifactSortFunctionLibrary");
static_assert(sizeof(UUIArtifactSortFunctionLibrary) == 0x000030, "Wrong size on UUIArtifactSortFunctionLibrary");

// Class DarwinGame.GameDataUIMap
// 0x0090 (0x00C0 - 0x0030)
class UGameDataUIMap final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             EnterAreaMask;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EnterFloorAreaMask;                                // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddSignData(EMapSymbolType Type, int32 FloorNum, class FName AreaID, const struct FVector& Location);
	class UGameDataUIMap* Clone();
	void CreateEnterAreaData(int32 ArraySize);
	void CreateEnterFloorAreaData(int32 ArraySize);
	class UTexture2D* GetEnterAreaMask();
	class UTexture2D* GetEnterFloorAreaMask();
	bool GetIsFirstOpenAllMap();
	bool GetIsFirstOpenFaskullMap();
	int32 GetZoomScaleIndex();
	void Overwrite(class UGameDataUIMap* game_data);
	void RemoveSignData(EMapSymbolType Type);
	void SetEnterArea(int32 EnterAreaIndex, int32 Value);
	void SetEnterAreaMask(class UTexture2D* MaskData);
	void SetEnterFloorArea(int32 EnterFloorAreaIndex, int32 Value);
	void SetEnterFloorAreaMask(class UTexture2D* MaskData);
	void SetIsFirstOpenAllMap(bool Flag);
	void SetIsFirstOpenFaskullMap(bool Flag);
	void SetZoomScaleIndex(int32 Index_0);

	int32 GetEnterAreaValue(int32 EnterAreaIndex) const;
	int32 GetEnterFloorAreaValue(int32 EnterFloorAreaIndex) const;
	bool IsContainSignData(EMapSymbolType Type) const;
	bool IsEmptyArea() const;
	bool IsEmptyFloorArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataUIMap">();
	}
	static class UGameDataUIMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataUIMap>();
	}
};
static_assert(alignof(UGameDataUIMap) == 0x000008, "Wrong alignment on UGameDataUIMap");
static_assert(sizeof(UGameDataUIMap) == 0x0000C0, "Wrong size on UGameDataUIMap");
static_assert(offsetof(UGameDataUIMap, EnterAreaMask) == 0x0000B0, "Member 'UGameDataUIMap::EnterAreaMask' has a wrong offset!");
static_assert(offsetof(UGameDataUIMap, EnterFloorAreaMask) == 0x0000B8, "Member 'UGameDataUIMap::EnterFloorAreaMask' has a wrong offset!");

// Class DarwinGame.GameDataUIMapLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameDataUIMapLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataUIMapLibrary">();
	}
	static class UGameDataUIMapLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataUIMapLibrary>();
	}
};
static_assert(alignof(UGameDataUIMapLibrary) == 0x000008, "Wrong alignment on UGameDataUIMapLibrary");
static_assert(sizeof(UGameDataUIMapLibrary) == 0x000030, "Wrong size on UGameDataUIMapLibrary");

// Class DarwinGame.UIShot_Detail
// 0x0028 (0x04B8 - 0x0490)
class UUIShot_Detail : public UDarwinUserWidget
{
public:
	class UTextBlock*                             CategoryText;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BaseImage;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsShotDetaile;                                     // 0x04B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShot_Detail">();
	}
	static class UUIShot_Detail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShot_Detail>();
	}
};
static_assert(alignof(UUIShot_Detail) == 0x000008, "Wrong alignment on UUIShot_Detail");
static_assert(sizeof(UUIShot_Detail) == 0x0004B8, "Wrong size on UUIShot_Detail");
static_assert(offsetof(UUIShot_Detail, CategoryText) == 0x000490, "Member 'UUIShot_Detail::CategoryText' has a wrong offset!");
static_assert(offsetof(UUIShot_Detail, BaseImage) == 0x000498, "Member 'UUIShot_Detail::BaseImage' has a wrong offset!");
static_assert(offsetof(UUIShot_Detail, HorizontalBox) == 0x0004A0, "Member 'UUIShot_Detail::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UUIShot_Detail, IconImage) == 0x0004A8, "Member 'UUIShot_Detail::IconImage' has a wrong offset!");
static_assert(offsetof(UUIShot_Detail, IsShotDetaile) == 0x0004B0, "Member 'UUIShot_Detail::IsShotDetaile' has a wrong offset!");

// Class DarwinGame.GameFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsClassDefaultObject(class UObject* Obj);
	static bool IsDebug();
	static bool IsEditor();
	static bool IsNotPlayInEditor(class UObject* Obj);
	static bool IsPlayInEditor(class UObject* Obj);
	static bool IsRelease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFunctionLibrary">();
	}
	static class UGameFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFunctionLibrary>();
	}
};
static_assert(alignof(UGameFunctionLibrary) == 0x000008, "Wrong alignment on UGameFunctionLibrary");
static_assert(sizeof(UGameFunctionLibrary) == 0x000030, "Wrong size on UGameFunctionLibrary");

// Class DarwinGame.UIAutoSell_Win_01
// 0x0000 (0x05F0 - 0x05F0)
class UUIAutoSell_Win_01 : public UUIWinMenuCloseOnly
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAutoSell_Win_01">();
	}
	static class UUIAutoSell_Win_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAutoSell_Win_01>();
	}
};
static_assert(alignof(UUIAutoSell_Win_01) == 0x000008, "Wrong alignment on UUIAutoSell_Win_01");
static_assert(sizeof(UUIAutoSell_Win_01) == 0x0005F0, "Wrong size on UUIAutoSell_Win_01");

// Class DarwinGame.GameplayEffectDataTable
// 0x0000 (0x0030 - 0x0030)
class UGameplayEffectDataTable final : public UBlueprintFunctionLibrary
{
public:
	static TSubclassOf<class UGameplayEffect> GetEffect(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffectDataTable">();
	}
	static class UGameplayEffectDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectDataTable>();
	}
};
static_assert(alignof(UGameplayEffectDataTable) == 0x000008, "Wrong alignment on UGameplayEffectDataTable");
static_assert(sizeof(UGameplayEffectDataTable) == 0x000030, "Wrong size on UGameplayEffectDataTable");

// Class DarwinGame.GameProgress
// 0x0060 (0x0090 - 0x0030)
class UGameProgress : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEpisodeType, class UDataTable*>         EpisodeDataTableList;                              // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UDataTable*                             DT_MainScenarioDestinationPoint;                   // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	int32 GetEpisodeProgressMaxNum(EEpisodeType episode_type);
	void UpdateChapter();
	void UpdateEpisodeProgress(EEpisodeType update_episode_type);
	void UpdateEpisodeProgressAll();

	int32 GetChapterNum() const;
	class FName GetCurrentEpisodeProgressID(EEpisodeType episode_type) const;
	int32 GetEpisodeProgress(EEpisodeType episode_type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameProgress">();
	}
	static class UGameProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameProgress>();
	}
};
static_assert(alignof(UGameProgress) == 0x000008, "Wrong alignment on UGameProgress");
static_assert(sizeof(UGameProgress) == 0x000090, "Wrong size on UGameProgress");
static_assert(offsetof(UGameProgress, EpisodeDataTableList) == 0x000038, "Member 'UGameProgress::EpisodeDataTableList' has a wrong offset!");
static_assert(offsetof(UGameProgress, DT_MainScenarioDestinationPoint) == 0x000088, "Member 'UGameProgress::DT_MainScenarioDestinationPoint' has a wrong offset!");

// Class DarwinGame.GameScriptDataAsset
// 0x0050 (0x0088 - 0x0038)
class UGameScriptDataAsset final : public UDataAsset
{
public:
	TMap<EAreaType, struct FGameScriptTableList>  mGameScriptMap;                                    // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameScriptDataAsset">();
	}
	static class UGameScriptDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameScriptDataAsset>();
	}
};
static_assert(alignof(UGameScriptDataAsset) == 0x000008, "Wrong alignment on UGameScriptDataAsset");
static_assert(sizeof(UGameScriptDataAsset) == 0x000088, "Wrong size on UGameScriptDataAsset");
static_assert(offsetof(UGameScriptDataAsset, mGameScriptMap) == 0x000038, "Member 'UGameScriptDataAsset::mGameScriptMap' has a wrong offset!");

// Class DarwinGame.UIBoardmenu_GoldIcon
// 0x0000 (0x0490 - 0x0490)
class UUIBoardmenu_GoldIcon final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_GoldIcon">();
	}
	static class UUIBoardmenu_GoldIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_GoldIcon>();
	}
};
static_assert(alignof(UUIBoardmenu_GoldIcon) == 0x000008, "Wrong alignment on UUIBoardmenu_GoldIcon");
static_assert(sizeof(UUIBoardmenu_GoldIcon) == 0x000490, "Wrong size on UUIBoardmenu_GoldIcon");

// Class DarwinGame.GameScriptManager
// 0x01F0 (0x0220 - 0x0030)
class UGameScriptManager : public UObject
{
public:
	TMap<class FName, class AGameScriptBase*>     GameScriptList;                                    // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           ExecuteRequestList;                                // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   mDebugEventRectActor;                              // 0x0098(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameScriptDataAsset*                   mDataAsset;                                        // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x50];                                      // 0x00C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FST_DebugEventRectInfo> DebugForceMoveEventRectList;                       // 0x0118(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FST_DebugEventRectInfo> DebugScenarioEventRectList;                        // 0x0168(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class ADebugEventRectActor*> DebugEventRectActorList;                           // 0x01B8(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           ExceptNpcList;                                     // 0x0208(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExceptNpcList(const class FName& NpcID);
	bool ContainsExceptNpcList(const class FName& NpcID);
	void ExecuteGameScriptAll();
	void RemoveExceptNpcList(const class FName& NpcID);
	void RemoveSpawnFriendMonsterNPC();
	void RemoveSpawnObjectAll();
	void ResetExceptNpcList();

	TArray<class AGameScriptBase*> GetAllGameScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameScriptManager">();
	}
	static class UGameScriptManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameScriptManager>();
	}
};
static_assert(alignof(UGameScriptManager) == 0x000008, "Wrong alignment on UGameScriptManager");
static_assert(sizeof(UGameScriptManager) == 0x000220, "Wrong size on UGameScriptManager");
static_assert(offsetof(UGameScriptManager, GameScriptList) == 0x000030, "Member 'UGameScriptManager::GameScriptList' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, ExecuteRequestList) == 0x000080, "Member 'UGameScriptManager::ExecuteRequestList' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, mDebugEventRectActor) == 0x000098, "Member 'UGameScriptManager::mDebugEventRectActor' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, mDataAsset) == 0x0000C0, "Member 'UGameScriptManager::mDataAsset' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, DebugForceMoveEventRectList) == 0x000118, "Member 'UGameScriptManager::DebugForceMoveEventRectList' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, DebugScenarioEventRectList) == 0x000168, "Member 'UGameScriptManager::DebugScenarioEventRectList' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, DebugEventRectActorList) == 0x0001B8, "Member 'UGameScriptManager::DebugEventRectActorList' has a wrong offset!");
static_assert(offsetof(UGameScriptManager, ExceptNpcList) == 0x000208, "Member 'UGameScriptManager::ExceptNpcList' has a wrong offset!");

// Class DarwinGame.GameSequenceFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameSequenceFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void StartEventSequence(const class FName& event_id, EQuestState quest_state, class FName fast_travel_id, bool debug_play, bool is_reopen_quest_ui, bool is_keep_hide_ui, bool is_keep_disable_input);
	static void StartFastTravelSequence(const class FName& fast_travel_id, EFastTravelWarpCategory warp, EFastTravelLoadingShowType loading_show_type, bool is_arrival_event_skip);
	static void StartNewItemGetSequence(bool bIsSkipTeamRankUpSequecne);
	static void StartOpenLevelSequence(const class FName& fast_travel_id);
	static void StartTeamRankUpSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSequenceFunctionLibrary">();
	}
	static class UGameSequenceFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSequenceFunctionLibrary>();
	}
};
static_assert(alignof(UGameSequenceFunctionLibrary) == 0x000008, "Wrong alignment on UGameSequenceFunctionLibrary");
static_assert(sizeof(UGameSequenceFunctionLibrary) == 0x000030, "Wrong size on UGameSequenceFunctionLibrary");

// Class DarwinGame.GameSetting
// 0x0040 (0x0070 - 0x0030)
class UGameSetting final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDisplaySettings();
	void ApplyGraphicSettings();
	EOptionResolutionIndex GetPCResolutionIndex(bool AllowUnsetValue);
	EOptionWindowMode GetPCWindowMode();
	void HandleResolutionChanges();
	void Initialize();
	void LoadStartupResolution();
	void ReflectDisplaySettings(const class UGameDataOption* GameDataOption);
	void ReflectGraphicSettings(const class UGameDataOption* GameDataOption);
	void ReflectSavedResolution();
	void RestoreDepthOfFieldQuality();
	void SetAmbient(EOptionAmbient InAmbientValue);
	void SetAntialiasing(EOptionAntialiasing InAntialiasing);
	void SetBloom(EOptionBloom InBloom);
	void SetBrightness(int32 InValue);
	void SetDensity(EOptionDensity InDensity);
	void SetDepthOfFieldQuality(int32 Quality);
	void SetDisplayData(EOptionBrightness InBrightnessVolume, float InFpsValue, bool InVysncIsEnabled);
	void SetGraphicData(EOptionAntialiasing InAntialiasingValue, EOptionAmbient InAmbientValue, EOptionShadow InShadowValue, EOptionGraphicsQuality InTextureFilterValue, EOptionGraphicsQuality InTextureDetailValue, EOptionDensity InDensityValue, EOptionLOD InLODValue, EOptionReflection InReflectionValue, EOptionBloom InBloomValue);
	void SetLOD(EOptionLOD InLOD);
	void SetPCFps(float InValue);
	void SetPCResolution(EOptionResolutionIndex InResolutionIndex);
	void SetPCVsync(bool InEnabled);
	void SetPCWindowMode(EOptionWindowMode InWindowMode);
	void SetReflection(EOptionReflection InReflection);
	void SetRendering(bool Visibility);
	void SetResolutionData(EOptionResolutionIndex InResolutionIndex, EOptionWindowMode InWindowMode);
	void SetShadow(EOptionShadow InShadow);
	void SetTextureDetail(EOptionGraphicsQuality InTextureDetail);
	void SetTextureFilter(EOptionGraphicsQuality InTextureFilter);

	struct FIntPoint GetWindowsDesktopResolution() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSetting">();
	}
	static class UGameSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSetting>();
	}
};
static_assert(alignof(UGameSetting) == 0x000008, "Wrong alignment on UGameSetting");
static_assert(sizeof(UGameSetting) == 0x000070, "Wrong size on UGameSetting");

// Class DarwinGame.GenSoundBaseComponent
// 0x0070 (0x0270 - 0x0200)
class UGenSoundBaseComponent : public USceneComponent
{
public:
	class FName                                   GroupName;                                         // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          GenMorning;                                        // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          GenNoon;                                           // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          GenEvening;                                        // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          GenNight;                                          // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         GenComp;                                           // 0x0228(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          SoundActiveRange;                                  // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SoundActiveRangeSize;                              // 0x0238(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsActivate;                                        // 0x0244(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AreaSoundName;                                     // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESoundInsulationType                          SIType;                                            // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTimer;                                         // 0x0254(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          CurrentPlaySound;                                  // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETimeZoneType                                 CurrentPlayTimeZone;                               // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0xF];                                      // 0x0261(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSoundActiveRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSoundActiveRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenSoundBaseComponent">();
	}
	static class UGenSoundBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenSoundBaseComponent>();
	}
};
static_assert(alignof(UGenSoundBaseComponent) == 0x000010, "Wrong alignment on UGenSoundBaseComponent");
static_assert(sizeof(UGenSoundBaseComponent) == 0x000270, "Wrong size on UGenSoundBaseComponent");
static_assert(offsetof(UGenSoundBaseComponent, GroupName) == 0x000200, "Member 'UGenSoundBaseComponent::GroupName' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, GenMorning) == 0x000208, "Member 'UGenSoundBaseComponent::GenMorning' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, GenNoon) == 0x000210, "Member 'UGenSoundBaseComponent::GenNoon' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, GenEvening) == 0x000218, "Member 'UGenSoundBaseComponent::GenEvening' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, GenNight) == 0x000220, "Member 'UGenSoundBaseComponent::GenNight' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, GenComp) == 0x000228, "Member 'UGenSoundBaseComponent::GenComp' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, SoundActiveRange) == 0x000230, "Member 'UGenSoundBaseComponent::SoundActiveRange' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, SoundActiveRangeSize) == 0x000238, "Member 'UGenSoundBaseComponent::SoundActiveRangeSize' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, IsActivate) == 0x000244, "Member 'UGenSoundBaseComponent::IsActivate' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, AreaSoundName) == 0x000248, "Member 'UGenSoundBaseComponent::AreaSoundName' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, SIType) == 0x000250, "Member 'UGenSoundBaseComponent::SIType' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, LifeTimer) == 0x000254, "Member 'UGenSoundBaseComponent::LifeTimer' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, CurrentPlaySound) == 0x000258, "Member 'UGenSoundBaseComponent::CurrentPlaySound' has a wrong offset!");
static_assert(offsetof(UGenSoundBaseComponent, CurrentPlayTimeZone) == 0x000260, "Member 'UGenSoundBaseComponent::CurrentPlayTimeZone' has a wrong offset!");

// Class DarwinGame.ObjectReactionUIComponent
// 0x0030 (0x0198 - 0x0168)
class UObjectReactionUIComponent final : public UObjectReactionBaseComponent
{
public:
	TSoftClassPtr<class UClass>                   UIClass;                                           // 0x0168(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mTipsID;                                           // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionUIComponent">();
	}
	static class UObjectReactionUIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionUIComponent>();
	}
};
static_assert(alignof(UObjectReactionUIComponent) == 0x000008, "Wrong alignment on UObjectReactionUIComponent");
static_assert(sizeof(UObjectReactionUIComponent) == 0x000198, "Wrong size on UObjectReactionUIComponent");
static_assert(offsetof(UObjectReactionUIComponent, UIClass) == 0x000168, "Member 'UObjectReactionUIComponent::UIClass' has a wrong offset!");
static_assert(offsetof(UObjectReactionUIComponent, mTipsID) == 0x000190, "Member 'UObjectReactionUIComponent::mTipsID' has a wrong offset!");

// Class DarwinGame.GetBackQuestFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGetBackQuestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetBackQuestFunctionLibrary">();
	}
	static class UGetBackQuestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetBackQuestFunctionLibrary>();
	}
};
static_assert(alignof(UGetBackQuestFunctionLibrary) == 0x000008, "Wrong alignment on UGetBackQuestFunctionLibrary");
static_assert(sizeof(UGetBackQuestFunctionLibrary) == 0x000030, "Wrong size on UGetBackQuestFunctionLibrary");

// Class DarwinGame.TreasureFigureTable
// 0x0000 (0x0030 - 0x0030)
class UTreasureFigureTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureFigureTable">();
	}
	static class UTreasureFigureTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTreasureFigureTable>();
	}
};
static_assert(alignof(UTreasureFigureTable) == 0x000008, "Wrong alignment on UTreasureFigureTable");
static_assert(sizeof(UTreasureFigureTable) == 0x000030, "Wrong size on UTreasureFigureTable");

// Class DarwinGame.UIQM_PanelQuestName
// 0x0070 (0x05A0 - 0x0530)
class UUIQM_PanelQuestName : public UUIPartyMenu_PM_Panel_Base
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPanelQuestColorType, struct FST_PanelQuestColor> TextColor;                                         // 0x0540(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             QuestNameBlock;                                    // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USideScrollTextBlock*                   ScrollBlock;                                       // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_PanelQuestName">();
	}
	static class UUIQM_PanelQuestName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_PanelQuestName>();
	}
};
static_assert(alignof(UUIQM_PanelQuestName) == 0x000008, "Wrong alignment on UUIQM_PanelQuestName");
static_assert(sizeof(UUIQM_PanelQuestName) == 0x0005A0, "Wrong size on UUIQM_PanelQuestName");
static_assert(offsetof(UUIQM_PanelQuestName, TextColor) == 0x000540, "Member 'UUIQM_PanelQuestName::TextColor' has a wrong offset!");
static_assert(offsetof(UUIQM_PanelQuestName, QuestNameBlock) == 0x000590, "Member 'UUIQM_PanelQuestName::QuestNameBlock' has a wrong offset!");
static_assert(offsetof(UUIQM_PanelQuestName, ScrollBlock) == 0x000598, "Member 'UUIQM_PanelQuestName::ScrollBlock' has a wrong offset!");

// Class DarwinGame.GiraMagicBase
// 0x00F0 (0x03E0 - 0x02F0)
class AGiraMagicBase final : public AMagicBase
{
public:
	uint8                                         Pad_2F0[0xF0];                                     // 0x02F0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StopPillarOfFier(class AEffectBase* Effect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GiraMagicBase">();
	}
	static class AGiraMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGiraMagicBase>();
	}
};
static_assert(alignof(AGiraMagicBase) == 0x000008, "Wrong alignment on AGiraMagicBase");
static_assert(sizeof(AGiraMagicBase) == 0x0003E0, "Wrong size on AGiraMagicBase");

// Class DarwinGame.GrenadeMagicBase
// 0x0050 (0x0360 - 0x0310)
class AGrenadeMagicBase final : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeMagicBase">();
	}
	static class AGrenadeMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeMagicBase>();
	}
};
static_assert(alignof(AGrenadeMagicBase) == 0x000008, "Wrong alignment on AGrenadeMagicBase");
static_assert(sizeof(AGrenadeMagicBase) == 0x000360, "Wrong size on AGrenadeMagicBase");

// Class DarwinGame.TreasurePedestalObject
// 0x0078 (0x0328 - 0x02B0)
class ATreasurePedestalObject final : public AFieldObjectBase
{
public:
	int32                                         mMyArtifactIndex;                                  // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ChildFigureActor;                                  // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        mTreasurePosition;                                 // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            mPedestalEffect;                                   // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEffectBase*                            mTargetedEffect;                                   // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseAreaTreasureStolenFlag*            mStolenFlag;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   mStolenFlagBP;                                     // 0x02E0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasurePedestalObject">();
	}
	static class ATreasurePedestalObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasurePedestalObject>();
	}
};
static_assert(alignof(ATreasurePedestalObject) == 0x000008, "Wrong alignment on ATreasurePedestalObject");
static_assert(sizeof(ATreasurePedestalObject) == 0x000328, "Wrong size on ATreasurePedestalObject");
static_assert(offsetof(ATreasurePedestalObject, mMyArtifactIndex) == 0x0002B0, "Member 'ATreasurePedestalObject::mMyArtifactIndex' has a wrong offset!");
static_assert(offsetof(ATreasurePedestalObject, ChildFigureActor) == 0x0002B8, "Member 'ATreasurePedestalObject::ChildFigureActor' has a wrong offset!");
static_assert(offsetof(ATreasurePedestalObject, mTreasurePosition) == 0x0002C0, "Member 'ATreasurePedestalObject::mTreasurePosition' has a wrong offset!");
static_assert(offsetof(ATreasurePedestalObject, mPedestalEffect) == 0x0002C8, "Member 'ATreasurePedestalObject::mPedestalEffect' has a wrong offset!");
static_assert(offsetof(ATreasurePedestalObject, mTargetedEffect) == 0x0002D0, "Member 'ATreasurePedestalObject::mTargetedEffect' has a wrong offset!");
static_assert(offsetof(ATreasurePedestalObject, mStolenFlag) == 0x0002D8, "Member 'ATreasurePedestalObject::mStolenFlag' has a wrong offset!");
static_assert(offsetof(ATreasurePedestalObject, mStolenFlagBP) == 0x0002E0, "Member 'ATreasurePedestalObject::mStolenFlagBP' has a wrong offset!");

// Class DarwinGame.SlingShotBulletBase
// 0x0070 (0x0320 - 0x02B0)
class ASlingShotBulletBase : public ABulletBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABulletPath*                            BulletPath;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x30];                                     // 0x02C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        TargetComponent;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x02F8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToEnableGravity;                               // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingTime;                                        // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HomingOffAngle;                                    // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlingShotBulletBase">();
	}
	static class ASlingShotBulletBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlingShotBulletBase>();
	}
};
static_assert(alignof(ASlingShotBulletBase) == 0x000008, "Wrong alignment on ASlingShotBulletBase");
static_assert(sizeof(ASlingShotBulletBase) == 0x000320, "Wrong size on ASlingShotBulletBase");
static_assert(offsetof(ASlingShotBulletBase, BulletPath) == 0x0002B8, "Member 'ASlingShotBulletBase::BulletPath' has a wrong offset!");
static_assert(offsetof(ASlingShotBulletBase, TargetComponent) == 0x0002F0, "Member 'ASlingShotBulletBase::TargetComponent' has a wrong offset!");
static_assert(offsetof(ASlingShotBulletBase, TargetLocation) == 0x0002F8, "Member 'ASlingShotBulletBase::TargetLocation' has a wrong offset!");
static_assert(offsetof(ASlingShotBulletBase, TimeToEnableGravity) == 0x000304, "Member 'ASlingShotBulletBase::TimeToEnableGravity' has a wrong offset!");
static_assert(offsetof(ASlingShotBulletBase, HomingTime) == 0x000308, "Member 'ASlingShotBulletBase::HomingTime' has a wrong offset!");
static_assert(offsetof(ASlingShotBulletBase, HomingOffAngle) == 0x00030C, "Member 'ASlingShotBulletBase::HomingOffAngle' has a wrong offset!");

// Class DarwinGame.GrenadeSlingShotBullet
// 0x0000 (0x0320 - 0x0320)
class AGrenadeSlingShotBullet final : public ASlingShotBulletBase
{
public:
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeSlingShotBullet">();
	}
	static class AGrenadeSlingShotBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenadeSlingShotBullet>();
	}
};
static_assert(alignof(AGrenadeSlingShotBullet) == 0x000008, "Wrong alignment on AGrenadeSlingShotBullet");
static_assert(sizeof(AGrenadeSlingShotBullet) == 0x000320, "Wrong size on AGrenadeSlingShotBullet");

// Class DarwinGame.UIProfile_TopBar
// 0x0010 (0x04A0 - 0x0490)
class UUIProfile_TopBar : public UDarwinUserWidget
{
public:
	class UUITabLRItemBase*                       LeftPageIcon;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITabLRItemBase*                       RightPageIcon;                                     // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProfile_TopBar">();
	}
	static class UUIProfile_TopBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProfile_TopBar>();
	}
};
static_assert(alignof(UUIProfile_TopBar) == 0x000008, "Wrong alignment on UUIProfile_TopBar");
static_assert(sizeof(UUIProfile_TopBar) == 0x0004A0, "Wrong size on UUIProfile_TopBar");
static_assert(offsetof(UUIProfile_TopBar, LeftPageIcon) == 0x000490, "Member 'UUIProfile_TopBar::LeftPageIcon' has a wrong offset!");
static_assert(offsetof(UUIProfile_TopBar, RightPageIcon) == 0x000498, "Member 'UUIProfile_TopBar::RightPageIcon' has a wrong offset!");

// Class DarwinGame.GroundCrawlMagicFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGroundCrawlMagicFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundCrawlMagicFunctionLibrary">();
	}
	static class UGroundCrawlMagicFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundCrawlMagicFunctionLibrary>();
	}
};
static_assert(alignof(UGroundCrawlMagicFunctionLibrary) == 0x000008, "Wrong alignment on UGroundCrawlMagicFunctionLibrary");
static_assert(sizeof(UGroundCrawlMagicFunctionLibrary) == 0x000030, "Wrong size on UGroundCrawlMagicFunctionLibrary");

// Class DarwinGame.OutbreakQuestGetBack
// 0x0000 (0x0340 - 0x0340)
class AOutbreakQuestGetBack final : public AOutbreakQuestRevengeBattle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestGetBack">();
	}
	static class AOutbreakQuestGetBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestGetBack>();
	}
};
static_assert(alignof(AOutbreakQuestGetBack) == 0x000008, "Wrong alignment on AOutbreakQuestGetBack");
static_assert(sizeof(AOutbreakQuestGetBack) == 0x000340, "Wrong size on AOutbreakQuestGetBack");

// Class DarwinGame.UI3DCharacterDataTable
// 0x0000 (0x0030 - 0x0030)
class UUI3DCharacterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI3DCharacterDataTable">();
	}
	static class UUI3DCharacterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI3DCharacterDataTable>();
	}
};
static_assert(alignof(UUI3DCharacterDataTable) == 0x000008, "Wrong alignment on UUI3DCharacterDataTable");
static_assert(sizeof(UUI3DCharacterDataTable) == 0x000030, "Wrong size on UUI3DCharacterDataTable");

// Class DarwinGame.GroundStateCrouch
// 0x0008 (0x0178 - 0x0170)
class UGroundStateCrouch final : public UGroundStateBase
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateCrouch">();
	}
	static class UGroundStateCrouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateCrouch>();
	}
};
static_assert(alignof(UGroundStateCrouch) == 0x000008, "Wrong alignment on UGroundStateCrouch");
static_assert(sizeof(UGroundStateCrouch) == 0x000178, "Wrong size on UGroundStateCrouch");

// Class DarwinGame.GroundStateDive
// 0x0020 (0x0190 - 0x0170)
class UGroundStateDive : public UGroundStateBase
{
public:
	uint8                                         Pad_170[0xA];                                      // 0x0170(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	ESocket                                       mUIAttachSocket;                                   // 0x017A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17B[0x1];                                      // 0x017B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mBoarderHeightToDuctMode;                          // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mThresholdHeightForCancel;                         // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mHeightOfGazePoint;                                // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mHeightOfGazePointInDuctMode;                      // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateDive">();
	}
	static class UGroundStateDive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateDive>();
	}
};
static_assert(alignof(UGroundStateDive) == 0x000008, "Wrong alignment on UGroundStateDive");
static_assert(sizeof(UGroundStateDive) == 0x000190, "Wrong size on UGroundStateDive");
static_assert(offsetof(UGroundStateDive, mUIAttachSocket) == 0x00017A, "Member 'UGroundStateDive::mUIAttachSocket' has a wrong offset!");
static_assert(offsetof(UGroundStateDive, mBoarderHeightToDuctMode) == 0x00017C, "Member 'UGroundStateDive::mBoarderHeightToDuctMode' has a wrong offset!");
static_assert(offsetof(UGroundStateDive, mThresholdHeightForCancel) == 0x000180, "Member 'UGroundStateDive::mThresholdHeightForCancel' has a wrong offset!");
static_assert(offsetof(UGroundStateDive, mHeightOfGazePoint) == 0x000184, "Member 'UGroundStateDive::mHeightOfGazePoint' has a wrong offset!");
static_assert(offsetof(UGroundStateDive, mHeightOfGazePointInDuctMode) == 0x000188, "Member 'UGroundStateDive::mHeightOfGazePointInDuctMode' has a wrong offset!");

// Class DarwinGame.OutbreakQuestPointDataTable
// 0x0000 (0x0030 - 0x0030)
class UOutbreakQuestPointDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestPointDataTable">();
	}
	static class UOutbreakQuestPointDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutbreakQuestPointDataTable>();
	}
};
static_assert(alignof(UOutbreakQuestPointDataTable) == 0x000008, "Wrong alignment on UOutbreakQuestPointDataTable");
static_assert(sizeof(UOutbreakQuestPointDataTable) == 0x000030, "Wrong size on UOutbreakQuestPointDataTable");

// Class DarwinGame.UILeftMenu_2
// 0x0000 (0x0650 - 0x0650)
class UUILeftMenu_2 : public UUILeftMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_2">();
	}
	static class UUILeftMenu_2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_2>();
	}
};
static_assert(alignof(UUILeftMenu_2) == 0x000008, "Wrong alignment on UUILeftMenu_2");
static_assert(sizeof(UUILeftMenu_2) == 0x000650, "Wrong size on UUILeftMenu_2");

// Class DarwinGame.GroundStateLand
// 0x0008 (0x0178 - 0x0170)
class UGroundStateLand : public UGroundStateBase
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInputEnabled(bool Enabled);
	void SetJumpEnabled(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateLand">();
	}
	static class UGroundStateLand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateLand>();
	}
};
static_assert(alignof(UGroundStateLand) == 0x000008, "Wrong alignment on UGroundStateLand");
static_assert(sizeof(UGroundStateLand) == 0x000178, "Wrong size on UGroundStateLand");

// Class DarwinGame.UIAbilityBase
// 0x0038 (0x0568 - 0x0530)
class UUIAbilityBase final : public UUIScrollMenuItemBase
{
public:
	class UImage*                                 AbilityIconWidget;                                 // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             AbilityNameWidget;                                 // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             AbilityNoteWidget;                                 // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICoinRankIcon*                        AbilityRankIcon;                                   // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUpDownIcon*                          AbilityUpDownIcon;                                 // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWidgetAnimation*>               AbilityPanelColorAnimetionArray;                   // 0x0558(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitWidget(class UImage* abilityIcon, class UTextBlock* nameWidget, class UTextBlock* noteWidget, class UUICoinRankIcon* rankIcon, class UUIUpDownIcon* upDownIcon, const TArray<class UWidgetAnimation*>& panelAnmAry);
	void SetData(const struct FST_CoinFeature& InParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAbilityBase">();
	}
	static class UUIAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAbilityBase>();
	}
};
static_assert(alignof(UUIAbilityBase) == 0x000008, "Wrong alignment on UUIAbilityBase");
static_assert(sizeof(UUIAbilityBase) == 0x000568, "Wrong size on UUIAbilityBase");
static_assert(offsetof(UUIAbilityBase, AbilityIconWidget) == 0x000530, "Member 'UUIAbilityBase::AbilityIconWidget' has a wrong offset!");
static_assert(offsetof(UUIAbilityBase, AbilityNameWidget) == 0x000538, "Member 'UUIAbilityBase::AbilityNameWidget' has a wrong offset!");
static_assert(offsetof(UUIAbilityBase, AbilityNoteWidget) == 0x000540, "Member 'UUIAbilityBase::AbilityNoteWidget' has a wrong offset!");
static_assert(offsetof(UUIAbilityBase, AbilityRankIcon) == 0x000548, "Member 'UUIAbilityBase::AbilityRankIcon' has a wrong offset!");
static_assert(offsetof(UUIAbilityBase, AbilityUpDownIcon) == 0x000550, "Member 'UUIAbilityBase::AbilityUpDownIcon' has a wrong offset!");
static_assert(offsetof(UUIAbilityBase, AbilityPanelColorAnimetionArray) == 0x000558, "Member 'UUIAbilityBase::AbilityPanelColorAnimetionArray' has a wrong offset!");

// Class DarwinGame.GroundStateSelfHeal
// 0x0008 (0x0178 - 0x0170)
class UGroundStateSelfHeal final : public UGroundStateBase
{
public:
	float                                         mHealInterval;                                     // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateSelfHeal">();
	}
	static class UGroundStateSelfHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateSelfHeal>();
	}
};
static_assert(alignof(UGroundStateSelfHeal) == 0x000008, "Wrong alignment on UGroundStateSelfHeal");
static_assert(sizeof(UGroundStateSelfHeal) == 0x000178, "Wrong size on UGroundStateSelfHeal");
static_assert(offsetof(UGroundStateSelfHeal, mHealInterval) == 0x000170, "Member 'UGroundStateSelfHeal::mHealInterval' has a wrong offset!");

// Class DarwinGame.GroundStateWalk
// 0x0008 (0x0178 - 0x0170)
class UGroundStateWalk final : public UGroundStateBase
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundStateWalk">();
	}
	static class UGroundStateWalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundStateWalk>();
	}
};
static_assert(alignof(UGroundStateWalk) == 0x000008, "Wrong alignment on UGroundStateWalk");
static_assert(sizeof(UGroundStateWalk) == 0x000178, "Wrong size on UGroundStateWalk");

// Class DarwinGame.GuestEditLibrary
// 0x0000 (0x0030 - 0x0030)
class UGuestEditLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 K2_Add(int32 stockUid, const struct FGuestEditOption& Option);
	static void K2_MemberChange(const TArray<int32>& stockUids, const struct FGuestEditOption& Option);
	static int32 K2_Remove(int32 partyIndex, const struct FGuestEditOption& Option);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuestEditLibrary">();
	}
	static class UGuestEditLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuestEditLibrary>();
	}
};
static_assert(alignof(UGuestEditLibrary) == 0x000008, "Wrong alignment on UGuestEditLibrary");
static_assert(sizeof(UGuestEditLibrary) == 0x000030, "Wrong size on UGuestEditLibrary");

// Class DarwinGame.HateFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UHateFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HateFunctionLibrary">();
	}
	static class UHateFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHateFunctionLibrary>();
	}
};
static_assert(alignof(UHateFunctionLibrary) == 0x000008, "Wrong alignment on UHateFunctionLibrary");
static_assert(sizeof(UHateFunctionLibrary) == 0x000030, "Wrong size on UHateFunctionLibrary");

// Class DarwinGame.SoundFoliageInstancedStaticMeshComponent
// 0x0030 (0x06A0 - 0x0670)
class USoundFoliageInstancedStaticMeshComponent final : public UFoliageInstancedStaticMeshComponent
{
public:
	TArray<class UESoundBase*>                    SoundComps;                                        // 0x0670(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UESoundBase>                SoundClass;                                        // 0x0680(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SoundCompRelativeLocation;                         // 0x0688(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0xC];                                      // 0x0694(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundFoliageInstancedStaticMeshComponent">();
	}
	static class USoundFoliageInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundFoliageInstancedStaticMeshComponent>();
	}
};
static_assert(alignof(USoundFoliageInstancedStaticMeshComponent) == 0x000010, "Wrong alignment on USoundFoliageInstancedStaticMeshComponent");
static_assert(sizeof(USoundFoliageInstancedStaticMeshComponent) == 0x0006A0, "Wrong size on USoundFoliageInstancedStaticMeshComponent");
static_assert(offsetof(USoundFoliageInstancedStaticMeshComponent, SoundComps) == 0x000670, "Member 'USoundFoliageInstancedStaticMeshComponent::SoundComps' has a wrong offset!");
static_assert(offsetof(USoundFoliageInstancedStaticMeshComponent, SoundClass) == 0x000680, "Member 'USoundFoliageInstancedStaticMeshComponent::SoundClass' has a wrong offset!");
static_assert(offsetof(USoundFoliageInstancedStaticMeshComponent, SoundCompRelativeLocation) == 0x000688, "Member 'USoundFoliageInstancedStaticMeshComponent::SoundCompRelativeLocation' has a wrong offset!");

// Class DarwinGame.UIOptionBase
// 0x0008 (0x05D8 - 0x05D0)
class UUIOptionBase : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionBase">();
	}
	static class UUIOptionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionBase>();
	}
};
static_assert(alignof(UUIOptionBase) == 0x000008, "Wrong alignment on UUIOptionBase");
static_assert(sizeof(UUIOptionBase) == 0x0005D8, "Wrong size on UUIOptionBase");

// Class DarwinGame.UIOptionScreenSoundBase
// 0x0008 (0x05E0 - 0x05D8)
class UUIOptionScreenSoundBase : public UUIOptionBase
{
public:
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionScreenSoundBase">();
	}
	static class UUIOptionScreenSoundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionScreenSoundBase>();
	}
};
static_assert(alignof(UUIOptionScreenSoundBase) == 0x000008, "Wrong alignment on UUIOptionScreenSoundBase");
static_assert(sizeof(UUIOptionScreenSoundBase) == 0x0005E0, "Wrong size on UUIOptionScreenSoundBase");

// Class DarwinGame.UIOptionGraphics
// 0x00E0 (0x06C0 - 0x05E0)
class UUIOptionGraphics : public UUIOptionScreenSoundBase
{
public:
	TArray<struct FST_OptionPanelData>            OptionPanelData;                                   // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIOptionPanel*>                 OptionGraphicsPanels;                              // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0xC0];                                     // 0x0600(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionGraphics">();
	}
	static class UUIOptionGraphics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionGraphics>();
	}
};
static_assert(alignof(UUIOptionGraphics) == 0x000008, "Wrong alignment on UUIOptionGraphics");
static_assert(sizeof(UUIOptionGraphics) == 0x0006C0, "Wrong size on UUIOptionGraphics");
static_assert(offsetof(UUIOptionGraphics, OptionPanelData) == 0x0005E0, "Member 'UUIOptionGraphics::OptionPanelData' has a wrong offset!");
static_assert(offsetof(UUIOptionGraphics, OptionGraphicsPanels) == 0x0005F0, "Member 'UUIOptionGraphics::OptionGraphicsPanels' has a wrong offset!");

// Class DarwinGame.HighTensionCue
// 0x0008 (0x02B0 - 0x02A8)
class AHighTensionCue : public ADarwinGameplayCue
{
public:
	int32                                         mTimeScale;                                        // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mInterpSpeed;                                      // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighTensionCue">();
	}
	static class AHighTensionCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHighTensionCue>();
	}
};
static_assert(alignof(AHighTensionCue) == 0x000008, "Wrong alignment on AHighTensionCue");
static_assert(sizeof(AHighTensionCue) == 0x0002B0, "Wrong size on AHighTensionCue");
static_assert(offsetof(AHighTensionCue, mTimeScale) == 0x0002A8, "Member 'AHighTensionCue::mTimeScale' has a wrong offset!");
static_assert(offsetof(AHighTensionCue, mInterpSpeed) == 0x0002AC, "Member 'AHighTensionCue::mInterpSpeed' has a wrong offset!");

// Class DarwinGame.HitEffectCue
// 0x0000 (0x0298 - 0x0298)
class AHitEffectCue : public AGameplayCueNotify_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEffectCue">();
	}
	static class AHitEffectCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHitEffectCue>();
	}
};
static_assert(alignof(AHitEffectCue) == 0x000008, "Wrong alignment on AHitEffectCue");
static_assert(sizeof(AHitEffectCue) == 0x000298, "Wrong size on AHitEffectCue");

// Class DarwinGame.RectTriggerBase
// 0x0060 (0x0288 - 0x0228)
class ARectTriggerBase : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x58];                                     // 0x0230(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapForBind(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlapForBind(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnEnterTrigger(class AActor* OtherActor);
	void OnExitTrigger(class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RectTriggerBase">();
	}
	static class ARectTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARectTriggerBase>();
	}
};
static_assert(alignof(ARectTriggerBase) == 0x000008, "Wrong alignment on ARectTriggerBase");
static_assert(sizeof(ARectTriggerBase) == 0x000288, "Wrong size on ARectTriggerBase");
static_assert(offsetof(ARectTriggerBase, RootComp) == 0x000228, "Member 'ARectTriggerBase::RootComp' has a wrong offset!");

// Class DarwinGame.HollowRectTrigger
// 0x0000 (0x0288 - 0x0288)
class AHollowRectTrigger final : public ARectTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HollowRectTrigger">();
	}
	static class AHollowRectTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHollowRectTrigger>();
	}
};
static_assert(alignof(AHollowRectTrigger) == 0x000008, "Wrong alignment on AHollowRectTrigger");
static_assert(sizeof(AHollowRectTrigger) == 0x000288, "Wrong size on AHollowRectTrigger");

// Class DarwinGame.SoundPoolObject
// 0x0010 (0x0040 - 0x0030)
class USoundPoolObject final : public UObject
{
public:
	class UAtomComponent*                         Component;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Used;                                              // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPoolObject">();
	}
	static class USoundPoolObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPoolObject>();
	}
};
static_assert(alignof(USoundPoolObject) == 0x000008, "Wrong alignment on USoundPoolObject");
static_assert(sizeof(USoundPoolObject) == 0x000040, "Wrong size on USoundPoolObject");
static_assert(offsetof(USoundPoolObject, Component) == 0x000030, "Member 'USoundPoolObject::Component' has a wrong offset!");
static_assert(offsetof(USoundPoolObject, Used) == 0x000038, "Member 'USoundPoolObject::Used' has a wrong offset!");

// Class DarwinGame.HopComponent
// 0x0000 (0x0440 - 0x0440)
class UHopComponent final : public USphereComponent
{
public:
	bool                                          bEndPoint;                                         // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPointType                                 EndType;                                           // 0x0439(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43A[0x6];                                      // 0x043A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HopComponent">();
	}
	static class UHopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHopComponent>();
	}
};
static_assert(alignof(UHopComponent) == 0x000010, "Wrong alignment on UHopComponent");
static_assert(sizeof(UHopComponent) == 0x000440, "Wrong size on UHopComponent");
static_assert(offsetof(UHopComponent, bEndPoint) == 0x000438, "Member 'UHopComponent::bEndPoint' has a wrong offset!");
static_assert(offsetof(UHopComponent, EndType) == 0x000439, "Member 'UHopComponent::EndType' has a wrong offset!");

// Class DarwinGame.SoundUtility
// 0x0000 (0x0030 - 0x0030)
class USoundUtility final : public UBlueprintFunctionLibrary
{
public:
	static void ControlBSComp(ESoundControlType ControlType, EAtomCompCategory CompCategory, float FadeTime, float FadeVolume, class USoundAtomCue* Sound);
	static void DebugDisplayESound();
	static void FadeByACVolume(class UAtomComponent* Component, ESoundFadeType Type, float FadeTime, float FadeVolume, ESFadeOutEndState FOState);
	static void FadeByCSGroupTableVolume(class FName GroupID);
	static void FadeByEventStatus(class FName Timing);
	static class UAtomComponent* GetBSComp(EAtomCompCategory CompCategory);
	static class USoundAtomCue* GetCueByCueSheetTable(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName);
	static TArray<class UESoundBase*> GetESoundList();
	static TArray<class UGenSoundBaseComponent*> GetGenCreatureList();
	static TArray<class UGenSoundBaseComponent*> GetGenNatureList();
	static bool GetLoadSoundStatus();
	static void GetParameterByTextSoundTable(ETextSoundTableCategory Category, class FName RowName, class FName* SheetName, class FString* ID, class FString* ID_Me);
	static class UDataTable* GetSoundDataTable(ESoundTableCategory STCategory);
	static bool GetUpdateSoundStatus();
	static bool IsChangeBgmBossBattle();
	static bool IsEnableBgmChange();
	static bool IsLoadedCueSheetEnvAll();
	static bool IsPlayingBgmName(const class FString& CueName);
	static bool IsPlayingMe();
	static bool IsStopBgmBossFinish();
	static bool IsWaitStartBgmBaseAreaBattle();
	static class USoundAtomCueSheet* LoadCueSheetByCueSheetTable(ECueSheetTableCategory Category, class FName SheetName);
	static void LoadCueSheetEnvAll(EAreaType Type);
	static void LoadCueSheetTravellerVoice(bool IsAutoTraveller);
	static void LoadPointEnvSound();
	static void PauseBgm(EAtomCompCategory Category, float FadeTime, float FadeVolume, float Timer);
	static void Play2DLoopSoundByCueName(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName);
	static class UAtomComponent* Play2DSoundByCueName(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName);
	static void Play3DSound(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName, class USceneComponent* Component, ESoundInsulationType SIType);
	static void PlayBaseEnv();
	static void PlayBgm(EAtomCompCategory Category, const class FString& CueName, bool IsForce);
	static void PlayBgmByAfterBonfire();
	static void PlayBgmByBaseArea();
	static void PlayBoardVoice(EVoiceTiming Timing);
	static void PlayBossMonsterVoice(EVoiceTimingBoss Timing, class AMonsterBase* Monster, bool Is3DPosition);
	static void PlayEventSeByActor(class AActor* Actor, class FName SheetName, const class FString& CueName);
	static void PlayEventSeByPlayer(class AActor* Actor, bool IsPlayer, class FName SheetName, const class FString& CueName);
	static void PlayFlagPulloutSuccessSe();
	static class UAtomComponent* PlayFukidashiVoice(class FName RowName, class FName NpcID, class AActor* Actor);
	static void PlayGuidePartVoice(const class FString& PartVoiceID);
	static void PlayGuideVoice(EVoiceTimingGuide Timing);
	static void PlayInstructorVoice(EVoiceTimingInstructor Timing);
	static void PlayItemGetSound(class FName ItemId);
	static void PlayMe(const class FString& CueName);
	static void PlayMeByLevelUp();
	static void PlayMonsterVoice(EVoiceTiming Timing, class AMonsterBase* Monster, bool Is3DPosition);
	static class UAtomComponent* PlayNPCVoice(const class FString& PartVoiceID, class FName NpcID);
	static class UAtomComponent* PlayNPCVoiceCallPC(class FName NpcID);
	static class UAtomComponent* PlayObjectSound(EObjectSoundCategory Category, class FName RowName, class USceneComponent* AttachComp);
	static void PlayPCPartVoice(const class FString& PartVoiceID, bool Is3DPosition);
	static void PlayPCPartVoiceReverse(const class FString& PartVoiceID, bool Is3DPosition);
	static void PlayPCVoice(EVoiceTimingPC Timing, bool Is3DPosition);
	static void PlayPCVoiceReverse(EVoiceTimingPC Timing, bool Is3DPosition);
	static void PlayPCVoiceSpecify(bool IsP000, EVoiceTimingPC Timing, bool Is3DPosition);
	static void PlayReceptionVoice(EVoiceTimingReception Timing);
	static void PlayStationStaffVoice(EVoiceTimingStationStaff Timing, class FName NpcID);
	static void PlayTableSound(class UDataTable* Table, class FName SoundID, ESoundInsulationType SIType, class USceneComponent* Component);
	static void PlayTravellerVoice(int32 KindId, class FName NickNameID, EVoiceDataType VoiceType, ELanguageVoiceType LanguageType);
	static void ReleaseCueSheetByCueSheetTable(ECueSheetTableCategory Category, class FName SheetName);
	static void ReleaseCueSheetEnvAll();
	static void ReleaseCueSheetTravellerVoice(bool IsAutoTraveller);
	static void ReleasePointEnvSound();
	static void ResumeBgm(EAtomCompCategory Category, float FadeTime, float FadeVolume, float Timer);
	static void SetChangeBgmBossBattle(bool enable);
	static void SetEventExceptionSoundControl(bool isEnable);
	static void SetIsPlayMeBaseAreaBattleNotify(bool isEnable);
	static void SetMeAfterResumeBgm(bool isEnable);
	static void SetSEVSoundStatus(ESoundTriggerTiming Timing);
	static void SetStopBgmBossFinish(bool enable);
	static void SetUpdateAreaBgm(bool enable);
	static void SetUpdateAreaBgmNight(bool enable);
	static void SetUpdateSoundStatus(bool enable);
	static void SetVolcanoBattleBgm(bool enable);
	static void SetWaitStartBgmBaseAreaBattle(bool bIsEnable);
	static class UAtomComponent* Spawn2DSound(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName);
	static class UAtomComponent* Spawn2DSoundCalcReverb(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName);
	static void Stop2DLoopSoundByCueName(const class FString& CueName);
	static void StopBaseEnv();
	static void StopBgm(EAtomCompCategory Category, float FadeTime, bool IsSpecify);
	static void StopBgmAll(float FadeTime);
	static void StopEventCategorySound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundUtility">();
	}
	static class USoundUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundUtility>();
	}
};
static_assert(alignof(USoundUtility) == 0x000008, "Wrong alignment on USoundUtility");
static_assert(sizeof(USoundUtility) == 0x000030, "Wrong size on USoundUtility");

// Class DarwinGame.HubSceneCapture
// 0x0060 (0x03E0 - 0x0380)
class AHubSceneCapture final : public ASceneCaptureCharacter
{
public:
	EDisplayHubType                               DisplayHubType;                                    // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x5F];                                     // 0x0381(0x005F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HubSceneCapture">();
	}
	static class AHubSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHubSceneCapture>();
	}
};
static_assert(alignof(AHubSceneCapture) == 0x000010, "Wrong alignment on AHubSceneCapture");
static_assert(sizeof(AHubSceneCapture) == 0x0003E0, "Wrong size on AHubSceneCapture");
static_assert(offsetof(AHubSceneCapture, DisplayHubType) == 0x000380, "Member 'AHubSceneCapture::DisplayHubType' has a wrong offset!");

// Class DarwinGame.HyenaBattleIdDataTable
// 0x0000 (0x0030 - 0x0030)
class UHyenaBattleIdDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HyenaBattleIdDataTable">();
	}
	static class UHyenaBattleIdDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHyenaBattleIdDataTable>();
	}
};
static_assert(alignof(UHyenaBattleIdDataTable) == 0x000008, "Wrong alignment on UHyenaBattleIdDataTable");
static_assert(sizeof(UHyenaBattleIdDataTable) == 0x000030, "Wrong size on UHyenaBattleIdDataTable");

// Class DarwinGame.IcicleMagicBase
// 0x0070 (0x0380 - 0x0310)
class AIcicleMagicBase final : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x70];                                     // 0x0310(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IcicleMagicBase">();
	}
	static class AIcicleMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIcicleMagicBase>();
	}
};
static_assert(alignof(AIcicleMagicBase) == 0x000008, "Wrong alignment on AIcicleMagicBase");
static_assert(sizeof(AIcicleMagicBase) == 0x000380, "Wrong size on AIcicleMagicBase");

// Class DarwinGame.StartLinkAction
// 0x0008 (0x0138 - 0x0130)
class UStartLinkAction final : public UActionStateBase
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartLinkAction">();
	}
	static class UStartLinkAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartLinkAction>();
	}
};
static_assert(alignof(UStartLinkAction) == 0x000008, "Wrong alignment on UStartLinkAction");
static_assert(sizeof(UStartLinkAction) == 0x000138, "Wrong size on UStartLinkAction");

// Class DarwinGame.IndoorHierarchyTrigger
// 0x0008 (0x0238 - 0x0230)
class AIndoorHierarchyTrigger final : public AIndoorTriggerBase
{
public:
	EIndoorHierarchyType                          IndoorHierarchyType;                               // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndoorHierarchyTrigger">();
	}
	static class AIndoorHierarchyTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIndoorHierarchyTrigger>();
	}
};
static_assert(alignof(AIndoorHierarchyTrigger) == 0x000008, "Wrong alignment on AIndoorHierarchyTrigger");
static_assert(sizeof(AIndoorHierarchyTrigger) == 0x000238, "Wrong size on AIndoorHierarchyTrigger");
static_assert(offsetof(AIndoorHierarchyTrigger, IndoorHierarchyType) == 0x000230, "Member 'AIndoorHierarchyTrigger::IndoorHierarchyType' has a wrong offset!");

// Class DarwinGame.InitialPositionDoor
// 0x0008 (0x02B8 - 0x02B0)
class AInitialPositionDoor final : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveSetClose();
	void ReceiveSetOpen(const struct FVector& Vector);
	void SetClose();
	void SetOpen(const struct FVector& Vector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitialPositionDoor">();
	}
	static class AInitialPositionDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInitialPositionDoor>();
	}
};
static_assert(alignof(AInitialPositionDoor) == 0x000008, "Wrong alignment on AInitialPositionDoor");
static_assert(sizeof(AInitialPositionDoor) == 0x0002B8, "Wrong size on AInitialPositionDoor");

// Class DarwinGame.UIAreaNameDisplayer
// 0x0000 (0x0030 - 0x0030)
class UUIAreaNameDisplayer final : public UBlueprintFunctionLibrary
{
public:
	static void InAreaExec();
	static void OutAreaExec();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaNameDisplayer">();
	}
	static class UUIAreaNameDisplayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaNameDisplayer>();
	}
};
static_assert(alignof(UUIAreaNameDisplayer) == 0x000008, "Wrong alignment on UUIAreaNameDisplayer");
static_assert(sizeof(UUIAreaNameDisplayer) == 0x000030, "Wrong size on UUIAreaNameDisplayer");

// Class DarwinGame.ItemConvertTreasureDataAsset
// 0x0020 (0x0058 - 0x0038)
class UItemConvertTreasureDataAsset final : public UDataAsset
{
public:
	TArray<class FName>                           EnableGameFlags;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartMessageId;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemConvertTreasureDataAsset">();
	}
	static class UItemConvertTreasureDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemConvertTreasureDataAsset>();
	}
};
static_assert(alignof(UItemConvertTreasureDataAsset) == 0x000008, "Wrong alignment on UItemConvertTreasureDataAsset");
static_assert(sizeof(UItemConvertTreasureDataAsset) == 0x000058, "Wrong size on UItemConvertTreasureDataAsset");
static_assert(offsetof(UItemConvertTreasureDataAsset, EnableGameFlags) == 0x000038, "Member 'UItemConvertTreasureDataAsset::EnableGameFlags' has a wrong offset!");
static_assert(offsetof(UItemConvertTreasureDataAsset, StartMessageId) == 0x000048, "Member 'UItemConvertTreasureDataAsset::StartMessageId' has a wrong offset!");

// Class DarwinGame.UIRewardWin_00_Root
// 0x0048 (0x0518 - 0x04D0)
class UUIRewardWin_00_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x48];                                     // 0x04D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardWin_00_Root">();
	}
	static class UUIRewardWin_00_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardWin_00_Root>();
	}
};
static_assert(alignof(UUIRewardWin_00_Root) == 0x000008, "Wrong alignment on UUIRewardWin_00_Root");
static_assert(sizeof(UUIRewardWin_00_Root) == 0x000518, "Wrong size on UUIRewardWin_00_Root");

// Class DarwinGame.ItemConvertTreasureTable
// 0x0000 (0x0030 - 0x0030)
class UItemConvertTreasureTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemConvertTreasureTable">();
	}
	static class UItemConvertTreasureTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemConvertTreasureTable>();
	}
};
static_assert(alignof(UItemConvertTreasureTable) == 0x000008, "Wrong alignment on UItemConvertTreasureTable");
static_assert(sizeof(UItemConvertTreasureTable) == 0x000030, "Wrong size on UItemConvertTreasureTable");

// Class DarwinGame.ItemDataTable
// 0x0000 (0x0030 - 0x0030)
class UItemDataTable final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertItemID(int32 Index_0, class FString* ItemId);
	static void GetItemInfo(const class FName& ItemId, struct FST_ItemInfoData* itemInfo);
	static TArray<class FName> GetItemKeys();
	static TArray<class FName> GetItemKeysOf(EItemDataType Type);
	static void GetItemName(const class FName& ItemId, class FText* itemNameString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDataTable">();
	}
	static class UItemDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDataTable>();
	}
};
static_assert(alignof(UItemDataTable) == 0x000008, "Wrong alignment on UItemDataTable");
static_assert(sizeof(UItemDataTable) == 0x000030, "Wrong size on UItemDataTable");

// Class DarwinGame.ItemInterface
// 0x0000 (0x0030 - 0x0030)
class IItemInterface final : public IInterface
{
public:
	void Aim(const struct FVector& HandLocation);
	void Hold(bool End);
	void SetVisible(bool Visibility);
	void Use();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInterface">();
	}
	static class IItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemInterface>();
	}
};
static_assert(alignof(IItemInterface) == 0x000008, "Wrong alignment on IItemInterface");
static_assert(sizeof(IItemInterface) == 0x000030, "Wrong size on IItemInterface");

// Class DarwinGame.UIArtifact_ItemChoice
// 0x0058 (0x0588 - 0x0530)
class UUIArtifact_ItemChoice : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIArtifact_ItemIcon*                   ItemIcon;                                          // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageNew;                                          // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageLockIcon;                                     // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageTreasureSetIcon;                              // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageTravelTreasureIcon;                           // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_StolenRivalTeamInfo>        StolenRivalTeamInfoList;                           // 0x0578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifact_ItemChoice">();
	}
	static class UUIArtifact_ItemChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifact_ItemChoice>();
	}
};
static_assert(alignof(UUIArtifact_ItemChoice) == 0x000008, "Wrong alignment on UUIArtifact_ItemChoice");
static_assert(sizeof(UUIArtifact_ItemChoice) == 0x000588, "Wrong size on UUIArtifact_ItemChoice");
static_assert(offsetof(UUIArtifact_ItemChoice, Frame) == 0x000540, "Member 'UUIArtifact_ItemChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemChoice, ItemIcon) == 0x000548, "Member 'UUIArtifact_ItemChoice::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemChoice, ImageNew) == 0x000558, "Member 'UUIArtifact_ItemChoice::ImageNew' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemChoice, ImageLockIcon) == 0x000560, "Member 'UUIArtifact_ItemChoice::ImageLockIcon' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemChoice, ImageTreasureSetIcon) == 0x000568, "Member 'UUIArtifact_ItemChoice::ImageTreasureSetIcon' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemChoice, ImageTravelTreasureIcon) == 0x000570, "Member 'UUIArtifact_ItemChoice::ImageTravelTreasureIcon' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemChoice, StolenRivalTeamInfoList) == 0x000578, "Member 'UUIArtifact_ItemChoice::StolenRivalTeamInfoList' has a wrong offset!");

// Class DarwinGame.ItemSortFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UItemSortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSortFunctionLibrary">();
	}
	static class UItemSortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSortFunctionLibrary>();
	}
};
static_assert(alignof(UItemSortFunctionLibrary) == 0x000008, "Wrong alignment on UItemSortFunctionLibrary");
static_assert(sizeof(UItemSortFunctionLibrary) == 0x000030, "Wrong size on UItemSortFunctionLibrary");

// Class DarwinGame.KeyInputFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKeyInputFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetAfterSecond(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static EInputType GetInputType(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static float GetValue(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static bool IsJustPressed(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static bool IsJustReleased(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static bool IsPressed(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static bool IsRepeatPressed(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static struct FKeyInput Reset(const struct FKeyInput& KeyInput, EAxisMappingType Type);
	static struct FKeyInput ResetAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyInputFunctionLibrary">();
	}
	static class UKeyInputFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyInputFunctionLibrary>();
	}
};
static_assert(alignof(UKeyInputFunctionLibrary) == 0x000008, "Wrong alignment on UKeyInputFunctionLibrary");
static_assert(sizeof(UKeyInputFunctionLibrary) == 0x000030, "Wrong size on UKeyInputFunctionLibrary");

// Class DarwinGame.UIRewardBar_00
// 0x0010 (0x04A0 - 0x0490)
class UUIRewardBar_00 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardBar_00">();
	}
	static class UUIRewardBar_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardBar_00>();
	}
};
static_assert(alignof(UUIRewardBar_00) == 0x000008, "Wrong alignment on UUIRewardBar_00");
static_assert(sizeof(UUIRewardBar_00) == 0x0004A0, "Wrong size on UUIRewardBar_00");

// Class DarwinGame.KindDataTable
// 0x0000 (0x0030 - 0x0030)
class UKindDataTable final : public UBlueprintFunctionLibrary
{
public:
	static float GetActionCycleEnemy(class FName ID);
	static float GetActionCycleFriend(class FName ID);
	static int32 GetArtifactCarryingCapacity(class FName ID);
	static int32 GetArtifactDropOffRate(class FName ID);
	static int32 GetAttackAccordingToLevel(class FName ID, int32 Level);
	static int32 GetBattleArea(class FName ID);
	static int32 GetCoreHearing(class FName ID);
	static struct FCustomPartsLotteryRate GetCustomPartsLotteryRate(class FName ID);
	static int32 GetDefenceAccordingToLevel(class FName ID, int32 Level);
	static int32 GetDexterityAccordingToLevel(class FName ID, int32 Level);
	static void GetDropItemInfo(class FName KindId, TArray<struct FST_DropItemInfo>* DropItemInfos);
	static int32 GetEcologicalArea(class FName ID);
	static EEffectSizeID GetEffectSizeID(class FName KindId);
	static int32 GetEscapeCountMax(class FName ID);
	static int32 GetEscapeProbability(class FName ID);
	static int32 GetExpGrowthType(class FName ID);
	static void GetFeatureInfos(class FName ID, TArray<struct FST_CharacterFeatureInfo>* FeatureInfos);
	static int32 GetFormationSize(class FName ID);
	static float GetGazeTime(class FName ID);
	static int32 GetHPAccordingToLevel(class FName ID, int32 Level);
	static bool GetIsFlyType(class FName ID);
	static ELineageCategory GetLineageCategory(class FName ID);
	static void GetLinkData(class FName KindId, ELinkType Type, struct FST_LinkData* LinkData);
	static int32 GetMagicAccordingToLevel(class FName ID, int32 Level);
	static int32 GetMonsterSenseLotteryWeightByArrayIndex(class FName ID, int32 ArrayIndex);
	static int32 GetMonsterSenseTotalWeight(class FName ID);
	static int32 GetMPAccordingToLevel(class FName ID, int32 Level);
	static int32 GetNightSight(class FName ID);
	static int32 GetNormalHearing(class FName ID);
	static int32 GetNormalSight(class FName ID);
	static class FName GetOriginKindID(class FName ID);
	static int32 GetResistCalcType(class FName ID, EResistanceType Type);
	static struct FST_Status GetStatusAccordingToLevel(class FName ID, int32 Level);
	static int32 GetSurprisePopRange(class FName ID);
	static class FText GetTribalName(class FName ID);
	static bool HasSuperArmor(class FName ID);
	static bool IsResistToBlown(class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KindDataTable">();
	}
	static class UKindDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKindDataTable>();
	}
};
static_assert(alignof(UKindDataTable) == 0x000008, "Wrong alignment on UKindDataTable");
static_assert(sizeof(UKindDataTable) == 0x000030, "Wrong size on UKindDataTable");

// Class DarwinGame.LabyrinthDoorManager
// 0x0028 (0x02D8 - 0x02B0)
class ALabyrinthDoorManager final : public AFieldObjectBase
{
public:
	class FName                                   mEventID;                                          // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           mSaveFlag;                                         // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LabyrinthDoorManager">();
	}
	static class ALabyrinthDoorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALabyrinthDoorManager>();
	}
};
static_assert(alignof(ALabyrinthDoorManager) == 0x000008, "Wrong alignment on ALabyrinthDoorManager");
static_assert(sizeof(ALabyrinthDoorManager) == 0x0002D8, "Wrong size on ALabyrinthDoorManager");
static_assert(offsetof(ALabyrinthDoorManager, mEventID) == 0x0002B0, "Member 'ALabyrinthDoorManager::mEventID' has a wrong offset!");
static_assert(offsetof(ALabyrinthDoorManager, mSaveFlag) == 0x0002B8, "Member 'ALabyrinthDoorManager::mSaveFlag' has a wrong offset!");

// Class DarwinGame.LandMineMagicBase
// 0x0070 (0x0360 - 0x02F0)
class ALandMineMagicBase final : public AMagicBase
{
public:
	class UCapsuleComponent*                      collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x68];                                     // 0x02F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandMineMagicBase">();
	}
	static class ALandMineMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALandMineMagicBase>();
	}
};
static_assert(alignof(ALandMineMagicBase) == 0x000008, "Wrong alignment on ALandMineMagicBase");
static_assert(sizeof(ALandMineMagicBase) == 0x000360, "Wrong size on ALandMineMagicBase");
static_assert(offsetof(ALandMineMagicBase, collision) == 0x0002F0, "Member 'ALandMineMagicBase::collision' has a wrong offset!");

// Class DarwinGame.LevelManager
// 0x00E0 (0x0118 - 0x0038)
class ULevelManager : public UManagerBase
{
public:
	class UDataTable*                             mEventProgressLevelDataTable;                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistentLevelDataAsset*              mPersistentLevelData;                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStreamingLevelData*                    mStreamingLevelData;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   mBaseRegionID;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 mAreaTriggerLevelName;                             // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, EAreaType>                mAreaLayerNameList;                                // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULevelManager* GetInstance();

	void LoadPersistent(const class FName level_path);
	void SetAmbientVisible(bool visible);

	bool IsFinishLoadLevelOnPlayer(bool is_narrow) const;
	bool IsFinishLoadLevelOnPosition(const struct FVector& Position) const;
	bool IsFinishLoadPersistent() const;
	bool IsFinishVisibleLevelOnPlayer(bool is_narrow) const;
	bool IsFinishVisibleLevelOnPosition(const struct FVector& Position) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelManager">();
	}
	static class ULevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelManager>();
	}
};
static_assert(alignof(ULevelManager) == 0x000008, "Wrong alignment on ULevelManager");
static_assert(sizeof(ULevelManager) == 0x000118, "Wrong size on ULevelManager");
static_assert(offsetof(ULevelManager, mEventProgressLevelDataTable) == 0x000038, "Member 'ULevelManager::mEventProgressLevelDataTable' has a wrong offset!");
static_assert(offsetof(ULevelManager, mPersistentLevelData) == 0x000040, "Member 'ULevelManager::mPersistentLevelData' has a wrong offset!");
static_assert(offsetof(ULevelManager, mStreamingLevelData) == 0x000048, "Member 'ULevelManager::mStreamingLevelData' has a wrong offset!");
static_assert(offsetof(ULevelManager, mBaseRegionID) == 0x000050, "Member 'ULevelManager::mBaseRegionID' has a wrong offset!");
static_assert(offsetof(ULevelManager, mAreaTriggerLevelName) == 0x000058, "Member 'ULevelManager::mAreaTriggerLevelName' has a wrong offset!");
static_assert(offsetof(ULevelManager, mAreaLayerNameList) == 0x000068, "Member 'ULevelManager::mAreaLayerNameList' has a wrong offset!");

// Class DarwinGame.ArtifactClassificationDataTable
// 0x0000 (0x0030 - 0x0030)
class UArtifactClassificationDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactClassificationDataTable">();
	}
	static class UArtifactClassificationDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactClassificationDataTable>();
	}
};
static_assert(alignof(UArtifactClassificationDataTable) == 0x000008, "Wrong alignment on UArtifactClassificationDataTable");
static_assert(sizeof(UArtifactClassificationDataTable) == 0x000030, "Wrong size on UArtifactClassificationDataTable");

// Class DarwinGame.LiftDataAsset
// 0x0050 (0x0088 - 0x0038)
class ULiftDataAsset final : public UDataAsset
{
public:
	TMap<ELiftPositionType, struct FVector>       LiftAccessPointLocationList;                       // 0x0038(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LiftDataAsset">();
	}
	static class ULiftDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULiftDataAsset>();
	}
};
static_assert(alignof(ULiftDataAsset) == 0x000008, "Wrong alignment on ULiftDataAsset");
static_assert(sizeof(ULiftDataAsset) == 0x000088, "Wrong size on ULiftDataAsset");
static_assert(offsetof(ULiftDataAsset, LiftAccessPointLocationList) == 0x000038, "Member 'ULiftDataAsset::LiftAccessPointLocationList' has a wrong offset!");

// Class DarwinGame.LiftDataTable
// 0x0000 (0x0030 - 0x0030)
class ULiftDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LiftDataTable">();
	}
	static class ULiftDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULiftDataTable>();
	}
};
static_assert(alignof(ULiftDataTable) == 0x000008, "Wrong alignment on ULiftDataTable");
static_assert(sizeof(ULiftDataTable) == 0x000030, "Wrong size on ULiftDataTable");

// Class DarwinGame.LightningStrikeMagicBase
// 0x0058 (0x0368 - 0x0310)
class ALightningStrikeMagicBase final : public AProjectileMagicBase
{
public:
	uint8                                         Pad_310[0x58];                                     // 0x0310(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightningStrikeMagicBase">();
	}
	static class ALightningStrikeMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALightningStrikeMagicBase>();
	}
};
static_assert(alignof(ALightningStrikeMagicBase) == 0x000008, "Wrong alignment on ALightningStrikeMagicBase");
static_assert(sizeof(ALightningStrikeMagicBase) == 0x000368, "Wrong size on ALightningStrikeMagicBase");

// Class DarwinGame.NPCCSLookTargetActor
// 0x0000 (0x0288 - 0x0288)
class ANPCCSLookTargetActor final : public APawn
{
public:
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCCSLookTargetActor">();
	}
	static class ANPCCSLookTargetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCCSLookTargetActor>();
	}
};
static_assert(alignof(ANPCCSLookTargetActor) == 0x000008, "Wrong alignment on ANPCCSLookTargetActor");
static_assert(sizeof(ANPCCSLookTargetActor) == 0x000288, "Wrong size on ANPCCSLookTargetActor");

// Class DarwinGame.LinkSystemComponent
// 0x02C8 (0x0380 - 0x00B8)
class ULinkSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x5C];                                      // 0x00B8(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         mCurrentFieldLinkIndex;                            // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           mLinkIDList;                                       // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0xA0];                                     // 0x0130(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  mExecutableFlagList;                               // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x38];                                     // 0x01E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         mOffseDistOfStartDive;                             // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x164];                                    // 0x021C(0x0164)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close(ELinkType Type, bool bForce);
	void ExecuteLinkAction(int32 Index_0);
	bool IsMenuOpend();
	void LinkCancel();
	void OnUseAnimationEnd();
	void open(ELinkType Type);
	void StartGlideElapsedTimer();
	void StartReacstTimer(class AGPACharacter* LinkTarget, ELinkType Type, int32 Index_0);

	class UUIField_IconLink* GetLinkWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinkSystemComponent">();
	}
	static class ULinkSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULinkSystemComponent>();
	}
};
static_assert(alignof(ULinkSystemComponent) == 0x000008, "Wrong alignment on ULinkSystemComponent");
static_assert(sizeof(ULinkSystemComponent) == 0x000380, "Wrong size on ULinkSystemComponent");
static_assert(offsetof(ULinkSystemComponent, mCurrentFieldLinkIndex) == 0x000114, "Member 'ULinkSystemComponent::mCurrentFieldLinkIndex' has a wrong offset!");
static_assert(offsetof(ULinkSystemComponent, mLinkIDList) == 0x000120, "Member 'ULinkSystemComponent::mLinkIDList' has a wrong offset!");
static_assert(offsetof(ULinkSystemComponent, mExecutableFlagList) == 0x0001D0, "Member 'ULinkSystemComponent::mExecutableFlagList' has a wrong offset!");
static_assert(offsetof(ULinkSystemComponent, mOffseDistOfStartDive) == 0x000218, "Member 'ULinkSystemComponent::mOffseDistOfStartDive' has a wrong offset!");

// Class DarwinGame.LinkSystemLibrary
// 0x0000 (0x0030 - 0x0030)
class ULinkSystemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetHighJumpHeight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LinkSystemLibrary">();
	}
	static class ULinkSystemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULinkSystemLibrary>();
	}
};
static_assert(alignof(ULinkSystemLibrary) == 0x000008, "Wrong alignment on ULinkSystemLibrary");
static_assert(sizeof(ULinkSystemLibrary) == 0x000030, "Wrong size on ULinkSystemLibrary");

// Class DarwinGame.LockedTreasureBox
// 0x0010 (0x02F8 - 0x02E8)
class ALockedTreasureBox final : public ATreasureBoxBase
{
public:
	class FName                                   mLockedEventID;                                    // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   mNeedItemID;                                       // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockedTreasureBox">();
	}
	static class ALockedTreasureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALockedTreasureBox>();
	}
};
static_assert(alignof(ALockedTreasureBox) == 0x000008, "Wrong alignment on ALockedTreasureBox");
static_assert(sizeof(ALockedTreasureBox) == 0x0002F8, "Wrong size on ALockedTreasureBox");
static_assert(offsetof(ALockedTreasureBox, mLockedEventID) == 0x0002E8, "Member 'ALockedTreasureBox::mLockedEventID' has a wrong offset!");
static_assert(offsetof(ALockedTreasureBox, mNeedItemID) == 0x0002F0, "Member 'ALockedTreasureBox::mNeedItemID' has a wrong offset!");

// Class DarwinGame.LockOnComponent
// 0x0000 (0x0440 - 0x0440)
class ULockOnComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockOnComponent">();
	}
	static class ULockOnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockOnComponent>();
	}
};
static_assert(alignof(ULockOnComponent) == 0x000010, "Wrong alignment on ULockOnComponent");
static_assert(sizeof(ULockOnComponent) == 0x000440, "Wrong size on ULockOnComponent");

// Class DarwinGame.ObjectCommunicationFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UObjectCommunicationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectCommunicationFunctionLibrary">();
	}
	static class UObjectCommunicationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectCommunicationFunctionLibrary>();
	}
};
static_assert(alignof(UObjectCommunicationFunctionLibrary) == 0x000008, "Wrong alignment on UObjectCommunicationFunctionLibrary");
static_assert(sizeof(UObjectCommunicationFunctionLibrary) == 0x000030, "Wrong size on UObjectCommunicationFunctionLibrary");

// Class DarwinGame.LocTextUtility
// 0x0000 (0x0030 - 0x0030)
class ULocTextUtility final : public UBlueprintFunctionLibrary
{
public:
	static class FString AddNoBreakSpace(const class FString& srcStr, ESpaceInsertLocale spaceInsertlocale);
	static class FString AlignNewLines(const class FString& DisplayText, class UComputeTextBlock* TextBlock);
	static bool IsCurrenLanguageJapanese();
	static bool IsCurrenLanguageKorean();
	static bool IsCurrenLanguageZhHant();
	static bool IsCurrentLanguageZhHans();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocTextUtility">();
	}
	static class ULocTextUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocTextUtility>();
	}
};
static_assert(alignof(ULocTextUtility) == 0x000008, "Wrong alignment on ULocTextUtility");
static_assert(sizeof(ULocTextUtility) == 0x000030, "Wrong size on ULocTextUtility");

// Class DarwinGame.LogWindow
// 0x0050 (0x0080 - 0x0030)
class ULogWindow final : public UObject
{
public:
	TArray<struct FLogItemData>                   ItemList;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLogItemData                           NullItem;                                          // 0x0040(0x0028)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogWindow">();
	}
	static class ULogWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogWindow>();
	}
};
static_assert(alignof(ULogWindow) == 0x000008, "Wrong alignment on ULogWindow");
static_assert(sizeof(ULogWindow) == 0x000080, "Wrong size on ULogWindow");
static_assert(offsetof(ULogWindow, ItemList) == 0x000030, "Member 'ULogWindow::ItemList' has a wrong offset!");
static_assert(offsetof(ULogWindow, NullItem) == 0x000040, "Member 'ULogWindow::NullItem' has a wrong offset!");

// Class DarwinGame.LotteryBattleID
// 0x0000 (0x0030 - 0x0030)
class ULotteryBattleID final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LotteryBattleID">();
	}
	static class ULotteryBattleID* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULotteryBattleID>();
	}
};
static_assert(alignof(ULotteryBattleID) == 0x000008, "Wrong alignment on ULotteryBattleID");
static_assert(sizeof(ULotteryBattleID) == 0x000030, "Wrong size on ULotteryBattleID");

// Class DarwinGame.LotteryDungeonBossMonsterBattleID
// 0x0000 (0x0030 - 0x0030)
class ULotteryDungeonBossMonsterBattleID final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LotteryDungeonBossMonsterBattleID">();
	}
	static class ULotteryDungeonBossMonsterBattleID* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULotteryDungeonBossMonsterBattleID>();
	}
};
static_assert(alignof(ULotteryDungeonBossMonsterBattleID) == 0x000008, "Wrong alignment on ULotteryDungeonBossMonsterBattleID");
static_assert(sizeof(ULotteryDungeonBossMonsterBattleID) == 0x000030, "Wrong size on ULotteryDungeonBossMonsterBattleID");

// Class DarwinGame.ObjectReactionCollisionDataBox
// 0x0018 (0x0048 - 0x0030)
class UObjectReactionCollisionDataBox final : public UObjectReactionCollisionDataBase
{
public:
	struct FIntVector                             Size;                                              // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Rotate;                                            // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionCollisionDataBox">();
	}
	static class UObjectReactionCollisionDataBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionCollisionDataBox>();
	}
};
static_assert(alignof(UObjectReactionCollisionDataBox) == 0x000008, "Wrong alignment on UObjectReactionCollisionDataBox");
static_assert(sizeof(UObjectReactionCollisionDataBox) == 0x000048, "Wrong size on UObjectReactionCollisionDataBox");
static_assert(offsetof(UObjectReactionCollisionDataBox, Size) == 0x000030, "Member 'UObjectReactionCollisionDataBox::Size' has a wrong offset!");
static_assert(offsetof(UObjectReactionCollisionDataBox, Rotate) == 0x00003C, "Member 'UObjectReactionCollisionDataBox::Rotate' has a wrong offset!");

// Class DarwinGame.LotteryDungeonGroupBattleID
// 0x0000 (0x0030 - 0x0030)
class ULotteryDungeonGroupBattleID final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LotteryDungeonGroupBattleID">();
	}
	static class ULotteryDungeonGroupBattleID* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULotteryDungeonGroupBattleID>();
	}
};
static_assert(alignof(ULotteryDungeonGroupBattleID) == 0x000008, "Wrong alignment on ULotteryDungeonGroupBattleID");
static_assert(sizeof(ULotteryDungeonGroupBattleID) == 0x000030, "Wrong size on ULotteryDungeonGroupBattleID");

// Class DarwinGame.LotteryDungeonNormalMonsterBattleID
// 0x0000 (0x0030 - 0x0030)
class ULotteryDungeonNormalMonsterBattleID final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LotteryDungeonNormalMonsterBattleID">();
	}
	static class ULotteryDungeonNormalMonsterBattleID* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULotteryDungeonNormalMonsterBattleID>();
	}
};
static_assert(alignof(ULotteryDungeonNormalMonsterBattleID) == 0x000008, "Wrong alignment on ULotteryDungeonNormalMonsterBattleID");
static_assert(sizeof(ULotteryDungeonNormalMonsterBattleID) == 0x000030, "Wrong size on ULotteryDungeonNormalMonsterBattleID");

// Class DarwinGame.UIItemmenu_WinList
// 0x0010 (0x04A0 - 0x0490)
class UUIItemmenu_WinList final : public UDarwinUserWidget
{
public:
	class UImage*                                 ImgIconItem;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         ItemNameTextBlock;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinList">();
	}
	static class UUIItemmenu_WinList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinList>();
	}
};
static_assert(alignof(UUIItemmenu_WinList) == 0x000008, "Wrong alignment on UUIItemmenu_WinList");
static_assert(sizeof(UUIItemmenu_WinList) == 0x0004A0, "Wrong size on UUIItemmenu_WinList");
static_assert(offsetof(UUIItemmenu_WinList, ImgIconItem) == 0x000490, "Member 'UUIItemmenu_WinList::ImgIconItem' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_WinList, ItemNameTextBlock) == 0x000498, "Member 'UUIItemmenu_WinList::ItemNameTextBlock' has a wrong offset!");

// Class DarwinGame.LotteryDungeonToughMonsterBattleID
// 0x0000 (0x0030 - 0x0030)
class ULotteryDungeonToughMonsterBattleID final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LotteryDungeonToughMonsterBattleID">();
	}
	static class ULotteryDungeonToughMonsterBattleID* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULotteryDungeonToughMonsterBattleID>();
	}
};
static_assert(alignof(ULotteryDungeonToughMonsterBattleID) == 0x000008, "Wrong alignment on ULotteryDungeonToughMonsterBattleID");
static_assert(sizeof(ULotteryDungeonToughMonsterBattleID) == 0x000030, "Wrong size on ULotteryDungeonToughMonsterBattleID");

// Class DarwinGame.ObjectReactionDataEvent
// 0x0010 (0x0040 - 0x0030)
class UObjectReactionDataEvent final : public UObjectReactionDataBase
{
public:
	TArray<class FName>                           mEventList;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionDataEvent">();
	}
	static class UObjectReactionDataEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionDataEvent>();
	}
};
static_assert(alignof(UObjectReactionDataEvent) == 0x000008, "Wrong alignment on UObjectReactionDataEvent");
static_assert(sizeof(UObjectReactionDataEvent) == 0x000040, "Wrong size on UObjectReactionDataEvent");
static_assert(offsetof(UObjectReactionDataEvent, mEventList) == 0x000030, "Member 'UObjectReactionDataEvent::mEventList' has a wrong offset!");

// Class DarwinGame.UIItemmenu_SortIconChoice
// 0x0038 (0x0568 - 0x0530)
class UUIItemmenu_SortIconChoice : public UUIScrollMenuItemBase
{
public:
	class FText                                   DefaultButtonText;                                 // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UTexture2D*                             DefaultIconTexture;                                // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_SortIconChoice">();
	}
	static class UUIItemmenu_SortIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_SortIconChoice>();
	}
};
static_assert(alignof(UUIItemmenu_SortIconChoice) == 0x000008, "Wrong alignment on UUIItemmenu_SortIconChoice");
static_assert(sizeof(UUIItemmenu_SortIconChoice) == 0x000568, "Wrong size on UUIItemmenu_SortIconChoice");
static_assert(offsetof(UUIItemmenu_SortIconChoice, DefaultButtonText) == 0x000530, "Member 'UUIItemmenu_SortIconChoice::DefaultButtonText' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_SortIconChoice, DefaultIconTexture) == 0x000548, "Member 'UUIItemmenu_SortIconChoice::DefaultIconTexture' has a wrong offset!");

// Class DarwinGame.M000
// 0x0000 (0x16B0 - 0x16B0)
class AM000 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M000">();
	}
	static class AM000* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM000>();
	}
};
static_assert(alignof(AM000) == 0x000010, "Wrong alignment on AM000");
static_assert(sizeof(AM000) == 0x0016B0, "Wrong size on AM000");

// Class DarwinGame.M001
// 0x0000 (0x16B0 - 0x16B0)
class AM001 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M001">();
	}
	static class AM001* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM001>();
	}
};
static_assert(alignof(AM001) == 0x000010, "Wrong alignment on AM001");
static_assert(sizeof(AM001) == 0x0016B0, "Wrong size on AM001");

// Class DarwinGame.M003
// 0x0000 (0x16B0 - 0x16B0)
class AM003 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M003">();
	}
	static class AM003* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM003>();
	}
};
static_assert(alignof(AM003) == 0x000010, "Wrong alignment on AM003");
static_assert(sizeof(AM003) == 0x0016B0, "Wrong size on AM003");

// Class DarwinGame.NetworkQuestDataAsset
// 0x0008 (0x0040 - 0x0038)
class UNetworkQuestDataAsset final : public UDataAsset
{
public:
	struct FNetworkQuestConfig                    mConfig;                                           // 0x0038(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkQuestDataAsset">();
	}
	static class UNetworkQuestDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkQuestDataAsset>();
	}
};
static_assert(alignof(UNetworkQuestDataAsset) == 0x000008, "Wrong alignment on UNetworkQuestDataAsset");
static_assert(sizeof(UNetworkQuestDataAsset) == 0x000040, "Wrong size on UNetworkQuestDataAsset");
static_assert(offsetof(UNetworkQuestDataAsset, mConfig) == 0x000038, "Member 'UNetworkQuestDataAsset::mConfig' has a wrong offset!");

// Class DarwinGame.M004
// 0x0000 (0x16B0 - 0x16B0)
class AM004 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M004">();
	}
	static class AM004* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM004>();
	}
};
static_assert(alignof(AM004) == 0x000010, "Wrong alignment on AM004");
static_assert(sizeof(AM004) == 0x0016B0, "Wrong size on AM004");

// Class DarwinGame.M005
// 0x0000 (0x16B0 - 0x16B0)
class AM005 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M005">();
	}
	static class AM005* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM005>();
	}
};
static_assert(alignof(AM005) == 0x000010, "Wrong alignment on AM005");
static_assert(sizeof(AM005) == 0x0016B0, "Wrong size on AM005");

// Class DarwinGame.M006
// 0x0000 (0x16B0 - 0x16B0)
class AM006 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M006">();
	}
	static class AM006* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM006>();
	}
};
static_assert(alignof(AM006) == 0x000010, "Wrong alignment on AM006");
static_assert(sizeof(AM006) == 0x0016B0, "Wrong size on AM006");

// Class DarwinGame.M011
// 0x0000 (0x16B0 - 0x16B0)
class AM011 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M011">();
	}
	static class AM011* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM011>();
	}
};
static_assert(alignof(AM011) == 0x000010, "Wrong alignment on AM011");
static_assert(sizeof(AM011) == 0x0016B0, "Wrong size on AM011");

// Class DarwinGame.RectangleAreaOfEffect
// 0x0008 (0x0258 - 0x0250)
class ARectangleAreaOfEffect final : public AAreaOfEffectBase
{
public:
	struct FVector2D                              DecalSize;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSize(const struct FVector2D& Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RectangleAreaOfEffect">();
	}
	static class ARectangleAreaOfEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARectangleAreaOfEffect>();
	}
};
static_assert(alignof(ARectangleAreaOfEffect) == 0x000008, "Wrong alignment on ARectangleAreaOfEffect");
static_assert(sizeof(ARectangleAreaOfEffect) == 0x000258, "Wrong size on ARectangleAreaOfEffect");
static_assert(offsetof(ARectangleAreaOfEffect, DecalSize) == 0x000250, "Member 'ARectangleAreaOfEffect::DecalSize' has a wrong offset!");

// Class DarwinGame.M016
// 0x0000 (0x16B0 - 0x16B0)
class AM016 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M016">();
	}
	static class AM016* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM016>();
	}
};
static_assert(alignof(AM016) == 0x000010, "Wrong alignment on AM016");
static_assert(sizeof(AM016) == 0x0016B0, "Wrong size on AM016");

// Class DarwinGame.M026
// 0x0000 (0x16B0 - 0x16B0)
class AM026 final : public AMonster
{
public:
	void SetHideBone(class FName BoneName, bool hide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M026">();
	}
	static class AM026* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM026>();
	}
};
static_assert(alignof(AM026) == 0x000010, "Wrong alignment on AM026");
static_assert(sizeof(AM026) == 0x0016B0, "Wrong size on AM026");

// Class DarwinGame.M027
// 0x0000 (0x16B0 - 0x16B0)
class AM027 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M027">();
	}
	static class AM027* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM027>();
	}
};
static_assert(alignof(AM027) == 0x000010, "Wrong alignment on AM027");
static_assert(sizeof(AM027) == 0x0016B0, "Wrong size on AM027");

// Class DarwinGame.M028
// 0x0000 (0x16B0 - 0x16B0)
class AM028 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M028">();
	}
	static class AM028* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM028>();
	}
};
static_assert(alignof(AM028) == 0x000010, "Wrong alignment on AM028");
static_assert(sizeof(AM028) == 0x0016B0, "Wrong size on AM028");

// Class DarwinGame.ReplicaDifficultyDataTable
// 0x0000 (0x0030 - 0x0030)
class UReplicaDifficultyDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicaDifficultyDataTable">();
	}
	static class UReplicaDifficultyDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicaDifficultyDataTable>();
	}
};
static_assert(alignof(UReplicaDifficultyDataTable) == 0x000008, "Wrong alignment on UReplicaDifficultyDataTable");
static_assert(sizeof(UReplicaDifficultyDataTable) == 0x000030, "Wrong size on UReplicaDifficultyDataTable");

// Class DarwinGame.M029
// 0x0000 (0x16B0 - 0x16B0)
class AM029 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M029">();
	}
	static class AM029* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM029>();
	}
};
static_assert(alignof(AM029) == 0x000010, "Wrong alignment on AM029");
static_assert(sizeof(AM029) == 0x0016B0, "Wrong size on AM029");

// Class DarwinGame.M030
// 0x0000 (0x16B0 - 0x16B0)
class AM030 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M030">();
	}
	static class AM030* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM030>();
	}
};
static_assert(alignof(AM030) == 0x000010, "Wrong alignment on AM030");
static_assert(sizeof(AM030) == 0x0016B0, "Wrong size on AM030");

// Class DarwinGame.UIMonsterDict_ContentMenu
// 0x0058 (0x04E8 - 0x0490)
class UUIMonsterDict_ContentMenu : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITopbar_00*                           Topbar;                                            // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x38];                                     // 0x04B0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_ContentMenu">();
	}
	static class UUIMonsterDict_ContentMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_ContentMenu>();
	}
};
static_assert(alignof(UUIMonsterDict_ContentMenu) == 0x000008, "Wrong alignment on UUIMonsterDict_ContentMenu");
static_assert(sizeof(UUIMonsterDict_ContentMenu) == 0x0004E8, "Wrong size on UUIMonsterDict_ContentMenu");
static_assert(offsetof(UUIMonsterDict_ContentMenu, Topbar) == 0x0004A8, "Member 'UUIMonsterDict_ContentMenu::Topbar' has a wrong offset!");

// Class DarwinGame.M031
// 0x0000 (0x16B0 - 0x16B0)
class AM031 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M031">();
	}
	static class AM031* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM031>();
	}
};
static_assert(alignof(AM031) == 0x000010, "Wrong alignment on AM031");
static_assert(sizeof(AM031) == 0x0016B0, "Wrong size on AM031");

// Class DarwinGame.M032
// 0x0000 (0x16B0 - 0x16B0)
class AM032 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M032">();
	}
	static class AM032* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM032>();
	}
};
static_assert(alignof(AM032) == 0x000010, "Wrong alignment on AM032");
static_assert(sizeof(AM032) == 0x0016B0, "Wrong size on AM032");

// Class DarwinGame.RevengeBattleIdDataTable
// 0x0000 (0x0030 - 0x0030)
class URevengeBattleIdDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevengeBattleIdDataTable">();
	}
	static class URevengeBattleIdDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevengeBattleIdDataTable>();
	}
};
static_assert(alignof(URevengeBattleIdDataTable) == 0x000008, "Wrong alignment on URevengeBattleIdDataTable");
static_assert(sizeof(URevengeBattleIdDataTable) == 0x000030, "Wrong size on URevengeBattleIdDataTable");

// Class DarwinGame.UIMonsterDict_Content_10
// 0x0000 (0x04A0 - 0x04A0)
class UUIMonsterDict_Content_10 : public UUIMonsterDict_ContentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_10">();
	}
	static class UUIMonsterDict_Content_10* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_10>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_10) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_10");
static_assert(sizeof(UUIMonsterDict_Content_10) == 0x0004A0, "Wrong size on UUIMonsterDict_Content_10");

// Class DarwinGame.M033
// 0x0000 (0x16B0 - 0x16B0)
class AM033 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M033">();
	}
	static class AM033* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM033>();
	}
};
static_assert(alignof(AM033) == 0x000010, "Wrong alignment on AM033");
static_assert(sizeof(AM033) == 0x0016B0, "Wrong size on AM033");

// Class DarwinGame.MonsterBoss
// 0x0450 (0x1920 - 0x14D0)
class AMonsterBoss : public AMonsterBase
{
public:
	TMulticastInlineDelegate<void(class AGPACharacter* LinkTarget, ELinkType Type, int32 Index)> OnLinkActionFinish;                                // 0x14D0(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E0[0x30];                                    // 0x14E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterBoss*                           mParentBoss;                                       // 0x1510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMonsterBoss*                           mChildBoss;                                        // 0x1518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1520[0x5];                                     // 0x1520(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mNohitCollision;                                   // 0x1525(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1526[0x3A];                                    // 0x1526(0x003A)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  mDragonStones;                                     // 0x1560(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mBarrier;                                          // 0x1570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossBarrierStep                       mBarrierStep;                                      // 0x1571(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1572[0x1];                                     // 0x1572(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mBarrierChange;                                    // 0x1573(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossBarrierAppend                     mBarrierAppend;                                    // 0x1574(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1575[0x3];                                     // 0x1575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mBarrierRestartDefaultTime;                        // 0x1578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mBarrierWarmDefaultTime;                           // 0x157C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mBarrierAutoRecover;                               // 0x1580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         mDmgCountSubMax;                                   // 0x1584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mForceChargeBreakAmplify;                          // 0x1588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mBeastChargeBreakAmplify;                          // 0x158C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mStatueChargeBreakAmplify;                         // 0x1590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mReplacement;                                      // 0x1594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossBodyType                          mBodyType;                                         // 0x1595(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1596[0x1];                                     // 0x1596(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EMonsterBossCombatDuring                      mCombatDuring;                                     // 0x1597(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1598[0x2];                                     // 0x1598(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EMonsterBossType                              mBossType;                                         // 0x159A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossForm                              mBossForm;                                         // 0x159B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossDerived                           mBossDerived;                                      // 0x159C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159D[0x1];                                     // 0x159D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EMonsterLastBossEffect                        mLastBossEffect;                                   // 0x159E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mLastBossEffectChange;                             // 0x159F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mQteRequest;                                       // 0x15A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A1[0x7];                                     // 0x15A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                mSensorLeftFrontFrontEnd;                          // 0x15A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mSensorLeftFrontRearEnd;                           // 0x15B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mSensorRightFrontFrontEnd;                         // 0x15C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mSensorRightFrontRearEnd;                          // 0x15CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mImpactCollisionFrontEnd;                          // 0x15D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mImpactCollisionRearEnd;                           // 0x15E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                mBarrierLocation;                                  // 0x15F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mSensorRadius;                                     // 0x15FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mImpactRadius;                                     // 0x1600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mBarrierRadius;                                    // 0x1604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mNohitRadius;                                      // 0x1608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         mSensorLoopCnt;                                    // 0x160C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         mImpactLoopCnt;                                    // 0x1610(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   mNextSection;                                      // 0x1614(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161C[0x1];                                     // 0x161C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mStartQuickSand;                                   // 0x161D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mEndQuickSand;                                     // 0x161E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161F[0x1];                                     // 0x161F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         mQuickSandDefaultSpeed;                            // 0x1620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          mAttackCont;                                       // 0x1624(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1625[0x2];                                     // 0x1625(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mInBattle;                                         // 0x1627(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         mPlayTime;                                         // 0x1628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162C[0x1C];                                    // 0x162C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_BossAvoidanceInfo>          mAvoidanceInfoList;                                // 0x1648(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        mGimmickFixedPos;                                  // 0x1658(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1668[0x8];                                     // 0x1668(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABossAvoidWall*>                 mAvoidWallList;                                    // 0x1670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1680[0x84];                                    // 0x1680(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mRedeyeChange;                                     // 0x1704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMonsterBossRedeyeStep                        mRedeyeStep;                                       // 0x1705(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1706[0x22];                                    // 0x1706(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorDecisionMonsterBoss*           mBehaviorDecision;                                 // 0x1728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMonsterBossBattleAI*                   mBattleAI;                                         // 0x1730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1738[0x88];                                    // 0x1738(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsterTableComponent*                 MonsterTableComponent;                             // 0x17C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C8[0xD0];                                    // 0x17C8(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMonsNotifyState_BossBoostingCheck*     mMonsNotifyState_BossBoostingCheck;                // 0x1898(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossRotateInsightTarget* mMonsNotifyState_BossRotateInsightTarget;          // 0x18A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossTargetInRange*     mMonsNotifyState_BossTargetInRange;                // 0x18A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_TimeCheckMultipleAttack* mMonsNotifyState_TimeCheckMultipleAttack;          // 0x18B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossRetarget*          mMonsNotifyState_BossRetarget;                     // 0x18B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossCombatDuring*      mMonsNotifyState_BossCombatDuring;                 // 0x18C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossSelfhalm*          mMonsNotifyState_BossSelfhalm;                     // 0x18C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossExposeWeaknesses*  mMonsNotifyState_BossExposeWeaknesses;             // 0x18D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossPossessFlying*     mMonsNotifyState_BossPossessFlying;                // 0x18D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossPossessed*         mMonsNotifyState_BossPossessed;                    // 0x18E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossStatueDeadWait*    mMonsNotifyState_BossStatueDeadWait;               // 0x18E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossStatueDestroy*     mMonsNotifyState_BossStatueDestroy;                // 0x18F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_BossUIRestart*         mMonsNotifyState_BossUIRestart;                    // 0x18F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMonsNotifyState_GuideSysLog*           mMonsNotifyState_GuideSysLog;                      // 0x1900(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1908[0x18];                                    // 0x1908(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoreActor(class AActor* Actor);
	void AddIgnoreActorInRush(class AActor* Actor);
	void BehaviorDecision();
	void BindOnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void BoostTick(float DeltaSeconds);
	void BossBoostingCheckBegin(const struct FST_NotifyBegin& fst);
	void BossRotateInsightTargetBegin(const struct FST_NotifyBegin& fst);
	void CheckWeaknesses();
	void ClearBossFainting();
	void ClearFrontHit();
	void FinishQte();
	class UMonsterBossBattleAI* GetBattleAI();
	float GetBodyRange();
	EMonsterBossSightType GetBossObjectSightType(class AActor* Target);
	EMonsterBossSightType GetBossSightType(class AGPACharacter* Target);
	class AActor* GetGimmickActor();
	class FName GetSummonID();
	EMonsterBossSightType HitCheckCircleImpactFront(const struct FVector& Location, float Radius);
	float HitCheckCircleImpactFrontAng(const struct FVector& Location, float Radius);
	EMonsterBossSightType HitCheckSphereImpactFront(const struct FVector& Location, float Radius);
	void IncBossGimmick();
	void IncBossGimmickBreak();
	void IncContCnt();
	void InitBattleTimer();
	bool IsMaxSummon();
	bool IsNoneSummon();
	bool IsOnBarrier();
	void OnChangedRedEyeStep();
	void PushBackAvoidBody();
	void PushBackBarrier();
	void PushBackCircleImpactFront(const struct FVector& Location, float Radius);
	void RemoveAttackLocationUser();
	void RequestQte();
	void SequenceRollBack(int32 Back);
	void SetAttackCont(bool flg);
	void SetBarrier(bool flg);
	void SetBarrierAppend(EMonsterBossBarrierAppend step);
	void SetBarrierStep(EMonsterBossBarrierStep step);
	void SetBossBarrierBreak();
	void SetBossBoostingCheck(const struct FST_BossBoostingCheck& fst);
	void SetBossFainting();
	void SetBossForceChargeBreak();
	void SetBossGimmickBreak(bool flg);
	void SetBossHidden(bool flg);
	void SetBossPhase(EMonsterBossPhase phase);
	void SetBossRotateInsightTarget(const struct FST_BossRotateInsightTarget& cnt);
	void SetBossSerialPeriod(int32 Period);
	void SetBossTargetInRange(const struct FST_BossTargetInRange& cnt);
	void SetBossType(EMonsterBossType Type);
	void SetCamEnd(bool flg);
	void SetCameraControll(EMonsterBossCameraControllType Type);
	void SetCameraType(EMonsterBossCameraType Type);
	void SetCollisionRadius(float sensor, float impact, float barrier);
	void SetCollisonLocation(const struct FVector& sensorleft, const struct FVector& sensorright, const struct FVector& impact, const struct FVector& sensorleft2, const struct FVector& sensorright2, const struct FVector& impact2, const struct FVector& barrier);
	void SetCombatDuring(EMonsterBossCombatDuring during);
	void SetContCnt(int32 cnt);
	void SetCursedStatue(class AActor* statue);
	void SetCursedStatueLocation(const struct FVector& Location, bool exitui);
	void SetEndQuickSand(bool flg);
	void SetFirstWaitPos(const struct FVector& vec);
	void SetGimmickActor(class AActor* Actor, const struct FVector& Location, float Radius);
	void SetGimmickFixedPos(const TArray<struct FVector>& fixedpos);
	void SetHitWeaknesses(const bool flg);
	void SetIsInVisible(bool flg);
	void SetLastBossEffect(EMonsterLastBossEffect eff);
	void SetLeftFrontHit(bool flg);
	void SetLeftFrontOverlap(bool flg);
	void SetNextSection(class FName Section);
	void SetNohitRadius(float nohit);
	void SetPossessedID(class FName Summon);
	void SetQuickSandBreaking(bool flg);
	void SetQuickSandWait(bool flg);
	void SetRedeyeStep(EMonsterBossRedeyeStep step);
	void SetReplacement(bool flg);
	void SetReplacementBody(EMonsterBossBodyType Type);
	void SetRestraintChargeBreak();
	void SetRightFrontHit(bool flg);
	void SetRightFrontOverlap(bool flg);
	void SetStartCameraShake(bool flg);
	void SetStartQuickSand(bool flg);
	void SetSummonID(class FName Summon);
	void SetSummonPossessedID();
	void SetVolcanoCollided(bool flg);
	void SetVolcanoGimmickAllDestroyed(bool flg);
	void StopQuickSand();

	bool GetAttackCont() const;
	EMonsterBossBarrierAppend GetBarrierAppend() const;
	struct FST_BossBoostingCheck GetBossBoostingCheck() const;
	EMonsterBossDerived GetBossDerived() const;
	bool GetBossForceChargeBreak() const;
	EMonsterBossForm GetBossForm() const;
	bool GetBossGimmickBreak() const;
	bool GetBossHidden() const;
	EMonsterBossPhase GetBossPhase() const;
	struct FST_BossRotateInsightTarget GetBossRotateInsightTarget() const;
	int32 GetBossSerialPeriod() const;
	int32 GetBossStage() const;
	struct FST_BossTargetInRange GetBossTargetInRange() const;
	EMonsterBossType GetBossType() const;
	bool GetCamEnd() const;
	EMonsterBossCameraControllType GetCameraControll() const;
	EMonsterBossCameraType GetCameraType() const;
	bool GetChargeBreakingStun() const;
	EMonsterBossCombatDuring GetCombatDuring() const;
	int32 GetContCnt() const;
	bool GetEndQuickSand() const;
	bool GetExposeWeaknesses() const;
	bool GetHitWeaknesses() const;
	struct FVector GetImpactCollisionFrontEnd() const;
	float GetImpactCollisionRadius() const;
	struct FVector GetImpactCollisionRearEnd() const;
	bool GetIsInVisible() const;
	bool GetLeftFrontHit() const;
	bool GetLeftFrontOverlap() const;
	class FName GetNextSection() const;
	float GetNohitRadius() const;
	class FName GetPossessedID() const;
	class AFieldObjectBase* GetQuickSand() const;
	bool GetQuickSandBreaking() const;
	bool GetQuickSandWait() const;
	EMonsterBossRedeyeStep GetRedeyeStep() const;
	bool GetReplacement() const;
	bool GetRestraintChargeBreak() const;
	bool GetRightFrontHit() const;
	bool GetRightFrontOverlap() const;
	bool GetStartCameraShake() const;
	bool GetStartQuickSand() const;
	bool GetVolcanoCollided() const;
	bool IsBossBoost() const;
	bool IsBossDead() const;
	bool IsBossDeathblow() const;
	bool IsBossFainting() const;
	bool IsChangeRedeyeStep() const;
	bool IsGimmickFirstBreak() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBoss">();
	}
	static class AMonsterBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterBoss>();
	}
};
static_assert(alignof(AMonsterBoss) == 0x000010, "Wrong alignment on AMonsterBoss");
static_assert(sizeof(AMonsterBoss) == 0x001920, "Wrong size on AMonsterBoss");
static_assert(offsetof(AMonsterBoss, OnLinkActionFinish) == 0x0014D0, "Member 'AMonsterBoss::OnLinkActionFinish' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mParentBoss) == 0x001510, "Member 'AMonsterBoss::mParentBoss' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mChildBoss) == 0x001518, "Member 'AMonsterBoss::mChildBoss' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mNohitCollision) == 0x001525, "Member 'AMonsterBoss::mNohitCollision' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mDragonStones) == 0x001560, "Member 'AMonsterBoss::mDragonStones' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrier) == 0x001570, "Member 'AMonsterBoss::mBarrier' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierStep) == 0x001571, "Member 'AMonsterBoss::mBarrierStep' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierChange) == 0x001573, "Member 'AMonsterBoss::mBarrierChange' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierAppend) == 0x001574, "Member 'AMonsterBoss::mBarrierAppend' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierRestartDefaultTime) == 0x001578, "Member 'AMonsterBoss::mBarrierRestartDefaultTime' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierWarmDefaultTime) == 0x00157C, "Member 'AMonsterBoss::mBarrierWarmDefaultTime' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierAutoRecover) == 0x001580, "Member 'AMonsterBoss::mBarrierAutoRecover' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mDmgCountSubMax) == 0x001584, "Member 'AMonsterBoss::mDmgCountSubMax' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mForceChargeBreakAmplify) == 0x001588, "Member 'AMonsterBoss::mForceChargeBreakAmplify' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBeastChargeBreakAmplify) == 0x00158C, "Member 'AMonsterBoss::mBeastChargeBreakAmplify' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mStatueChargeBreakAmplify) == 0x001590, "Member 'AMonsterBoss::mStatueChargeBreakAmplify' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mReplacement) == 0x001594, "Member 'AMonsterBoss::mReplacement' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBodyType) == 0x001595, "Member 'AMonsterBoss::mBodyType' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mCombatDuring) == 0x001597, "Member 'AMonsterBoss::mCombatDuring' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBossType) == 0x00159A, "Member 'AMonsterBoss::mBossType' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBossForm) == 0x00159B, "Member 'AMonsterBoss::mBossForm' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBossDerived) == 0x00159C, "Member 'AMonsterBoss::mBossDerived' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mLastBossEffect) == 0x00159E, "Member 'AMonsterBoss::mLastBossEffect' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mLastBossEffectChange) == 0x00159F, "Member 'AMonsterBoss::mLastBossEffectChange' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mQteRequest) == 0x0015A0, "Member 'AMonsterBoss::mQteRequest' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mSensorLeftFrontFrontEnd) == 0x0015A8, "Member 'AMonsterBoss::mSensorLeftFrontFrontEnd' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mSensorLeftFrontRearEnd) == 0x0015B4, "Member 'AMonsterBoss::mSensorLeftFrontRearEnd' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mSensorRightFrontFrontEnd) == 0x0015C0, "Member 'AMonsterBoss::mSensorRightFrontFrontEnd' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mSensorRightFrontRearEnd) == 0x0015CC, "Member 'AMonsterBoss::mSensorRightFrontRearEnd' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mImpactCollisionFrontEnd) == 0x0015D8, "Member 'AMonsterBoss::mImpactCollisionFrontEnd' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mImpactCollisionRearEnd) == 0x0015E4, "Member 'AMonsterBoss::mImpactCollisionRearEnd' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierLocation) == 0x0015F0, "Member 'AMonsterBoss::mBarrierLocation' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mSensorRadius) == 0x0015FC, "Member 'AMonsterBoss::mSensorRadius' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mImpactRadius) == 0x001600, "Member 'AMonsterBoss::mImpactRadius' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBarrierRadius) == 0x001604, "Member 'AMonsterBoss::mBarrierRadius' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mNohitRadius) == 0x001608, "Member 'AMonsterBoss::mNohitRadius' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mSensorLoopCnt) == 0x00160C, "Member 'AMonsterBoss::mSensorLoopCnt' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mImpactLoopCnt) == 0x001610, "Member 'AMonsterBoss::mImpactLoopCnt' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mNextSection) == 0x001614, "Member 'AMonsterBoss::mNextSection' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mStartQuickSand) == 0x00161D, "Member 'AMonsterBoss::mStartQuickSand' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mEndQuickSand) == 0x00161E, "Member 'AMonsterBoss::mEndQuickSand' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mQuickSandDefaultSpeed) == 0x001620, "Member 'AMonsterBoss::mQuickSandDefaultSpeed' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mAttackCont) == 0x001624, "Member 'AMonsterBoss::mAttackCont' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mInBattle) == 0x001627, "Member 'AMonsterBoss::mInBattle' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mPlayTime) == 0x001628, "Member 'AMonsterBoss::mPlayTime' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mAvoidanceInfoList) == 0x001648, "Member 'AMonsterBoss::mAvoidanceInfoList' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mGimmickFixedPos) == 0x001658, "Member 'AMonsterBoss::mGimmickFixedPos' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mAvoidWallList) == 0x001670, "Member 'AMonsterBoss::mAvoidWallList' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mRedeyeChange) == 0x001704, "Member 'AMonsterBoss::mRedeyeChange' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mRedeyeStep) == 0x001705, "Member 'AMonsterBoss::mRedeyeStep' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBehaviorDecision) == 0x001728, "Member 'AMonsterBoss::mBehaviorDecision' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mBattleAI) == 0x001730, "Member 'AMonsterBoss::mBattleAI' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, MonsterTableComponent) == 0x0017C0, "Member 'AMonsterBoss::MonsterTableComponent' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossBoostingCheck) == 0x001898, "Member 'AMonsterBoss::mMonsNotifyState_BossBoostingCheck' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossRotateInsightTarget) == 0x0018A0, "Member 'AMonsterBoss::mMonsNotifyState_BossRotateInsightTarget' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossTargetInRange) == 0x0018A8, "Member 'AMonsterBoss::mMonsNotifyState_BossTargetInRange' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_TimeCheckMultipleAttack) == 0x0018B0, "Member 'AMonsterBoss::mMonsNotifyState_TimeCheckMultipleAttack' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossRetarget) == 0x0018B8, "Member 'AMonsterBoss::mMonsNotifyState_BossRetarget' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossCombatDuring) == 0x0018C0, "Member 'AMonsterBoss::mMonsNotifyState_BossCombatDuring' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossSelfhalm) == 0x0018C8, "Member 'AMonsterBoss::mMonsNotifyState_BossSelfhalm' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossExposeWeaknesses) == 0x0018D0, "Member 'AMonsterBoss::mMonsNotifyState_BossExposeWeaknesses' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossPossessFlying) == 0x0018D8, "Member 'AMonsterBoss::mMonsNotifyState_BossPossessFlying' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossPossessed) == 0x0018E0, "Member 'AMonsterBoss::mMonsNotifyState_BossPossessed' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossStatueDeadWait) == 0x0018E8, "Member 'AMonsterBoss::mMonsNotifyState_BossStatueDeadWait' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossStatueDestroy) == 0x0018F0, "Member 'AMonsterBoss::mMonsNotifyState_BossStatueDestroy' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_BossUIRestart) == 0x0018F8, "Member 'AMonsterBoss::mMonsNotifyState_BossUIRestart' has a wrong offset!");
static_assert(offsetof(AMonsterBoss, mMonsNotifyState_GuideSysLog) == 0x001900, "Member 'AMonsterBoss::mMonsNotifyState_GuideSysLog' has a wrong offset!");

// Class DarwinGame.M036
// 0x0000 (0x1920 - 0x1920)
class AM036 final : public AMonsterBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M036">();
	}
	static class AM036* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM036>();
	}
};
static_assert(alignof(AM036) == 0x000010, "Wrong alignment on AM036");
static_assert(sizeof(AM036) == 0x001920, "Wrong size on AM036");

// Class DarwinGame.M037
// 0x0000 (0x1920 - 0x1920)
class AM037 final : public AMonsterBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M037">();
	}
	static class AM037* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM037>();
	}
};
static_assert(alignof(AM037) == 0x000010, "Wrong alignment on AM037");
static_assert(sizeof(AM037) == 0x001920, "Wrong size on AM037");

// Class DarwinGame.P000AsMonster
// 0x0000 (0x16B0 - 0x16B0)
class AP000AsMonster final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"P000AsMonster">();
	}
	static class AP000AsMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AP000AsMonster>();
	}
};
static_assert(alignof(AP000AsMonster) == 0x000010, "Wrong alignment on AP000AsMonster");
static_assert(sizeof(AP000AsMonster) == 0x0016B0, "Wrong size on AP000AsMonster");

// Class DarwinGame.M038
// 0x0000 (0x1920 - 0x1920)
class AM038 final : public AMonsterBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M038">();
	}
	static class AM038* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM038>();
	}
};
static_assert(alignof(AM038) == 0x000010, "Wrong alignment on AM038");
static_assert(sizeof(AM038) == 0x001920, "Wrong size on AM038");

// Class DarwinGame.UIQuest_Order_List
// 0x0030 (0x0600 - 0x05D0)
class UUIQuest_Order_List final : public UUIScrollMenuBase
{
public:
	TArray<class UDarwinUserWidget*>              ClearEffectWidget;                                 // 0x05D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x20];                                     // 0x05E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearOutFinishedFunction();
	void DeleteNewCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuest_Order_List">();
	}
	static class UUIQuest_Order_List* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuest_Order_List>();
	}
};
static_assert(alignof(UUIQuest_Order_List) == 0x000008, "Wrong alignment on UUIQuest_Order_List");
static_assert(sizeof(UUIQuest_Order_List) == 0x000600, "Wrong size on UUIQuest_Order_List");
static_assert(offsetof(UUIQuest_Order_List, ClearEffectWidget) == 0x0005D0, "Member 'UUIQuest_Order_List::ClearEffectWidget' has a wrong offset!");

// Class DarwinGame.M039
// 0x0000 (0x16B0 - 0x16B0)
class AM039 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M039">();
	}
	static class AM039* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM039>();
	}
};
static_assert(alignof(AM039) == 0x000010, "Wrong alignment on AM039");
static_assert(sizeof(AM039) == 0x0016B0, "Wrong size on AM039");

// Class DarwinGame.MainIndoorTrigger
// 0x0010 (0x0240 - 0x0230)
class AMainIndoorTrigger final : public AIndoorTriggerBase
{
public:
	struct FST_IndoorData                         IndoorData;                                        // 0x0230(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainIndoorTrigger">();
	}
	static class AMainIndoorTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainIndoorTrigger>();
	}
};
static_assert(alignof(AMainIndoorTrigger) == 0x000008, "Wrong alignment on AMainIndoorTrigger");
static_assert(sizeof(AMainIndoorTrigger) == 0x000240, "Wrong size on AMainIndoorTrigger");
static_assert(offsetof(AMainIndoorTrigger, IndoorData) == 0x000230, "Member 'AMainIndoorTrigger::IndoorData' has a wrong offset!");

// Class DarwinGame.UIAppraise_Panel_01
// 0x00D0 (0x0560 - 0x0490)
class UUIAppraise_Panel_01 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             EffectDataTable;                                   // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIAppraise_Count*>              CountList;                                         // 0x04B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIAppraise_Count*>              CommaList;                                         // 0x04C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIAppraise_Count*                      Count_G;                                           // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIAppraise_Count_Flash*>        FlashCountList;                                    // 0x04E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIAppraise_Count_Flash*>        FlashCommaList;                                    // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIAppraise_Count_Flash*                FlashCount_G;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         LoopSound;                                         // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_510[0x50];                                     // 0x0510(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EffectEnd();
	void ExpansionEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraise_Panel_01">();
	}
	static class UUIAppraise_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraise_Panel_01>();
	}
};
static_assert(alignof(UUIAppraise_Panel_01) == 0x000008, "Wrong alignment on UUIAppraise_Panel_01");
static_assert(sizeof(UUIAppraise_Panel_01) == 0x000560, "Wrong size on UUIAppraise_Panel_01");
static_assert(offsetof(UUIAppraise_Panel_01, EffectDataTable) == 0x0004B0, "Member 'UUIAppraise_Panel_01::EffectDataTable' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, CountList) == 0x0004B8, "Member 'UUIAppraise_Panel_01::CountList' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, CommaList) == 0x0004C8, "Member 'UUIAppraise_Panel_01::CommaList' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, Count_G) == 0x0004D8, "Member 'UUIAppraise_Panel_01::Count_G' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, FlashCountList) == 0x0004E0, "Member 'UUIAppraise_Panel_01::FlashCountList' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, FlashCommaList) == 0x0004F0, "Member 'UUIAppraise_Panel_01::FlashCommaList' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, FlashCount_G) == 0x000500, "Member 'UUIAppraise_Panel_01::FlashCount_G' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Panel_01, LoopSound) == 0x000508, "Member 'UUIAppraise_Panel_01::LoopSound' has a wrong offset!");

// Class DarwinGame.ManagerContainer
// 0x0370 (0x03A0 - 0x0030)
class UManagerContainer : public UObject
{
public:
	TSoftClassPtr<class UClass>                   mDataTableManagerClass;                            // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mLevelManagerClass;                                // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mResidentDataManagerClass;                         // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mEffectManagerClass;                               // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mSaveManagerClass;                                 // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mSoundManagerClass;                                // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mUIManagerClass;                                   // 0x0120(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mFieldManagerClass;                                // 0x0148(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mTextManagerClass;                                 // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mMonsterManagerClass;                              // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mGameDataManagerClass;                             // 0x01C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mQuestManagerClass;                                // 0x01E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mEventSystemManagerClass;                          // 0x0210(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mCharacterAssetManagerClass;                       // 0x0238(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mNPCAssetManagerClass;                             // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mDarwinAssetManagerClass;                          // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mCollisionManagerClass;                            // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mAreaOfEffectManager;                              // 0x02D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mFriendPositionManager;                            // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mTimerReportManager;                               // 0x0328(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mProjectHttpManager;                               // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   mRivalTeamStampManager;                            // 0x0378(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManagerContainer">();
	}
	static class UManagerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManagerContainer>();
	}
};
static_assert(alignof(UManagerContainer) == 0x000008, "Wrong alignment on UManagerContainer");
static_assert(sizeof(UManagerContainer) == 0x0003A0, "Wrong size on UManagerContainer");
static_assert(offsetof(UManagerContainer, mDataTableManagerClass) == 0x000030, "Member 'UManagerContainer::mDataTableManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mLevelManagerClass) == 0x000058, "Member 'UManagerContainer::mLevelManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mResidentDataManagerClass) == 0x000080, "Member 'UManagerContainer::mResidentDataManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mEffectManagerClass) == 0x0000A8, "Member 'UManagerContainer::mEffectManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mSaveManagerClass) == 0x0000D0, "Member 'UManagerContainer::mSaveManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mSoundManagerClass) == 0x0000F8, "Member 'UManagerContainer::mSoundManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mUIManagerClass) == 0x000120, "Member 'UManagerContainer::mUIManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mFieldManagerClass) == 0x000148, "Member 'UManagerContainer::mFieldManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mTextManagerClass) == 0x000170, "Member 'UManagerContainer::mTextManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mMonsterManagerClass) == 0x000198, "Member 'UManagerContainer::mMonsterManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mGameDataManagerClass) == 0x0001C0, "Member 'UManagerContainer::mGameDataManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mQuestManagerClass) == 0x0001E8, "Member 'UManagerContainer::mQuestManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mEventSystemManagerClass) == 0x000210, "Member 'UManagerContainer::mEventSystemManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mCharacterAssetManagerClass) == 0x000238, "Member 'UManagerContainer::mCharacterAssetManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mNPCAssetManagerClass) == 0x000260, "Member 'UManagerContainer::mNPCAssetManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mDarwinAssetManagerClass) == 0x000288, "Member 'UManagerContainer::mDarwinAssetManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mCollisionManagerClass) == 0x0002B0, "Member 'UManagerContainer::mCollisionManagerClass' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mAreaOfEffectManager) == 0x0002D8, "Member 'UManagerContainer::mAreaOfEffectManager' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mFriendPositionManager) == 0x000300, "Member 'UManagerContainer::mFriendPositionManager' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mTimerReportManager) == 0x000328, "Member 'UManagerContainer::mTimerReportManager' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mProjectHttpManager) == 0x000350, "Member 'UManagerContainer::mProjectHttpManager' has a wrong offset!");
static_assert(offsetof(UManagerContainer, mRivalTeamStampManager) == 0x000378, "Member 'UManagerContainer::mRivalTeamStampManager' has a wrong offset!");

// Class DarwinGame.MeController
// 0x00F0 (0x0120 - 0x0030)
class alignas(0x10) UMeController : public UObject
{
public:
	class UDataTable*                             MeParameterList;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         mMeComp;                                           // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x98];                                      // 0x0088(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeController">();
	}
	static class UMeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeController>();
	}
};
static_assert(alignof(UMeController) == 0x000010, "Wrong alignment on UMeController");
static_assert(sizeof(UMeController) == 0x000120, "Wrong size on UMeController");
static_assert(offsetof(UMeController, MeParameterList) == 0x000030, "Member 'UMeController::MeParameterList' has a wrong offset!");
static_assert(offsetof(UMeController, mMeComp) == 0x000080, "Member 'UMeController::mMeComp' has a wrong offset!");

// Class DarwinGame.MemoryTestGameMode
// 0x0010 (0x02D8 - 0x02C8)
class AMemoryTestGameMode final : public AAppGameModeBase
{
public:
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateAndAddTestObject();

	TArray<class UMemoryTestObject*> GetTestObjects() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemoryTestGameMode">();
	}
	static class AMemoryTestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMemoryTestGameMode>();
	}
};
static_assert(alignof(AMemoryTestGameMode) == 0x000008, "Wrong alignment on AMemoryTestGameMode");
static_assert(sizeof(AMemoryTestGameMode) == 0x0002D8, "Wrong size on AMemoryTestGameMode");

// Class DarwinGame.UIQuest_Data
// 0x0068 (0x04F8 - 0x0490)
class UUIQuest_Data : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x28];                                     // 0x0490(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_UIQuestDataTextInfo>        TextBlockInfo;                                     // 0x04B8(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ClearAnim;                                         // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ReserveInAnim;                                     // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ReserveLoopAnim;                                   // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 CheckBox02;                                        // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 CheckBox03;                                        // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuest_Data">();
	}
	static class UUIQuest_Data* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuest_Data>();
	}
};
static_assert(alignof(UUIQuest_Data) == 0x000008, "Wrong alignment on UUIQuest_Data");
static_assert(sizeof(UUIQuest_Data) == 0x0004F8, "Wrong size on UUIQuest_Data");
static_assert(offsetof(UUIQuest_Data, TextBlockInfo) == 0x0004B8, "Member 'UUIQuest_Data::TextBlockInfo' has a wrong offset!");
static_assert(offsetof(UUIQuest_Data, ClearAnim) == 0x0004D0, "Member 'UUIQuest_Data::ClearAnim' has a wrong offset!");
static_assert(offsetof(UUIQuest_Data, ReserveInAnim) == 0x0004D8, "Member 'UUIQuest_Data::ReserveInAnim' has a wrong offset!");
static_assert(offsetof(UUIQuest_Data, ReserveLoopAnim) == 0x0004E0, "Member 'UUIQuest_Data::ReserveLoopAnim' has a wrong offset!");
static_assert(offsetof(UUIQuest_Data, CheckBox02) == 0x0004E8, "Member 'UUIQuest_Data::CheckBox02' has a wrong offset!");
static_assert(offsetof(UUIQuest_Data, CheckBox03) == 0x0004F0, "Member 'UUIQuest_Data::CheckBox03' has a wrong offset!");

// Class DarwinGame.MemoryTestObject
// 0x0000 (0x0030 - 0x0030)
class UMemoryTestObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemoryTestObject">();
	}
	static class UMemoryTestObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMemoryTestObject>();
	}
};
static_assert(alignof(UMemoryTestObject) == 0x000008, "Wrong alignment on UMemoryTestObject");
static_assert(sizeof(UMemoryTestObject) == 0x000030, "Wrong size on UMemoryTestObject");

// Class DarwinGame.ParkourFoliageComponent
// 0x0000 (0x0670 - 0x0670)
class UParkourFoliageComponent final : public UFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParkourFoliageComponent">();
	}
	static class UParkourFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParkourFoliageComponent>();
	}
};
static_assert(alignof(UParkourFoliageComponent) == 0x000010, "Wrong alignment on UParkourFoliageComponent");
static_assert(sizeof(UParkourFoliageComponent) == 0x000670, "Wrong size on UParkourFoliageComponent");

// Class DarwinGame.MessageUtils
// 0x0000 (0x0030 - 0x0030)
class UMessageUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool adjustIEMessageId(const class FString& SrcID, class FString* DstID);
	static bool adjustIEMessageId_Branch(const class FString& Src, class FString* NextID, const int32 Flag);
	static bool adjustIEMessageId_Jouken(const class FString& Src, class FString* NextID, ETextJoukenType JoukenType);
	static bool adjustIEMessageId_PCType(const class FString& Src, class FString* NextID, ETextPCType NewPcType);
	static bool adjustIEMessageId_TalkNum(const class FString& Src, class FString* NextID, const EQuestState QuestState);
	static bool adjustIEMessageId_Time(const class FString& Src, class FString* NextID, const int32 Hour);
	static void AdjustIEQuestTalkID(const class FString& TalkId, EEventType EventType, EQuestState QuestState, class FString* NewTalkId);
	static void CheckColorTag(const class FString& Src, bool* IsColor, float* R, float* G, float* B, float* A);
	static bool CheckDelegateTag(const class FString& Src, class FString* OutString);
	static void CheckEmojiChangeColorTag(const class FString& Src, bool* IsColor, float* R, float* G, float* B, float* A);
	static void CheckEmojiTag(const class FString& Src, bool* IsStamp, int32* TypeID);
	static void CheckEmotionEffectTag(const class FString& Src, bool* IsemotionEffect, EEmotionEffectID* EmotionEffectID);
	static int32 CheckFlagCommand(const class FString& TextID);
	static bool CheckFukidashiStamp(const class FString& Serifu, EStampIconType* StampType);
	static void CheckOutLineColorTag(const class FString& Src, bool* IsColor, float* R, float* G, float* B, float* A);
	static void CheckPartVoiceTag(const class FString& Src, bool* IsPartVoice, class FString* TalkTypeName);
	static void CheckSoundTag(const class FString& Src, bool* IsSound, EAtomCueSheetCategory* SoundType, int32* SoundNo);
	static void CheckStampTag(const class FString& Src, bool* IsStamp, EStampIconType* StampType, EEmoteType* emoteType, class FString* Option, int32* LoopNum);
	static bool CheckTag(const class FString& Src);
	static void CheckTipsTag(const class FString& Src, bool* IsTips, class FString* TipsID);
	static void Command_Check_Chart(const class FString& Str, ETextTalkChart* ChartID, bool* IsChartOnly);
	static void Command_Check_Icon(const class FString& Str, ETextTalkIcon* Type);
	static void Command_Check_LipSync(const class FString& Str, bool* IsLipSync);
	static void Command_Check_TurnPC(const class FString& Str, bool* IsTurn, bool* IsWait, bool* IsReturn);
	static class FString createIEMessageID(const struct FMessageIdInfo& Info);
	static class FString createIEMessageID_Old(const struct FMessageIdInfo& Info);
	static void GetEmojiStr(int32 emojiId, int32 SysytemType, class FString* Str);
	static bool GetEventTalkData(const class FName& TextID, struct FST_EventTalkData* EventTalkData);
	static const class FName GetFukidashiID(const class FName SrcID, int32 Hour, const bool SubFlag);
	static const TArray<class FName> GetFukidashiIDList(const class FName SrcID, int32 Hour);
	static bool getNextCSMessageId(const class FString& SrcID, const class FString& Src, class FString* NextID);
	static class FName GetNextTextID(const class FString& TextID, const EEndType EndType);
	static class FString GetSerifuDataDirect(const class FName& TextID);
	static class FName GetStampID(const class FString& Src);
	static void InsertSpaceToTop(const class FString& Src, class FString* Dst);
	static class FString IsEmojiChangeSizeTag(const class FString& Src);
	static bool IsFukidashiID(const class FName TextID);
	static bool IsJapanese();
	static bool IsValidMessageID(const class FString& ID);
	static bool procIEMessageID(const class FString& Src, struct FMessageIdInfo* IdInfo);
	static class FString ProcSerifuText(const class FString& Src);
	static class FString RemoveSquareBrackets(const class FString& Text);
	static class FString ShapeFukidashiText(const class FString& Serifu);

	bool SerifuToFukidashi(const class FString& Serifu, class FString* Fukidashi, const int32 Length);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageUtils">();
	}
	static class UMessageUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageUtils>();
	}
};
static_assert(alignof(UMessageUtils) == 0x000008, "Wrong alignment on UMessageUtils");
static_assert(sizeof(UMessageUtils) == 0x000030, "Wrong size on UMessageUtils");

// Class DarwinGame.MissileLaunchPadMagicBase
// 0x00F0 (0x03E0 - 0x02F0)
class AMissileLaunchPadMagicBase final : public AMagicBase
{
public:
	TMulticastInlineDelegate<void(ESocket socket, class FName actionDetailID)> OnBulletLoadEvent;                                 // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0xE0];                                     // 0x0300(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMissile(class AMissileMagicBase* missile);
	void BulletsLoad(const TArray<ESocket>& Sockets, const TArray<class FName>& ActionDetailIDs);
	class FName GetBulletActionDetailID();
	struct FActionGameplayEffectContainerSpec GetEffectContainerSpec();
	void Launch();
	void LaunchStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissileLaunchPadMagicBase">();
	}
	static class AMissileLaunchPadMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissileLaunchPadMagicBase>();
	}
};
static_assert(alignof(AMissileLaunchPadMagicBase) == 0x000008, "Wrong alignment on AMissileLaunchPadMagicBase");
static_assert(sizeof(AMissileLaunchPadMagicBase) == 0x0003E0, "Wrong size on AMissileLaunchPadMagicBase");
static_assert(offsetof(AMissileLaunchPadMagicBase, OnBulletLoadEvent) == 0x0002F0, "Member 'AMissileLaunchPadMagicBase::OnBulletLoadEvent' has a wrong offset!");

// Class DarwinGame.PartyMemberFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UPartyMemberFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyMemberFunctionLibrary">();
	}
	static class UPartyMemberFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyMemberFunctionLibrary>();
	}
};
static_assert(alignof(UPartyMemberFunctionLibrary) == 0x000008, "Wrong alignment on UPartyMemberFunctionLibrary");
static_assert(sizeof(UPartyMemberFunctionLibrary) == 0x000030, "Wrong size on UPartyMemberFunctionLibrary");

// Class DarwinGame.UISaveLoadFacePanelBase
// 0x00B8 (0x0548 - 0x0490)
class UUISaveLoadFacePanelBase : public UDarwinUserWidget
{
public:
	TSoftObjectPtr<class UTexture2D>              MonsterMask;                                       // 0x0490(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              CharacterMask;                                     // 0x04B8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FST_MonsterIconParts                   MonsterIconParts;                                  // 0x04E0(0x0050)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutoTextBlock*                         TextLevel;                                         // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadFacePanelBase">();
	}
	static class UUISaveLoadFacePanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadFacePanelBase>();
	}
};
static_assert(alignof(UUISaveLoadFacePanelBase) == 0x000008, "Wrong alignment on UUISaveLoadFacePanelBase");
static_assert(sizeof(UUISaveLoadFacePanelBase) == 0x000548, "Wrong size on UUISaveLoadFacePanelBase");
static_assert(offsetof(UUISaveLoadFacePanelBase, MonsterMask) == 0x000490, "Member 'UUISaveLoadFacePanelBase::MonsterMask' has a wrong offset!");
static_assert(offsetof(UUISaveLoadFacePanelBase, CharacterMask) == 0x0004B8, "Member 'UUISaveLoadFacePanelBase::CharacterMask' has a wrong offset!");
static_assert(offsetof(UUISaveLoadFacePanelBase, MonsterIconParts) == 0x0004E0, "Member 'UUISaveLoadFacePanelBase::MonsterIconParts' has a wrong offset!");
static_assert(offsetof(UUISaveLoadFacePanelBase, TextLevel) == 0x000540, "Member 'UUISaveLoadFacePanelBase::TextLevel' has a wrong offset!");

// Class DarwinGame.UILoadFacePanel
// 0x0000 (0x0548 - 0x0548)
class UUILoadFacePanel : public UUISaveLoadFacePanelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadFacePanel">();
	}
	static class UUILoadFacePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoadFacePanel>();
	}
};
static_assert(alignof(UUILoadFacePanel) == 0x000008, "Wrong alignment on UUILoadFacePanel");
static_assert(sizeof(UUILoadFacePanel) == 0x000548, "Wrong size on UUILoadFacePanel");

// Class DarwinGame.UIAppraiseSequence
// 0x0060 (0x04F0 - 0x0490)
class UUIAppraiseSequence final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinSceneCaptureImage*               CaptureImage;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWhiteFade*                           SkipFadePanel;                                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILineFade_00*                         FadePanel;                                         // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         InSe;                                              // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x30];                                     // 0x04C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyFlashEffect();
	void EndFlashSequencer();
	void FadeOut();
	class USceneCaptureComponent2D* GetCaptureComponent();
	bool IsFlash(int32 Index_0);
	bool IsFly(int32 Index_0);
	void QualityUpPopUp();
	void SetDefaultMaterial();
	void SpawnFlashEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraiseSequence">();
	}
	static class UUIAppraiseSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraiseSequence>();
	}
};
static_assert(alignof(UUIAppraiseSequence) == 0x000008, "Wrong alignment on UUIAppraiseSequence");
static_assert(sizeof(UUIAppraiseSequence) == 0x0004F0, "Wrong size on UUIAppraiseSequence");
static_assert(offsetof(UUIAppraiseSequence, CaptureImage) == 0x0004A0, "Member 'UUIAppraiseSequence::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIAppraiseSequence, SkipFadePanel) == 0x0004A8, "Member 'UUIAppraiseSequence::SkipFadePanel' has a wrong offset!");
static_assert(offsetof(UUIAppraiseSequence, FadePanel) == 0x0004B0, "Member 'UUIAppraiseSequence::FadePanel' has a wrong offset!");
static_assert(offsetof(UUIAppraiseSequence, InSe) == 0x0004B8, "Member 'UUIAppraiseSequence::InSe' has a wrong offset!");

// Class DarwinGame.MonsNotifyState_BossBoostingCheck
// 0x0010 (0x0048 - 0x0038)
class UMonsNotifyState_BossBoostingCheck final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossBoostingCheck">();
	}
	static class UMonsNotifyState_BossBoostingCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossBoostingCheck>();
	}
};
static_assert(alignof(UMonsNotifyState_BossBoostingCheck) == 0x000008, "Wrong alignment on UMonsNotifyState_BossBoostingCheck");
static_assert(sizeof(UMonsNotifyState_BossBoostingCheck) == 0x000048, "Wrong size on UMonsNotifyState_BossBoostingCheck");

// Class DarwinGame.MonsNotifyState_BossCombatDuring
// 0x0010 (0x0048 - 0x0038)
class UMonsNotifyState_BossCombatDuring final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossCombatDuring">();
	}
	static class UMonsNotifyState_BossCombatDuring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossCombatDuring>();
	}
};
static_assert(alignof(UMonsNotifyState_BossCombatDuring) == 0x000008, "Wrong alignment on UMonsNotifyState_BossCombatDuring");
static_assert(sizeof(UMonsNotifyState_BossCombatDuring) == 0x000048, "Wrong size on UMonsNotifyState_BossCombatDuring");

// Class DarwinGame.MonsNotifyState_BossCombatState
// 0x0008 (0x0040 - 0x0038)
class UMonsNotifyState_BossCombatState final : public UMonsNotifyStateBase
{
public:
	EMonsterCombatState                           mCombatState;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossCombatState">();
	}
	static class UMonsNotifyState_BossCombatState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossCombatState>();
	}
};
static_assert(alignof(UMonsNotifyState_BossCombatState) == 0x000008, "Wrong alignment on UMonsNotifyState_BossCombatState");
static_assert(sizeof(UMonsNotifyState_BossCombatState) == 0x000040, "Wrong size on UMonsNotifyState_BossCombatState");
static_assert(offsetof(UMonsNotifyState_BossCombatState, mCombatState) == 0x000038, "Member 'UMonsNotifyState_BossCombatState::mCombatState' has a wrong offset!");

// Class DarwinGame.MonsNotifyState_BossExposeWeaknesses
// 0x0008 (0x0040 - 0x0038)
class UMonsNotifyState_BossExposeWeaknesses final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossExposeWeaknesses">();
	}
	static class UMonsNotifyState_BossExposeWeaknesses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossExposeWeaknesses>();
	}
};
static_assert(alignof(UMonsNotifyState_BossExposeWeaknesses) == 0x000008, "Wrong alignment on UMonsNotifyState_BossExposeWeaknesses");
static_assert(sizeof(UMonsNotifyState_BossExposeWeaknesses) == 0x000040, "Wrong size on UMonsNotifyState_BossExposeWeaknesses");

// Class DarwinGame.NavLinkProxyEx
// 0x0008 (0x0280 - 0x0278)
class ANavLinkProxyEx final : public ANavLinkProxy
{
public:
	ENavLinkThroughType                           ThroughType;                                       // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SmartLinkReached(class AActor* Actor, const struct FVector& destPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxyEx">();
	}
	static class ANavLinkProxyEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxyEx>();
	}
};
static_assert(alignof(ANavLinkProxyEx) == 0x000008, "Wrong alignment on ANavLinkProxyEx");
static_assert(sizeof(ANavLinkProxyEx) == 0x000280, "Wrong size on ANavLinkProxyEx");
static_assert(offsetof(ANavLinkProxyEx, ThroughType) == 0x000278, "Member 'ANavLinkProxyEx::ThroughType' has a wrong offset!");

// Class DarwinGame.MonsNotifyState_BossPossessed
// 0x0008 (0x0040 - 0x0038)
class UMonsNotifyState_BossPossessed final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossPossessed">();
	}
	static class UMonsNotifyState_BossPossessed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossPossessed>();
	}
};
static_assert(alignof(UMonsNotifyState_BossPossessed) == 0x000008, "Wrong alignment on UMonsNotifyState_BossPossessed");
static_assert(sizeof(UMonsNotifyState_BossPossessed) == 0x000040, "Wrong size on UMonsNotifyState_BossPossessed");

// Class DarwinGame.MonsNotifyState_BossPossessFlying
// 0x0020 (0x0058 - 0x0038)
class UMonsNotifyState_BossPossessFlying final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossPossessFlying">();
	}
	static class UMonsNotifyState_BossPossessFlying* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossPossessFlying>();
	}
};
static_assert(alignof(UMonsNotifyState_BossPossessFlying) == 0x000008, "Wrong alignment on UMonsNotifyState_BossPossessFlying");
static_assert(sizeof(UMonsNotifyState_BossPossessFlying) == 0x000058, "Wrong size on UMonsNotifyState_BossPossessFlying");

// Class DarwinGame.MonsNotifyState_BossRetarget
// 0x0030 (0x0068 - 0x0038)
class UMonsNotifyState_BossRetarget final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossRetarget">();
	}
	static class UMonsNotifyState_BossRetarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossRetarget>();
	}
};
static_assert(alignof(UMonsNotifyState_BossRetarget) == 0x000008, "Wrong alignment on UMonsNotifyState_BossRetarget");
static_assert(sizeof(UMonsNotifyState_BossRetarget) == 0x000068, "Wrong size on UMonsNotifyState_BossRetarget");

// Class DarwinGame.MonsNotifyState_BossRotateInsightTarget
// 0x0028 (0x0060 - 0x0038)
class UMonsNotifyState_BossRotateInsightTarget final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossRotateInsightTarget">();
	}
	static class UMonsNotifyState_BossRotateInsightTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossRotateInsightTarget>();
	}
};
static_assert(alignof(UMonsNotifyState_BossRotateInsightTarget) == 0x000008, "Wrong alignment on UMonsNotifyState_BossRotateInsightTarget");
static_assert(sizeof(UMonsNotifyState_BossRotateInsightTarget) == 0x000060, "Wrong size on UMonsNotifyState_BossRotateInsightTarget");

// Class DarwinGame.MonsNotifyState_BossSelfhalm
// 0x0018 (0x0050 - 0x0038)
class UMonsNotifyState_BossSelfhalm final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossSelfhalm">();
	}
	static class UMonsNotifyState_BossSelfhalm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossSelfhalm>();
	}
};
static_assert(alignof(UMonsNotifyState_BossSelfhalm) == 0x000008, "Wrong alignment on UMonsNotifyState_BossSelfhalm");
static_assert(sizeof(UMonsNotifyState_BossSelfhalm) == 0x000050, "Wrong size on UMonsNotifyState_BossSelfhalm");

// Class DarwinGame.MonsNotifyState_BossStatueDeadWait
// 0x0018 (0x0050 - 0x0038)
class UMonsNotifyState_BossStatueDeadWait final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossStatueDeadWait">();
	}
	static class UMonsNotifyState_BossStatueDeadWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossStatueDeadWait>();
	}
};
static_assert(alignof(UMonsNotifyState_BossStatueDeadWait) == 0x000008, "Wrong alignment on UMonsNotifyState_BossStatueDeadWait");
static_assert(sizeof(UMonsNotifyState_BossStatueDeadWait) == 0x000050, "Wrong size on UMonsNotifyState_BossStatueDeadWait");

// Class DarwinGame.MonsNotifyState_BossStatueDestroy
// 0x0008 (0x0040 - 0x0038)
class UMonsNotifyState_BossStatueDestroy final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossStatueDestroy">();
	}
	static class UMonsNotifyState_BossStatueDestroy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossStatueDestroy>();
	}
};
static_assert(alignof(UMonsNotifyState_BossStatueDestroy) == 0x000008, "Wrong alignment on UMonsNotifyState_BossStatueDestroy");
static_assert(sizeof(UMonsNotifyState_BossStatueDestroy) == 0x000040, "Wrong size on UMonsNotifyState_BossStatueDestroy");

// Class DarwinGame.MonsNotifyState_BossTargetInRange
// 0x0048 (0x0080 - 0x0038)
class UMonsNotifyState_BossTargetInRange final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossTargetInRange">();
	}
	static class UMonsNotifyState_BossTargetInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossTargetInRange>();
	}
};
static_assert(alignof(UMonsNotifyState_BossTargetInRange) == 0x000008, "Wrong alignment on UMonsNotifyState_BossTargetInRange");
static_assert(sizeof(UMonsNotifyState_BossTargetInRange) == 0x000080, "Wrong size on UMonsNotifyState_BossTargetInRange");

// Class DarwinGame.NetworkTravellerEvent
// 0x0010 (0x02B8 - 0x02A8)
class ANetworkTravellerEvent final : public AScriptEventBase
{
public:
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConnectNetworkTravelIine(bool bRandamTraverller);
	void FadeIn(int32 NextSectionNum);
	bool IsPlayNotArtifactReplicaReaction(bool IsAutoTraveller);
	void OpenAboutReplicaDialog();
	void OpenNetoworkTravellerUI(int32 NextSectionNum, bool bRandamTraverller);
	void PlayMonsterVoice(bool IsAutoTraveller);
	void PlaySoundLeaveTravellerMsgWindowOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkTravellerEvent">();
	}
	static class ANetworkTravellerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANetworkTravellerEvent>();
	}
};
static_assert(alignof(ANetworkTravellerEvent) == 0x000008, "Wrong alignment on ANetworkTravellerEvent");
static_assert(sizeof(ANetworkTravellerEvent) == 0x0002B8, "Wrong size on ANetworkTravellerEvent");

// Class DarwinGame.MonsNotifyState_BossUIRestart
// 0x0018 (0x0050 - 0x0038)
class UMonsNotifyState_BossUIRestart final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_BossUIRestart">();
	}
	static class UMonsNotifyState_BossUIRestart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_BossUIRestart>();
	}
};
static_assert(alignof(UMonsNotifyState_BossUIRestart) == 0x000008, "Wrong alignment on UMonsNotifyState_BossUIRestart");
static_assert(sizeof(UMonsNotifyState_BossUIRestart) == 0x000050, "Wrong size on UMonsNotifyState_BossUIRestart");

// Class DarwinGame.MonsNotifyState_GuideSysLog
// 0x0078 (0x00B0 - 0x0038)
class UMonsNotifyState_GuideSysLog final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_GuideSysLog">();
	}
	static class UMonsNotifyState_GuideSysLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_GuideSysLog>();
	}
};
static_assert(alignof(UMonsNotifyState_GuideSysLog) == 0x000008, "Wrong alignment on UMonsNotifyState_GuideSysLog");
static_assert(sizeof(UMonsNotifyState_GuideSysLog) == 0x0000B0, "Wrong size on UMonsNotifyState_GuideSysLog");

// Class DarwinGame.UIItemmenu_Efficacy
// 0x0010 (0x04A0 - 0x0490)
class UUIItemmenu_Efficacy final : public UDarwinUserWidget
{
public:
	class UImage*                                 IconEffect;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextEffect;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_Efficacy">();
	}
	static class UUIItemmenu_Efficacy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_Efficacy>();
	}
};
static_assert(alignof(UUIItemmenu_Efficacy) == 0x000008, "Wrong alignment on UUIItemmenu_Efficacy");
static_assert(sizeof(UUIItemmenu_Efficacy) == 0x0004A0, "Wrong size on UUIItemmenu_Efficacy");
static_assert(offsetof(UUIItemmenu_Efficacy, IconEffect) == 0x000490, "Member 'UUIItemmenu_Efficacy::IconEffect' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_Efficacy, TextEffect) == 0x000498, "Member 'UUIItemmenu_Efficacy::TextEffect' has a wrong offset!");

// Class DarwinGame.MonsNotifyState_IgnoreCollision
// 0x0010 (0x0048 - 0x0038)
class UMonsNotifyState_IgnoreCollision final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_IgnoreCollision">();
	}
	static class UMonsNotifyState_IgnoreCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_IgnoreCollision>();
	}
};
static_assert(alignof(UMonsNotifyState_IgnoreCollision) == 0x000008, "Wrong alignment on UMonsNotifyState_IgnoreCollision");
static_assert(sizeof(UMonsNotifyState_IgnoreCollision) == 0x000048, "Wrong size on UMonsNotifyState_IgnoreCollision");

// Class DarwinGame.MonsNotifyState_MonsterCheckFloorChangeSection
// 0x0030 (0x0068 - 0x0038)
class UMonsNotifyState_MonsterCheckFloorChangeSection final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_MonsterCheckFloorChangeSection">();
	}
	static class UMonsNotifyState_MonsterCheckFloorChangeSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_MonsterCheckFloorChangeSection>();
	}
};
static_assert(alignof(UMonsNotifyState_MonsterCheckFloorChangeSection) == 0x000008, "Wrong alignment on UMonsNotifyState_MonsterCheckFloorChangeSection");
static_assert(sizeof(UMonsNotifyState_MonsterCheckFloorChangeSection) == 0x000068, "Wrong size on UMonsNotifyState_MonsterCheckFloorChangeSection");

// Class DarwinGame.NPCAIController
// 0x0020 (0x0350 - 0x0330)
class ANPCAIController : public AAIController
{
public:
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mPlayerKeyName;                                    // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          mBehaviorTree;                                     // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AGPACharacter* GetAttackTarget();
	float GetFloat(class FName Key);
	int32 GetInt(class FName Key);
	ENPCAiType GetNPCAiType(class FName Key);
	struct FRotator GetRotator(class FName Key);
	class AGPACharacter* GetTraceTarget();
	struct FVector GetVector(class FName Key);
	void NPCAiInit(const class ACharacter* NPCActor);
	void SetAttackTarget(class APawn* Target);
	void SetFloat(class FName Key, float Value);
	void SetInt(class FName Key, int32 Value);
	void SetNPCAiType(class FName Key, ENPCAiType Value);
	void SetRotator(class FName Key, const struct FRotator& Rotator);
	void SetTarget(class FName Key, class APawn* Target);
	void SetTraceTarget(class APawn* Target);
	void SetVector(class FName Key, const struct FVector& Vector);

	class APawn* GetTarget(class FName Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCAIController">();
	}
	static class ANPCAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCAIController>();
	}
};
static_assert(alignof(ANPCAIController) == 0x000008, "Wrong alignment on ANPCAIController");
static_assert(sizeof(ANPCAIController) == 0x000350, "Wrong size on ANPCAIController");
static_assert(offsetof(ANPCAIController, mPlayerKeyName) == 0x000340, "Member 'ANPCAIController::mPlayerKeyName' has a wrong offset!");
static_assert(offsetof(ANPCAIController, mBehaviorTree) == 0x000348, "Member 'ANPCAIController::mBehaviorTree' has a wrong offset!");

// Class DarwinGame.UIItemmenu_ArtifactIcon
// 0x0050 (0x04E0 - 0x0490)
class UUIItemmenu_ArtifactIcon final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_ArtifactIcon">();
	}
	static class UUIItemmenu_ArtifactIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_ArtifactIcon>();
	}
};
static_assert(alignof(UUIItemmenu_ArtifactIcon) == 0x000008, "Wrong alignment on UUIItemmenu_ArtifactIcon");
static_assert(sizeof(UUIItemmenu_ArtifactIcon) == 0x0004E0, "Wrong size on UUIItemmenu_ArtifactIcon");

// Class DarwinGame.MonsNotifyState_MonsterRotateInsightTarget
// 0x0028 (0x0060 - 0x0038)
class UMonsNotifyState_MonsterRotateInsightTarget final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_MonsterRotateInsightTarget">();
	}
	static class UMonsNotifyState_MonsterRotateInsightTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_MonsterRotateInsightTarget>();
	}
};
static_assert(alignof(UMonsNotifyState_MonsterRotateInsightTarget) == 0x000008, "Wrong alignment on UMonsNotifyState_MonsterRotateInsightTarget");
static_assert(sizeof(UMonsNotifyState_MonsterRotateInsightTarget) == 0x000060, "Wrong size on UMonsNotifyState_MonsterRotateInsightTarget");

// Class DarwinGame.MonsNotifyState_TargetInRangeFin
// 0x0010 (0x0048 - 0x0038)
class UMonsNotifyState_TargetInRangeFin final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_TargetInRangeFin">();
	}
	static class UMonsNotifyState_TargetInRangeFin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_TargetInRangeFin>();
	}
};
static_assert(alignof(UMonsNotifyState_TargetInRangeFin) == 0x000008, "Wrong alignment on UMonsNotifyState_TargetInRangeFin");
static_assert(sizeof(UMonsNotifyState_TargetInRangeFin) == 0x000048, "Wrong size on UMonsNotifyState_TargetInRangeFin");

// Class DarwinGame.MonsNotifyState_MonsterTimeCheckAttack
// 0x0038 (0x0070 - 0x0038)
class UMonsNotifyState_MonsterTimeCheckAttack final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_MonsterTimeCheckAttack">();
	}
	static class UMonsNotifyState_MonsterTimeCheckAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_MonsterTimeCheckAttack>();
	}
};
static_assert(alignof(UMonsNotifyState_MonsterTimeCheckAttack) == 0x000008, "Wrong alignment on UMonsNotifyState_MonsterTimeCheckAttack");
static_assert(sizeof(UMonsNotifyState_MonsterTimeCheckAttack) == 0x000070, "Wrong size on UMonsNotifyState_MonsterTimeCheckAttack");

// Class DarwinGame.MonsNotifyState_RotateToTargetWithLocationOffset
// 0x0068 (0x00A0 - 0x0038)
class UMonsNotifyState_RotateToTargetWithLocationOffset final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_RotateToTargetWithLocationOffset">();
	}
	static class UMonsNotifyState_RotateToTargetWithLocationOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_RotateToTargetWithLocationOffset>();
	}
};
static_assert(alignof(UMonsNotifyState_RotateToTargetWithLocationOffset) == 0x000008, "Wrong alignment on UMonsNotifyState_RotateToTargetWithLocationOffset");
static_assert(sizeof(UMonsNotifyState_RotateToTargetWithLocationOffset) == 0x0000A0, "Wrong size on UMonsNotifyState_RotateToTargetWithLocationOffset");

// Class DarwinGame.MonsNotifyState_TimeCheckMultipleAttack
// 0x0040 (0x0078 - 0x0038)
class UMonsNotifyState_TimeCheckMultipleAttack final : public UMonsNotifyStateBase
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyBegin(const struct FST_NotifyBegin& fst);
	void NotifyEnd(const struct FST_NotifyBase& fst);
	void NotifyTick(const struct FST_NotifyBase& fst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsNotifyState_TimeCheckMultipleAttack">();
	}
	static class UMonsNotifyState_TimeCheckMultipleAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsNotifyState_TimeCheckMultipleAttack>();
	}
};
static_assert(alignof(UMonsNotifyState_TimeCheckMultipleAttack) == 0x000008, "Wrong alignment on UMonsNotifyState_TimeCheckMultipleAttack");
static_assert(sizeof(UMonsNotifyState_TimeCheckMultipleAttack) == 0x000078, "Wrong size on UMonsNotifyState_TimeCheckMultipleAttack");

// Class DarwinGame.UIItemmenu_03_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIItemmenu_03_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_03_Root">();
	}
	static class UUIItemmenu_03_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_03_Root>();
	}
};
static_assert(alignof(UUIItemmenu_03_Root) == 0x000008, "Wrong alignment on UUIItemmenu_03_Root");
static_assert(sizeof(UUIItemmenu_03_Root) == 0x0004D8, "Wrong size on UUIItemmenu_03_Root");

// Class DarwinGame.MonsterActionCycleDataTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterActionCycleDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterActionCycleDataTable">();
	}
	static class UMonsterActionCycleDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterActionCycleDataTable>();
	}
};
static_assert(alignof(UMonsterActionCycleDataTable) == 0x000008, "Wrong alignment on UMonsterActionCycleDataTable");
static_assert(sizeof(UMonsterActionCycleDataTable) == 0x000030, "Wrong size on UMonsterActionCycleDataTable");

// Class DarwinGame.MonsterAddFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterAddFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterAddFunctionLibrary">();
	}
	static class UMonsterAddFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterAddFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterAddFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterAddFunctionLibrary");
static_assert(sizeof(UMonsterAddFunctionLibrary) == 0x000030, "Wrong size on UMonsterAddFunctionLibrary");

// Class DarwinGame.PointEnvSound
// 0x0098 (0x0170 - 0x00D8)
class UPointEnvSound : public UPointEnvironmentSoundBase
{
public:
	struct FEnvironmentSoundCollisionData         mCollisionData;                                    // 0x00D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<EEnvironmentSoundPatternID, struct FTimesEnvironmentSoundData> mSoundDataList;                                    // 0x0108(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UShapeComponent*                        mCollision;                                        // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         mAtom;                                             // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSoundInsulation;                                  // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSoundActiveRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSoundActiveRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointEnvSound">();
	}
	static class UPointEnvSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointEnvSound>();
	}
};
static_assert(alignof(UPointEnvSound) == 0x000008, "Wrong alignment on UPointEnvSound");
static_assert(sizeof(UPointEnvSound) == 0x000170, "Wrong size on UPointEnvSound");
static_assert(offsetof(UPointEnvSound, mCollisionData) == 0x0000D8, "Member 'UPointEnvSound::mCollisionData' has a wrong offset!");
static_assert(offsetof(UPointEnvSound, mSoundDataList) == 0x000108, "Member 'UPointEnvSound::mSoundDataList' has a wrong offset!");
static_assert(offsetof(UPointEnvSound, mCollision) == 0x000158, "Member 'UPointEnvSound::mCollision' has a wrong offset!");
static_assert(offsetof(UPointEnvSound, mAtom) == 0x000160, "Member 'UPointEnvSound::mAtom' has a wrong offset!");
static_assert(offsetof(UPointEnvSound, bSoundInsulation) == 0x000168, "Member 'UPointEnvSound::bSoundInsulation' has a wrong offset!");

// Class DarwinGame.MonsterAIController
// 0x0020 (0x0350 - 0x0330)
class AMonsterAIController : public AAIController
{
public:
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mPlayerKeyName;                                    // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          mBehaviorTree;                                     // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AGPACharacter* GetAttackTarget();
	class AGPACharacter* GetTraceTarget();
	void SetAttackTarget(class APawn* Target);
	void SetTraceTarget(class APawn* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterAIController">();
	}
	static class AMonsterAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterAIController>();
	}
};
static_assert(alignof(AMonsterAIController) == 0x000008, "Wrong alignment on AMonsterAIController");
static_assert(sizeof(AMonsterAIController) == 0x000350, "Wrong size on AMonsterAIController");
static_assert(offsetof(AMonsterAIController, mPlayerKeyName) == 0x000340, "Member 'AMonsterAIController::mPlayerKeyName' has a wrong offset!");
static_assert(offsetof(AMonsterAIController, mBehaviorTree) == 0x000348, "Member 'AMonsterAIController::mBehaviorTree' has a wrong offset!");

// Class DarwinGame.MonsterBattleAI
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAI final : public UMonsterBattleAIBase
{
public:
	void DeriVateActionDecision(class AMonster* Monster, class FName ID);
	void LeaveRequest(class AMonster* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAI">();
	}
	static class UMonsterBattleAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAI>();
	}
};
static_assert(alignof(UMonsterBattleAI) == 0x000008, "Wrong alignment on UMonsterBattleAI");
static_assert(sizeof(UMonsterBattleAI) == 0x000030, "Wrong size on UMonsterBattleAI");

// Class DarwinGame.PulloutFlag
// 0x0008 (0x02C0 - 0x02B8)
class APulloutFlag final : public AFlagBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PulloutFlag">();
	}
	static class APulloutFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<APulloutFlag>();
	}
};
static_assert(alignof(APulloutFlag) == 0x000008, "Wrong alignment on APulloutFlag");
static_assert(sizeof(APulloutFlag) == 0x0002C0, "Wrong size on APulloutFlag");

// Class DarwinGame.MonsterBattleAIActionConditionCheckFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIActionConditionCheckFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIActionConditionCheckFunctionLibrary">();
	}
	static class UMonsterBattleAIActionConditionCheckFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIActionConditionCheckFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIActionConditionCheckFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIActionConditionCheckFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIActionConditionCheckFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIActionConditionCheckFunctionLibrary");

// Class DarwinGame.MonsterBattleAIActionCycleFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIActionCycleFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIActionCycleFunctionLibrary">();
	}
	static class UMonsterBattleAIActionCycleFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIActionCycleFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIActionCycleFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIActionCycleFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIActionCycleFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIActionCycleFunctionLibrary");

// Class DarwinGame.UIMenu_WinSort
// 0x0068 (0x0638 - 0x05D0)
class UUIMenu_WinSort : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutoTextBlock*                         HeaderTitleText;                                   // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIItemmenu_SortIconChoice*>     mSortIcons;                                        // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIScrollMenuItemBase*                  ChoiceButton;                                      // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x38];                                     // 0x0600(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenu_WinSort">();
	}
	static class UUIMenu_WinSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenu_WinSort>();
	}
};
static_assert(alignof(UUIMenu_WinSort) == 0x000008, "Wrong alignment on UUIMenu_WinSort");
static_assert(sizeof(UUIMenu_WinSort) == 0x000638, "Wrong size on UUIMenu_WinSort");
static_assert(offsetof(UUIMenu_WinSort, HeaderTitleText) == 0x0005E0, "Member 'UUIMenu_WinSort::HeaderTitleText' has a wrong offset!");
static_assert(offsetof(UUIMenu_WinSort, mSortIcons) == 0x0005E8, "Member 'UUIMenu_WinSort::mSortIcons' has a wrong offset!");
static_assert(offsetof(UUIMenu_WinSort, ChoiceButton) == 0x0005F8, "Member 'UUIMenu_WinSort::ChoiceButton' has a wrong offset!");

// Class DarwinGame.MonsterBattleAIActionFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIActionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIActionFunctionLibrary">();
	}
	static class UMonsterBattleAIActionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIActionFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIActionFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIActionFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIActionFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIActionFunctionLibrary");

// Class DarwinGame.MonsterBattleAIActionScoreFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIActionScoreFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIActionScoreFunctionLibrary">();
	}
	static class UMonsterBattleAIActionScoreFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIActionScoreFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIActionScoreFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIActionScoreFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIActionScoreFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIActionScoreFunctionLibrary");

// Class DarwinGame.QuestDestinationRectBase
// 0x0028 (0x0250 - 0x0228)
class AQuestDestinationRectBase : public AActor
{
public:
	class FName                                   QuestID;                                           // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Scene;                                             // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComp;                                           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComp;                                       // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereComp;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestDestinationRectBase">();
	}
	static class AQuestDestinationRectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AQuestDestinationRectBase>();
	}
};
static_assert(alignof(AQuestDestinationRectBase) == 0x000008, "Wrong alignment on AQuestDestinationRectBase");
static_assert(sizeof(AQuestDestinationRectBase) == 0x000250, "Wrong size on AQuestDestinationRectBase");
static_assert(offsetof(AQuestDestinationRectBase, QuestID) == 0x000228, "Member 'AQuestDestinationRectBase::QuestID' has a wrong offset!");
static_assert(offsetof(AQuestDestinationRectBase, Scene) == 0x000230, "Member 'AQuestDestinationRectBase::Scene' has a wrong offset!");
static_assert(offsetof(AQuestDestinationRectBase, BoxComp) == 0x000238, "Member 'AQuestDestinationRectBase::BoxComp' has a wrong offset!");
static_assert(offsetof(AQuestDestinationRectBase, CapsuleComp) == 0x000240, "Member 'AQuestDestinationRectBase::CapsuleComp' has a wrong offset!");
static_assert(offsetof(AQuestDestinationRectBase, SphereComp) == 0x000248, "Member 'AQuestDestinationRectBase::SphereComp' has a wrong offset!");

// Class DarwinGame.UIMapPlaceBase
// 0x0008 (0x0498 - 0x0490)
class UUIMapPlaceBase : public UDarwinUserWidget
{
public:
	class UTextBlock*                             LandNameWidget;                                    // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapPlaceBase">();
	}
	static class UUIMapPlaceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapPlaceBase>();
	}
};
static_assert(alignof(UUIMapPlaceBase) == 0x000008, "Wrong alignment on UUIMapPlaceBase");
static_assert(sizeof(UUIMapPlaceBase) == 0x000498, "Wrong size on UUIMapPlaceBase");
static_assert(offsetof(UUIMapPlaceBase, LandNameWidget) == 0x000490, "Member 'UUIMapPlaceBase::LandNameWidget' has a wrong offset!");

// Class DarwinGame.MonsterBattleAIBackStepFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIBackStepFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIBackStepFunctionLibrary">();
	}
	static class UMonsterBattleAIBackStepFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIBackStepFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIBackStepFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIBackStepFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIBackStepFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIBackStepFunctionLibrary");

// Class DarwinGame.MonsterBattleAIBehaviorFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIBehaviorFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIBehaviorFunctionLibrary">();
	}
	static class UMonsterBattleAIBehaviorFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIBehaviorFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIBehaviorFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIBehaviorFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIBehaviorFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIBehaviorFunctionLibrary");

// Class DarwinGame.MonsterBattleAIDecideActionFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIDecideActionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIDecideActionFunctionLibrary">();
	}
	static class UMonsterBattleAIDecideActionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIDecideActionFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIDecideActionFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIDecideActionFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIDecideActionFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIDecideActionFunctionLibrary");

// Class DarwinGame.UIItemmenu_SatisfactGauge
// 0x0010 (0x04A0 - 0x0490)
class UUIItemmenu_SatisfactGauge : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_SatisfactGauge">();
	}
	static class UUIItemmenu_SatisfactGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_SatisfactGauge>();
	}
};
static_assert(alignof(UUIItemmenu_SatisfactGauge) == 0x000008, "Wrong alignment on UUIItemmenu_SatisfactGauge");
static_assert(sizeof(UUIItemmenu_SatisfactGauge) == 0x0004A0, "Wrong size on UUIItemmenu_SatisfactGauge");

// Class DarwinGame.MonsterBattleAISideStepFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAISideStepFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAISideStepFunctionLibrary">();
	}
	static class UMonsterBattleAISideStepFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAISideStepFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAISideStepFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAISideStepFunctionLibrary");
static_assert(sizeof(UMonsterBattleAISideStepFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAISideStepFunctionLibrary");

// Class DarwinGame.MonsterBattleAIStepCommonFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBattleAIStepCommonFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBattleAIStepCommonFunctionLibrary">();
	}
	static class UMonsterBattleAIStepCommonFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBattleAIStepCommonFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBattleAIStepCommonFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBattleAIStepCommonFunctionLibrary");
static_assert(sizeof(UMonsterBattleAIStepCommonFunctionLibrary) == 0x000030, "Wrong size on UMonsterBattleAIStepCommonFunctionLibrary");

// Class DarwinGame.TagTextRubyDataAsset
// 0x0050 (0x0088 - 0x0038)
class UTagTextRubyDataAsset final : public UDataAsset
{
public:
	TMap<class FString, class FString>            mDataList;                                         // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TagTextRubyDataAsset">();
	}
	static class UTagTextRubyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTagTextRubyDataAsset>();
	}
};
static_assert(alignof(UTagTextRubyDataAsset) == 0x000008, "Wrong alignment on UTagTextRubyDataAsset");
static_assert(sizeof(UTagTextRubyDataAsset) == 0x000088, "Wrong size on UTagTextRubyDataAsset");
static_assert(offsetof(UTagTextRubyDataAsset, mDataList) == 0x000038, "Member 'UTagTextRubyDataAsset::mDataList' has a wrong offset!");

// Class DarwinGame.UIItemmenu_HoldIcon
// 0x0008 (0x0498 - 0x0490)
class UUIItemmenu_HoldIcon : public UDarwinUserWidget
{
public:
	class UTextBlock*                             HoldNumberWidget;                                  // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_HoldIcon">();
	}
	static class UUIItemmenu_HoldIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_HoldIcon>();
	}
};
static_assert(alignof(UUIItemmenu_HoldIcon) == 0x000008, "Wrong alignment on UUIItemmenu_HoldIcon");
static_assert(sizeof(UUIItemmenu_HoldIcon) == 0x000498, "Wrong size on UUIItemmenu_HoldIcon");
static_assert(offsetof(UUIItemmenu_HoldIcon, HoldNumberWidget) == 0x000490, "Member 'UUIItemmenu_HoldIcon::HoldNumberWidget' has a wrong offset!");

// Class DarwinGame.MonsterBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActionCancel(class AMonsterBase* Monster, float blendOut);
	static void ActionCancelAndSetLocationAndRotation(class AMonsterBase* Monster, const struct FVector& Location, const struct FRotator& Rotator);
	static void ActionOneShotMotion(class AGPACharacter* Character, bool isAir);
	static void AddHateDirect(class AMonsterBase* Monster, class AGPACharacter* Target, float hateValue);
	static TArray<bool> GetAcquiredDragonStones();
	static float GetAngleToRotatorAndIsLeft(bool* isLeft, const struct FRotator& object_rot, class AGPACharacter* Observer);
	static float GetAngleToTargetLocation(const struct FVector& object_vec, class AGPACharacter* Observer);
	static float GetAngleToTargetLocationAndIsLeft(bool* isLeft, const struct FVector& object_vec, class AGPACharacter* Observer);
	static EMonsterBossForm GetBossFormFromType(EMonsterBossType Type);
	static class FText GetBossName();
	static EMonsterBossType GetBossType();
	static EMonsterBossType GetBossTypeFromDungeon();
	static class AMonsterBase* GetCamOwner();
	static EPersistentLevelID GetCurrentPersistentLevelID();
	static struct FVector2D GetDir(const struct FVector& object_vec, const struct FVector& observer_vec);
	static void GetFootLocation(struct FVector* Out, const class AGPACharacter* Character);
	static class AMonsterBase* GetGuest();
	static class FName GetGuestID();
	static bool GetIsDungeon();
	static class AMonster* GetMonster(const class APawn* Pawn);
	static class AMonsterBase* GetMonsterBase(const class APawn* Pawn);
	static class AMonsterBoss* GetMonsterBoss(const class APawn* Pawn);
	static void GetMonsterTargettingMe(TArray<class AMonsterBase*>* Array, EMonsterRegisterType Type, class FName Key, const class AMonsterBase* own);
	static class AMonster* GetPartyMonster(int32 partyIndex);
	static int32 GetPartyMonsterUID(int32 partyIndex);
	static void GetRandomPoint(struct FVector* Out, const struct FVector& Center, float Radius, int32 division);
	static float GetRandomWalkRange(const class AMonsterBase* Monster);
	static bool GetSpawnLasboss();
	static class AGPACharacter* GetTarget(EMonsterRegisterType Type, const class AGPACharacter* Character, EMonsterStatus Status, float Distance, bool Player);
	static class AGPACharacter* GetTargetInSight(EMonsterRegisterType Type, const class AGPACharacter* Character, EMonsterStatus Status, float Distance, float Angle, bool Player);
	static int32 GetTerraceWallNum();
	static bool GetTerraceWallOpen();
	static class AGPACharacter* GetTraceTarget(int32 partyIndex);
	static void GuestLeaveRequest();
	static bool IsBossDead();
	static bool IsBossReady();
	static bool IsCloseEnough(const struct FVector& Center, const struct FVector& Location, float Radius);
	static bool IsEnableMakeRandomWalkPointThirdCheck();
	static bool IsFarEnough(const struct FVector& Center, const struct FVector& Location, float Radius);
	static bool IsForceBattlePlaying();
	static bool IsLastBossReady();
	static bool IsLocationHeightTolerance(class AMonsterBase* Owner, class AGPACharacter* Target);
	static bool IsReleaseFlag(class FName KeyName);
	static bool IsSpecialAbility();
	static void Preload(const class FName& KindId);
	static bool Relocation(class AMonsterBase* Monster);
	static void RequestLeaveBySpawnID(class FName SpawnPointID);
	static void RequestLeaveBySpawnPoint(class UEnemySpawnGeneratorBase* spawnPoint);
	static void SetAcquiredDragonStones(const TArray<bool>& arr);
	static void SetBossBattleStartWaiting(bool flg);
	static void SetBossPause(bool Pause, bool visible);
	static void SetBossType(EMonsterBossType Type);
	static void SetBossTypeToDungeon(EMonsterBossType BossType);
	static void SetBossVisible(bool flg);
	static void SetCamOwner(class AMonsterBase* NewOwner);
	static void SetFriendMonsterLocationPlayerAround();
	static void SetHideEffect(bool hide);
	static void SetHideEffectToEffectAndMonsterType(bool hide, EMonsterHideEffect Effect, EMonsterRegisterType MonsterType);
	static void SetHideEffectToMonsterType(bool hide, EMonsterRegisterType MonsterType);
	static void SetHideEffectToType(bool hide, EMonsterHideEffect Effect);
	static void SetIsDungeon(bool flg);
	static void SetLastBossBattleStartWaiting(bool flg);
	static void SetMoveAwayQueryParams(const class AMonsterBase* Monster, float Radius, float Min, float Max);
	static void SetSpawnLasboss(bool flg);
	static void SetWaitTime(const class AMonsterBase* Monster, float Min, float Max);
	static void SpawnGuest(class FName guestid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBlueprintFunctionLibrary">();
	}
	static class UMonsterBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterBlueprintFunctionLibrary");
static_assert(sizeof(UMonsterBlueprintFunctionLibrary) == 0x000030, "Wrong size on UMonsterBlueprintFunctionLibrary");

// Class DarwinGame.MonsterBossAIController
// 0x0000 (0x0350 - 0x0350)
class AMonsterBossAIController final : public AMonsterAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBossAIController">();
	}
	static class AMonsterBossAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterBossAIController>();
	}
};
static_assert(alignof(AMonsterBossAIController) == 0x000008, "Wrong alignment on AMonsterBossAIController");
static_assert(sizeof(AMonsterBossAIController) == 0x000350, "Wrong size on AMonsterBossAIController");

// Class DarwinGame.MonsterBTTaskExecuter
// 0x0090 (0x00C0 - 0x0030)
class UMonsterBTTaskExecuter final : public UObject
{
public:
	class UBTTask_TraceTo*                        mBTTask_TraceTo;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_FormTo*                         mBTTask_FormTo;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_JumpTo*                         mBTTask_JumpTo;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_Relocation*                     mBTTask_Relocation;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_WaitState*                      mBTTask_WaitState;                                 // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_JumpingMoveTo*                  mBTTask_JumpingMoveTo;                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_Warp*                           mBTTask_Warp;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_GazePlayer*                     mBTTask_GazePlayer;                                // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_BackStep*                       mBTTask_BackStep;                                  // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_SideStep*                       mBTTask_SideStep;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_TurnToLocation*                 mBTTask_TurnToLocation;                            // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_TurnToAngle*                    mBTTask_TurnToAngle;                               // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_EmoteWait*                      mBTTask_EmoteWait;                                 // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_ActionCycleGesture*             mBTTask_ActionCycleGesture;                        // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_SearchNearestArtifact*          mBTTask_SearchNearestArtifact;                     // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_PlayMontage*                    mBTTask_PlayMontage;                               // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_SpecialAbilityStart*            mBTTask_SpecialAbilityStart;                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBTTask_SpecialAbilityEnd*              mBTTask_SpecialAbilityEnd;                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AvortTask(class AMonsterBase* Monster, EMonsterBTTask Task);
	bool ExecuteTask(class AMonsterBase* Monster, EMonsterBTTask Task, float DeltaTime);
	void FinishTask(class AMonsterBase* Monster, EMonsterBTTask Task);
	void InitTask(class AMonsterBase* Monster, EMonsterBTTask Task);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterBTTaskExecuter">();
	}
	static class UMonsterBTTaskExecuter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterBTTaskExecuter>();
	}
};
static_assert(alignof(UMonsterBTTaskExecuter) == 0x000008, "Wrong alignment on UMonsterBTTaskExecuter");
static_assert(sizeof(UMonsterBTTaskExecuter) == 0x0000C0, "Wrong size on UMonsterBTTaskExecuter");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_TraceTo) == 0x000030, "Member 'UMonsterBTTaskExecuter::mBTTask_TraceTo' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_FormTo) == 0x000038, "Member 'UMonsterBTTaskExecuter::mBTTask_FormTo' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_JumpTo) == 0x000040, "Member 'UMonsterBTTaskExecuter::mBTTask_JumpTo' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_Relocation) == 0x000048, "Member 'UMonsterBTTaskExecuter::mBTTask_Relocation' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_WaitState) == 0x000050, "Member 'UMonsterBTTaskExecuter::mBTTask_WaitState' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_JumpingMoveTo) == 0x000058, "Member 'UMonsterBTTaskExecuter::mBTTask_JumpingMoveTo' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_Warp) == 0x000060, "Member 'UMonsterBTTaskExecuter::mBTTask_Warp' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_GazePlayer) == 0x000068, "Member 'UMonsterBTTaskExecuter::mBTTask_GazePlayer' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_BackStep) == 0x000070, "Member 'UMonsterBTTaskExecuter::mBTTask_BackStep' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_SideStep) == 0x000078, "Member 'UMonsterBTTaskExecuter::mBTTask_SideStep' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_TurnToLocation) == 0x000080, "Member 'UMonsterBTTaskExecuter::mBTTask_TurnToLocation' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_TurnToAngle) == 0x000088, "Member 'UMonsterBTTaskExecuter::mBTTask_TurnToAngle' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_EmoteWait) == 0x000090, "Member 'UMonsterBTTaskExecuter::mBTTask_EmoteWait' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_ActionCycleGesture) == 0x000098, "Member 'UMonsterBTTaskExecuter::mBTTask_ActionCycleGesture' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_SearchNearestArtifact) == 0x0000A0, "Member 'UMonsterBTTaskExecuter::mBTTask_SearchNearestArtifact' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_PlayMontage) == 0x0000A8, "Member 'UMonsterBTTaskExecuter::mBTTask_PlayMontage' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_SpecialAbilityStart) == 0x0000B0, "Member 'UMonsterBTTaskExecuter::mBTTask_SpecialAbilityStart' has a wrong offset!");
static_assert(offsetof(UMonsterBTTaskExecuter, mBTTask_SpecialAbilityEnd) == 0x0000B8, "Member 'UMonsterBTTaskExecuter::mBTTask_SpecialAbilityEnd' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_StatusChangeBase
// 0x0000 (0x0530 - 0x0530)
class UUIPartyMenu_PM_Panel_StatusChangeBase : public UUIPartyMenu_PM_Panel_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_StatusChangeBase">();
	}
	static class UUIPartyMenu_PM_Panel_StatusChangeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_StatusChangeBase>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_StatusChangeBase) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_StatusChangeBase");
static_assert(sizeof(UUIPartyMenu_PM_Panel_StatusChangeBase) == 0x000530, "Wrong size on UUIPartyMenu_PM_Panel_StatusChangeBase");

// Class DarwinGame.UIPartyMenu_PM_Panel_02
// 0x0020 (0x0550 - 0x0530)
class UUIPartyMenu_PM_Panel_02 : public UUIPartyMenu_PM_Panel_StatusChangeBase
{
public:
	class UUIPartyMenu_PM_Icon_00*                Icon;                                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ScrollBaseText;                                    // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USideScrollTextBlock*                   ScrollText;                                        // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FocusScrollFlag;                                   // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_02">();
	}
	static class UUIPartyMenu_PM_Panel_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_02>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_02) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_02");
static_assert(sizeof(UUIPartyMenu_PM_Panel_02) == 0x000550, "Wrong size on UUIPartyMenu_PM_Panel_02");
static_assert(offsetof(UUIPartyMenu_PM_Panel_02, Icon) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_02::Icon' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Panel_02, ScrollBaseText) == 0x000538, "Member 'UUIPartyMenu_PM_Panel_02::ScrollBaseText' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Panel_02, ScrollText) == 0x000540, "Member 'UUIPartyMenu_PM_Panel_02::ScrollText' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Panel_02, FocusScrollFlag) == 0x000548, "Member 'UUIPartyMenu_PM_Panel_02::FocusScrollFlag' has a wrong offset!");

// Class DarwinGame.UIPanel_CoinAbility
// 0x0000 (0x0550 - 0x0550)
class UUIPanel_CoinAbility : public UUIPartyMenu_PM_Panel_02
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanel_CoinAbility">();
	}
	static class UUIPanel_CoinAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanel_CoinAbility>();
	}
};
static_assert(alignof(UUIPanel_CoinAbility) == 0x000008, "Wrong alignment on UUIPanel_CoinAbility");
static_assert(sizeof(UUIPanel_CoinAbility) == 0x000550, "Wrong size on UUIPanel_CoinAbility");

// Class DarwinGame.MonsterCommonDataTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterCommonDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterCommonDataTable">();
	}
	static class UMonsterCommonDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterCommonDataTable>();
	}
};
static_assert(alignof(UMonsterCommonDataTable) == 0x000008, "Wrong alignment on UMonsterCommonDataTable");
static_assert(sizeof(UMonsterCommonDataTable) == 0x000030, "Wrong size on UMonsterCommonDataTable");

// Class DarwinGame.MonsterCustomEquipmentDataTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterCustomEquipmentDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterCustomEquipmentDataTable">();
	}
	static class UMonsterCustomEquipmentDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterCustomEquipmentDataTable>();
	}
};
static_assert(alignof(UMonsterCustomEquipmentDataTable) == 0x000008, "Wrong alignment on UMonsterCustomEquipmentDataTable");
static_assert(sizeof(UMonsterCustomEquipmentDataTable) == 0x000030, "Wrong size on UMonsterCustomEquipmentDataTable");

// Class DarwinGame.TargetSystemComponent
// 0x00C8 (0x0180 - 0x00B8)
class UTargetSystemComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnTargetFound;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTargetLose;                                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bStart)>   OnAimTrigger;                                      // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bStart)>   OnAimMarkerOnOwnerTrigger;                         // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   actionDetailID;                                    // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Target;                                            // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTargetSystemFilterSetting             Filter;                                            // 0x0110(0x0038)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          IsAiming;                                          // 0x0148(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAimAssist;                                  // 0x0149(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                AimAssistTargets;                                  // 0x0150(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        AimAssistTarget;                                   // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        AutoIgnoreTarget;                                  // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DegreeThresholdForDitheringAlphaOnAim;             // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Aim(bool End);
	void NextTarget(int32 AddValue);
	void ReleaseAimAssist(bool bStateEnd);

	bool CanChangeTarget() const;
	class USceneComponent* GetTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSystemComponent">();
	}
	static class UTargetSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSystemComponent>();
	}
};
static_assert(alignof(UTargetSystemComponent) == 0x000008, "Wrong alignment on UTargetSystemComponent");
static_assert(sizeof(UTargetSystemComponent) == 0x000180, "Wrong size on UTargetSystemComponent");
static_assert(offsetof(UTargetSystemComponent, OnTargetFound) == 0x0000B8, "Member 'UTargetSystemComponent::OnTargetFound' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, OnTargetLose) == 0x0000C8, "Member 'UTargetSystemComponent::OnTargetLose' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, OnAimTrigger) == 0x0000D8, "Member 'UTargetSystemComponent::OnAimTrigger' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, OnAimMarkerOnOwnerTrigger) == 0x0000E8, "Member 'UTargetSystemComponent::OnAimMarkerOnOwnerTrigger' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, actionDetailID) == 0x0000F8, "Member 'UTargetSystemComponent::actionDetailID' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, TickInterval) == 0x000100, "Member 'UTargetSystemComponent::TickInterval' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, Target) == 0x000108, "Member 'UTargetSystemComponent::Target' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, Filter) == 0x000110, "Member 'UTargetSystemComponent::Filter' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, IsAiming) == 0x000148, "Member 'UTargetSystemComponent::IsAiming' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, bEnableAimAssist) == 0x000149, "Member 'UTargetSystemComponent::bEnableAimAssist' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, AimAssistTargets) == 0x000150, "Member 'UTargetSystemComponent::AimAssistTargets' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, AimAssistTarget) == 0x000160, "Member 'UTargetSystemComponent::AimAssistTarget' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, AutoIgnoreTarget) == 0x000168, "Member 'UTargetSystemComponent::AutoIgnoreTarget' has a wrong offset!");
static_assert(offsetof(UTargetSystemComponent, DegreeThresholdForDitheringAlphaOnAim) == 0x000178, "Member 'UTargetSystemComponent::DegreeThresholdForDitheringAlphaOnAim' has a wrong offset!");

// Class DarwinGame.UIOptionSound
// 0x0028 (0x0608 - 0x05E0)
class UUIOptionSound : public UUIOptionScreenSoundBase
{
public:
	TArray<class UUIVolume_01*>                   VolumeButtons;                                     // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUICommonmenu_OptionChoiceBase_Base*> VoiceLanguageButtons;                              // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x8];                                      // 0x0600(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionSound">();
	}
	static class UUIOptionSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionSound>();
	}
};
static_assert(alignof(UUIOptionSound) == 0x000008, "Wrong alignment on UUIOptionSound");
static_assert(sizeof(UUIOptionSound) == 0x000608, "Wrong size on UUIOptionSound");
static_assert(offsetof(UUIOptionSound, VolumeButtons) == 0x0005E0, "Member 'UUIOptionSound::VolumeButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionSound, VoiceLanguageButtons) == 0x0005F0, "Member 'UUIOptionSound::VoiceLanguageButtons' has a wrong offset!");

// Class DarwinGame.MonsterCustomMaterialDataTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterCustomMaterialDataTable final : public UBlueprintFunctionLibrary
{
public:
	static TArray<TSoftObjectPtr<class UMaterialInstance>> GetCustomMaterial(class FName KindId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterCustomMaterialDataTable">();
	}
	static class UMonsterCustomMaterialDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterCustomMaterialDataTable>();
	}
};
static_assert(alignof(UMonsterCustomMaterialDataTable) == 0x000008, "Wrong alignment on UMonsterCustomMaterialDataTable");
static_assert(sizeof(UMonsterCustomMaterialDataTable) == 0x000030, "Wrong size on UMonsterCustomMaterialDataTable");

// Class DarwinGame.MonsterDictSceneCapture
// 0x0030 (0x03B0 - 0x0380)
class AMonsterDictSceneCapture final : public ASceneCaptureCharacter
{
public:
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterDictSceneCapture">();
	}
	static class AMonsterDictSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterDictSceneCapture>();
	}
};
static_assert(alignof(AMonsterDictSceneCapture) == 0x000010, "Wrong alignment on AMonsterDictSceneCapture");
static_assert(sizeof(AMonsterDictSceneCapture) == 0x0003B0, "Wrong size on AMonsterDictSceneCapture");

// Class DarwinGame.MonsterEquipmentWhiteListLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterEquipmentWhiteListLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterEquipmentWhiteListLibrary">();
	}
	static class UMonsterEquipmentWhiteListLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterEquipmentWhiteListLibrary>();
	}
};
static_assert(alignof(UMonsterEquipmentWhiteListLibrary) == 0x000008, "Wrong alignment on UMonsterEquipmentWhiteListLibrary");
static_assert(sizeof(UMonsterEquipmentWhiteListLibrary) == 0x000030, "Wrong size on UMonsterEquipmentWhiteListLibrary");

// Class DarwinGame.RiverBase
// 0x0048 (0x0338 - 0x02F0)
class ARiverBase final : public ASplineMeshObject
{
public:
	TArray<class USphereComponent*>               SphereComps;                                       // 0x02F0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USphereComponent*>               OverlapSphereComps;                                // 0x0300(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionRadius;                                   // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalValue;                                     // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusValue;                                       // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StraightSound;                                     // 0x031C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurveSound;                                        // 0x0324(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurveDistanceRange;                                // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurveDegree;                                       // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RiverBase">();
	}
	static class ARiverBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARiverBase>();
	}
};
static_assert(alignof(ARiverBase) == 0x000008, "Wrong alignment on ARiverBase");
static_assert(sizeof(ARiverBase) == 0x000338, "Wrong size on ARiverBase");
static_assert(offsetof(ARiverBase, SphereComps) == 0x0002F0, "Member 'ARiverBase::SphereComps' has a wrong offset!");
static_assert(offsetof(ARiverBase, OverlapSphereComps) == 0x000300, "Member 'ARiverBase::OverlapSphereComps' has a wrong offset!");
static_assert(offsetof(ARiverBase, CollisionRadius) == 0x000310, "Member 'ARiverBase::CollisionRadius' has a wrong offset!");
static_assert(offsetof(ARiverBase, IntervalValue) == 0x000314, "Member 'ARiverBase::IntervalValue' has a wrong offset!");
static_assert(offsetof(ARiverBase, RadiusValue) == 0x000318, "Member 'ARiverBase::RadiusValue' has a wrong offset!");
static_assert(offsetof(ARiverBase, StraightSound) == 0x00031C, "Member 'ARiverBase::StraightSound' has a wrong offset!");
static_assert(offsetof(ARiverBase, CurveSound) == 0x000324, "Member 'ARiverBase::CurveSound' has a wrong offset!");
static_assert(offsetof(ARiverBase, CurveDistanceRange) == 0x00032C, "Member 'ARiverBase::CurveDistanceRange' has a wrong offset!");
static_assert(offsetof(ARiverBase, CurveDegree) == 0x000330, "Member 'ARiverBase::CurveDegree' has a wrong offset!");

// Class DarwinGame.MonsterFilterFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterFilterFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterFilterFunctionLibrary">();
	}
	static class UMonsterFilterFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterFilterFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterFilterFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterFilterFunctionLibrary");
static_assert(sizeof(UMonsterFilterFunctionLibrary) == 0x000030, "Wrong size on UMonsterFilterFunctionLibrary");

// Class DarwinGame.MonsterInterface
// 0x0000 (0x0030 - 0x0030)
class IMonsterInterface final : public IInterface
{
public:
	void DeactivationService();
	void UpdateService();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterInterface">();
	}
	static class IMonsterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMonsterInterface>();
	}
};
static_assert(alignof(IMonsterInterface) == 0x000008, "Wrong alignment on IMonsterInterface");
static_assert(sizeof(IMonsterInterface) == 0x000030, "Wrong size on IMonsterInterface");

// Class DarwinGame.MonsterKindIdBlackListLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterKindIdBlackListLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterKindIdBlackListLibrary">();
	}
	static class UMonsterKindIdBlackListLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterKindIdBlackListLibrary>();
	}
};
static_assert(alignof(UMonsterKindIdBlackListLibrary) == 0x000008, "Wrong alignment on UMonsterKindIdBlackListLibrary");
static_assert(sizeof(UMonsterKindIdBlackListLibrary) == 0x000030, "Wrong size on UMonsterKindIdBlackListLibrary");

// Class DarwinGame.MonsterManager
// 0x0140 (0x0178 - 0x0038)
class UMonsterManager : public UManagerBase
{
public:
	TMap<EMonsterRegisterType, struct FMembersData> mList;                                             // 0x0038(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class AArtifactObjectBase*                    mPlayerAccessingArtifact;                          // 0x0088(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMonsterBase*>                   InitializingMonsterList;                           // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x78];                                     // 0x0100(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMonsterManager* GetInstance();

	void AddMonster(const class AMonsterBase* Monster, EMonsterRegisterType Type);
	void ChangeBelong(const class AMonster* Monster, EMonsterRegisterType Type);
	void ClearFastTravel();
	void ClearMonsterOfProvocation(EMonsterRegisterType Type);
	void DestroyMonsterByBattleID(class FName BattleID);
	void DestroyMonsterByThoughtType(EMonsterThoughtType ThoughtType);
	void EnqueueRequestSpawnParam(class FName KindId, const struct FCommonSpawnParam& spawnParam);
	EMonsterBossType GetBossDerived();
	EMonsterBossType GetBossType();
	class FName GetFastTravel();
	class AMonsterBase* GetMonsterOfProvocation(EMonsterRegisterType Type);
	TArray<class AMonsterBase*> GetMonsters(EMonsterRegisterType Type);
	TArray<class AMonsterBase*> GetMonstersWithList(const TArray<EMonsterRegisterType>& TypeList);
	bool GetPauseFlag(EMonsterRegisterType Type);
	int32 GetPushBackType();
	void HiddenDeadIcon(bool Flag);
	bool IsBoss(const class AMonsterBase* Monster);
	bool IsEnemy(const class AMonster* Monster);
	bool IsEnemyBase(const class AMonsterBase* Monster);
	bool IsSpecialAbility();
	void NoticeEndRevengeBattle();
	void NoticeStartRevengeBattle(const struct FVector& FlagLocaton, class FName BattleID, int32 Subtract, TDelegate<void(class AMonsterBase* spawned)> begin_func, TDelegate<void(class AMonsterBase* deaded)> end_func);
	void PauseAttributeWithoutBoss();
	void PauseMonster(EMonsterRegisterType Type);
	void PauseMonsterWithoutBoss(bool Logic);
	void Remove(class AMonsterBase* Monster);
	void RemoveAll(EMonsterRegisterType Type);
	void RemoveFromSpawnID(class FName spawn_point_id, EMonsterRegisterType Type);
	void RequestSpawnParameterID(int32 MonsterParameterId, int32 PlaceType, class FName EcologicalAiType, EMonsterRegisterType Type, const struct FVector& Pos, class FName spawn_point_id, const struct FRotator& rot, EEnemySpawnGeneratorType parentType, int32 SpawnPriority, bool IsHighAltitude);
	void ResetTimeScale();
	void ResumeAttributeWithoutBoss();
	void ResumeMonster(EMonsterRegisterType Type);
	void ResumeMonsterWithoutBoss(bool Logic);
	void SetBossDerived(int32 derived);
	void SetBossType(EMonsterBossType Type);
	void SetDistanceCheckSkip(const bool skipFlag);
	void SetFastTravel(class FName ID);
	void SetIsStopUpdateMonsters(bool flg);
	void SetPlayerAccessingArtifact(class AArtifactObjectBase* Artifact);
	void SetPushBackType(int32 Type);
	void SetTimeScale(float Scale);
	void Spawn(class FName KindId, const struct FCommonSpawnParam& spawnParam);

	class AArtifactObjectBase* GetPlayerAccessingArtifact() const;
	bool IsDistanceCheckSkip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterManager">();
	}
	static class UMonsterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterManager>();
	}
};
static_assert(alignof(UMonsterManager) == 0x000008, "Wrong alignment on UMonsterManager");
static_assert(sizeof(UMonsterManager) == 0x000178, "Wrong size on UMonsterManager");
static_assert(offsetof(UMonsterManager, mList) == 0x000038, "Member 'UMonsterManager::mList' has a wrong offset!");
static_assert(offsetof(UMonsterManager, mPlayerAccessingArtifact) == 0x000088, "Member 'UMonsterManager::mPlayerAccessingArtifact' has a wrong offset!");
static_assert(offsetof(UMonsterManager, InitializingMonsterList) == 0x0000F0, "Member 'UMonsterManager::InitializingMonsterList' has a wrong offset!");

// Class DarwinGame.RuinsDoor
// 0x0008 (0x02B8 - 0x02B0)
class ARuinsDoor final : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayClose();
	void PlayOpen(const struct FVector& Vector);
	void ReceivePlayClose();
	void ReceivePlayOpen(const struct FVector& Vector);
	void ReceiveSetClose();
	void ReceiveSetOpen(const struct FVector& Vector);
	void SetClose();
	void SetOpen(const struct FVector& Vector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RuinsDoor">();
	}
	static class ARuinsDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARuinsDoor>();
	}
};
static_assert(alignof(ARuinsDoor) == 0x000008, "Wrong alignment on ARuinsDoor");
static_assert(sizeof(ARuinsDoor) == 0x0002B8, "Wrong size on ARuinsDoor");

// Class DarwinGame.MonsterNickNameBlackListLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterNickNameBlackListLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterNickNameBlackListLibrary">();
	}
	static class UMonsterNickNameBlackListLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterNickNameBlackListLibrary>();
	}
};
static_assert(alignof(UMonsterNickNameBlackListLibrary) == 0x000008, "Wrong alignment on UMonsterNickNameBlackListLibrary");
static_assert(sizeof(UMonsterNickNameBlackListLibrary) == 0x000030, "Wrong size on UMonsterNickNameBlackListLibrary");

// Class DarwinGame.MonsterNormalAIController
// 0x0000 (0x0350 - 0x0350)
class AMonsterNormalAIController final : public AMonsterAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterNormalAIController">();
	}
	static class AMonsterNormalAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterNormalAIController>();
	}
};
static_assert(alignof(AMonsterNormalAIController) == 0x000008, "Wrong alignment on AMonsterNormalAIController");
static_assert(sizeof(AMonsterNormalAIController) == 0x000350, "Wrong size on AMonsterNormalAIController");

// Class DarwinGame.MonsterParameterDataTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterParameterDataTable final : public UBlueprintFunctionLibrary
{
public:
	static void GetDropItemInfo(class FName MonsterParamID, TArray<struct FST_DropItemInfo>* DropItemInfos);
	static int32 GetExpGain(class FName MonsterId);
	static class FName GetKindID(class FName MonsterId);
	static int32 GetLevel(class FName MonsterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterParameterDataTable">();
	}
	static class UMonsterParameterDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterParameterDataTable>();
	}
};
static_assert(alignof(UMonsterParameterDataTable) == 0x000008, "Wrong alignment on UMonsterParameterDataTable");
static_assert(sizeof(UMonsterParameterDataTable) == 0x000030, "Wrong size on UMonsterParameterDataTable");

// Class DarwinGame.MonsterRelocationBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterRelocationBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool Main(class AMonsterBase* Monster);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterRelocationBlueprintFunctionLibrary">();
	}
	static class UMonsterRelocationBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterRelocationBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterRelocationBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterRelocationBlueprintFunctionLibrary");
static_assert(sizeof(UMonsterRelocationBlueprintFunctionLibrary) == 0x000030, "Wrong size on UMonsterRelocationBlueprintFunctionLibrary");

// Class DarwinGame.ScoutRequirement
// 0x0000 (0x0030 - 0x0030)
class UScoutRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoutRequirement">();
	}
	static class UScoutRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoutRequirement>();
	}
};
static_assert(alignof(UScoutRequirement) == 0x000008, "Wrong alignment on UScoutRequirement");
static_assert(sizeof(UScoutRequirement) == 0x000030, "Wrong size on UScoutRequirement");

// Class DarwinGame.MonsterRingComponent
// 0x0008 (0x00C0 - 0x00B8)
class UMonsterRingComponent final : public UActorComponent
{
public:
	class AStaticMeshActor*                       mRingActor;                                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AStaticMeshActor* GetRingActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterRingComponent">();
	}
	static class UMonsterRingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterRingComponent>();
	}
};
static_assert(alignof(UMonsterRingComponent) == 0x000008, "Wrong alignment on UMonsterRingComponent");
static_assert(sizeof(UMonsterRingComponent) == 0x0000C0, "Wrong size on UMonsterRingComponent");
static_assert(offsetof(UMonsterRingComponent, mRingActor) == 0x0000B8, "Member 'UMonsterRingComponent::mRingActor' has a wrong offset!");

// Class DarwinGame.MonsterRivalTeamEquipmentDataTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterRivalTeamEquipmentDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterRivalTeamEquipmentDataTable">();
	}
	static class UMonsterRivalTeamEquipmentDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterRivalTeamEquipmentDataTable>();
	}
};
static_assert(alignof(UMonsterRivalTeamEquipmentDataTable) == 0x000008, "Wrong alignment on UMonsterRivalTeamEquipmentDataTable");
static_assert(sizeof(UMonsterRivalTeamEquipmentDataTable) == 0x000030, "Wrong size on UMonsterRivalTeamEquipmentDataTable");

// Class DarwinGame.UIMy_Artifact_Panel
// 0x0070 (0x05A0 - 0x0530)
class UUIMy_Artifact_Panel final : public UUIScrollMenuItemBase
{
public:
	int32                                         AddOrder;                                          // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMy_Artifact_Panel*                   NextFocusItem;                                     // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMy_Artifact_Panel*                   PrevFocusItem;                                     // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMy_Artifact_Panel*                   UpFocusItem;                                       // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIMy_Artifact_Panel*                   DownFocusItem;                                     // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FST_SceneCapture2DLight>        DirectionalLights;                                 // 0x0558(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget2;                                     // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CaptureOffset;                                     // 0x0578(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinArtifactTwoCaptureImage*         CaptureImage;                                      // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FlagImage;                                         // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCreateArtifactLight;                            // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMy_Artifact_Panel">();
	}
	static class UUIMy_Artifact_Panel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMy_Artifact_Panel>();
	}
};
static_assert(alignof(UUIMy_Artifact_Panel) == 0x000008, "Wrong alignment on UUIMy_Artifact_Panel");
static_assert(sizeof(UUIMy_Artifact_Panel) == 0x0005A0, "Wrong size on UUIMy_Artifact_Panel");
static_assert(offsetof(UUIMy_Artifact_Panel, AddOrder) == 0x000530, "Member 'UUIMy_Artifact_Panel::AddOrder' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, NextFocusItem) == 0x000538, "Member 'UUIMy_Artifact_Panel::NextFocusItem' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, PrevFocusItem) == 0x000540, "Member 'UUIMy_Artifact_Panel::PrevFocusItem' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, UpFocusItem) == 0x000548, "Member 'UUIMy_Artifact_Panel::UpFocusItem' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, DownFocusItem) == 0x000550, "Member 'UUIMy_Artifact_Panel::DownFocusItem' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, DirectionalLights) == 0x000558, "Member 'UUIMy_Artifact_Panel::DirectionalLights' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, RenderTarget) == 0x000568, "Member 'UUIMy_Artifact_Panel::RenderTarget' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, RenderTarget2) == 0x000570, "Member 'UUIMy_Artifact_Panel::RenderTarget2' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, CaptureOffset) == 0x000578, "Member 'UUIMy_Artifact_Panel::CaptureOffset' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, CaptureImage) == 0x000588, "Member 'UUIMy_Artifact_Panel::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, FlagImage) == 0x000590, "Member 'UUIMy_Artifact_Panel::FlagImage' has a wrong offset!");
static_assert(offsetof(UUIMy_Artifact_Panel, bIsCreateArtifactLight) == 0x000598, "Member 'UUIMy_Artifact_Panel::bIsCreateArtifactLight' has a wrong offset!");

// Class DarwinGame.MonsterRivalTeamLotteryWeight
// 0x0000 (0x0030 - 0x0030)
class UMonsterRivalTeamLotteryWeight final : public UBlueprintFunctionLibrary
{
public:
	static ERivalTeamForce RandomSelectRivalTeamForce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterRivalTeamLotteryWeight">();
	}
	static class UMonsterRivalTeamLotteryWeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterRivalTeamLotteryWeight>();
	}
};
static_assert(alignof(UMonsterRivalTeamLotteryWeight) == 0x000008, "Wrong alignment on UMonsterRivalTeamLotteryWeight");
static_assert(sizeof(UMonsterRivalTeamLotteryWeight) == 0x000030, "Wrong size on UMonsterRivalTeamLotteryWeight");

// Class DarwinGame.MonsterRivalteamNonBattleAI
// 0x0000 (0x0030 - 0x0030)
class UMonsterRivalteamNonBattleAI final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterRivalteamNonBattleAI">();
	}
	static class UMonsterRivalteamNonBattleAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterRivalteamNonBattleAI>();
	}
};
static_assert(alignof(UMonsterRivalteamNonBattleAI) == 0x000008, "Wrong alignment on UMonsterRivalteamNonBattleAI");
static_assert(sizeof(UMonsterRivalteamNonBattleAI) == 0x000030, "Wrong size on UMonsterRivalteamNonBattleAI");

// Class DarwinGame.SectorAreaOfEffect
// 0x0008 (0x0258 - 0x0250)
class ASectorAreaOfEffect final : public AAreaOfEffectBase
{
public:
	float                                         SectorRadius;                                      // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESectorAoEAngle                               AngleType;                                         // 0x0254(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAngleType(ESectorAoEAngle Type);
	void SetRadius(float Rad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectorAreaOfEffect">();
	}
	static class ASectorAreaOfEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASectorAreaOfEffect>();
	}
};
static_assert(alignof(ASectorAreaOfEffect) == 0x000008, "Wrong alignment on ASectorAreaOfEffect");
static_assert(sizeof(ASectorAreaOfEffect) == 0x000258, "Wrong size on ASectorAreaOfEffect");
static_assert(offsetof(ASectorAreaOfEffect, SectorRadius) == 0x000250, "Member 'ASectorAreaOfEffect::SectorRadius' has a wrong offset!");
static_assert(offsetof(ASectorAreaOfEffect, AngleType) == 0x000254, "Member 'ASectorAreaOfEffect::AngleType' has a wrong offset!");

// Class DarwinGame.UIMonsterSpecialAbility
// 0x0000 (0x0490 - 0x0490)
class UUIMonsterSpecialAbility : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterSpecialAbility">();
	}
	static class UUIMonsterSpecialAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterSpecialAbility>();
	}
};
static_assert(alignof(UUIMonsterSpecialAbility) == 0x000008, "Wrong alignment on UUIMonsterSpecialAbility");
static_assert(sizeof(UUIMonsterSpecialAbility) == 0x000490, "Wrong size on UUIMonsterSpecialAbility");

// Class DarwinGame.MonsterRivalteamStealArtifactAI
// 0x0000 (0x0030 - 0x0030)
class UMonsterRivalteamStealArtifactAI final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterRivalteamStealArtifactAI">();
	}
	static class UMonsterRivalteamStealArtifactAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterRivalteamStealArtifactAI>();
	}
};
static_assert(alignof(UMonsterRivalteamStealArtifactAI) == 0x000008, "Wrong alignment on UMonsterRivalteamStealArtifactAI");
static_assert(sizeof(UMonsterRivalteamStealArtifactAI) == 0x000030, "Wrong size on UMonsterRivalteamStealArtifactAI");

// Class DarwinGame.MonsterServiceArranger
// 0x0068 (0x0098 - 0x0030)
class UMonsterServiceArranger final : public UObject
{
public:
	class UFarEnough*                             mFarEnough;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCloseEnough*                           mCloseEnough;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCloseEnoughToLocation*                 mCloseEnoughToLocation;                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventWhileTracing*                     mEventWhileTracing;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USearchTargetOutsideTerritory*          mSearchTargetOutsideTerritory;                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUpdatePerception*                      mUpdatePerception;                                 // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCompleteVigilance*                     mCompleteVigilance;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerRemaining*                        mTimerRemaining;                                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventWhileWaiting*                     mEventWhileWaiting;                                // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayReserveMotion*                     mPlayReserveMotion;                                // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCallingEnemy*                          mCallingEnemy;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USearchInArea*                          mSearchInArea;                                     // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEscapeTimer*                           mEscapeTimer;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterServiceArranger">();
	}
	static class UMonsterServiceArranger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterServiceArranger>();
	}
};
static_assert(alignof(UMonsterServiceArranger) == 0x000008, "Wrong alignment on UMonsterServiceArranger");
static_assert(sizeof(UMonsterServiceArranger) == 0x000098, "Wrong size on UMonsterServiceArranger");
static_assert(offsetof(UMonsterServiceArranger, mFarEnough) == 0x000030, "Member 'UMonsterServiceArranger::mFarEnough' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mCloseEnough) == 0x000038, "Member 'UMonsterServiceArranger::mCloseEnough' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mCloseEnoughToLocation) == 0x000040, "Member 'UMonsterServiceArranger::mCloseEnoughToLocation' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mEventWhileTracing) == 0x000048, "Member 'UMonsterServiceArranger::mEventWhileTracing' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mSearchTargetOutsideTerritory) == 0x000050, "Member 'UMonsterServiceArranger::mSearchTargetOutsideTerritory' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mUpdatePerception) == 0x000058, "Member 'UMonsterServiceArranger::mUpdatePerception' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mCompleteVigilance) == 0x000060, "Member 'UMonsterServiceArranger::mCompleteVigilance' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mTimerRemaining) == 0x000068, "Member 'UMonsterServiceArranger::mTimerRemaining' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mEventWhileWaiting) == 0x000070, "Member 'UMonsterServiceArranger::mEventWhileWaiting' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mPlayReserveMotion) == 0x000078, "Member 'UMonsterServiceArranger::mPlayReserveMotion' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mCallingEnemy) == 0x000080, "Member 'UMonsterServiceArranger::mCallingEnemy' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mSearchInArea) == 0x000088, "Member 'UMonsterServiceArranger::mSearchInArea' has a wrong offset!");
static_assert(offsetof(UMonsterServiceArranger, mEscapeTimer) == 0x000090, "Member 'UMonsterServiceArranger::mEscapeTimer' has a wrong offset!");

// Class DarwinGame.MonsterSortFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterSortFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterSortFunctionLibrary">();
	}
	static class UMonsterSortFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterSortFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterSortFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterSortFunctionLibrary");
static_assert(sizeof(UMonsterSortFunctionLibrary) == 0x000030, "Wrong size on UMonsterSortFunctionLibrary");

// Class DarwinGame.MonsterSpecialAbilityFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterSpecialAbilityFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelActionState(EMonsterRegisterType registerType);
	static void CloseAbilityName();
	static void CloseScreen();
	static void DisableInvincibleSingle(class AMonsterBase* Monster);
	static bool IsCancel(class AMonsterBase* Owner);
	static void LoadAbilityCueSheet(class FName RowName);
	static void OpenAbilityName();
	static void OpenScreen();
	static void ReleaseAbilityCueSheet(class FName RowName);
	static void SetEnvironmentEnable(bool enable);
	static void SetMonsterTimerPause(class AMonsterBase* Monster, bool isPause);
	static void SetPlayerInputEnable(bool enable);
	static void SetupAbilityName(class AMonsterBase* Monster);
	static void StopMonstersWithoutOwner(class AMonster* Owner);
	static void UnRegisterFieldTerrainInfo(class AGPACharacter* Owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterSpecialAbilityFunctionLibrary">();
	}
	static class UMonsterSpecialAbilityFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterSpecialAbilityFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterSpecialAbilityFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterSpecialAbilityFunctionLibrary");
static_assert(sizeof(UMonsterSpecialAbilityFunctionLibrary) == 0x000030, "Wrong size on UMonsterSpecialAbilityFunctionLibrary");

// Class DarwinGame.PCOptionIni
// 0x0028 (0x0250 - 0x0228)
class APCOptionIni final : public AActor
{
public:
	int32                                         DisplayBrightness;                                 // 0x0228(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnisotropicQuality;                                // 0x022C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AntiAliasQuality;                                  // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFps;                                            // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VsyncEnable;                                       // 0x0238(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DensityScale;                                      // 0x023C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmbientOcclusionLevel;                             // 0x0240(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmbientOcclusionQuality;                           // 0x0244(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShadowQuality;                                     // 0x0248(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureDetail;                                     // 0x024C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCOptionIni">();
	}
	static class APCOptionIni* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCOptionIni>();
	}
};
static_assert(alignof(APCOptionIni) == 0x000008, "Wrong alignment on APCOptionIni");
static_assert(sizeof(APCOptionIni) == 0x000250, "Wrong size on APCOptionIni");
static_assert(offsetof(APCOptionIni, DisplayBrightness) == 0x000228, "Member 'APCOptionIni::DisplayBrightness' has a wrong offset!");
static_assert(offsetof(APCOptionIni, AnisotropicQuality) == 0x00022C, "Member 'APCOptionIni::AnisotropicQuality' has a wrong offset!");
static_assert(offsetof(APCOptionIni, AntiAliasQuality) == 0x000230, "Member 'APCOptionIni::AntiAliasQuality' has a wrong offset!");
static_assert(offsetof(APCOptionIni, MaxFps) == 0x000234, "Member 'APCOptionIni::MaxFps' has a wrong offset!");
static_assert(offsetof(APCOptionIni, VsyncEnable) == 0x000238, "Member 'APCOptionIni::VsyncEnable' has a wrong offset!");
static_assert(offsetof(APCOptionIni, DensityScale) == 0x00023C, "Member 'APCOptionIni::DensityScale' has a wrong offset!");
static_assert(offsetof(APCOptionIni, AmbientOcclusionLevel) == 0x000240, "Member 'APCOptionIni::AmbientOcclusionLevel' has a wrong offset!");
static_assert(offsetof(APCOptionIni, AmbientOcclusionQuality) == 0x000244, "Member 'APCOptionIni::AmbientOcclusionQuality' has a wrong offset!");
static_assert(offsetof(APCOptionIni, ShadowQuality) == 0x000248, "Member 'APCOptionIni::ShadowQuality' has a wrong offset!");
static_assert(offsetof(APCOptionIni, TextureDetail) == 0x00024C, "Member 'APCOptionIni::TextureDetail' has a wrong offset!");

// Class DarwinGame.MonsterSpecialAbilityRoot
// 0x0000 (0x0228 - 0x0228)
class AMonsterSpecialAbilityRoot final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterSpecialAbilityRoot">();
	}
	static class AMonsterSpecialAbilityRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMonsterSpecialAbilityRoot>();
	}
};
static_assert(alignof(AMonsterSpecialAbilityRoot) == 0x000008, "Wrong alignment on AMonsterSpecialAbilityRoot");
static_assert(sizeof(AMonsterSpecialAbilityRoot) == 0x000228, "Wrong size on AMonsterSpecialAbilityRoot");

// Class DarwinGame.MonsterSpecialAbilitySequenceDelegater
// 0x0040 (0x0070 - 0x0030)
class UMonsterSpecialAbilitySequenceDelegater final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterSpecialAbilitySequenceDelegater">();
	}
	static class UMonsterSpecialAbilitySequenceDelegater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterSpecialAbilitySequenceDelegater>();
	}
};
static_assert(alignof(UMonsterSpecialAbilitySequenceDelegater) == 0x000008, "Wrong alignment on UMonsterSpecialAbilitySequenceDelegater");
static_assert(sizeof(UMonsterSpecialAbilitySequenceDelegater) == 0x000070, "Wrong size on UMonsterSpecialAbilitySequenceDelegater");

// Class DarwinGame.UISaveLoadContentBase
// 0x0000 (0x05D8 - 0x05D8)
class UUISaveLoadContentBase : public UUIOptionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadContentBase">();
	}
	static class UUISaveLoadContentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadContentBase>();
	}
};
static_assert(alignof(UUISaveLoadContentBase) == 0x000008, "Wrong alignment on UUISaveLoadContentBase");
static_assert(sizeof(UUISaveLoadContentBase) == 0x0005D8, "Wrong size on UUISaveLoadContentBase");

// Class DarwinGame.UILoadContent
// 0x0040 (0x0618 - 0x05D8)
class UUILoadContent : public UUISaveLoadContentBase
{
public:
	uint8                                         Pad_5D8[0x18];                                     // 0x05D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_SaveLoadContentData>        SaveDataList;                                      // 0x05F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUILoadIconChoice*>              LoadIconList;                                      // 0x0600(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecLoad();
	void FadeOutEnd();
	void LoadDialogCallback(bool IsYes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadContent">();
	}
	static class UUILoadContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoadContent>();
	}
};
static_assert(alignof(UUILoadContent) == 0x000008, "Wrong alignment on UUILoadContent");
static_assert(sizeof(UUILoadContent) == 0x000618, "Wrong size on UUILoadContent");
static_assert(offsetof(UUILoadContent, SaveDataList) == 0x0005F0, "Member 'UUILoadContent::SaveDataList' has a wrong offset!");
static_assert(offsetof(UUILoadContent, LoadIconList) == 0x000600, "Member 'UUILoadContent::LoadIconList' has a wrong offset!");

// Class DarwinGame.MonsterStateBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterStateBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyAttributeToMonsters(EMonsterRegisterType Type, class FName AttributeID, int32 Level);
	static bool GetMonstersHidden(EMonsterRegisterType Type);
	static bool GetMonstersStopLogic(EMonsterRegisterType Type);
	static bool HasMonster(EMonsterRegisterType Type);
	static bool IsBattle();
	static void PauseAllMonsters();
	static void PauseEnemy(class AMonsterBase* Monster);
	static void PauseToType(EMonsterRegisterType Type);
	static void PlayCharacterCommonEffect(EMonsterRegisterType Type, ECharacterCommonEffectID EffectId);
	static void ReleaseAttributeFromMonsters(EMonsterRegisterType Type, class FName AttributeID, TArray<class AMonsterBase*>* ignores);
	static void ResumeAllMonsters();
	static void ResumeEnemy(class AMonsterBase* Monster);
	static void ResumeToType(EMonsterRegisterType Type);
	static bool RivalTeamIsBattle();
	static void SetHide(class AMonsterBase* Monster, bool IsHide);
	static void SetHideFriendsWithoutSpecifiedFriend(class AMonsterBase* Monster, bool IsHide);
	static void SetHideToList(TArray<class AMonsterBase*>* MonsterList, const bool IsHide);
	static void SetHideToListReturnList(TArray<class AMonsterBase*>* MonsterList, const bool IsHide, TArray<class AMonsterBase*>* OutMonsterList);
	static void SetHideToType(EMonsterRegisterType Type, bool IsHide);
	static void SetHideToTypeReturnList(EMonsterRegisterType Type, bool IsHide, TArray<class AMonsterBase*>* OutMonsterList);
	static void SetMonstersTickEnabled(EMonsterRegisterType Type, bool Enabled);
	static void SetPauseMonstersActiveGameplayEffect(EMonsterRegisterType Type, bool Pause, TArray<class AMonsterBase*>* ignores);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterStateBlueprintFunctionLibrary">();
	}
	static class UMonsterStateBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterStateBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterStateBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterStateBlueprintFunctionLibrary");
static_assert(sizeof(UMonsterStateBlueprintFunctionLibrary) == 0x000030, "Wrong size on UMonsterStateBlueprintFunctionLibrary");

// Class DarwinGame.MonsterTableComponent
// 0x00C0 (0x0178 - 0x00B8)
class UMonsterTableComponent final : public UActorComponent
{
public:
	struct FST_EcologicalMotionData               EcologicalMotionData;                              // 0x00B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x60];                                      // 0x00E0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             EcologicalAIDateList;                              // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             EcologicalAIRateList;                              // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             EcologicalWaitRateList;                            // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             EcologicalWaitDetailList;                          // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             EcologicalMoveRateList;                            // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             EcologicalMoveDetailList;                          // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             EcologicalMotionList;                              // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool FindEcologicalMotionData(class AMonster* Monster, class FName MotionID);
	bool GetEcologicalMotionData(struct FST_EcologicalMotionData* Out, class AMonster* Monster, class FName MotionID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterTableComponent">();
	}
	static class UMonsterTableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterTableComponent>();
	}
};
static_assert(alignof(UMonsterTableComponent) == 0x000008, "Wrong alignment on UMonsterTableComponent");
static_assert(sizeof(UMonsterTableComponent) == 0x000178, "Wrong size on UMonsterTableComponent");
static_assert(offsetof(UMonsterTableComponent, EcologicalMotionData) == 0x0000B8, "Member 'UMonsterTableComponent::EcologicalMotionData' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalAIDateList) == 0x000140, "Member 'UMonsterTableComponent::EcologicalAIDateList' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalAIRateList) == 0x000148, "Member 'UMonsterTableComponent::EcologicalAIRateList' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalWaitRateList) == 0x000150, "Member 'UMonsterTableComponent::EcologicalWaitRateList' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalWaitDetailList) == 0x000158, "Member 'UMonsterTableComponent::EcologicalWaitDetailList' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalMoveRateList) == 0x000160, "Member 'UMonsterTableComponent::EcologicalMoveRateList' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalMoveDetailList) == 0x000168, "Member 'UMonsterTableComponent::EcologicalMoveDetailList' has a wrong offset!");
static_assert(offsetof(UMonsterTableComponent, EcologicalMotionList) == 0x000170, "Member 'UMonsterTableComponent::EcologicalMotionList' has a wrong offset!");

// Class DarwinGame.PlayAtomNotify
// 0x0018 (0x0058 - 0x0040)
class UPlayAtomNotify final : public UAnimNotify
{
public:
	class USoundAtomCue*                          Sound;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachedBoneName;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESoundInsulationType                          SIType;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayAtomNotify">();
	}
	static class UPlayAtomNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayAtomNotify>();
	}
};
static_assert(alignof(UPlayAtomNotify) == 0x000008, "Wrong alignment on UPlayAtomNotify");
static_assert(sizeof(UPlayAtomNotify) == 0x000058, "Wrong size on UPlayAtomNotify");
static_assert(offsetof(UPlayAtomNotify, Sound) == 0x000040, "Member 'UPlayAtomNotify::Sound' has a wrong offset!");
static_assert(offsetof(UPlayAtomNotify, AttachedBoneName) == 0x000048, "Member 'UPlayAtomNotify::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UPlayAtomNotify, SIType) == 0x000050, "Member 'UPlayAtomNotify::SIType' has a wrong offset!");

// Class DarwinGame.UICircleGaugeBase
// 0x0030 (0x05E0 - 0x05B0)
class UUICircleGaugeBase : public UUI3DBase
{
public:
	class FString                                 GaugeSound;                                        // 0x05A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GaugeSusscessSound;                                // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         AtomComp;                                          // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySuccessAnim();
	void SetPercent(float Percent);
	void SuccessAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICircleGaugeBase">();
	}
	static class UUICircleGaugeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICircleGaugeBase>();
	}
};
static_assert(alignof(UUICircleGaugeBase) == 0x000010, "Wrong alignment on UUICircleGaugeBase");
static_assert(sizeof(UUICircleGaugeBase) == 0x0005E0, "Wrong size on UUICircleGaugeBase");
static_assert(offsetof(UUICircleGaugeBase, GaugeSound) == 0x0005A8, "Member 'UUICircleGaugeBase::GaugeSound' has a wrong offset!");
static_assert(offsetof(UUICircleGaugeBase, GaugeSusscessSound) == 0x0005B8, "Member 'UUICircleGaugeBase::GaugeSusscessSound' has a wrong offset!");
static_assert(offsetof(UUICircleGaugeBase, AtomComp) == 0x0005D0, "Member 'UUICircleGaugeBase::AtomComp' has a wrong offset!");

// Class DarwinGame.UILiberation
// 0x0000 (0x05E0 - 0x05E0)
class UUILiberation : public UUICircleGaugeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILiberation">();
	}
	static class UUILiberation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILiberation>();
	}
};
static_assert(alignof(UUILiberation) == 0x000010, "Wrong alignment on UUILiberation");
static_assert(sizeof(UUILiberation) == 0x0005E0, "Wrong size on UUILiberation");

// Class DarwinGame.MonsterTaskBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMonsterTaskBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterTaskBlueprintFunctionLibrary">();
	}
	static class UMonsterTaskBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterTaskBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMonsterTaskBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMonsterTaskBlueprintFunctionLibrary");
static_assert(sizeof(UMonsterTaskBlueprintFunctionLibrary) == 0x000030, "Wrong size on UMonsterTaskBlueprintFunctionLibrary");

// Class DarwinGame.MonsterVariableExpRateTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterVariableExpRateTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterVariableExpRateTable">();
	}
	static class UMonsterVariableExpRateTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterVariableExpRateTable>();
	}
};
static_assert(alignof(UMonsterVariableExpRateTable) == 0x000008, "Wrong alignment on UMonsterVariableExpRateTable");
static_assert(sizeof(UMonsterVariableExpRateTable) == 0x000030, "Wrong size on UMonsterVariableExpRateTable");

// Class DarwinGame.MonsterVariableLevelRateTable
// 0x0000 (0x0030 - 0x0030)
class UMonsterVariableLevelRateTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonsterVariableLevelRateTable">();
	}
	static class UMonsterVariableLevelRateTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonsterVariableLevelRateTable>();
	}
};
static_assert(alignof(UMonsterVariableLevelRateTable) == 0x000008, "Wrong alignment on UMonsterVariableLevelRateTable");
static_assert(sizeof(UMonsterVariableLevelRateTable) == 0x000030, "Wrong size on UMonsterVariableLevelRateTable");

// Class DarwinGame.MovieFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMovieFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieFunctionLibrary">();
	}
	static class UMovieFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieFunctionLibrary>();
	}
};
static_assert(alignof(UMovieFunctionLibrary) == 0x000008, "Wrong alignment on UMovieFunctionLibrary");
static_assert(sizeof(UMovieFunctionLibrary) == 0x000030, "Wrong size on UMovieFunctionLibrary");

// Class DarwinGame.PlayerControllerInterface
// 0x0000 (0x0030 - 0x0030)
class IPlayerControllerInterface final : public IInterface
{
public:
	void PossessCamera(class ADarwinCamera* Camera);

	class ADarwinCamera* GetControlledCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerInterface">();
	}
	static class IPlayerControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerControllerInterface>();
	}
};
static_assert(alignof(IPlayerControllerInterface) == 0x000008, "Wrong alignment on IPlayerControllerInterface");
static_assert(sizeof(IPlayerControllerInterface) == 0x000030, "Wrong size on IPlayerControllerInterface");

// Class DarwinGame.MyArtifactSceneCapture
// 0x0010 (0x0390 - 0x0380)
class AMyArtifactSceneCapture final : public ASceneCaptureTwoCameraBase
{
public:
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnLimitTime;                                    // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyArtifactSceneCapture">();
	}
	static class AMyArtifactSceneCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyArtifactSceneCapture>();
	}
};
static_assert(alignof(AMyArtifactSceneCapture) == 0x000010, "Wrong alignment on AMyArtifactSceneCapture");
static_assert(sizeof(AMyArtifactSceneCapture) == 0x000390, "Wrong size on AMyArtifactSceneCapture");
static_assert(offsetof(AMyArtifactSceneCapture, SpawnLimitTime) == 0x000388, "Member 'AMyArtifactSceneCapture::SpawnLimitTime' has a wrong offset!");

// Class DarwinGame.MyTeamFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMyTeamFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddTeamArtifactValue(int64 UpArtifactValue);
	static int32 GetTeamFlagID();
	static bool IsTeamLevelUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTeamFunctionLibrary">();
	}
	static class UMyTeamFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTeamFunctionLibrary>();
	}
};
static_assert(alignof(UMyTeamFunctionLibrary) == 0x000008, "Wrong alignment on UMyTeamFunctionLibrary");
static_assert(sizeof(UMyTeamFunctionLibrary) == 0x000030, "Wrong size on UMyTeamFunctionLibrary");

// Class DarwinGame.UIMap_SymbolBase
// 0x0018 (0x04A8 - 0x0490)
class UUIMap_SymbolBase : public UDarwinUserWidget
{
public:
	class UImage*                                 ImageWidget;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_SymbolBase">();
	}
	static class UUIMap_SymbolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_SymbolBase>();
	}
};
static_assert(alignof(UUIMap_SymbolBase) == 0x000008, "Wrong alignment on UUIMap_SymbolBase");
static_assert(sizeof(UUIMap_SymbolBase) == 0x0004A8, "Wrong size on UUIMap_SymbolBase");
static_assert(offsetof(UUIMap_SymbolBase, ImageWidget) == 0x000490, "Member 'UUIMap_SymbolBase::ImageWidget' has a wrong offset!");
static_assert(offsetof(UUIMap_SymbolBase, WaitAnim) == 0x000498, "Member 'UUIMap_SymbolBase::WaitAnim' has a wrong offset!");

// Class DarwinGame.UIMap_AnimSymbolBase
// 0x0018 (0x04C0 - 0x04A8)
class UUIMap_AnimSymbolBase : public UUIMap_SymbolBase
{
public:
	class UTexture2D*                             FloorUpImage;                                      // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             FloorDownImage;                                    // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_AnimSymbolBase">();
	}
	static class UUIMap_AnimSymbolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_AnimSymbolBase>();
	}
};
static_assert(alignof(UUIMap_AnimSymbolBase) == 0x000008, "Wrong alignment on UUIMap_AnimSymbolBase");
static_assert(sizeof(UUIMap_AnimSymbolBase) == 0x0004C0, "Wrong size on UUIMap_AnimSymbolBase");
static_assert(offsetof(UUIMap_AnimSymbolBase, FloorUpImage) == 0x0004A8, "Member 'UUIMap_AnimSymbolBase::FloorUpImage' has a wrong offset!");
static_assert(offsetof(UUIMap_AnimSymbolBase, FloorDownImage) == 0x0004B0, "Member 'UUIMap_AnimSymbolBase::FloorDownImage' has a wrong offset!");

// Class DarwinGame.UIMap_MArtifact_Icon_00
// 0x0010 (0x04D0 - 0x04C0)
class UUIMap_MArtifact_Icon_00 final : public UUIMap_AnimSymbolBase
{
public:
	class UWidgetAnimation*                       AppealAnim;                                        // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_MArtifact_Icon_00">();
	}
	static class UUIMap_MArtifact_Icon_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_MArtifact_Icon_00>();
	}
};
static_assert(alignof(UUIMap_MArtifact_Icon_00) == 0x000008, "Wrong alignment on UUIMap_MArtifact_Icon_00");
static_assert(sizeof(UUIMap_MArtifact_Icon_00) == 0x0004D0, "Wrong size on UUIMap_MArtifact_Icon_00");
static_assert(offsetof(UUIMap_MArtifact_Icon_00, AppealAnim) == 0x0004C0, "Member 'UUIMap_MArtifact_Icon_00::AppealAnim' has a wrong offset!");

// Class DarwinGame.MyTeamLevelDataAsset
// 0x0528 (0x0560 - 0x0038)
class UMyTeamLevelDataAsset final : public UDataAsset
{
public:
	int32                                         DispatchUnlockLevel;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NetworkUnlockLevel;                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   ArtifactNumDataList;                               // 0x0040(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   DispatchNumDataList;                               // 0x0090(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   CoinNumDataList;                                   // 0x00E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   BoardEntryNumDataList;                             // 0x0130(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   BaseLevelDataList;                                 // 0x0180(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   LinkRecastBonusList;                               // 0x01D0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   LinkEffectBonusList;                               // 0x0220(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   GetUpBonusList;                                    // 0x0270(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   SkillChainBonusList;                               // 0x02C0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   DespoilBonusList;                                  // 0x0310(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   ArtifactBonusList;                                 // 0x0360(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   PickupNumDataList;                                 // 0x03B0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   NetworkLevelList;                                  // 0x0400(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   IineBonusList;                                     // 0x0450(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   DownloadBonusList;                                 // 0x04A0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FST_MyTeamLevelGrowData>   LabyrinthLevelList;                                // 0x04F0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FST_MyTeamIineRange>            IineRangeDataList;                                 // 0x0540(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FST_MyTeamRankName>             RankNameDataList;                                  // 0x0550(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTeamLevelDataAsset">();
	}
	static class UMyTeamLevelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTeamLevelDataAsset>();
	}
};
static_assert(alignof(UMyTeamLevelDataAsset) == 0x000008, "Wrong alignment on UMyTeamLevelDataAsset");
static_assert(sizeof(UMyTeamLevelDataAsset) == 0x000560, "Wrong size on UMyTeamLevelDataAsset");
static_assert(offsetof(UMyTeamLevelDataAsset, DispatchUnlockLevel) == 0x000038, "Member 'UMyTeamLevelDataAsset::DispatchUnlockLevel' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, NetworkUnlockLevel) == 0x00003C, "Member 'UMyTeamLevelDataAsset::NetworkUnlockLevel' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, ArtifactNumDataList) == 0x000040, "Member 'UMyTeamLevelDataAsset::ArtifactNumDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, DispatchNumDataList) == 0x000090, "Member 'UMyTeamLevelDataAsset::DispatchNumDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, CoinNumDataList) == 0x0000E0, "Member 'UMyTeamLevelDataAsset::CoinNumDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, BoardEntryNumDataList) == 0x000130, "Member 'UMyTeamLevelDataAsset::BoardEntryNumDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, BaseLevelDataList) == 0x000180, "Member 'UMyTeamLevelDataAsset::BaseLevelDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, LinkRecastBonusList) == 0x0001D0, "Member 'UMyTeamLevelDataAsset::LinkRecastBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, LinkEffectBonusList) == 0x000220, "Member 'UMyTeamLevelDataAsset::LinkEffectBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, GetUpBonusList) == 0x000270, "Member 'UMyTeamLevelDataAsset::GetUpBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, SkillChainBonusList) == 0x0002C0, "Member 'UMyTeamLevelDataAsset::SkillChainBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, DespoilBonusList) == 0x000310, "Member 'UMyTeamLevelDataAsset::DespoilBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, ArtifactBonusList) == 0x000360, "Member 'UMyTeamLevelDataAsset::ArtifactBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, PickupNumDataList) == 0x0003B0, "Member 'UMyTeamLevelDataAsset::PickupNumDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, NetworkLevelList) == 0x000400, "Member 'UMyTeamLevelDataAsset::NetworkLevelList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, IineBonusList) == 0x000450, "Member 'UMyTeamLevelDataAsset::IineBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, DownloadBonusList) == 0x0004A0, "Member 'UMyTeamLevelDataAsset::DownloadBonusList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, LabyrinthLevelList) == 0x0004F0, "Member 'UMyTeamLevelDataAsset::LabyrinthLevelList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, IineRangeDataList) == 0x000540, "Member 'UMyTeamLevelDataAsset::IineRangeDataList' has a wrong offset!");
static_assert(offsetof(UMyTeamLevelDataAsset, RankNameDataList) == 0x000550, "Member 'UMyTeamLevelDataAsset::RankNameDataList' has a wrong offset!");

// Class DarwinGame.MyTeamLevelDataTable
// 0x0000 (0x0030 - 0x0030)
class UMyTeamLevelDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTeamLevelDataTable">();
	}
	static class UMyTeamLevelDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTeamLevelDataTable>();
	}
};
static_assert(alignof(UMyTeamLevelDataTable) == 0x000008, "Wrong alignment on UMyTeamLevelDataTable");
static_assert(sizeof(UMyTeamLevelDataTable) == 0x000030, "Wrong size on UMyTeamLevelDataTable");

// Class DarwinGame.PlayGetArtifactVoice
// 0x0000 (0x0040 - 0x0040)
class UPlayGetArtifactVoice final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayGetArtifactVoice">();
	}
	static class UPlayGetArtifactVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayGetArtifactVoice>();
	}
};
static_assert(alignof(UPlayGetArtifactVoice) == 0x000008, "Wrong alignment on UPlayGetArtifactVoice");
static_assert(sizeof(UPlayGetArtifactVoice) == 0x000040, "Wrong size on UPlayGetArtifactVoice");

// Class DarwinGame.UIMap_Area_Base
// 0x0008 (0x0498 - 0x0490)
class UUIMap_Area_Base : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_Area_Base">();
	}
	static class UUIMap_Area_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_Area_Base>();
	}
};
static_assert(alignof(UUIMap_Area_Base) == 0x000008, "Wrong alignment on UUIMap_Area_Base");
static_assert(sizeof(UUIMap_Area_Base) == 0x000498, "Wrong size on UUIMap_Area_Base");

// Class DarwinGame.N005
// 0x0000 (0x16B0 - 0x16B0)
class AN005 final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"N005">();
	}
	static class AN005* GetDefaultObj()
	{
		return GetDefaultObjImpl<AN005>();
	}
};
static_assert(alignof(AN005) == 0x000010, "Wrong alignment on AN005");
static_assert(sizeof(AN005) == 0x0016B0, "Wrong size on AN005");

// Class DarwinGame.N007_B
// 0x0000 (0x1920 - 0x1920)
class AN007_B final : public AMonsterBoss
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"N007_B">();
	}
	static class AN007_B* GetDefaultObj()
	{
		return GetDefaultObjImpl<AN007_B>();
	}
};
static_assert(alignof(AN007_B) == 0x000010, "Wrong alignment on AN007_B");
static_assert(sizeof(AN007_B) == 0x001920, "Wrong size on AN007_B");

// Class DarwinGame.N007_M
// 0x0000 (0x16B0 - 0x16B0)
class AN007_M final : public AMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"N007_M">();
	}
	static class AN007_M* GetDefaultObj()
	{
		return GetDefaultObjImpl<AN007_M>();
	}
};
static_assert(alignof(AN007_M) == 0x000010, "Wrong alignment on AN007_M");
static_assert(sizeof(AN007_M) == 0x0016B0, "Wrong size on AN007_M");

// Class DarwinGame.NetworkManagementFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UNetworkManagementFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkManagementFunctionLibrary">();
	}
	static class UNetworkManagementFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkManagementFunctionLibrary>();
	}
};
static_assert(alignof(UNetworkManagementFunctionLibrary) == 0x000008, "Wrong alignment on UNetworkManagementFunctionLibrary");
static_assert(sizeof(UNetworkManagementFunctionLibrary) == 0x000030, "Wrong size on UNetworkManagementFunctionLibrary");

// Class DarwinGame.NetworkQuestFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UNetworkQuestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkQuestFunctionLibrary">();
	}
	static class UNetworkQuestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkQuestFunctionLibrary>();
	}
};
static_assert(alignof(UNetworkQuestFunctionLibrary) == 0x000008, "Wrong alignment on UNetworkQuestFunctionLibrary");
static_assert(sizeof(UNetworkQuestFunctionLibrary) == 0x000030, "Wrong size on UNetworkQuestFunctionLibrary");

// Class DarwinGame.NormalBonfire
// 0x0000 (0x02C0 - 0x02C0)
class ANormalBonfire final : public ABonfireBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NormalBonfire">();
	}
	static class ANormalBonfire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANormalBonfire>();
	}
};
static_assert(alignof(ANormalBonfire) == 0x000008, "Wrong alignment on ANormalBonfire");
static_assert(sizeof(ANormalBonfire) == 0x0002C0, "Wrong size on ANormalBonfire");

// Class DarwinGame.NPCBase
// 0x0450 (0x1030 - 0x0BE0)
class ANPCBase : public AGPACharacter
{
public:
	uint8                                         Pad_BE0[0x11];                                     // 0x0BE0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          mIsLockFukidashi;                                  // 0x0BF1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF2[0x2];                                      // 0x0BF2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveRotationSpeed;                                 // 0x0BF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               IdleRotationSpeed;                                 // 0x0BF8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C04[0x4];                                      // 0x0C04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_NPCData                            NPCData;                                           // 0x0C08(0x01A0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   NpcID;                                             // 0x0DA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NPCName;                                           // 0x0DB0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ValidNPCData;                                      // 0x0DB8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DB9[0x7];                                      // 0x0DB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TextID;                                            // 0x0DC0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 FukidashiID;                                       // 0x0DD0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PrevEventID;                                       // 0x0DE0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEventType                                    EventType;                                         // 0x0DF0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DF1[0x7];                                      // 0x0DF1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_EventTalkData                      EventTalkDataLocal;                                // 0x0DF8(0x0040)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          IsTalkEnable;                                      // 0x0E38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFukidasiEnable;                                  // 0x0E39(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFukidasiRange;                                   // 0x0E3A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayEvent;                                       // 0x0E3B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETalkFukidashiType                            FukidashiType;                                     // 0x0E3C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETalkFukidashiColor                           FukidashiColor;                                    // 0x0E3D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E3E[0x2];                                      // 0x0E3E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FukidashiTextIDList;                               // 0x0E40(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FukidashiTextIDListIndex;                          // 0x0E50(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FukidashiTextDispCount;                            // 0x0E54(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FukidashiTextDispFrame;                            // 0x0E58(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FukidashiTextIsVisible;                            // 0x0E5C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FukidashiTextIsMode;                               // 0x0E5D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLookAtPlayer;                                    // 0x0E5E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLookAtBodyPlaying;                               // 0x0E5F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E60[0x8];                                      // 0x0E60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ENpcOpenNearUIType                            CurrentOpenNearUIType;                             // 0x0E68(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E69[0xB];                                      // 0x0E69(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrevLocation;                                      // 0x0E74(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptableRadius;                                  // 0x0E80(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AiSettingID;                                       // 0x0E84(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IdleEmoteList_CurrentIndex;                        // 0x0E8C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleEmoteList_DisplayTimeCount;                    // 0x0E90(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E94[0x4];                                      // 0x0E94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QuestClearFlagName;                                // 0x0E98(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EQuestState                                   QuestState;                                        // 0x0EA8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA9[0x3];                                      // 0x0EA9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DrawQuestIconIndex;                                // 0x0EAC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OriginRotation;                                    // 0x0EB0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                OriginLocation;                                    // 0x0EBC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FST_NPCDataAIWork                      AiWork;                                            // 0x0EC8(0x0020)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                AiOriginalLocation;                                // 0x0EE8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AiIsWalkFlag;                                      // 0x0EF4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF5[0x3];                                      // 0x0EF5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AiOriginalMaxWalkSpeed;                            // 0x0EF8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EFC[0x4];                                      // 0x0EFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_NPCEventAiMovePoints               AiEventMoveParam;                                  // 0x0F00(0x0058)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x0F58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplinePosition;                                    // 0x0F60(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F64[0x4];                                      // 0x0F64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SplineAreaLength;                                  // 0x0F68(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F78[0x38];                                     // 0x0F78(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        ReactionCollision;                                 // 0x0FB0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsExtraEvent;                                      // 0x0FB8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB9[0x3];                                      // 0x0FB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookTagetLocation;                                 // 0x0FBC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNPCLooking;                                      // 0x0FC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC9[0x3];                                      // 0x0FC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NPCLookAtLocation;                                 // 0x0FCC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD8[0x29];                                     // 0x0FD8(0x0029)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsAiHideWork;                                      // 0x1001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1002[0x6];                                     // 0x1002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x1008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ParticleSystem;                                    // 0x1010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1018[0x18];                                    // 0x1018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FName GetSocketNameFromESoket(const ESocket socket);

	void AiTick();
	void ChangeEmoteList(const ENPCEmotePart PartID, const int32 EmoteID);
	void ChangeNPCAiTypeToNormal();
	void CheckAndPlayPartVoice(const class FString& Src);
	void CloseFukidashiWithoutStamp();
	void CloseIcon();
	void CloseNearUI();
	void CompLoad(class FName AppearanceID);
	void DisableMoveCapsule();
	void EnableMoveCapsule();
	void EndEvent();
	void EndNPCAnimState(const struct FGameplayTag& State);
	float GetAcceptableRadius();
	const struct FST_NPCEventAiMovePoints GetAiEventMoveParam();
	bool GetAIIsWalkFlag();
	void GetAIPoints(TArray<class FName>* Points);
	class FName GetCurrentEventID();
	void GetCurrentLocationAndRotation(const float Length, const bool Loop, struct FVector* Locate);
	struct FRotator GetEaseTurnRotation(const struct FRotator& Current, const struct FRotator& Target, float Speed);
	struct FVector GetFukidashiOffset();
	bool GetIsPlayEvent();
	bool GetIsTalking();
	bool GetIsTalkingTurn();
	struct FRotator GetLookAtRotationToLocation(const struct FVector& Location);
	struct FRotator GetLookAtRotationToPlayer();
	bool GetMoveAnimation();
	struct FST_NPCDataAIParam GetNPCAiParam();
	ENPCAiType GetNPCAiType();
	EFukidashiEnum GetOpenFukidashiType();
	TArray<float> GetSplineAreaLength();
	class USplineComponent* GetSplineComponent();
	float GetSplinePosition();
	struct FVector GetStampOffset();
	bool HitFukidashiCollision();
	void IncrementTalkNum();
	void Init();
	bool IsExtraTalk();
	bool IsOpenLocalizeStamp();
	bool IsOpenNetworkTravelerFukidashi();
	bool IsOpenNewDispatch();
	bool IsOpenNewHubReception();
	void NPCInitMovement();
	void NPCOpenFukidasiUI(const bool IconVisibility);
	void NPCStopMovement();
	void OpenIcon(EBalloonIconType IconType, const struct FVector& Offset);
	void OpenNearUI();
	bool PlayQuestEvent();
	void ProcHideWorkEnd();
	void ProcHideWorkLoop();
	void ProcNPCLookAtBody();
	void ResetFukidashiParam();
	void ResetFukidashiVisible();
	int32 ResetNPCEmoteDisplCount();
	void ResetTalkNum();
	void SetAcceptableRadius(float Radius);
	void SetAiEventMoveParam(const struct FST_NPCEventAiMovePoints& Data);
	void SetAIIsWalkFlag(bool Flag);
	void SetAIWorkIndex(const int32 Index_0);
	void SetAIWorkTargetLocation(const struct FVector& Location);
	void SetAIWorkTargetRotator(const struct FRotator& Rotation);
	void SetAppearance();
	void SetCapsuleVerocity(const struct FVector& Verocity);
	void SetCustomEquipmentsState(const class FName NPCListID);
	void SetFukidashiDrawCollisonRadious(const float Radious);
	void SetFukidashiRequest();
	void SetHideWorkReady();
	void SetIsLookAtBodyPlaying(const bool Flag);
	void SetMoveAnimation(bool Animation);
	void SetNPCAiType(const ENPCAiType AIType);
	void SetNPCCapsule(const struct FST_NPCAppearance& NPCAppearanceData, class UCapsuleComponent* MoveCapsuleComponent, class UCapsuleComponent* TalkEndCapsuleComponent);
	void SetNPCCapsuleDefaultSize(const struct FST_NPCAppearance& NPCAppearanceData, class UCapsuleComponent* MoveCapsuleComponent, class UCapsuleComponent* TalkEndCapsuleComponent);
	bool SetNPCData(const class FName ChangeNPCID, const bool IsOverwrite);
	void SetNPCEmoteSetting(const class FName& NPCAppearanceID);
	void SetNPCMaterial(const struct FST_NPCAppearance& NPCAppearanceData);
	void SetNPCRelativeLocation(const struct FST_NPCAppearance& NPCAppearanceData, const ENPCAiType NPCAiType, const struct FVector& CapsuleOffset);
	void SetNPCSkeletalMesh(const struct FST_NPCAppearance& NPCAppearanceData);
	void SetOriginRotat(const struct FRotator& rot);
	void SetRestartAI();
	void SetSearchTurn(const bool Flag);
	void SetSplinePosition(float Length);
	void SetTalkEndTurnBack(const bool Flag);
	void SetTalking(bool flg);
	void SetTalkingTurn(bool flg);
	void SetTalkLookAtEnable(const bool Flag);
	void SetTalkStartState();
	void SetTalkStartTurn(const bool Flag);
	void SoundRequest(const EAtomCueSheetCategory SoundType, const int32 SoundNo);
	void StartLookAt(const struct FVector& TargetLocation);
	void StartLookAtPlayer();
	void StartNPCAnimState(const struct FGameplayTag& AnimState, const struct FGameplayTag& State);
	void StopAIActive();
	void StopLookAt();
	bool UpdateBrancheEventID();
	void UpdateFukidashiList(bool* IsUpdate, class FName* NextFukidashiTextID, bool* IsVisible);
	void UpdateLookAt_Implementation();
	void UpdateMoveParam();
	void UpdateNavigateAiState(const bool IsUpdateIndex);
	void UpdateNavigateFukidashi();

	int32 GetAIWorkIndex() const;
	struct FVector GetAIWorkTargetLocation() const;
	struct FRotator GetAIWorkTargetRotator() const;
	EEmoteType GetCurrentEmoteType() const;
	int32 GetIdleEmoteListNum() const;
	struct FST_EventNPCLookAt GetLookAtBodyParams() const;
	struct FST_EventNPCLookAt GetLookAtParams() const;
	const class FName GetNPCID() const;
	const class FName GetNPCListID() const;
	const struct FRotator GetOriginRotat() const;
	EQuestState GetQuestStateNPC() const;
	const bool GetSearchTurn() const;
	bool GetTalkEndTurnBack() const;
	bool GetTalkLookAtEnable() const;
	int32 GetTalkNum() const;
	const bool GetTalkStartTurn() const;
	bool HasAIWorkIndex() const;
	bool HasQuest() const;
	bool IsDebugFlag() const;
	bool IsOverWriteSpawn() const;
	bool IsQuestClearAll() const;
	bool IsValidNPCData() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBase">();
	}
	static class ANPCBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCBase>();
	}
};
static_assert(alignof(ANPCBase) == 0x000010, "Wrong alignment on ANPCBase");
static_assert(sizeof(ANPCBase) == 0x001030, "Wrong size on ANPCBase");
static_assert(offsetof(ANPCBase, mIsLockFukidashi) == 0x000BF1, "Member 'ANPCBase::mIsLockFukidashi' has a wrong offset!");
static_assert(offsetof(ANPCBase, MoveRotationSpeed) == 0x000BF4, "Member 'ANPCBase::MoveRotationSpeed' has a wrong offset!");
static_assert(offsetof(ANPCBase, IdleRotationSpeed) == 0x000BF8, "Member 'ANPCBase::IdleRotationSpeed' has a wrong offset!");
static_assert(offsetof(ANPCBase, NPCData) == 0x000C08, "Member 'ANPCBase::NPCData' has a wrong offset!");
static_assert(offsetof(ANPCBase, NpcID) == 0x000DA8, "Member 'ANPCBase::NpcID' has a wrong offset!");
static_assert(offsetof(ANPCBase, NPCName) == 0x000DB0, "Member 'ANPCBase::NPCName' has a wrong offset!");
static_assert(offsetof(ANPCBase, ValidNPCData) == 0x000DB8, "Member 'ANPCBase::ValidNPCData' has a wrong offset!");
static_assert(offsetof(ANPCBase, TextID) == 0x000DC0, "Member 'ANPCBase::TextID' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiID) == 0x000DD0, "Member 'ANPCBase::FukidashiID' has a wrong offset!");
static_assert(offsetof(ANPCBase, PrevEventID) == 0x000DE0, "Member 'ANPCBase::PrevEventID' has a wrong offset!");
static_assert(offsetof(ANPCBase, EventType) == 0x000DF0, "Member 'ANPCBase::EventType' has a wrong offset!");
static_assert(offsetof(ANPCBase, EventTalkDataLocal) == 0x000DF8, "Member 'ANPCBase::EventTalkDataLocal' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsTalkEnable) == 0x000E38, "Member 'ANPCBase::IsTalkEnable' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsFukidasiEnable) == 0x000E39, "Member 'ANPCBase::IsFukidasiEnable' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsFukidasiRange) == 0x000E3A, "Member 'ANPCBase::IsFukidasiRange' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsPlayEvent) == 0x000E3B, "Member 'ANPCBase::IsPlayEvent' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiType) == 0x000E3C, "Member 'ANPCBase::FukidashiType' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiColor) == 0x000E3D, "Member 'ANPCBase::FukidashiColor' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiTextIDList) == 0x000E40, "Member 'ANPCBase::FukidashiTextIDList' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiTextIDListIndex) == 0x000E50, "Member 'ANPCBase::FukidashiTextIDListIndex' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiTextDispCount) == 0x000E54, "Member 'ANPCBase::FukidashiTextDispCount' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiTextDispFrame) == 0x000E58, "Member 'ANPCBase::FukidashiTextDispFrame' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiTextIsVisible) == 0x000E5C, "Member 'ANPCBase::FukidashiTextIsVisible' has a wrong offset!");
static_assert(offsetof(ANPCBase, FukidashiTextIsMode) == 0x000E5D, "Member 'ANPCBase::FukidashiTextIsMode' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsLookAtPlayer) == 0x000E5E, "Member 'ANPCBase::IsLookAtPlayer' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsLookAtBodyPlaying) == 0x000E5F, "Member 'ANPCBase::IsLookAtBodyPlaying' has a wrong offset!");
static_assert(offsetof(ANPCBase, CurrentOpenNearUIType) == 0x000E68, "Member 'ANPCBase::CurrentOpenNearUIType' has a wrong offset!");
static_assert(offsetof(ANPCBase, PrevLocation) == 0x000E74, "Member 'ANPCBase::PrevLocation' has a wrong offset!");
static_assert(offsetof(ANPCBase, AcceptableRadius) == 0x000E80, "Member 'ANPCBase::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(ANPCBase, AiSettingID) == 0x000E84, "Member 'ANPCBase::AiSettingID' has a wrong offset!");
static_assert(offsetof(ANPCBase, IdleEmoteList_CurrentIndex) == 0x000E8C, "Member 'ANPCBase::IdleEmoteList_CurrentIndex' has a wrong offset!");
static_assert(offsetof(ANPCBase, IdleEmoteList_DisplayTimeCount) == 0x000E90, "Member 'ANPCBase::IdleEmoteList_DisplayTimeCount' has a wrong offset!");
static_assert(offsetof(ANPCBase, QuestClearFlagName) == 0x000E98, "Member 'ANPCBase::QuestClearFlagName' has a wrong offset!");
static_assert(offsetof(ANPCBase, QuestState) == 0x000EA8, "Member 'ANPCBase::QuestState' has a wrong offset!");
static_assert(offsetof(ANPCBase, DrawQuestIconIndex) == 0x000EAC, "Member 'ANPCBase::DrawQuestIconIndex' has a wrong offset!");
static_assert(offsetof(ANPCBase, OriginRotation) == 0x000EB0, "Member 'ANPCBase::OriginRotation' has a wrong offset!");
static_assert(offsetof(ANPCBase, OriginLocation) == 0x000EBC, "Member 'ANPCBase::OriginLocation' has a wrong offset!");
static_assert(offsetof(ANPCBase, AiWork) == 0x000EC8, "Member 'ANPCBase::AiWork' has a wrong offset!");
static_assert(offsetof(ANPCBase, AiOriginalLocation) == 0x000EE8, "Member 'ANPCBase::AiOriginalLocation' has a wrong offset!");
static_assert(offsetof(ANPCBase, AiIsWalkFlag) == 0x000EF4, "Member 'ANPCBase::AiIsWalkFlag' has a wrong offset!");
static_assert(offsetof(ANPCBase, AiOriginalMaxWalkSpeed) == 0x000EF8, "Member 'ANPCBase::AiOriginalMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(ANPCBase, AiEventMoveParam) == 0x000F00, "Member 'ANPCBase::AiEventMoveParam' has a wrong offset!");
static_assert(offsetof(ANPCBase, SplineComponent) == 0x000F58, "Member 'ANPCBase::SplineComponent' has a wrong offset!");
static_assert(offsetof(ANPCBase, SplinePosition) == 0x000F60, "Member 'ANPCBase::SplinePosition' has a wrong offset!");
static_assert(offsetof(ANPCBase, SplineAreaLength) == 0x000F68, "Member 'ANPCBase::SplineAreaLength' has a wrong offset!");
static_assert(offsetof(ANPCBase, ReactionCollision) == 0x000FB0, "Member 'ANPCBase::ReactionCollision' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsExtraEvent) == 0x000FB8, "Member 'ANPCBase::IsExtraEvent' has a wrong offset!");
static_assert(offsetof(ANPCBase, LookTagetLocation) == 0x000FBC, "Member 'ANPCBase::LookTagetLocation' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsNPCLooking) == 0x000FC8, "Member 'ANPCBase::IsNPCLooking' has a wrong offset!");
static_assert(offsetof(ANPCBase, NPCLookAtLocation) == 0x000FCC, "Member 'ANPCBase::NPCLookAtLocation' has a wrong offset!");
static_assert(offsetof(ANPCBase, IsAiHideWork) == 0x001001, "Member 'ANPCBase::IsAiHideWork' has a wrong offset!");
static_assert(offsetof(ANPCBase, ParticleComponent) == 0x001008, "Member 'ANPCBase::ParticleComponent' has a wrong offset!");
static_assert(offsetof(ANPCBase, ParticleSystem) == 0x001010, "Member 'ANPCBase::ParticleSystem' has a wrong offset!");

// Class DarwinGame.NPCManager
// 0x0758 (0x0788 - 0x0030)
class UNPCManager : public UObject
{
public:
	uint8                                         Pad_30[0x3A8];                                     // 0x0030(0x03A8)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NPCClassPtr;                                       // 0x03D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SplinePointActor;                                  // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCVisibleFarRange;                                // 0x0408(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCVisibleNearRange;                               // 0x040C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCTickEnableFarRange;                             // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCTickEnableNearRange;                            // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCDataDT;                                        // 0x0418(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCPointDataDT;                                   // 0x0440(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCAppearanceDataDT;                              // 0x0468(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCPartVoiceDataDT;                               // 0x0490(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCMovePointDataDT;                               // 0x04B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCNaviPointDataDT;                               // 0x04E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCSplineNaviPointDataDT;                         // 0x0508(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCOptionDataDT;                                  // 0x0530(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCEmoteTableDT;                                  // 0x0558(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCParticleEffectTableDT;                         // 0x0580(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              mNPCBaseAreaTableDT;                               // 0x05A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ANPCBase>                   NPCClass;                                          // 0x05D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x1B0];                                    // 0x05D8(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddToList(class ANPCBase* NPC);
	bool ChangeNPCData(class FName NextNPCID);
	void CheckFukidashi();
	TArray<struct FVector> GetAllActiveNPCLocations();
	TArray<class ANPCBase*> GetAllNPCActor();
	void GetNPCAppearanceData(class FName NPCAppearanceID, bool* Result, struct FST_NPCAppearance* DataInfo);
	void GetNPCDataFromTable(const class FName NpcID, bool* Result, struct FST_NPCData* NPCData);
	TArray<struct FVector> GetNPCLocations(const TArray<class FName>& NPCIDs);
	void GetNPCMovePointData(class FName PointID, bool* Result, struct FST_NPCMovePoints* DataInfo);
	void GetNPCNaviPointData(class FName PointID, bool* Result, struct FST_NPCEventAiMovePoints* DataInfo);
	bool GetNPCParticleEffectList(const class FName ID, TArray<struct FST_NPCParticleEffectData>* ParticleEffectList);
	void GetNPCPointData(class FName NpcID, bool* Result, struct FST_PointDataTable* DataInfo);
	void GetNPCSplineNaviPointData(class FName PointID, bool* Result, struct FST_NPCEventAiMovePoints* DataInfo);
	void InitializeFriendNPCData();
	void Remove(class FName RemoveNPCId);
	void SetIsNPCAiSkip(const bool flg);
	void SetSplinePointActor(class UObject* Obj);
	void SetUpdateEnable(bool enable_flag);
	void SetVisibleNPCAll(bool Visibility);
	bool Spawn(const class FName NpcID, const struct FTransform& Transform);
	void UpdateNPCVisibility();

	bool ContainsList(const class FName NPC_ID) const;
	class FName ConvertNPCID(const class FName NPCDataID) const;
	bool GetIsNPCAiSkip() const;
	class ANPCBase* GetNPC(class FName NpcID) const;
	class UDataTable* GetNPCAppearanceDataTable() const;
	class UDataTable* GetNPCDataTable() const;
	class UDataTable* GetNPCEmoteDataTable() const;
	class UDataTable* GetNPCMovePointDataTable() const;
	class UDataTable* GetNPCNaviPointDataTable() const;
	class UDataTable* GetNPCOptionDataTable() const;
	class UDataTable* GetNPCParticleEffectDataTable() const;
	class UDataTable* GetNPCPartVoiceDataTable() const;
	int32 GetNPCPartVoiceID(const class FString& TalkTypeName, const int32 TalkerTypeNo) const;
	int32 GetNPCPartVoiceIDFromNpcID(const class FString& TalkType, const class FName NpcID) const;
	class UDataTable* GetNPCPointDataTable() const;
	class UDataTable* GetNPCSplineNaviPointDataTable() const;
	class UObject* GetSplinePointActor() const;
	bool IsAutoTravelerNPCId(const class FName& NpcID) const;
	bool IsFriendNPCId(const class FName& NpcID) const;
	bool IsInvitationTravelerNPCId(const class FName& NpcID) const;
	bool IsManagerActive() const;
	bool IsVisibleNPCId(const class FName& NpcID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCManager">();
	}
	static class UNPCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCManager>();
	}
};
static_assert(alignof(UNPCManager) == 0x000008, "Wrong alignment on UNPCManager");
static_assert(sizeof(UNPCManager) == 0x000788, "Wrong size on UNPCManager");
static_assert(offsetof(UNPCManager, NPCClassPtr) == 0x0003D8, "Member 'UNPCManager::NPCClassPtr' has a wrong offset!");
static_assert(offsetof(UNPCManager, SplinePointActor) == 0x000400, "Member 'UNPCManager::SplinePointActor' has a wrong offset!");
static_assert(offsetof(UNPCManager, NPCVisibleFarRange) == 0x000408, "Member 'UNPCManager::NPCVisibleFarRange' has a wrong offset!");
static_assert(offsetof(UNPCManager, NPCVisibleNearRange) == 0x00040C, "Member 'UNPCManager::NPCVisibleNearRange' has a wrong offset!");
static_assert(offsetof(UNPCManager, NPCTickEnableFarRange) == 0x000410, "Member 'UNPCManager::NPCTickEnableFarRange' has a wrong offset!");
static_assert(offsetof(UNPCManager, NPCTickEnableNearRange) == 0x000414, "Member 'UNPCManager::NPCTickEnableNearRange' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCDataDT) == 0x000418, "Member 'UNPCManager::mNPCDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCPointDataDT) == 0x000440, "Member 'UNPCManager::mNPCPointDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCAppearanceDataDT) == 0x000468, "Member 'UNPCManager::mNPCAppearanceDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCPartVoiceDataDT) == 0x000490, "Member 'UNPCManager::mNPCPartVoiceDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCMovePointDataDT) == 0x0004B8, "Member 'UNPCManager::mNPCMovePointDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCNaviPointDataDT) == 0x0004E0, "Member 'UNPCManager::mNPCNaviPointDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCSplineNaviPointDataDT) == 0x000508, "Member 'UNPCManager::mNPCSplineNaviPointDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCOptionDataDT) == 0x000530, "Member 'UNPCManager::mNPCOptionDataDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCEmoteTableDT) == 0x000558, "Member 'UNPCManager::mNPCEmoteTableDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCParticleEffectTableDT) == 0x000580, "Member 'UNPCManager::mNPCParticleEffectTableDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, mNPCBaseAreaTableDT) == 0x0005A8, "Member 'UNPCManager::mNPCBaseAreaTableDT' has a wrong offset!");
static_assert(offsetof(UNPCManager, NPCClass) == 0x0005D0, "Member 'UNPCManager::NPCClass' has a wrong offset!");

// Class DarwinGame.UIVision_Wave_Eff
// 0x0008 (0x0498 - 0x0490)
class UUIVision_Wave_Eff final : public UDarwinUserWidget
{
public:
	class UWidgetAnimation*                       Anim;                                              // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Wave_Eff">();
	}
	static class UUIVision_Wave_Eff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Wave_Eff>();
	}
};
static_assert(alignof(UUIVision_Wave_Eff) == 0x000008, "Wrong alignment on UUIVision_Wave_Eff");
static_assert(sizeof(UUIVision_Wave_Eff) == 0x000498, "Wrong size on UUIVision_Wave_Eff");
static_assert(offsetof(UUIVision_Wave_Eff, Anim) == 0x000490, "Member 'UUIVision_Wave_Eff::Anim' has a wrong offset!");

// Class DarwinGame.ObjectReactionEventComponent
// 0x0010 (0x0178 - 0x0168)
class UObjectReactionEventComponent final : public UObjectReactionBaseComponent
{
public:
	TArray<struct FObjectReactionEventData>       mEventDataList;                                    // 0x0168(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectReactionEventComponent">();
	}
	static class UObjectReactionEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectReactionEventComponent>();
	}
};
static_assert(alignof(UObjectReactionEventComponent) == 0x000008, "Wrong alignment on UObjectReactionEventComponent");
static_assert(sizeof(UObjectReactionEventComponent) == 0x000178, "Wrong size on UObjectReactionEventComponent");
static_assert(offsetof(UObjectReactionEventComponent, mEventDataList) == 0x000168, "Member 'UObjectReactionEventComponent::mEventDataList' has a wrong offset!");

// Class DarwinGame.OpenCheckFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UOpenCheckFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CanOpenCoinMenu();
	static bool CanOpenConfigMenu();
	static bool CanOpenDictionaryMenu();
	static bool CanOpenFieldLink();
	static bool CanOpenItemMenu();
	static bool CanOpenMainMenu();
	static bool CanOpenMapMenu();
	static bool CanOpenMiniMap();
	static bool CanOpenPartyMenu();
	static bool CanOpenQuestMenu();
	static bool CanOpenQuestWindow();
	static bool CanOpenSpStock();
	static bool CanOpenStatusWindow();
	static bool CanOpenTeamMenu();
	static bool CanShowBaseIsland();
	static bool CanShowCategory();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenCheckFunctionLibrary">();
	}
	static class UOpenCheckFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenCheckFunctionLibrary>();
	}
};
static_assert(alignof(UOpenCheckFunctionLibrary) == 0x000008, "Wrong alignment on UOpenCheckFunctionLibrary");
static_assert(sizeof(UOpenCheckFunctionLibrary) == 0x000030, "Wrong size on UOpenCheckFunctionLibrary");

// Class DarwinGame.UITitle_WinAutoSave
// 0x0000 (0x0490 - 0x0490)
class UUITitle_WinAutoSave final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_WinAutoSave">();
	}
	static class UUITitle_WinAutoSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_WinAutoSave>();
	}
};
static_assert(alignof(UUITitle_WinAutoSave) == 0x000008, "Wrong alignment on UUITitle_WinAutoSave");
static_assert(sizeof(UUITitle_WinAutoSave) == 0x000490, "Wrong size on UUITitle_WinAutoSave");

// Class DarwinGame.OutbreakQuestDiscoveryTreasure
// 0x0050 (0x0328 - 0x02D8)
class AOutbreakQuestDiscoveryTreasure final : public AOutbreakQuestGimmickBase
{
public:
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AMonsterSpawnedCallbackHolder*          spawnedCallback;                                   // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestDiscoveryTreasure">();
	}
	static class AOutbreakQuestDiscoveryTreasure* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestDiscoveryTreasure>();
	}
};
static_assert(alignof(AOutbreakQuestDiscoveryTreasure) == 0x000008, "Wrong alignment on AOutbreakQuestDiscoveryTreasure");
static_assert(sizeof(AOutbreakQuestDiscoveryTreasure) == 0x000328, "Wrong size on AOutbreakQuestDiscoveryTreasure");
static_assert(offsetof(AOutbreakQuestDiscoveryTreasure, spawnedCallback) == 0x000318, "Member 'AOutbreakQuestDiscoveryTreasure::spawnedCallback' has a wrong offset!");

// Class DarwinGame.OutbreakQuestPoint
// 0x0078 (0x0328 - 0x02B0)
class AOutbreakQuestPoint final : public AFieldObjectBase
{
public:
	TMap<EOutbreakQuestGimmickType, TSoftClassPtr<class UClass>> mGimmickBPList;                                    // 0x02B0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOutbreakQuestGimmickBase*              mpGimmick;                                         // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestPoint">();
	}
	static class AOutbreakQuestPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutbreakQuestPoint>();
	}
};
static_assert(alignof(AOutbreakQuestPoint) == 0x000008, "Wrong alignment on AOutbreakQuestPoint");
static_assert(sizeof(AOutbreakQuestPoint) == 0x000328, "Wrong size on AOutbreakQuestPoint");
static_assert(offsetof(AOutbreakQuestPoint, mGimmickBPList) == 0x0002B0, "Member 'AOutbreakQuestPoint::mGimmickBPList' has a wrong offset!");
static_assert(offsetof(AOutbreakQuestPoint, mpGimmick) == 0x000308, "Member 'AOutbreakQuestPoint::mpGimmick' has a wrong offset!");

// Class DarwinGame.OutbreakQuestPointManager
// 0x0038 (0x0068 - 0x0030)
class UOutbreakQuestPointManager : public UObject
{
public:
	TArray<class AOutbreakQuestPoint*>            mObjectList;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   mPointRef;                                         // 0x0040(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutbreakQuestPointManager">();
	}
	static class UOutbreakQuestPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutbreakQuestPointManager>();
	}
};
static_assert(alignof(UOutbreakQuestPointManager) == 0x000008, "Wrong alignment on UOutbreakQuestPointManager");
static_assert(sizeof(UOutbreakQuestPointManager) == 0x000068, "Wrong size on UOutbreakQuestPointManager");
static_assert(offsetof(UOutbreakQuestPointManager, mObjectList) == 0x000030, "Member 'UOutbreakQuestPointManager::mObjectList' has a wrong offset!");
static_assert(offsetof(UOutbreakQuestPointManager, mPointRef) == 0x000040, "Member 'UOutbreakQuestPointManager::mPointRef' has a wrong offset!");

// Class DarwinGame.UIQuest_Order
// 0x0070 (0x0500 - 0x0490)
class UUIQuest_Order final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIQuest_Order_List*                    QuestList;                                         // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UIUnderButtonDescription;                          // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIRewardWin_00_Root*                   RewardWindow;                                      // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x4];                                      // 0x04B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TipsDelayTime;                                     // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x40];                                     // 0x04C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Setup(const TArray<class FName>& InQuestIdList, const class FName& NpcID, bool bInIsParentDisplay, bool bInIsNewOrderQuest, bool bInIsClearedDisplay, bool bInIsClosedPlayEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuest_Order">();
	}
	static class UUIQuest_Order* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuest_Order>();
	}
};
static_assert(alignof(UUIQuest_Order) == 0x000008, "Wrong alignment on UUIQuest_Order");
static_assert(sizeof(UUIQuest_Order) == 0x000500, "Wrong size on UUIQuest_Order");
static_assert(offsetof(UUIQuest_Order, QuestList) == 0x0004A0, "Member 'UUIQuest_Order::QuestList' has a wrong offset!");
static_assert(offsetof(UUIQuest_Order, UIUnderButtonDescription) == 0x0004A8, "Member 'UUIQuest_Order::UIUnderButtonDescription' has a wrong offset!");
static_assert(offsetof(UUIQuest_Order, RewardWindow) == 0x0004B0, "Member 'UUIQuest_Order::RewardWindow' has a wrong offset!");
static_assert(offsetof(UUIQuest_Order, TipsDelayTime) == 0x0004BC, "Member 'UUIQuest_Order::TipsDelayTime' has a wrong offset!");

// Class DarwinGame.ParameterTypeDataTable
// 0x0000 (0x0030 - 0x0030)
class UParameterTypeDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParameterTypeDataTable">();
	}
	static class UParameterTypeDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParameterTypeDataTable>();
	}
};
static_assert(alignof(UParameterTypeDataTable) == 0x000008, "Wrong alignment on UParameterTypeDataTable");
static_assert(sizeof(UParameterTypeDataTable) == 0x000030, "Wrong size on UParameterTypeDataTable");

// Class DarwinGame.ParkourAbility
// 0x0070 (0x0490 - 0x0420)
class UParkourAbility : public UActionGameplayAbility
{
public:
	struct FVector                                PrevLocation;                                      // 0x0420(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x64];                                     // 0x042C(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustRotation();
	void CalculateParkourValue();
	void SetCapsuleScale(const struct FVector2D& CapsuleScale);

	struct FParkour GetParkourData() const;
	struct FRotator GetTurnRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParkourAbility">();
	}
	static class UParkourAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParkourAbility>();
	}
};
static_assert(alignof(UParkourAbility) == 0x000008, "Wrong alignment on UParkourAbility");
static_assert(sizeof(UParkourAbility) == 0x000490, "Wrong size on UParkourAbility");
static_assert(offsetof(UParkourAbility, PrevLocation) == 0x000420, "Member 'UParkourAbility::PrevLocation' has a wrong offset!");

// Class DarwinGame.ParkourSystemLibrary
// 0x0000 (0x0030 - 0x0030)
class UParkourSystemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParkourSystemLibrary">();
	}
	static class UParkourSystemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParkourSystemLibrary>();
	}
};
static_assert(alignof(UParkourSystemLibrary) == 0x000008, "Wrong alignment on UParkourSystemLibrary");
static_assert(sizeof(UParkourSystemLibrary) == 0x000030, "Wrong size on UParkourSystemLibrary");

// Class DarwinGame.PartyEditLibrary
// 0x0000 (0x0030 - 0x0030)
class UPartyEditLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 K2_Add(int32 stockUid, const struct FPartyEditOption& Option);
	static void K2_MemberChange(const TArray<int32>& stockUids, const struct FPartyEditOption& Option);
	static int32 K2_Remove(int32 partyIndex, const struct FPartyEditOption& Option);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyEditLibrary">();
	}
	static class UPartyEditLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyEditLibrary>();
	}
};
static_assert(alignof(UPartyEditLibrary) == 0x000008, "Wrong alignment on UPartyEditLibrary");
static_assert(sizeof(UPartyEditLibrary) == 0x000030, "Wrong size on UPartyEditLibrary");

// Class DarwinGame.PCInputIni
// 0x0008 (0x0230 - 0x0228)
class APCInputIni final : public AActor
{
public:
	int32                                         KeyboardType;                                      // 0x0228(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         controllerType;                                    // 0x022C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCInputIni">();
	}
	static class APCInputIni* GetDefaultObj()
	{
		return GetDefaultObjImpl<APCInputIni>();
	}
};
static_assert(alignof(APCInputIni) == 0x000008, "Wrong alignment on APCInputIni");
static_assert(sizeof(APCInputIni) == 0x000230, "Wrong size on APCInputIni");
static_assert(offsetof(APCInputIni, KeyboardType) == 0x000228, "Member 'APCInputIni::KeyboardType' has a wrong offset!");
static_assert(offsetof(APCInputIni, controllerType) == 0x00022C, "Member 'APCInputIni::controllerType' has a wrong offset!");

// Class DarwinGame.PersistentLevelDataAsset
// 0x0050 (0x0088 - 0x0038)
class UPersistentLevelDataAsset final : public UDataAsset
{
public:
	TMap<EPersistentLevelID, struct FPersistentLevelRecord> mLevelData;                                        // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void Import();

	struct FPersistentLevelRecord GetLevelData(EPersistentLevelID ID) const;
	class FName GetLevelPath(EPersistentLevelID ID) const;
	bool IsContainsLevelPath(const class FName level_path) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentLevelDataAsset">();
	}
	static class UPersistentLevelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistentLevelDataAsset>();
	}
};
static_assert(alignof(UPersistentLevelDataAsset) == 0x000008, "Wrong alignment on UPersistentLevelDataAsset");
static_assert(sizeof(UPersistentLevelDataAsset) == 0x000088, "Wrong size on UPersistentLevelDataAsset");
static_assert(offsetof(UPersistentLevelDataAsset, mLevelData) == 0x000038, "Member 'UPersistentLevelDataAsset::mLevelData' has a wrong offset!");

// Class DarwinGame.Play3DSoundNotify
// 0x0028 (0x0068 - 0x0040)
class UPlay3DSoundNotify final : public UAnimNotify
{
public:
	class FName                                   SheetName;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CueName;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachedBoneName;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESoundInsulationType                          SIType;                                            // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Play3DSoundNotify">();
	}
	static class UPlay3DSoundNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlay3DSoundNotify>();
	}
};
static_assert(alignof(UPlay3DSoundNotify) == 0x000008, "Wrong alignment on UPlay3DSoundNotify");
static_assert(sizeof(UPlay3DSoundNotify) == 0x000068, "Wrong size on UPlay3DSoundNotify");
static_assert(offsetof(UPlay3DSoundNotify, SheetName) == 0x000040, "Member 'UPlay3DSoundNotify::SheetName' has a wrong offset!");
static_assert(offsetof(UPlay3DSoundNotify, CueName) == 0x000048, "Member 'UPlay3DSoundNotify::CueName' has a wrong offset!");
static_assert(offsetof(UPlay3DSoundNotify, AttachedBoneName) == 0x000058, "Member 'UPlay3DSoundNotify::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UPlay3DSoundNotify, SIType) == 0x000060, "Member 'UPlay3DSoundNotify::SIType' has a wrong offset!");

// Class DarwinGame.PlayerCharacter
// 0x01C0 (0x0DA0 - 0x0BE0)
class APlayerCharacter : public AGPACharacter
{
public:
	struct FFieldActionEventStruct                mFieldActionInfo;                                  // 0x0BE0(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF8[0x20];                                     // 0x0BF8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UPlayerDataAsset*>    PlayerDataList;                                    // 0x0C18(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         WaitTimeToFade;                                    // 0x0C68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecordIntervalOfSafePoint;                         // 0x0C6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C70[0x10];                                     // 0x0C70(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           mForceMoveTimerHandle;                             // 0x0C80(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EObjectReactionType, EFieldActionEnum>   FieldActionList;                                   // 0x0C88(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ULinkSystemComponent*                   LinkSystem;                                        // 0x0CD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEffectBase*                            mLeftEyeEffect;                                    // 0x0CE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEffectBase*                            mRightEyeEffect;                                   // 0x0CE8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetSystemComponent*                 TargetSystem;                                      // 0x0CF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommunicationComponent*                CommunicationSystem;                               // 0x0CF8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D00[0x10];                                     // 0x0D00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFootEffectSystemComponent*             FootEffectSystem;                                  // 0x0D10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D18[0x18];                                     // 0x0D18(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FieldActMotionList;                                // 0x0D30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RideMotionList;                                    // 0x0D38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D40[0x20];                                     // 0x0D40(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            TransformInfoUIForDebug;                           // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D68[0x18];                                     // 0x0D68(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACompassBase>               CompassClass;                                      // 0x0D80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACompassBase*                           mCompass;                                          // 0x0D88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D90[0x8];                                      // 0x0D90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicaStampOffset;                                // 0x0D98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9C[0x4];                                      // 0x0D9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelProcessRunningOnHoldKeyPush();
	void ChangeStateCamera(const struct FGameplayTag& NextTag);
	void ChangeToBeast(bool End, float InterapSpeed);
	void DisableInvincible();
	void EnableInvincible();
	bool FindFieldActMotionData(class FName MotionID, struct FST_FieldAct* FieldActData);
	void ForceMove(const struct FVector& Direction, float Time);
	void GenerateEquipment();
	class ADarwinCamera* GetDarwinCamera();
	struct FGameplayTag GetLMBGameplayTag();
	bool GetRideMotion(struct FST_RideMotionData* FoundData);
	void HideMarker();
	void InitInteraction();
	void InteractWhenAlreadyPressed();
	bool IsLMBPressed();
	void LoseSightOfInteractObject();
	void OnAimMarkerOnOwner(bool bOverPlayer);
	void OnAimTrigger(bool bStart);
	void OnChangeMP();
	void OnInputChanged(bool Enabled);
	void OnSetEquipmentFlag(bool enable, bool isChanged);
	void RegisterAbyssInfo();
	void Restart(const struct FVector& Location, const struct FRotator& Rotation);
	void Search(float Time);
	void SetActiveRegenMP(bool Active);
	void ShowMarker();
	void ShowTransformInfoForDebug(bool IsShow);
	void StartAbyssSequence();
	void StartBattleTimer();
	void StartVision(float Time);

	struct FFieldActionEventStruct GetFieldActionInfo() const;
	bool IsBattleModeContinue() const;
	bool IsPlayingUseSwordAction() const;
	bool OnTheWater() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacter">();
	}
	static class APlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCharacter>();
	}
};
static_assert(alignof(APlayerCharacter) == 0x000010, "Wrong alignment on APlayerCharacter");
static_assert(sizeof(APlayerCharacter) == 0x000DA0, "Wrong size on APlayerCharacter");
static_assert(offsetof(APlayerCharacter, mFieldActionInfo) == 0x000BE0, "Member 'APlayerCharacter::mFieldActionInfo' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerDataList) == 0x000C18, "Member 'APlayerCharacter::PlayerDataList' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WaitTimeToFade) == 0x000C68, "Member 'APlayerCharacter::WaitTimeToFade' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RecordIntervalOfSafePoint) == 0x000C6C, "Member 'APlayerCharacter::RecordIntervalOfSafePoint' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, mForceMoveTimerHandle) == 0x000C80, "Member 'APlayerCharacter::mForceMoveTimerHandle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FieldActionList) == 0x000C88, "Member 'APlayerCharacter::FieldActionList' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LinkSystem) == 0x000CD8, "Member 'APlayerCharacter::LinkSystem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, mLeftEyeEffect) == 0x000CE0, "Member 'APlayerCharacter::mLeftEyeEffect' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, mRightEyeEffect) == 0x000CE8, "Member 'APlayerCharacter::mRightEyeEffect' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TargetSystem) == 0x000CF0, "Member 'APlayerCharacter::TargetSystem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CommunicationSystem) == 0x000CF8, "Member 'APlayerCharacter::CommunicationSystem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FootEffectSystem) == 0x000D10, "Member 'APlayerCharacter::FootEffectSystem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FieldActMotionList) == 0x000D30, "Member 'APlayerCharacter::FieldActMotionList' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RideMotionList) == 0x000D38, "Member 'APlayerCharacter::RideMotionList' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TransformInfoUIForDebug) == 0x000D60, "Member 'APlayerCharacter::TransformInfoUIForDebug' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CompassClass) == 0x000D80, "Member 'APlayerCharacter::CompassClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, mCompass) == 0x000D88, "Member 'APlayerCharacter::mCompass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ReplicaStampOffset) == 0x000D98, "Member 'APlayerCharacter::ReplicaStampOffset' has a wrong offset!");

// Class DarwinGame.PlayerCharacterOnUI
// 0x0050 (0x0C30 - 0x0BE0)
class APlayerCharacterOnUI : public AGPACharacter
{
public:
	TMap<class FName, class UPlayerDataAsset*>    PlayerDataList;                                    // 0x0BE0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacterOnUI">();
	}
	static class APlayerCharacterOnUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCharacterOnUI>();
	}
};
static_assert(alignof(APlayerCharacterOnUI) == 0x000010, "Wrong alignment on APlayerCharacterOnUI");
static_assert(sizeof(APlayerCharacterOnUI) == 0x000C30, "Wrong size on APlayerCharacterOnUI");
static_assert(offsetof(APlayerCharacterOnUI, PlayerDataList) == 0x000BE0, "Member 'APlayerCharacterOnUI::PlayerDataList' has a wrong offset!");

// Class DarwinGame.PlayerDataAsset
// 0x00A0 (0x00D8 - 0x0038)
class UPlayerDataAsset final : public UPrimaryDataAsset
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimClass;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCueSheet*                     UseCueSheet;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BattleMotionList;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TouchAttackCollisionList;                          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FieldActMotionList;                                // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RideMotionList;                                    // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UBlendSpaceBase*>     mRideMotionList;                                   // 0x0070(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             EmoteDataTable;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          EmoteFacialAnim;                                   // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFootprintDataAsset*                    FootprintAsset;                                    // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDataAsset">();
	}
	static class UPlayerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDataAsset>();
	}
};
static_assert(alignof(UPlayerDataAsset) == 0x000008, "Wrong alignment on UPlayerDataAsset");
static_assert(sizeof(UPlayerDataAsset) == 0x0000D8, "Wrong size on UPlayerDataAsset");
static_assert(offsetof(UPlayerDataAsset, Mesh) == 0x000038, "Member 'UPlayerDataAsset::Mesh' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, AnimClass) == 0x000040, "Member 'UPlayerDataAsset::AnimClass' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, UseCueSheet) == 0x000048, "Member 'UPlayerDataAsset::UseCueSheet' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, BattleMotionList) == 0x000050, "Member 'UPlayerDataAsset::BattleMotionList' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, TouchAttackCollisionList) == 0x000058, "Member 'UPlayerDataAsset::TouchAttackCollisionList' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, FieldActMotionList) == 0x000060, "Member 'UPlayerDataAsset::FieldActMotionList' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, RideMotionList) == 0x000068, "Member 'UPlayerDataAsset::RideMotionList' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, mRideMotionList) == 0x000070, "Member 'UPlayerDataAsset::mRideMotionList' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, EmoteDataTable) == 0x0000C0, "Member 'UPlayerDataAsset::EmoteDataTable' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, EmoteFacialAnim) == 0x0000C8, "Member 'UPlayerDataAsset::EmoteFacialAnim' has a wrong offset!");
static_assert(offsetof(UPlayerDataAsset, FootprintAsset) == 0x0000D0, "Member 'UPlayerDataAsset::FootprintAsset' has a wrong offset!");

// Class DarwinGame.PlayerDefaultWeaponDataTable
// 0x0000 (0x0030 - 0x0030)
class UPlayerDefaultWeaponDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDefaultWeaponDataTable">();
	}
	static class UPlayerDefaultWeaponDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDefaultWeaponDataTable>();
	}
};
static_assert(alignof(UPlayerDefaultWeaponDataTable) == 0x000008, "Wrong alignment on UPlayerDefaultWeaponDataTable");
static_assert(sizeof(UPlayerDefaultWeaponDataTable) == 0x000030, "Wrong size on UPlayerDefaultWeaponDataTable");

// Class DarwinGame.PlayMeNotify
// 0x0010 (0x0050 - 0x0040)
class UPlayMeNotify final : public UAnimNotify
{
public:
	class FString                                 CueName;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayMeNotify">();
	}
	static class UPlayMeNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayMeNotify>();
	}
};
static_assert(alignof(UPlayMeNotify) == 0x000008, "Wrong alignment on UPlayMeNotify");
static_assert(sizeof(UPlayMeNotify) == 0x000050, "Wrong size on UPlayMeNotify");
static_assert(offsetof(UPlayMeNotify, CueName) == 0x000040, "Member 'UPlayMeNotify::CueName' has a wrong offset!");

// Class DarwinGame.PlayReserveMotion
// 0x0000 (0x0038 - 0x0038)
class UPlayReserveMotion final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayReserveMotion">();
	}
	static class UPlayReserveMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayReserveMotion>();
	}
};
static_assert(alignof(UPlayReserveMotion) == 0x000008, "Wrong alignment on UPlayReserveMotion");
static_assert(sizeof(UPlayReserveMotion) == 0x000038, "Wrong size on UPlayReserveMotion");

// Class DarwinGame.PlayVoiceNotify
// 0x0028 (0x0068 - 0x0040)
class UPlayVoiceNotify final : public UAnimNotify
{
public:
	class FName                                   SheetName;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 CueName;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachedBoneName;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESoundInsulationType                          SIType;                                            // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayVoiceNotify">();
	}
	static class UPlayVoiceNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayVoiceNotify>();
	}
};
static_assert(alignof(UPlayVoiceNotify) == 0x000008, "Wrong alignment on UPlayVoiceNotify");
static_assert(sizeof(UPlayVoiceNotify) == 0x000068, "Wrong size on UPlayVoiceNotify");
static_assert(offsetof(UPlayVoiceNotify, SheetName) == 0x000040, "Member 'UPlayVoiceNotify::SheetName' has a wrong offset!");
static_assert(offsetof(UPlayVoiceNotify, CueName) == 0x000048, "Member 'UPlayVoiceNotify::CueName' has a wrong offset!");
static_assert(offsetof(UPlayVoiceNotify, AttachedBoneName) == 0x000058, "Member 'UPlayVoiceNotify::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UPlayVoiceNotify, SIType) == 0x000060, "Member 'UPlayVoiceNotify::SIType' has a wrong offset!");

// Class DarwinGame.UIStation_CategoryIcon_L
// 0x0010 (0x04A8 - 0x0498)
class UUIStation_CategoryIcon_L final : public UUIStation_CategoryIconBase
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      CategoryTextureList;                               // 0x0498(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_CategoryIcon_L">();
	}
	static class UUIStation_CategoryIcon_L* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_CategoryIcon_L>();
	}
};
static_assert(alignof(UUIStation_CategoryIcon_L) == 0x000008, "Wrong alignment on UUIStation_CategoryIcon_L");
static_assert(sizeof(UUIStation_CategoryIcon_L) == 0x0004A8, "Wrong size on UUIStation_CategoryIcon_L");
static_assert(offsetof(UUIStation_CategoryIcon_L, CategoryTextureList) == 0x000498, "Member 'UUIStation_CategoryIcon_L::CategoryTextureList' has a wrong offset!");

// Class DarwinGame.PointEnvSoundController
// 0x0048 (0x0078 - 0x0030)
class UPointEnvSoundController : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             GenEnvSoundLoadList;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GenEnvSound;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGenSoundBaseComponent*>         NatureList;                                        // 0x0058(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGenSoundBaseComponent*>         CreatureList;                                      // 0x0068(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointEnvSoundController">();
	}
	static class UPointEnvSoundController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointEnvSoundController>();
	}
};
static_assert(alignof(UPointEnvSoundController) == 0x000008, "Wrong alignment on UPointEnvSoundController");
static_assert(sizeof(UPointEnvSoundController) == 0x000078, "Wrong size on UPointEnvSoundController");
static_assert(offsetof(UPointEnvSoundController, GenEnvSoundLoadList) == 0x000040, "Member 'UPointEnvSoundController::GenEnvSoundLoadList' has a wrong offset!");
static_assert(offsetof(UPointEnvSoundController, GenEnvSound) == 0x000048, "Member 'UPointEnvSoundController::GenEnvSound' has a wrong offset!");
static_assert(offsetof(UPointEnvSoundController, NatureList) == 0x000058, "Member 'UPointEnvSoundController::NatureList' has a wrong offset!");
static_assert(offsetof(UPointEnvSoundController, CreatureList) == 0x000068, "Member 'UPointEnvSoundController::CreatureList' has a wrong offset!");

// Class DarwinGame.PositionTraceRendering
// 0x0068 (0x0290 - 0x0228)
class APositionTraceRendering final : public AActor
{
public:
	class USceneCaptureComponent2D*               mSceneCapture2D;                                   // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UTextureRenderTarget2D*> mRenderTargetList;                                 // 0x0230(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PositionTraceRendering">();
	}
	static class APositionTraceRendering* GetDefaultObj()
	{
		return GetDefaultObjImpl<APositionTraceRendering>();
	}
};
static_assert(alignof(APositionTraceRendering) == 0x000008, "Wrong alignment on APositionTraceRendering");
static_assert(sizeof(APositionTraceRendering) == 0x000290, "Wrong size on APositionTraceRendering");
static_assert(offsetof(APositionTraceRendering, mSceneCapture2D) == 0x000228, "Member 'APositionTraceRendering::mSceneCapture2D' has a wrong offset!");
static_assert(offsetof(APositionTraceRendering, mRenderTargetList) == 0x000230, "Member 'APositionTraceRendering::mRenderTargetList' has a wrong offset!");

// Class DarwinGame.PushWaveBase
// 0x00F0 (0x03A0 - 0x02B0)
class APushWaveBase : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ObjectSize;                                        // 0x02B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Split;                                             // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingSpeed;                                       // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovingDistance;                                    // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBoxComponent*>                  BoxComponents;                                     // 0x02D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBoxComponent*>                  BlockBoxComponents;                                // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UBoxComponent*, class AEffectBase*> WaveEffects;                                       // 0x02F8(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UActionAbilitySystemComponent*          AbilitySystem;                                     // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x50];                                     // 0x0350(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitParam(const struct FVector& Size, int32 SplitNum, float Speed, float Distance);
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushWaveBase">();
	}
	static class APushWaveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APushWaveBase>();
	}
};
static_assert(alignof(APushWaveBase) == 0x000008, "Wrong alignment on APushWaveBase");
static_assert(sizeof(APushWaveBase) == 0x0003A0, "Wrong size on APushWaveBase");
static_assert(offsetof(APushWaveBase, ObjectSize) == 0x0002B8, "Member 'APushWaveBase::ObjectSize' has a wrong offset!");
static_assert(offsetof(APushWaveBase, Split) == 0x0002C4, "Member 'APushWaveBase::Split' has a wrong offset!");
static_assert(offsetof(APushWaveBase, MovingSpeed) == 0x0002C8, "Member 'APushWaveBase::MovingSpeed' has a wrong offset!");
static_assert(offsetof(APushWaveBase, MovingDistance) == 0x0002CC, "Member 'APushWaveBase::MovingDistance' has a wrong offset!");
static_assert(offsetof(APushWaveBase, BoxComponents) == 0x0002D8, "Member 'APushWaveBase::BoxComponents' has a wrong offset!");
static_assert(offsetof(APushWaveBase, BlockBoxComponents) == 0x0002E8, "Member 'APushWaveBase::BlockBoxComponents' has a wrong offset!");
static_assert(offsetof(APushWaveBase, WaveEffects) == 0x0002F8, "Member 'APushWaveBase::WaveEffects' has a wrong offset!");
static_assert(offsetof(APushWaveBase, AbilitySystem) == 0x000348, "Member 'APushWaveBase::AbilitySystem' has a wrong offset!");

// Class DarwinGame.QualityUpDataTable
// 0x0000 (0x0030 - 0x0030)
class UQualityUpDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QualityUpDataTable">();
	}
	static class UQualityUpDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQualityUpDataTable>();
	}
};
static_assert(alignof(UQualityUpDataTable) == 0x000008, "Wrong alignment on UQualityUpDataTable");
static_assert(sizeof(UQualityUpDataTable) == 0x000030, "Wrong size on UQualityUpDataTable");

// Class DarwinGame.RailSplineComponent
// 0x0000 (0x0510 - 0x0510)
class URailSplineComponent final : public USplineComponent
{
public:
	struct FVector GetClosestPointAndDistance(const struct FVector& Location, float* Distance);
	void GetLocationAndRotationAtDistance(float Distance, struct FVector* Location, struct FRotator* Rotation);
	struct FVector GetRailDirectionAtDistance(float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RailSplineComponent">();
	}
	static class URailSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URailSplineComponent>();
	}
};
static_assert(alignof(URailSplineComponent) == 0x000010, "Wrong alignment on URailSplineComponent");
static_assert(sizeof(URailSplineComponent) == 0x000510, "Wrong size on URailSplineComponent");

// Class DarwinGame.RectangleNoEntryArea
// 0x0020 (0x0300 - 0x02E0)
class ARectangleNoEntryArea final : public ANoEntryAreaBase
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BoxExtent;                                         // 0x02E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0xC];                                      // 0x02F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RectangleNoEntryArea">();
	}
	static class ARectangleNoEntryArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARectangleNoEntryArea>();
	}
};
static_assert(alignof(ARectangleNoEntryArea) == 0x000008, "Wrong alignment on ARectangleNoEntryArea");
static_assert(sizeof(ARectangleNoEntryArea) == 0x000300, "Wrong size on ARectangleNoEntryArea");
static_assert(offsetof(ARectangleNoEntryArea, BoxComponent) == 0x0002E0, "Member 'ARectangleNoEntryArea::BoxComponent' has a wrong offset!");
static_assert(offsetof(ARectangleNoEntryArea, BoxExtent) == 0x0002E8, "Member 'ARectangleNoEntryArea::BoxExtent' has a wrong offset!");

// Class DarwinGame.UIWinMenu_S_08
// 0x0008 (0x0628 - 0x0620)
class UUIWinMenu_S_08 final : public UUIWinMenuSimple
{
public:
	class UTextWidgetData*                        textData;                                          // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_08">();
	}
	static class UUIWinMenu_S_08* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_08>();
	}
};
static_assert(alignof(UUIWinMenu_S_08) == 0x000008, "Wrong alignment on UUIWinMenu_S_08");
static_assert(sizeof(UUIWinMenu_S_08) == 0x000628, "Wrong size on UUIWinMenu_S_08");
static_assert(offsetof(UUIWinMenu_S_08, textData) == 0x000620, "Member 'UUIWinMenu_S_08::textData' has a wrong offset!");

// Class DarwinGame.ReduceDamageAmountRequirement
// 0x0000 (0x0030 - 0x0030)
class UReduceDamageAmountRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReduceDamageAmountRequirement">();
	}
	static class UReduceDamageAmountRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReduceDamageAmountRequirement>();
	}
};
static_assert(alignof(UReduceDamageAmountRequirement) == 0x000008, "Wrong alignment on UReduceDamageAmountRequirement");
static_assert(sizeof(UReduceDamageAmountRequirement) == 0x000030, "Wrong size on UReduceDamageAmountRequirement");

// Class DarwinGame.ResistDataTable
// 0x0000 (0x0030 - 0x0030)
class UResistDataTable final : public UBlueprintFunctionLibrary
{
public:
	static float GetResistValue(class FName ID, int32 CalcType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResistDataTable">();
	}
	static class UResistDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResistDataTable>();
	}
};
static_assert(alignof(UResistDataTable) == 0x000008, "Wrong alignment on UResistDataTable");
static_assert(sizeof(UResistDataTable) == 0x000030, "Wrong size on UResistDataTable");

// Class DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class URivalTeamMonsterBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ExistAppearRivalTeamMonsterWithoutOwner(class AMonsterBase* Owner);
	static TArray<class AMonsterBase*> GetFootpadMonsters();
	static class ADropItemObject* GetNearestArtifactObject(class AMonsterBase* Monster);
	static class FText GetRivalTeamForceName(ERivalTeamForce RivalTeam);
	static TArray<class AMonsterBase*> GetRivalTeamMonsters();
	static TArray<class AMonsterBase*> GetRivalTeamMonstersHasArtifact();
	static TArray<ERivalTeamForce> GetTravelRivalTeamForce();
	static bool IsEventRivalTeamID(ERivalTeamForce RivalTeam);
	static bool IsRivalTeamMonster(const class AMonsterBase* Monster);
	static bool IsTravelRivalTeamForce(ERivalTeamForce RivalTeam);
	static void NoticeAccessArtifactByPlayer(class AArtifactObjectBase* Artifact);
	static void NoticeDropArtifact();
	static void NoticeWithdrawalRivalTeamMonster(class AMonsterBase* Monster);
	static void WithdrawalRivalTeam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RivalTeamMonsterBlueprintFunctionLibrary">();
	}
	static class URivalTeamMonsterBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URivalTeamMonsterBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(URivalTeamMonsterBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on URivalTeamMonsterBlueprintFunctionLibrary");
static_assert(sizeof(URivalTeamMonsterBlueprintFunctionLibrary) == 0x000030, "Wrong size on URivalTeamMonsterBlueprintFunctionLibrary");

// Class DarwinGame.RouteMap
// 0x00A8 (0x0358 - 0x02B0)
class ARouteMap final : public AFieldObjectBase
{
public:
	class FName                                   mStationID;                                        // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEffectBase>                mSmogEffectRes;                                    // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   mSmogEffectSocketName;                             // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          mIsBaseArea;                                       // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   mPreClearSealEventID;                              // 0x02CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   mClearSealEventID;                                 // 0x02D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   mPreClearReleaseEventID;                           // 0x02DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   mBaseAreaBattleConfirmTextID;                      // 0x02E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EC[0x5C];                                     // 0x02EC(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	class AEffectBase*                            mSmogEffect;                                       // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroySmogEffect();
	void PlayGearAnim();
	void SetReflectionRelease();
	void SetReflectionSeal();
	void SpawnSmogEffect();
	void StopGearAnim();
	void SwitchLightGradually(bool on);
	void SwitchPointLightGradually(bool on);

	class FName GetStationID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RouteMap">();
	}
	static class ARouteMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARouteMap>();
	}
};
static_assert(alignof(ARouteMap) == 0x000008, "Wrong alignment on ARouteMap");
static_assert(sizeof(ARouteMap) == 0x000358, "Wrong size on ARouteMap");
static_assert(offsetof(ARouteMap, mStationID) == 0x0002B0, "Member 'ARouteMap::mStationID' has a wrong offset!");
static_assert(offsetof(ARouteMap, mSmogEffectRes) == 0x0002B8, "Member 'ARouteMap::mSmogEffectRes' has a wrong offset!");
static_assert(offsetof(ARouteMap, mSmogEffectSocketName) == 0x0002C0, "Member 'ARouteMap::mSmogEffectSocketName' has a wrong offset!");
static_assert(offsetof(ARouteMap, mIsBaseArea) == 0x0002C8, "Member 'ARouteMap::mIsBaseArea' has a wrong offset!");
static_assert(offsetof(ARouteMap, mPreClearSealEventID) == 0x0002CC, "Member 'ARouteMap::mPreClearSealEventID' has a wrong offset!");
static_assert(offsetof(ARouteMap, mClearSealEventID) == 0x0002D4, "Member 'ARouteMap::mClearSealEventID' has a wrong offset!");
static_assert(offsetof(ARouteMap, mPreClearReleaseEventID) == 0x0002DC, "Member 'ARouteMap::mPreClearReleaseEventID' has a wrong offset!");
static_assert(offsetof(ARouteMap, mBaseAreaBattleConfirmTextID) == 0x0002E4, "Member 'ARouteMap::mBaseAreaBattleConfirmTextID' has a wrong offset!");
static_assert(offsetof(ARouteMap, mSmogEffect) == 0x000348, "Member 'ARouteMap::mSmogEffect' has a wrong offset!");

// Class DarwinGame.SaveManager
// 0x12E0 (0x1318 - 0x0038)
class USaveManager : public UManagerBase
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 mDefSlotName;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         mDefUserIndex;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameDatabase*                          mSaveGameData;                                     // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinSaveGame*                        mDarwinSaveGame;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x12A0];                                    // 0x0078(0x12A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USaveManager* GetInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveManager">();
	}
	static class USaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveManager>();
	}
};
static_assert(alignof(USaveManager) == 0x000008, "Wrong alignment on USaveManager");
static_assert(sizeof(USaveManager) == 0x001318, "Wrong size on USaveManager");
static_assert(offsetof(USaveManager, mDefSlotName) == 0x000050, "Member 'USaveManager::mDefSlotName' has a wrong offset!");
static_assert(offsetof(USaveManager, mDefUserIndex) == 0x000060, "Member 'USaveManager::mDefUserIndex' has a wrong offset!");
static_assert(offsetof(USaveManager, mSaveGameData) == 0x000068, "Member 'USaveManager::mSaveGameData' has a wrong offset!");
static_assert(offsetof(USaveManager, mDarwinSaveGame) == 0x000070, "Member 'USaveManager::mDarwinSaveGame' has a wrong offset!");

// Class DarwinGame.SearchInArea
// 0x0000 (0x0038 - 0x0038)
class USearchInArea final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchInArea">();
	}
	static class USearchInArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchInArea>();
	}
};
static_assert(alignof(USearchInArea) == 0x000008, "Wrong alignment on USearchInArea");
static_assert(sizeof(USearchInArea) == 0x000038, "Wrong size on USearchInArea");

// Class DarwinGame.SequencerController
// 0x0080 (0x0138 - 0x00B8)
class USequencerController : public UActorComponent
{
public:
	class ULevelSequencePlayer*                   MainLevelSequencePlayer;                           // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    MainLevelSequenceActor;                            // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   PlayingSubLevelSequencePlayer;                     // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    PlayingSubLevelSequenceActor;                      // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequencePlayer*                   PlayedSubLevelSequencePlayer;                      // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FST_SequencerRebindOrder> RebindOrders;                                      // 0x00E0(0x0050)(BlueprintVisible, NativeAccessSpecifierPrivate)
	ESequenserPlayState                           SequencerPlayState;                                // 0x0130(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMap<class FString, struct FST_SequencerRebindOrder> GetRebindOrders();
	void PlayLevelSequence();
	void PlaySubLevelSequencer();
	void SetPlayLevelSequence(class ALevelSequenceActor* PlayMainLevelSequenceActor, class ULevelSequencePlayer* PlayMainLevelSequencePlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerController">();
	}
	static class USequencerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencerController>();
	}
};
static_assert(alignof(USequencerController) == 0x000008, "Wrong alignment on USequencerController");
static_assert(sizeof(USequencerController) == 0x000138, "Wrong size on USequencerController");
static_assert(offsetof(USequencerController, MainLevelSequencePlayer) == 0x0000B8, "Member 'USequencerController::MainLevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(USequencerController, MainLevelSequenceActor) == 0x0000C0, "Member 'USequencerController::MainLevelSequenceActor' has a wrong offset!");
static_assert(offsetof(USequencerController, PlayingSubLevelSequencePlayer) == 0x0000C8, "Member 'USequencerController::PlayingSubLevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(USequencerController, PlayingSubLevelSequenceActor) == 0x0000D0, "Member 'USequencerController::PlayingSubLevelSequenceActor' has a wrong offset!");
static_assert(offsetof(USequencerController, PlayedSubLevelSequencePlayer) == 0x0000D8, "Member 'USequencerController::PlayedSubLevelSequencePlayer' has a wrong offset!");
static_assert(offsetof(USequencerController, RebindOrders) == 0x0000E0, "Member 'USequencerController::RebindOrders' has a wrong offset!");
static_assert(offsetof(USequencerController, SequencerPlayState) == 0x000130, "Member 'USequencerController::SequencerPlayState' has a wrong offset!");

// Class DarwinGame.ShotgunMagicBase
// 0x0060 (0x0350 - 0x02F0)
class alignas(0x10) AShotgunMagicBase final : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x58];                                     // 0x02F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndOfLife();
	void GenerateShotgunAllCollisions();
	void GenerateShotgunCollision();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShotgunMagicBase">();
	}
	static class AShotgunMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShotgunMagicBase>();
	}
};
static_assert(alignof(AShotgunMagicBase) == 0x000010, "Wrong alignment on AShotgunMagicBase");
static_assert(sizeof(AShotgunMagicBase) == 0x000350, "Wrong size on AShotgunMagicBase");
static_assert(offsetof(AShotgunMagicBase, collision) == 0x0002F0, "Member 'AShotgunMagicBase::collision' has a wrong offset!");

// Class DarwinGame.UISkillPop_Count_00
// 0x0008 (0x0498 - 0x0490)
class UUISkillPop_Count_00 : public UDarwinUserWidget
{
public:
	class UImage*                                 NumberImage;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISkillPop_Count_00">();
	}
	static class UUISkillPop_Count_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISkillPop_Count_00>();
	}
};
static_assert(alignof(UUISkillPop_Count_00) == 0x000008, "Wrong alignment on UUISkillPop_Count_00");
static_assert(sizeof(UUISkillPop_Count_00) == 0x000498, "Wrong size on UUISkillPop_Count_00");
static_assert(offsetof(UUISkillPop_Count_00, NumberImage) == 0x000490, "Member 'UUISkillPop_Count_00::NumberImage' has a wrong offset!");

// Class DarwinGame.SimpleModeAnimInstance
// 0x0000 (0x0270 - 0x0270)
class USimpleModeAnimInstance final : public UModeAnimInstance
{
public:
	void PlayMode(EModeAnimMode Mode);
	void SetMode(EModeAnimMode Mode);

	bool IsModeAndPlayAnimation(EModeAnimMode Mode) const;
	bool IsModeAndSkipAnimation(EModeAnimMode Mode) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleModeAnimInstance">();
	}
	static class USimpleModeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleModeAnimInstance>();
	}
};
static_assert(alignof(USimpleModeAnimInstance) == 0x000010, "Wrong alignment on USimpleModeAnimInstance");
static_assert(sizeof(USimpleModeAnimInstance) == 0x000270, "Wrong size on USimpleModeAnimInstance");

// Class DarwinGame.SkillChainEffectCue
// 0x0000 (0x0298 - 0x0298)
class ASkillChainEffectCue : public AGameplayCueNotify_Actor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillChainEffectCue">();
	}
	static class ASkillChainEffectCue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkillChainEffectCue>();
	}
};
static_assert(alignof(ASkillChainEffectCue) == 0x000008, "Wrong alignment on ASkillChainEffectCue");
static_assert(sizeof(ASkillChainEffectCue) == 0x000298, "Wrong size on ASkillChainEffectCue");

// Class DarwinGame.SlingShot
// 0x0030 (0x0288 - 0x0258)
class ASlingShot : public AWeaponBase
{
public:
	class ABulletPath*                            Path;                                              // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0xC];                                      // 0x0260(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HandSocketName;                                    // 0x026C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTangentScale;                                 // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTangentScale;                                   // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalScale;                                     // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalScale;                                   // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtDistance;                                    // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Grab(float Alpha);
	void SetHandSocketName();
	void Shot(const class FName ItemId, const class FName actionDetailID, const struct FActionGameplayEffectContainerSpec& Spec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlingShot">();
	}
	static class ASlingShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlingShot>();
	}
};
static_assert(alignof(ASlingShot) == 0x000008, "Wrong alignment on ASlingShot");
static_assert(sizeof(ASlingShot) == 0x000288, "Wrong size on ASlingShot");
static_assert(offsetof(ASlingShot, Path) == 0x000258, "Member 'ASlingShot::Path' has a wrong offset!");
static_assert(offsetof(ASlingShot, HandSocketName) == 0x00026C, "Member 'ASlingShot::HandSocketName' has a wrong offset!");
static_assert(offsetof(ASlingShot, StartTangentScale) == 0x000274, "Member 'ASlingShot::StartTangentScale' has a wrong offset!");
static_assert(offsetof(ASlingShot, EndTangentScale) == 0x000278, "Member 'ASlingShot::EndTangentScale' has a wrong offset!");
static_assert(offsetof(ASlingShot, VerticalScale) == 0x00027C, "Member 'ASlingShot::VerticalScale' has a wrong offset!");
static_assert(offsetof(ASlingShot, HorizontalScale) == 0x000280, "Member 'ASlingShot::HorizontalScale' has a wrong offset!");
static_assert(offsetof(ASlingShot, LookAtDistance) == 0x000284, "Member 'ASlingShot::LookAtDistance' has a wrong offset!");

// Class DarwinGame.SofdecMoviePlayer
// 0x0000 (0x0228 - 0x0228)
class ASofdecMoviePlayer final : public AActor
{
public:
	class UManaComponent* GetPlayer();
	bool IsEnd();
	void Play();
	bool Prepare(const class FName& Path);
	void SetPlayerTickableWhenPaused(bool bTickableWhenPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SofdecMoviePlayer">();
	}
	static class ASofdecMoviePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASofdecMoviePlayer>();
	}
};
static_assert(alignof(ASofdecMoviePlayer) == 0x000008, "Wrong alignment on ASofdecMoviePlayer");
static_assert(sizeof(ASofdecMoviePlayer) == 0x000228, "Wrong size on ASofdecMoviePlayer");

// Class DarwinGame.SoundManagerActor
// 0x0010 (0x0238 - 0x0228)
class ASoundManagerActor final : public AActor
{
public:
	class USceneComponent*                        FadeTask;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        GenSoundTask;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundManagerActor">();
	}
	static class ASoundManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundManagerActor>();
	}
};
static_assert(alignof(ASoundManagerActor) == 0x000008, "Wrong alignment on ASoundManagerActor");
static_assert(sizeof(ASoundManagerActor) == 0x000238, "Wrong size on ASoundManagerActor");
static_assert(offsetof(ASoundManagerActor, FadeTask) == 0x000228, "Member 'ASoundManagerActor::FadeTask' has a wrong offset!");
static_assert(offsetof(ASoundManagerActor, GenSoundTask) == 0x000230, "Member 'ASoundManagerActor::GenSoundTask' has a wrong offset!");

// Class DarwinGame.SoundPoolManager
// 0x0020 (0x0050 - 0x0030)
class USoundPoolManager final : public UObject
{
public:
	uint8                                         Pad_30[0x1];                                       // 0x0030(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsInitialze;                                       // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundPoolObject*>               Heap;                                              // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Num;                                               // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPoolManager">();
	}
	static class USoundPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPoolManager>();
	}
};
static_assert(alignof(USoundPoolManager) == 0x000008, "Wrong alignment on USoundPoolManager");
static_assert(sizeof(USoundPoolManager) == 0x000050, "Wrong size on USoundPoolManager");
static_assert(offsetof(USoundPoolManager, IsInitialze) == 0x000031, "Member 'USoundPoolManager::IsInitialze' has a wrong offset!");
static_assert(offsetof(USoundPoolManager, Heap) == 0x000038, "Member 'USoundPoolManager::Heap' has a wrong offset!");
static_assert(offsetof(USoundPoolManager, Num) == 0x000048, "Member 'USoundPoolManager::Num' has a wrong offset!");

// Class DarwinGame.UITreasureHouse_WinSort
// 0x0080 (0x0650 - 0x05D0)
class UUITreasureHouse_WinSort : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     SortBtnList;                                       // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIScrollMenuItemBase*>          CategoryFilterBtnList;                             // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIScrollMenuItemBase*>          MenuBtnList;                                       // 0x0600(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x40];                                     // 0x0610(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureHouse_WinSort">();
	}
	static class UUITreasureHouse_WinSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureHouse_WinSort>();
	}
};
static_assert(alignof(UUITreasureHouse_WinSort) == 0x000008, "Wrong alignment on UUITreasureHouse_WinSort");
static_assert(sizeof(UUITreasureHouse_WinSort) == 0x000650, "Wrong size on UUITreasureHouse_WinSort");
static_assert(offsetof(UUITreasureHouse_WinSort, SortBtnList) == 0x0005E0, "Member 'UUITreasureHouse_WinSort::SortBtnList' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_WinSort, CategoryFilterBtnList) == 0x0005F0, "Member 'UUITreasureHouse_WinSort::CategoryFilterBtnList' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_WinSort, MenuBtnList) == 0x000600, "Member 'UUITreasureHouse_WinSort::MenuBtnList' has a wrong offset!");

// Class DarwinGame.SoundTest
// 0x0000 (0x0490 - 0x0490)
class USoundTest final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundTest">();
	}
	static class USoundTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundTest>();
	}
};
static_assert(alignof(USoundTest) == 0x000008, "Wrong alignment on USoundTest");
static_assert(sizeof(USoundTest) == 0x000490, "Wrong size on USoundTest");

// Class DarwinGame.SpawnPointBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class USpawnPointBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointBlueprintFunctionLibrary">();
	}
	static class USpawnPointBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPointBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(USpawnPointBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on USpawnPointBlueprintFunctionLibrary");
static_assert(sizeof(USpawnPointBlueprintFunctionLibrary) == 0x000030, "Wrong size on USpawnPointBlueprintFunctionLibrary");

// Class DarwinGame.StationBase
// 0x0070 (0x0320 - 0x02B0)
class AStationBase final : public AFieldObjectBase
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            mSealFlagMesh;                                     // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            mReleaseFlagMesh;                                  // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x58];                                     // 0x02C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeReleaseFlag();
	void EnableLine(float Time);
	void EnableTeamFlag();
	void ForcePlacementTrain();
	void PlaySmogEffect();
	void StopSmogEffect();
	void SwitchLightGradually(bool on);

	void GetTrainGuide(struct FVector* OutStopLocation, struct FVector* OutInboundVector) const;
	struct FVector GetTrainGuideInboundVector() const;
	struct FVector GetTrainGuideStopLocation() const;
	bool IsRelease() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationBase">();
	}
	static class AStationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStationBase>();
	}
};
static_assert(alignof(AStationBase) == 0x000008, "Wrong alignment on AStationBase");
static_assert(sizeof(AStationBase) == 0x000320, "Wrong size on AStationBase");
static_assert(offsetof(AStationBase, mSealFlagMesh) == 0x0002B8, "Member 'AStationBase::mSealFlagMesh' has a wrong offset!");
static_assert(offsetof(AStationBase, mReleaseFlagMesh) == 0x0002C0, "Member 'AStationBase::mReleaseFlagMesh' has a wrong offset!");

// Class DarwinGame.StreamingLevelData
// 0x0318 (0x0350 - 0x0038)
class UStreamingLevelData final : public UDataAsset
{
public:
	TMap<EAreaType, struct FST_StreamingLevelDataBase> AreaStreamingData;                                 // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FST_BaseStreamingLevelData             BaseStreamingLevelData;                            // 0x0088(0x00C8)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FST_FaskullStreamingLevelData          FaskullStreamingLevelData;                         // 0x0150(0x0110)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FST_DungeonStreamingLevelData          DungeonStreamingLevelData;                         // 0x0260(0x00B0)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FST_AmbientStreamingLevelData          AmbientStreamingLevelData;                         // 0x0310(0x0040)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();
	void m________________________________();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamingLevelData">();
	}
	static class UStreamingLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamingLevelData>();
	}
};
static_assert(alignof(UStreamingLevelData) == 0x000008, "Wrong alignment on UStreamingLevelData");
static_assert(sizeof(UStreamingLevelData) == 0x000350, "Wrong size on UStreamingLevelData");
static_assert(offsetof(UStreamingLevelData, AreaStreamingData) == 0x000038, "Member 'UStreamingLevelData::AreaStreamingData' has a wrong offset!");
static_assert(offsetof(UStreamingLevelData, BaseStreamingLevelData) == 0x000088, "Member 'UStreamingLevelData::BaseStreamingLevelData' has a wrong offset!");
static_assert(offsetof(UStreamingLevelData, FaskullStreamingLevelData) == 0x000150, "Member 'UStreamingLevelData::FaskullStreamingLevelData' has a wrong offset!");
static_assert(offsetof(UStreamingLevelData, DungeonStreamingLevelData) == 0x000260, "Member 'UStreamingLevelData::DungeonStreamingLevelData' has a wrong offset!");
static_assert(offsetof(UStreamingLevelData, AmbientStreamingLevelData) == 0x000310, "Member 'UStreamingLevelData::AmbientStreamingLevelData' has a wrong offset!");

// Class DarwinGame.StunRequirement
// 0x0000 (0x0030 - 0x0030)
class UStunRequirement final : public UGameplayEffectCustomApplicationRequirement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunRequirement">();
	}
	static class UStunRequirement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStunRequirement>();
	}
};
static_assert(alignof(UStunRequirement) == 0x000008, "Wrong alignment on UStunRequirement");
static_assert(sizeof(UStunRequirement) == 0x000030, "Wrong size on UStunRequirement");

// Class DarwinGame.TargetObjectDataAsset
// 0x00A0 (0x00D8 - 0x0038)
class UTargetObjectDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FST_TargetObjectData> mDataList;                                         // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<ETargetObjectType, TSoftClassPtr<class UClass>> mTargetObjectPairBPList;                           // 0x0088(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetObjectDataAsset">();
	}
	static class UTargetObjectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetObjectDataAsset>();
	}
};
static_assert(alignof(UTargetObjectDataAsset) == 0x000008, "Wrong alignment on UTargetObjectDataAsset");
static_assert(sizeof(UTargetObjectDataAsset) == 0x0000D8, "Wrong size on UTargetObjectDataAsset");
static_assert(offsetof(UTargetObjectDataAsset, mDataList) == 0x000038, "Member 'UTargetObjectDataAsset::mDataList' has a wrong offset!");
static_assert(offsetof(UTargetObjectDataAsset, mTargetObjectPairBPList) == 0x000088, "Member 'UTargetObjectDataAsset::mTargetObjectPairBPList' has a wrong offset!");

// Class DarwinGame.TargetObjectDataTable
// 0x0000 (0x0030 - 0x0030)
class UTargetObjectDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetObjectDataTable">();
	}
	static class UTargetObjectDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetObjectDataTable>();
	}
};
static_assert(alignof(UTargetObjectDataTable) == 0x000008, "Wrong alignment on UTargetObjectDataTable");
static_assert(sizeof(UTargetObjectDataTable) == 0x000030, "Wrong size on UTargetObjectDataTable");

// Class DarwinGame.ThunderCloudMagicBase
// 0x0078 (0x0368 - 0x02F0)
class AThunderCloudMagicBase final : public AMagicBase
{
public:
	class USphereComponent*                       collision;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x70];                                     // 0x02F8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThunderCloudMagicBase">();
	}
	static class AThunderCloudMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThunderCloudMagicBase>();
	}
};
static_assert(alignof(AThunderCloudMagicBase) == 0x000008, "Wrong alignment on AThunderCloudMagicBase");
static_assert(sizeof(AThunderCloudMagicBase) == 0x000368, "Wrong size on AThunderCloudMagicBase");
static_assert(offsetof(AThunderCloudMagicBase, collision) == 0x0002F0, "Member 'AThunderCloudMagicBase::collision' has a wrong offset!");

// Class DarwinGame.TimerRemaining
// 0x0000 (0x0038 - 0x0038)
class UTimerRemaining final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerRemaining">();
	}
	static class UTimerRemaining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimerRemaining>();
	}
};
static_assert(alignof(UTimerRemaining) == 0x000008, "Wrong alignment on UTimerRemaining");
static_assert(sizeof(UTimerRemaining) == 0x000038, "Wrong size on UTimerRemaining");

// Class DarwinGame.TimeScaleComponent
// 0x0018 (0x00D0 - 0x00B8)
class UTimeScaleComponent final : public UActorComponent
{
public:
	bool                                          UseHitStop;                                        // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggerActorHitStop;                             // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTriggerAttackActorHitStop;                       // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           HitStopTimer;                                      // 0x00C0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndHitStop();
	bool IsActivateHitStop(class AActor* Attacker, class FName actionDetailID, bool ExternalTrigger);
	void ResetTimeScale();
	void SetTimeScale(float Scale);
	void StartHitStop(float stopMsTime);

	float GetTimeScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeScaleComponent">();
	}
	static class UTimeScaleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeScaleComponent>();
	}
};
static_assert(alignof(UTimeScaleComponent) == 0x000008, "Wrong alignment on UTimeScaleComponent");
static_assert(sizeof(UTimeScaleComponent) == 0x0000D0, "Wrong size on UTimeScaleComponent");
static_assert(offsetof(UTimeScaleComponent, UseHitStop) == 0x0000B8, "Member 'UTimeScaleComponent::UseHitStop' has a wrong offset!");
static_assert(offsetof(UTimeScaleComponent, IsTriggerActorHitStop) == 0x0000B9, "Member 'UTimeScaleComponent::IsTriggerActorHitStop' has a wrong offset!");
static_assert(offsetof(UTimeScaleComponent, IsTriggerAttackActorHitStop) == 0x0000BA, "Member 'UTimeScaleComponent::IsTriggerAttackActorHitStop' has a wrong offset!");
static_assert(offsetof(UTimeScaleComponent, HitStopTimer) == 0x0000C0, "Member 'UTimeScaleComponent::HitStopTimer' has a wrong offset!");

// Class DarwinGame.UISign_IconAreaBase
// 0x0008 (0x0498 - 0x0490)
class UUISign_IconAreaBase : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(const class FName& ID, const class FText& AreaName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconAreaBase">();
	}
	static class UUISign_IconAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconAreaBase>();
	}
};
static_assert(alignof(UUISign_IconAreaBase) == 0x000008, "Wrong alignment on UUISign_IconAreaBase");
static_assert(sizeof(UUISign_IconAreaBase) == 0x000498, "Wrong size on UUISign_IconAreaBase");

// Class DarwinGame.UISign_IconArea02
// 0x0000 (0x0498 - 0x0498)
class UUISign_IconArea02 : public UUISign_IconAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconArea02">();
	}
	static class UUISign_IconArea02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconArea02>();
	}
};
static_assert(alignof(UUISign_IconArea02) == 0x000008, "Wrong alignment on UUISign_IconArea02");
static_assert(sizeof(UUISign_IconArea02) == 0x000498, "Wrong size on UUISign_IconArea02");

// Class DarwinGame.TipsOpenConditionsChecker
// 0x0008 (0x0038 - 0x0030)
class UTipsOpenConditionsChecker : public UObject
{
public:
	class UDataTable*                             DT_TipsConditions;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TipsOpenConditionsChecker">();
	}
	static class UTipsOpenConditionsChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTipsOpenConditionsChecker>();
	}
};
static_assert(alignof(UTipsOpenConditionsChecker) == 0x000008, "Wrong alignment on UTipsOpenConditionsChecker");
static_assert(sizeof(UTipsOpenConditionsChecker) == 0x000038, "Wrong size on UTipsOpenConditionsChecker");
static_assert(offsetof(UTipsOpenConditionsChecker, DT_TipsConditions) == 0x000030, "Member 'UTipsOpenConditionsChecker::DT_TipsConditions' has a wrong offset!");

// Class DarwinGame.TornadoMagicBase
// 0x00B0 (0x03C0 - 0x0310)
class alignas(0x10) ATornadoMagicBase final : public AProjectileMagicBase
{
public:
	class UCapsuleComponent*                      CapsuleCollision;                                  // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0xA8];                                     // 0x0318(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HomingOff();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TornadoMagicBase">();
	}
	static class ATornadoMagicBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATornadoMagicBase>();
	}
};
static_assert(alignof(ATornadoMagicBase) == 0x000010, "Wrong alignment on ATornadoMagicBase");
static_assert(sizeof(ATornadoMagicBase) == 0x0003C0, "Wrong size on ATornadoMagicBase");
static_assert(offsetof(ATornadoMagicBase, CapsuleCollision) == 0x000310, "Member 'ATornadoMagicBase::CapsuleCollision' has a wrong offset!");

// Class DarwinGame.TreasureBoxBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTreasureBoxBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureBoxBlueprintFunctionLibrary">();
	}
	static class UTreasureBoxBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTreasureBoxBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UTreasureBoxBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UTreasureBoxBlueprintFunctionLibrary");
static_assert(sizeof(UTreasureBoxBlueprintFunctionLibrary) == 0x000030, "Wrong size on UTreasureBoxBlueprintFunctionLibrary");

// Class DarwinGame.TreasureIslandPedestalManager
// 0x0028 (0x02D8 - 0x02B0)
class ATreasureIslandPedestalManager final : public AFieldObjectBase
{
public:
	class FName                                   mEventID;                                          // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureIslandPedestalManager">();
	}
	static class ATreasureIslandPedestalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureIslandPedestalManager>();
	}
};
static_assert(alignof(ATreasureIslandPedestalManager) == 0x000008, "Wrong alignment on ATreasureIslandPedestalManager");
static_assert(sizeof(ATreasureIslandPedestalManager) == 0x0002D8, "Wrong size on ATreasureIslandPedestalManager");
static_assert(offsetof(ATreasureIslandPedestalManager, mEventID) == 0x0002B0, "Member 'ATreasureIslandPedestalManager::mEventID' has a wrong offset!");

// Class DarwinGame.UITitle_WinGuidelines
// 0x0020 (0x05F0 - 0x05D0)
class UUITitle_WinGuidelines final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIIconChoice*                          IconChoice;                                        // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUINetWorkWinTermsText*                 TermsText;                                         // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TitleText;                                         // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_WinGuidelines">();
	}
	static class UUITitle_WinGuidelines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_WinGuidelines>();
	}
};
static_assert(alignof(UUITitle_WinGuidelines) == 0x000008, "Wrong alignment on UUITitle_WinGuidelines");
static_assert(sizeof(UUITitle_WinGuidelines) == 0x0005F0, "Wrong size on UUITitle_WinGuidelines");
static_assert(offsetof(UUITitle_WinGuidelines, IconChoice) == 0x0005D8, "Member 'UUITitle_WinGuidelines::IconChoice' has a wrong offset!");
static_assert(offsetof(UUITitle_WinGuidelines, TermsText) == 0x0005E0, "Member 'UUITitle_WinGuidelines::TermsText' has a wrong offset!");
static_assert(offsetof(UUITitle_WinGuidelines, TitleText) == 0x0005E8, "Member 'UUITitle_WinGuidelines::TitleText' has a wrong offset!");

// Class DarwinGame.TrialFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTrialFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsTrial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrialFunctionLibrary">();
	}
	static class UTrialFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrialFunctionLibrary>();
	}
};
static_assert(alignof(UTrialFunctionLibrary) == 0x000008, "Wrong alignment on UTrialFunctionLibrary");
static_assert(sizeof(UTrialFunctionLibrary) == 0x000030, "Wrong size on UTrialFunctionLibrary");

// Class DarwinGame.UISign_IconLvupStatus
// 0x0048 (0x04D8 - 0x0490)
class UUISign_IconLvupStatus : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StatusList;                                        // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           StatusNameList;                                    // 0x04B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NowAnim;                                           // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastEndStatusUp();
	void RequestStatusUp();
	void SetIsStatusIcon(bool IsIcon);
	void SetStatusList(int32 InLevel, int32 InBeforeLevel, class FName InCharacterID, int32 InUid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconLvupStatus">();
	}
	static class UUISign_IconLvupStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconLvupStatus>();
	}
};
static_assert(alignof(UUISign_IconLvupStatus) == 0x000008, "Wrong alignment on UUISign_IconLvupStatus");
static_assert(sizeof(UUISign_IconLvupStatus) == 0x0004D8, "Wrong size on UUISign_IconLvupStatus");
static_assert(offsetof(UUISign_IconLvupStatus, StatusList) == 0x0004A8, "Member 'UUISign_IconLvupStatus::StatusList' has a wrong offset!");
static_assert(offsetof(UUISign_IconLvupStatus, StatusNameList) == 0x0004B8, "Member 'UUISign_IconLvupStatus::StatusNameList' has a wrong offset!");
static_assert(offsetof(UUISign_IconLvupStatus, NowAnim) == 0x0004C8, "Member 'UUISign_IconLvupStatus::NowAnim' has a wrong offset!");

// Class DarwinGame.UIAlert_00
// 0x0020 (0x0638 - 0x0618)
class UUIAlert_00 : public UUIAlertBase
{
public:
	float                                         MoveSpeed;                                         // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartWidthPos;                                     // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       TopSlot;                                           // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x10];                                     // 0x0628(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAlert_00">();
	}
	static class UUIAlert_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAlert_00>();
	}
};
static_assert(alignof(UUIAlert_00) == 0x000008, "Wrong alignment on UUIAlert_00");
static_assert(sizeof(UUIAlert_00) == 0x000638, "Wrong size on UUIAlert_00");
static_assert(offsetof(UUIAlert_00, MoveSpeed) == 0x000618, "Member 'UUIAlert_00::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UUIAlert_00, StartWidthPos) == 0x00061C, "Member 'UUIAlert_00::StartWidthPos' has a wrong offset!");
static_assert(offsetof(UUIAlert_00, TopSlot) == 0x000620, "Member 'UUIAlert_00::TopSlot' has a wrong offset!");

// Class DarwinGame.UIAlert_01
// 0x0000 (0x0618 - 0x0618)
class UUIAlert_01 : public UUIAlertBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAlert_01">();
	}
	static class UUIAlert_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAlert_01>();
	}
};
static_assert(alignof(UUIAlert_01) == 0x000008, "Wrong alignment on UUIAlert_01");
static_assert(sizeof(UUIAlert_01) == 0x000618, "Wrong size on UUIAlert_01");

// Class DarwinGame.UIAppraise_Count_Flash
// 0x0000 (0x04A0 - 0x04A0)
class UUIAppraise_Count_Flash final : public UUIAppraise_Count
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraise_Count_Flash">();
	}
	static class UUIAppraise_Count_Flash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraise_Count_Flash>();
	}
};
static_assert(alignof(UUIAppraise_Count_Flash) == 0x000008, "Wrong alignment on UUIAppraise_Count_Flash");
static_assert(sizeof(UUIAppraise_Count_Flash) == 0x0004A0, "Wrong size on UUIAppraise_Count_Flash");

// Class DarwinGame.UIAppraise_Menu
// 0x00E0 (0x0570 - 0x0490)
class UUIAppraise_Menu final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             NameBlock;                                         // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIAppraise_Panel_01*                   PricePanel;                                        // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICorrection_00*                       Correction;                                        // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICorrection_01*                       NetworkCorrection;                                 // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIValueFlash_00*                       Flash;                                             // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_FlavorText*                 Flavor;                                            // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         LoopSe;                                            // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x88];                                     // 0x04E8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonInEnd();
	void ButtonOutEnd();
	void FlavorTextInEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraise_Menu">();
	}
	static class UUIAppraise_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraise_Menu>();
	}
};
static_assert(alignof(UUIAppraise_Menu) == 0x000008, "Wrong alignment on UUIAppraise_Menu");
static_assert(sizeof(UUIAppraise_Menu) == 0x000570, "Wrong size on UUIAppraise_Menu");
static_assert(offsetof(UUIAppraise_Menu, NameBlock) == 0x0004B0, "Member 'UUIAppraise_Menu::NameBlock' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Menu, PricePanel) == 0x0004B8, "Member 'UUIAppraise_Menu::PricePanel' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Menu, Correction) == 0x0004C0, "Member 'UUIAppraise_Menu::Correction' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Menu, NetworkCorrection) == 0x0004C8, "Member 'UUIAppraise_Menu::NetworkCorrection' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Menu, Flash) == 0x0004D0, "Member 'UUIAppraise_Menu::Flash' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Menu, Flavor) == 0x0004D8, "Member 'UUIAppraise_Menu::Flavor' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Menu, LoopSe) == 0x0004E0, "Member 'UUIAppraise_Menu::LoopSe' has a wrong offset!");

// Class DarwinGame.UIAppraise_Popup
// 0x0060 (0x04F0 - 0x0490)
class UUIAppraise_Popup final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIAppraise_Count*>              CountList;                                         // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIAppraise_Count*>              CommaList;                                         // 0x04B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIAppraise_Count*                      Unit;                                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       InAnim;                                            // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x20];                                     // 0x04D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InAnimEnd();
	void OutAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraise_Popup">();
	}
	static class UUIAppraise_Popup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraise_Popup>();
	}
};
static_assert(alignof(UUIAppraise_Popup) == 0x000008, "Wrong alignment on UUIAppraise_Popup");
static_assert(sizeof(UUIAppraise_Popup) == 0x0004F0, "Wrong size on UUIAppraise_Popup");
static_assert(offsetof(UUIAppraise_Popup, CountList) == 0x0004A0, "Member 'UUIAppraise_Popup::CountList' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Popup, CommaList) == 0x0004B0, "Member 'UUIAppraise_Popup::CommaList' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Popup, Unit) == 0x0004C0, "Member 'UUIAppraise_Popup::Unit' has a wrong offset!");
static_assert(offsetof(UUIAppraise_Popup, InAnim) == 0x0004C8, "Member 'UUIAppraise_Popup::InAnim' has a wrong offset!");

// Class DarwinGame.WallForcedBattleArea
// 0x0010 (0x0328 - 0x0318)
class AWallForcedBattleArea : public AForcedBattleAreaBase
{
public:
	class FName                                   PN_ThicknessScale;                                 // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseWidth;                                         // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallForcedBattleArea">();
	}
	static class AWallForcedBattleArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWallForcedBattleArea>();
	}
};
static_assert(alignof(AWallForcedBattleArea) == 0x000008, "Wrong alignment on AWallForcedBattleArea");
static_assert(sizeof(AWallForcedBattleArea) == 0x000328, "Wrong size on AWallForcedBattleArea");
static_assert(offsetof(AWallForcedBattleArea, PN_ThicknessScale) == 0x000318, "Member 'AWallForcedBattleArea::PN_ThicknessScale' has a wrong offset!");
static_assert(offsetof(AWallForcedBattleArea, BaseWidth) == 0x000320, "Member 'AWallForcedBattleArea::BaseWidth' has a wrong offset!");

// Class DarwinGame.UIMainMenu_GoBase
// 0x0010 (0x04A0 - 0x0490)
class UUIMainMenu_GoBase final : public UDarwinUserWidget
{
public:
	struct FLinearColor                           MaxTextColor;                                      // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainMenu_GoBase">();
	}
	static class UUIMainMenu_GoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainMenu_GoBase>();
	}
};
static_assert(alignof(UUIMainMenu_GoBase) == 0x000008, "Wrong alignment on UUIMainMenu_GoBase");
static_assert(sizeof(UUIMainMenu_GoBase) == 0x0004A0, "Wrong size on UUIMainMenu_GoBase");
static_assert(offsetof(UUIMainMenu_GoBase, MaxTextColor) == 0x000490, "Member 'UUIMainMenu_GoBase::MaxTextColor' has a wrong offset!");

// Class DarwinGame.UIAppraisePerformance_Root
// 0x0040 (0x0510 - 0x04D0)
class UUIAppraisePerformance_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x40];                                     // 0x04D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAppraisePerformance_Root">();
	}
	static class UUIAppraisePerformance_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAppraisePerformance_Root>();
	}
};
static_assert(alignof(UUIAppraisePerformance_Root) == 0x000008, "Wrong alignment on UUIAppraisePerformance_Root");
static_assert(sizeof(UUIAppraisePerformance_Root) == 0x000510, "Wrong size on UUIAppraisePerformance_Root");

// Class DarwinGame.UIStaff_Roll_Name_1
// 0x0000 (0x0490 - 0x0490)
class UUIStaff_Roll_Name_1 final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_Name_1">();
	}
	static class UUIStaff_Roll_Name_1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_Name_1>();
	}
};
static_assert(alignof(UUIStaff_Roll_Name_1) == 0x000008, "Wrong alignment on UUIStaff_Roll_Name_1");
static_assert(sizeof(UUIStaff_Roll_Name_1) == 0x000490, "Wrong size on UUIStaff_Roll_Name_1");

// Class DarwinGame.UIAreaPanel
// 0x0010 (0x04D0 - 0x04C0)
class UUIAreaPanel final : public UUITabLRBase
{
public:
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaPanel">();
	}
	static class UUIAreaPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaPanel>();
	}
};
static_assert(alignof(UUIAreaPanel) == 0x000008, "Wrong alignment on UUIAreaPanel");
static_assert(sizeof(UUIAreaPanel) == 0x0004D0, "Wrong size on UUIAreaPanel");

// Class DarwinGame.UIARMarkerSystem
// 0x0048 (0x0078 - 0x0030)
class UUIARMarkerSystem : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIARMarkerSystem">();
	}
	static class UUIARMarkerSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIARMarkerSystem>();
	}
};
static_assert(alignof(UUIARMarkerSystem) == 0x000008, "Wrong alignment on UUIARMarkerSystem");
static_assert(sizeof(UUIARMarkerSystem) == 0x000078, "Wrong size on UUIARMarkerSystem");

// Class DarwinGame.UIArtifact_ItemIcon
// 0x0038 (0x04C8 - 0x0490)
class UUIArtifact_ItemIcon : public UDarwinUserWidget
{
public:
	class UTexture2D*                             Frame_Bronze;                                      // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Frame_Silver;                                      // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Frame_Gold;                                        // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Frame_Rainbow;                                     // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImgIconItem;                                       // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifact_ItemIcon">();
	}
	static class UUIArtifact_ItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifact_ItemIcon>();
	}
};
static_assert(alignof(UUIArtifact_ItemIcon) == 0x000008, "Wrong alignment on UUIArtifact_ItemIcon");
static_assert(sizeof(UUIArtifact_ItemIcon) == 0x0004C8, "Wrong size on UUIArtifact_ItemIcon");
static_assert(offsetof(UUIArtifact_ItemIcon, Frame_Bronze) == 0x000490, "Member 'UUIArtifact_ItemIcon::Frame_Bronze' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemIcon, Frame_Silver) == 0x000498, "Member 'UUIArtifact_ItemIcon::Frame_Silver' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemIcon, Frame_Gold) == 0x0004A0, "Member 'UUIArtifact_ItemIcon::Frame_Gold' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemIcon, Frame_Rainbow) == 0x0004A8, "Member 'UUIArtifact_ItemIcon::Frame_Rainbow' has a wrong offset!");
static_assert(offsetof(UUIArtifact_ItemIcon, ImgIconItem) == 0x0004B0, "Member 'UUIArtifact_ItemIcon::ImgIconItem' has a wrong offset!");

// Class DarwinGame.UIUtility
// 0x0000 (0x0030 - 0x0030)
class UUIUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddAllUnclaimedBenefits();
	static void AddPlayerGold(int32 AddGold);
	static bool CanGetUnclaimedBenefits();
	static bool CanUnlockFacilityDismiss();
	static void ClearDelayedTipsSchedule();
	static void CloseBoard();
	static void CloseBulletShop();
	static void CloseDispatch();
	static void CloseFacility();
	static bool CloseFieldStatus(EFieldStatusOpenType OpenType);
	static void CloseFoodShop();
	static void CloseMyArtifact();
	static void CloseNetworkTop();
	static void CloseQuestConfirmation();
	static void CloseShop();
	static void CloseSwap();
	static void DynamicCreateWidgetFromClass(TSubclassOf<class UDarwinUserWidget> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget);
	static void DynamicCreateWidgetFromSoftClass(TSoftClassPtr<class UClass> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget);
	static void EventMaskContinuedOn();
	static void ExitWidgetGroup(EManagedUIGroup Group);
	static class FText FormatItemFlavorText(const class FText& ItemText, const TArray<EAreaType>& AreaTypeList);
	static class FText GetArtifactTypeName(EArtifactType Type);
	static bool GetHasTipsSchedule();
	static void GetHubReceptionQuestIDs(TArray<class FName>* OutIDs);
	static int32 GetPlayerGold();
	static struct FVector GetPlayerLocation();
	static class FText GetPlayerName();
	static void GetUnusedWidgetFromClass(TSubclassOf<class UDarwinUserWidget> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget);
	static void GetUnusedWidgetFromSoftClass(TSoftClassPtr<class UClass> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget);
	static void GetWidgetFromClass(TSubclassOf<class UDarwinUserWidget> DarwinUserWidgetClass, int32 Index_0, class UDarwinUserWidget** OutWidget);
	static void GetWidgetFromSoftClass(TSoftClassPtr<class UClass> DarwinUserWidgetClass, int32 Index_0, class UDarwinUserWidget** OutWidget);
	static bool IfLoadEndOpenFieldStatus();
	static void InitWidgetGroup(EManagedUIGroup Group);
	static bool IsCloseBoard();
	static bool IsCloseDispatch();
	static bool IsCloseNetworkTop();
	static bool IsInitWidgetGroup(EManagedUIGroup Group);
	static bool IsLargeSizeFlavorWindowByLanguage();
	static bool IsNewDispatch();
	static bool IsNewFacilityReception();
	static bool IsNewHubReception();
	static bool IsOpenQuestMenuDirectly();
	static bool IsOpenTeamMenuConfirmation();
	static bool IsOpenTeamMenuDirectly();
	static bool IsPlayLevelUpAnim();
	static bool IsRewordTypeContainUnclaimedBenefits(EAddOnContentRewordType RewordType);
	static bool IsUnclaimedBenefits();
	static void LastBattleQTESevenStoneGetBackLog(ELastBtlQTELogType Type);
	static class UTexture2D* LoadTexture(class UObject* Outer_0, const class FString& Path);
	static class UTexture2D* LoadTextureSoft(class UObject* Outer_0, const TSoftObjectPtr<class UTexture2D>& SoftObjectReference);
	static void OpenBoard();
	static void OpenBulletShop();
	static void OpenDelayedTips(class FName TipsID, float DelayTime);
	static void OpenDispatch();
	static void OpenFacility();
	static bool OpenFieldStatus(EFieldStatusOpenType OpenType);
	static void OpenFoodShop();
	static void OpenMyArtifact(const int32& PedestalIndex);
	static void OpenNetworkTop(EOpenNetworkUIType Type);
	static void OpenQuestMenuDirectly(EQuestMenuOpenType InOpenType);
	static bool OpenQuestOrder(const TArray<class FName>& QuestIdList, const class FName& NpcID, bool bIsParentDisplay, bool bInIsNewOrderQuest, bool bInIsClearedDisplay, bool bInIsClosedPlayEvent);
	static void OpenShop(ETradePlace TradePlace);
	static void OpenSwap();
	static void OpenTeamMenuDirectly();
	static bool ReOpenQuestOrder();
	static void SetHubReceptionDelegateAtQuestOrder();
	static void SetSubtitlesText(const class FString& inString);
	static void SubtitlesMaskIn(float AnimationSeconds);
	static void SubtitlesMaskOut(float AnimationSeconds);
	static void SubtitlesSkipIn();
	static void SubtitlesSkipOut();
	static void SubtitlesTextHidden();
	static void SubtitlesTextVisible();
	static void ThreePeopleComposerNameIn();
	static void ThreePeopleComposerNameOut();
	static void ThreePeopleDesignerNameIn();
	static void ThreePeopleDesignerNameOut();
	static void ThreePeopleDirectorNameIn();
	static void ThreePeopleDirectorNameOut();
	static void ThreePeopleMaskIn(float AnimationSeconds);
	static void ThreePeopleMaskOut(float AnimationSeconds);
	static void ThreePeopleSkipIn();
	static void ThreePeopleSkipOut();
	static void UIMapDrawEnterArea(EAreaType AreaType);
	static void UIMapDrawEnterCurrentArea();
	static void UnlockFacilityDismiss();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUtility">();
	}
	static class UUIUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUtility>();
	}
};
static_assert(alignof(UUIUtility) == 0x000008, "Wrong alignment on UUIUtility");
static_assert(sizeof(UUIUtility) == 0x000030, "Wrong size on UUIUtility");

// Class DarwinGame.UIArtifact_Panel_01
// 0x0000 (0x0490 - 0x0490)
class UUIArtifact_Panel_01 : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifact_Panel_01">();
	}
	static class UUIArtifact_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifact_Panel_01>();
	}
};
static_assert(alignof(UUIArtifact_Panel_01) == 0x000008, "Wrong alignment on UUIArtifact_Panel_01");
static_assert(sizeof(UUIArtifact_Panel_01) == 0x000490, "Wrong size on UUIArtifact_Panel_01");

// Class DarwinGame.ArtifactAuthorityDataTable
// 0x0000 (0x0030 - 0x0030)
class UArtifactAuthorityDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactAuthorityDataTable">();
	}
	static class UArtifactAuthorityDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactAuthorityDataTable>();
	}
};
static_assert(alignof(UArtifactAuthorityDataTable) == 0x000008, "Wrong alignment on UArtifactAuthorityDataTable");
static_assert(sizeof(UArtifactAuthorityDataTable) == 0x000030, "Wrong size on UArtifactAuthorityDataTable");

// Class DarwinGame.UIArtifactCategoryDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIArtifactCategoryDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactCategoryDataTable">();
	}
	static class UUIArtifactCategoryDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactCategoryDataTable>();
	}
};
static_assert(alignof(UUIArtifactCategoryDataTable) == 0x000008, "Wrong alignment on UUIArtifactCategoryDataTable");
static_assert(sizeof(UUIArtifactCategoryDataTable) == 0x000030, "Wrong size on UUIArtifactCategoryDataTable");

// Class DarwinGame.ArtifactCompleteDataTable
// 0x0000 (0x0030 - 0x0030)
class UArtifactCompleteDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactCompleteDataTable">();
	}
	static class UArtifactCompleteDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactCompleteDataTable>();
	}
};
static_assert(alignof(UArtifactCompleteDataTable) == 0x000008, "Wrong alignment on UArtifactCompleteDataTable");
static_assert(sizeof(UArtifactCompleteDataTable) == 0x000030, "Wrong size on UArtifactCompleteDataTable");

// Class DarwinGame.UIStation_MonsterIconEffect
// 0x0068 (0x0560 - 0x04F8)
class UUIStation_MonsterIconEffect final : public UUIStartLoopAnimation
{
public:
	TMap<ECategoryMatchType, class UTexture2D*>   EffectDataList;                                    // 0x04F8(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         EffectList;                                        // 0x0548(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_MonsterIconEffect">();
	}
	static class UUIStation_MonsterIconEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_MonsterIconEffect>();
	}
};
static_assert(alignof(UUIStation_MonsterIconEffect) == 0x000008, "Wrong alignment on UUIStation_MonsterIconEffect");
static_assert(sizeof(UUIStation_MonsterIconEffect) == 0x000560, "Wrong size on UUIStation_MonsterIconEffect");
static_assert(offsetof(UUIStation_MonsterIconEffect, EffectDataList) == 0x0004F8, "Member 'UUIStation_MonsterIconEffect::EffectDataList' has a wrong offset!");
static_assert(offsetof(UUIStation_MonsterIconEffect, EffectList) == 0x000548, "Member 'UUIStation_MonsterIconEffect::EffectList' has a wrong offset!");

// Class DarwinGame.ArtifactCompRewardDataTable
// 0x0000 (0x0030 - 0x0030)
class UArtifactCompRewardDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArtifactCompRewardDataTable">();
	}
	static class UArtifactCompRewardDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArtifactCompRewardDataTable>();
	}
};
static_assert(alignof(UArtifactCompRewardDataTable) == 0x000008, "Wrong alignment on UArtifactCompRewardDataTable");
static_assert(sizeof(UArtifactCompRewardDataTable) == 0x000030, "Wrong size on UArtifactCompRewardDataTable");

// Class DarwinGame.UIArtifactQualityDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIArtifactQualityDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactQualityDataTable">();
	}
	static class UUIArtifactQualityDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactQualityDataTable>();
	}
};
static_assert(alignof(UUIArtifactQualityDataTable) == 0x000008, "Wrong alignment on UUIArtifactQualityDataTable");
static_assert(sizeof(UUIArtifactQualityDataTable) == 0x000030, "Wrong size on UUIArtifactQualityDataTable");

// Class DarwinGame.UIArtifactSmallCategoryDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIArtifactSmallCategoryDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIArtifactSmallCategoryDataTable">();
	}
	static class UUIArtifactSmallCategoryDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIArtifactSmallCategoryDataTable>();
	}
};
static_assert(alignof(UUIArtifactSmallCategoryDataTable) == 0x000008, "Wrong alignment on UUIArtifactSmallCategoryDataTable");
static_assert(sizeof(UUIArtifactSmallCategoryDataTable) == 0x000030, "Wrong size on UUIArtifactSmallCategoryDataTable");

// Class DarwinGame.UIAutoSave
// 0x0018 (0x04A8 - 0x0490)
class UUIAutoSave : public UUIResidentWidgetBase
{
public:
	float                                         DispMinTime;                                       // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISaveIcon*                            SaveIcon;                                          // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAutoSave">();
	}
	static class UUIAutoSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAutoSave>();
	}
};
static_assert(alignof(UUIAutoSave) == 0x000008, "Wrong alignment on UUIAutoSave");
static_assert(sizeof(UUIAutoSave) == 0x0004A8, "Wrong size on UUIAutoSave");
static_assert(offsetof(UUIAutoSave, DispMinTime) == 0x000490, "Member 'UUIAutoSave::DispMinTime' has a wrong offset!");
static_assert(offsetof(UUIAutoSave, SaveIcon) == 0x000498, "Member 'UUIAutoSave::SaveIcon' has a wrong offset!");

// Class DarwinGame.UIBaseView_00
// 0x00D0 (0x0560 - 0x0490)
class UUIBaseView_00 final : public UDarwinUserWidget
{
public:
	class UDataTable*                             MyTeamMenuObjectData;                              // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MyTeamMenuFacilityData;                            // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             ViewPanelNameList;                                 // 0x04A0(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UImage*>              ViewImageList;                                     // 0x04F0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x20];                                     // 0x0540(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseView_00">();
	}
	static class UUIBaseView_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBaseView_00>();
	}
};
static_assert(alignof(UUIBaseView_00) == 0x000008, "Wrong alignment on UUIBaseView_00");
static_assert(sizeof(UUIBaseView_00) == 0x000560, "Wrong size on UUIBaseView_00");
static_assert(offsetof(UUIBaseView_00, MyTeamMenuObjectData) == 0x000490, "Member 'UUIBaseView_00::MyTeamMenuObjectData' has a wrong offset!");
static_assert(offsetof(UUIBaseView_00, MyTeamMenuFacilityData) == 0x000498, "Member 'UUIBaseView_00::MyTeamMenuFacilityData' has a wrong offset!");
static_assert(offsetof(UUIBaseView_00, ViewPanelNameList) == 0x0004A0, "Member 'UUIBaseView_00::ViewPanelNameList' has a wrong offset!");
static_assert(offsetof(UUIBaseView_00, ViewImageList) == 0x0004F0, "Member 'UUIBaseView_00::ViewImageList' has a wrong offset!");

// Class DarwinGame.UIBoardmenu
// 0x00B0 (0x0680 - 0x05D0)
class UUIBoardmenu final : public UUIScrollMenuBase
{
public:
	TArray<class FText>                           SortText;                                          // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUIBoardmenu_ItemIcon*>          ItemIcons;                                         // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBoardmenu_GoldIcon*                  GoldIcon;                                          // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x38];                                     // 0x05F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShortenOpenAnimTime;                               // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_MonsterIconTextures>        MonsterIconTextures;                               // 0x0638(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIFacilityMenu_Root*                   Facility;                                          // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISwapMenu_Root*                       SwapRoot;                                          // 0x0650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         InSe;                                              // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x20];                                     // 0x0660(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu">();
	}
	static class UUIBoardmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu>();
	}
};
static_assert(alignof(UUIBoardmenu) == 0x000008, "Wrong alignment on UUIBoardmenu");
static_assert(sizeof(UUIBoardmenu) == 0x000680, "Wrong size on UUIBoardmenu");
static_assert(offsetof(UUIBoardmenu, SortText) == 0x0005D0, "Member 'UUIBoardmenu::SortText' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, ItemIcons) == 0x0005E0, "Member 'UUIBoardmenu::ItemIcons' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, GoldIcon) == 0x0005F0, "Member 'UUIBoardmenu::GoldIcon' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, ShortenOpenAnimTime) == 0x000630, "Member 'UUIBoardmenu::ShortenOpenAnimTime' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, MonsterIconTextures) == 0x000638, "Member 'UUIBoardmenu::MonsterIconTextures' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, Facility) == 0x000648, "Member 'UUIBoardmenu::Facility' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, SwapRoot) == 0x000650, "Member 'UUIBoardmenu::SwapRoot' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu, InSe) == 0x000658, "Member 'UUIBoardmenu::InSe' has a wrong offset!");

// Class DarwinGame.UIBoardmenu_ItemIcon
// 0x0008 (0x0498 - 0x0490)
class UUIBoardmenu_ItemIcon final : public UDarwinUserWidget
{
public:
	class UImage*                                 ImgItemIcon;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_ItemIcon">();
	}
	static class UUIBoardmenu_ItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_ItemIcon>();
	}
};
static_assert(alignof(UUIBoardmenu_ItemIcon) == 0x000008, "Wrong alignment on UUIBoardmenu_ItemIcon");
static_assert(sizeof(UUIBoardmenu_ItemIcon) == 0x000498, "Wrong size on UUIBoardmenu_ItemIcon");
static_assert(offsetof(UUIBoardmenu_ItemIcon, ImgItemIcon) == 0x000490, "Member 'UUIBoardmenu_ItemIcon::ImgItemIcon' has a wrong offset!");

// Class DarwinGame.UIEvent_Mask
// 0x0018 (0x04A8 - 0x0490)
class UUIEvent_Mask : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       BindAnimation;                                     // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OutAnimationFinished();
	void PlaySkipWaitAnimation();
	void PlayWaitAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEvent_Mask">();
	}
	static class UUIEvent_Mask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEvent_Mask>();
	}
};
static_assert(alignof(UUIEvent_Mask) == 0x000008, "Wrong alignment on UUIEvent_Mask");
static_assert(sizeof(UUIEvent_Mask) == 0x0004A8, "Wrong size on UUIEvent_Mask");
static_assert(offsetof(UUIEvent_Mask, BindAnimation) == 0x0004A0, "Member 'UUIEvent_Mask::BindAnimation' has a wrong offset!");

// Class DarwinGame.UISub_02
// 0x0000 (0x04A8 - 0x04A8)
class UUISub_02 : public UUIEvent_Mask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISub_02">();
	}
	static class UUISub_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISub_02>();
	}
};
static_assert(alignof(UUISub_02) == 0x000008, "Wrong alignment on UUISub_02");
static_assert(sizeof(UUISub_02) == 0x0004A8, "Wrong size on UUISub_02");

// Class DarwinGame.UIBoardmenu_MonsterIcon
// 0x0098 (0x0528 - 0x0490)
class UUIBoardmenu_MonsterIcon final : public UDarwinUserWidget
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      PanelTextureList;                                  // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      IconBaseTextureList;                               // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_MonsterIconParts                   MonsterIconParts;                                  // 0x04B8(0x0050)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         CategoryIconList;                                  // 0x0508(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImagePanel;                                        // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconBase;                                          // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_MonsterIcon">();
	}
	static class UUIBoardmenu_MonsterIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_MonsterIcon>();
	}
};
static_assert(alignof(UUIBoardmenu_MonsterIcon) == 0x000008, "Wrong alignment on UUIBoardmenu_MonsterIcon");
static_assert(sizeof(UUIBoardmenu_MonsterIcon) == 0x000528, "Wrong size on UUIBoardmenu_MonsterIcon");
static_assert(offsetof(UUIBoardmenu_MonsterIcon, PanelTextureList) == 0x000490, "Member 'UUIBoardmenu_MonsterIcon::PanelTextureList' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIcon, IconBaseTextureList) == 0x0004A0, "Member 'UUIBoardmenu_MonsterIcon::IconBaseTextureList' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIcon, MonsterIconParts) == 0x0004B8, "Member 'UUIBoardmenu_MonsterIcon::MonsterIconParts' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIcon, CategoryIconList) == 0x000508, "Member 'UUIBoardmenu_MonsterIcon::CategoryIconList' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIcon, ImagePanel) == 0x000518, "Member 'UUIBoardmenu_MonsterIcon::ImagePanel' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_MonsterIcon, IconBase) == 0x000520, "Member 'UUIBoardmenu_MonsterIcon::IconBase' has a wrong offset!");

// Class DarwinGame.UIBoardmenu_Root
// 0x0000 (0x04D0 - 0x04D0)
class UUIBoardmenu_Root : public UUIInitWidget_Root
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_Root">();
	}
	static class UUIBoardmenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_Root>();
	}
};
static_assert(alignof(UUIBoardmenu_Root) == 0x000008, "Wrong alignment on UUIBoardmenu_Root");
static_assert(sizeof(UUIBoardmenu_Root) == 0x0004D0, "Wrong size on UUIBoardmenu_Root");

// Class DarwinGame.UIBoardmenu_Status
// 0x02C8 (0x07D0 - 0x0508)
class UUIBoardmenu_Status final : public UUIStatusBase
{
public:
	uint8                                         Pad_508[0x298];                                    // 0x0508(0x0298)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPartyMenu_PMR_Page_07*               Page07;                                            // 0x07A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_PMR_Page_00*               Page00;                                            // 0x07A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_PMR_Page_01*               Page01;                                            // 0x07B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_PMR_Page_02*               Page02;                                            // 0x07B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_PMR_Page_03*               Page03;                                            // 0x07C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardmenu_Status">();
	}
	static class UUIBoardmenu_Status* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardmenu_Status>();
	}
};
static_assert(alignof(UUIBoardmenu_Status) == 0x000008, "Wrong alignment on UUIBoardmenu_Status");
static_assert(sizeof(UUIBoardmenu_Status) == 0x0007D0, "Wrong size on UUIBoardmenu_Status");
static_assert(offsetof(UUIBoardmenu_Status, Page07) == 0x0007A0, "Member 'UUIBoardmenu_Status::Page07' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_Status, Page00) == 0x0007A8, "Member 'UUIBoardmenu_Status::Page00' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_Status, Page01) == 0x0007B0, "Member 'UUIBoardmenu_Status::Page01' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_Status, Page02) == 0x0007B8, "Member 'UUIBoardmenu_Status::Page02' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_Status, Page03) == 0x0007C0, "Member 'UUIBoardmenu_Status::Page03' has a wrong offset!");
static_assert(offsetof(UUIBoardmenu_Status, UIUnderButton) == 0x0007C8, "Member 'UUIBoardmenu_Status::UIUnderButton' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_11
// 0x0008 (0x0538 - 0x0530)
class UUIPartyMenu_PM_Panel_11 final : public UUIPartyMenu_PM_Panel_StatusChangeBase
{
public:
	class UUIPartyMenu_PM_Icon_00*                Icon;                                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_11">();
	}
	static class UUIPartyMenu_PM_Panel_11* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_11>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_11) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_11");
static_assert(sizeof(UUIPartyMenu_PM_Panel_11) == 0x000538, "Wrong size on UUIPartyMenu_PM_Panel_11");
static_assert(offsetof(UUIPartyMenu_PM_Panel_11, Icon) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_11::Icon' has a wrong offset!");

// Class DarwinGame.UIBoardNickNameDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIBoardNickNameDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardNickNameDataTable">();
	}
	static class UUIBoardNickNameDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardNickNameDataTable>();
	}
};
static_assert(alignof(UUIBoardNickNameDataTable) == 0x000008, "Wrong alignment on UUIBoardNickNameDataTable");
static_assert(sizeof(UUIBoardNickNameDataTable) == 0x000030, "Wrong size on UUIBoardNickNameDataTable");

// Class DarwinGame.UIBoardRequireItemDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIBoardRequireItemDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBoardRequireItemDataTable">();
	}
	static class UUIBoardRequireItemDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBoardRequireItemDataTable>();
	}
};
static_assert(alignof(UUIBoardRequireItemDataTable) == 0x000008, "Wrong alignment on UUIBoardRequireItemDataTable");
static_assert(sizeof(UUIBoardRequireItemDataTable) == 0x000030, "Wrong size on UUIBoardRequireItemDataTable");

// Class DarwinGame.UIBonus_Points_01
// 0x0030 (0x04C0 - 0x0490)
class UUIBonus_Points_01 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIAppraise_Count*>              CountList;                                         // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CountDataTable;                                    // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBonus_Points_01">();
	}
	static class UUIBonus_Points_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBonus_Points_01>();
	}
};
static_assert(alignof(UUIBonus_Points_01) == 0x000008, "Wrong alignment on UUIBonus_Points_01");
static_assert(sizeof(UUIBonus_Points_01) == 0x0004C0, "Wrong size on UUIBonus_Points_01");
static_assert(offsetof(UUIBonus_Points_01, CountList) == 0x0004A0, "Member 'UUIBonus_Points_01::CountList' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_01, CountDataTable) == 0x0004B0, "Member 'UUIBonus_Points_01::CountDataTable' has a wrong offset!");

// Class DarwinGame.UIBonus_Points_02
// 0x00B8 (0x0548 - 0x0490)
class UUIBonus_Points_02 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIAppraise_Count*>              CountList;                                         // 0x04B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIAppraise_Count*>              CommaList;                                         // 0x04C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIAppraise_Count*                      Unit;                                              // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIAppraise_Count_Flash*>        FlashCountList;                                    // 0x04D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIAppraise_Count_Flash*>        FlashCommaList;                                    // 0x04E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIAppraise_Count_Flash*                FlashUnit;                                         // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             CountDataTable;                                    // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomTime;                                        // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x3C];                                     // 0x050C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlashEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBonus_Points_02">();
	}
	static class UUIBonus_Points_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBonus_Points_02>();
	}
};
static_assert(alignof(UUIBonus_Points_02) == 0x000008, "Wrong alignment on UUIBonus_Points_02");
static_assert(sizeof(UUIBonus_Points_02) == 0x000548, "Wrong size on UUIBonus_Points_02");
static_assert(offsetof(UUIBonus_Points_02, CountList) == 0x0004B0, "Member 'UUIBonus_Points_02::CountList' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, CommaList) == 0x0004C0, "Member 'UUIBonus_Points_02::CommaList' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, Unit) == 0x0004D0, "Member 'UUIBonus_Points_02::Unit' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, FlashCountList) == 0x0004D8, "Member 'UUIBonus_Points_02::FlashCountList' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, FlashCommaList) == 0x0004E8, "Member 'UUIBonus_Points_02::FlashCommaList' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, FlashUnit) == 0x0004F8, "Member 'UUIBonus_Points_02::FlashUnit' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, CountDataTable) == 0x000500, "Member 'UUIBonus_Points_02::CountDataTable' has a wrong offset!");
static_assert(offsetof(UUIBonus_Points_02, RandomTime) == 0x000508, "Member 'UUIBonus_Points_02::RandomTime' has a wrong offset!");

// Class DarwinGame.UIQM_Panel_00
// 0x0028 (0x05C8 - 0x05A0)
class UUIQM_Panel_00 : public UUIQM_PanelQuestName
{
public:
	uint8                                         Pad_5A0[0x20];                                     // 0x05A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ClearOutAnim;                                      // 0x05C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClearOutAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_00">();
	}
	static class UUIQM_Panel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_00>();
	}
};
static_assert(alignof(UUIQM_Panel_00) == 0x000008, "Wrong alignment on UUIQM_Panel_00");
static_assert(sizeof(UUIQM_Panel_00) == 0x0005C8, "Wrong size on UUIQM_Panel_00");
static_assert(offsetof(UUIQM_Panel_00, ClearOutAnim) == 0x0005C0, "Member 'UUIQM_Panel_00::ClearOutAnim' has a wrong offset!");

// Class DarwinGame.UICategory_AreaIcon_01
// 0x0040 (0x04D0 - 0x0490)
class UUICategory_AreaIcon_01 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CompletedTextColor;                                // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PossessionText;                                    // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalText;                                         // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_AreaIcon_01">();
	}
	static class UUICategory_AreaIcon_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_AreaIcon_01>();
	}
};
static_assert(alignof(UUICategory_AreaIcon_01) == 0x000008, "Wrong alignment on UUICategory_AreaIcon_01");
static_assert(sizeof(UUICategory_AreaIcon_01) == 0x0004D0, "Wrong size on UUICategory_AreaIcon_01");
static_assert(offsetof(UUICategory_AreaIcon_01, CompletedTextColor) == 0x0004B0, "Member 'UUICategory_AreaIcon_01::CompletedTextColor' has a wrong offset!");
static_assert(offsetof(UUICategory_AreaIcon_01, PossessionText) == 0x0004C0, "Member 'UUICategory_AreaIcon_01::PossessionText' has a wrong offset!");
static_assert(offsetof(UUICategory_AreaIcon_01, TotalText) == 0x0004C8, "Member 'UUICategory_AreaIcon_01::TotalText' has a wrong offset!");

// Class DarwinGame.UICategory_Panel_00
// 0x0008 (0x0498 - 0x0490)
class UUICategory_Panel_00 : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_Panel_00">();
	}
	static class UUICategory_Panel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_Panel_00>();
	}
};
static_assert(alignof(UUICategory_Panel_00) == 0x000008, "Wrong alignment on UUICategory_Panel_00");
static_assert(sizeof(UUICategory_Panel_00) == 0x000498, "Wrong size on UUICategory_Panel_00");

// Class DarwinGame.UICategory_Set_Area
// 0x0080 (0x0520 - 0x04A0)
class UUICategory_Set_Area final : public UUICategory_Set_Base
{
public:
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIStation_CategoryIcon_S*>      CategoryIcons;                                     // 0x04A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICategory_AreaIcon_01*                BoxCountIcon;                                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICategory_AreaIcon_01*                TreasureBoxCountIcon;                              // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICategory_AreaIcon_01*                TargetObjectCountIcon;                             // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x50];                                     // 0x04D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_Set_Area">();
	}
	static class UUICategory_Set_Area* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_Set_Area>();
	}
};
static_assert(alignof(UUICategory_Set_Area) == 0x000008, "Wrong alignment on UUICategory_Set_Area");
static_assert(sizeof(UUICategory_Set_Area) == 0x000520, "Wrong size on UUICategory_Set_Area");
static_assert(offsetof(UUICategory_Set_Area, CategoryIcons) == 0x0004A8, "Member 'UUICategory_Set_Area::CategoryIcons' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Area, BoxCountIcon) == 0x0004B8, "Member 'UUICategory_Set_Area::BoxCountIcon' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Area, TreasureBoxCountIcon) == 0x0004C0, "Member 'UUICategory_Set_Area::TreasureBoxCountIcon' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Area, TargetObjectCountIcon) == 0x0004C8, "Member 'UUICategory_Set_Area::TargetObjectCountIcon' has a wrong offset!");

// Class DarwinGame.UICategory_Set_Train
// 0x0038 (0x04D8 - 0x04A0)
class UUICategory_Set_Train : public UUICategory_Set_Base
{
public:
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       OnAnim;                                            // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OffAnim;                                           // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OpenAnim;                                          // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       CloseAnim;                                         // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FlashAnim;                                         // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_Set_Train">();
	}
	static class UUICategory_Set_Train* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_Set_Train>();
	}
};
static_assert(alignof(UUICategory_Set_Train) == 0x000008, "Wrong alignment on UUICategory_Set_Train");
static_assert(sizeof(UUICategory_Set_Train) == 0x0004D8, "Wrong size on UUICategory_Set_Train");
static_assert(offsetof(UUICategory_Set_Train, OnAnim) == 0x0004A8, "Member 'UUICategory_Set_Train::OnAnim' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Train, OffAnim) == 0x0004B0, "Member 'UUICategory_Set_Train::OffAnim' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Train, OpenAnim) == 0x0004B8, "Member 'UUICategory_Set_Train::OpenAnim' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Train, CloseAnim) == 0x0004C0, "Member 'UUICategory_Set_Train::CloseAnim' has a wrong offset!");
static_assert(offsetof(UUICategory_Set_Train, FlashAnim) == 0x0004C8, "Member 'UUICategory_Set_Train::FlashAnim' has a wrong offset!");

// Class DarwinGame.UICategory_Set_Map
// 0x0000 (0x04D8 - 0x04D8)
class UUICategory_Set_Map final : public UUICategory_Set_Train
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_Set_Map">();
	}
	static class UUICategory_Set_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_Set_Map>();
	}
};
static_assert(alignof(UUICategory_Set_Map) == 0x000008, "Wrong alignment on UUICategory_Set_Map");
static_assert(sizeof(UUICategory_Set_Map) == 0x0004D8, "Wrong size on UUICategory_Set_Map");

// Class DarwinGame.UICategory_WinSort
// 0x0058 (0x0628 - 0x05D0)
class UUICategory_WinSort final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     SortList;                                          // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUICategory_SortIconChoice*>     FilterList;                                        // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x28];                                     // 0x0600(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICategory_WinSort">();
	}
	static class UUICategory_WinSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICategory_WinSort>();
	}
};
static_assert(alignof(UUICategory_WinSort) == 0x000008, "Wrong alignment on UUICategory_WinSort");
static_assert(sizeof(UUICategory_WinSort) == 0x000628, "Wrong size on UUICategory_WinSort");
static_assert(offsetof(UUICategory_WinSort, SortList) == 0x0005E0, "Member 'UUICategory_WinSort::SortList' has a wrong offset!");
static_assert(offsetof(UUICategory_WinSort, FilterList) == 0x0005F0, "Member 'UUICategory_WinSort::FilterList' has a wrong offset!");

// Class DarwinGame.UINetworkMemberSend_Member_Root
// 0x00A0 (0x0570 - 0x04D0)
class UUINetworkMemberSend_Member_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0xA0];                                     // 0x04D0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkMemberSend_Member_Root">();
	}
	static class UUINetworkMemberSend_Member_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkMemberSend_Member_Root>();
	}
};
static_assert(alignof(UUINetworkMemberSend_Member_Root) == 0x000008, "Wrong alignment on UUINetworkMemberSend_Member_Root");
static_assert(sizeof(UUINetworkMemberSend_Member_Root) == 0x000570, "Wrong size on UUINetworkMemberSend_Member_Root");

// Class DarwinGame.UICaution
// 0x00F8 (0x0588 - 0x0490)
class UUICaution : public UDarwinUserWidget
{
public:
	TMap<ECautionRivalType, class UTexture2D*>    RivalIconTexture;                                  // 0x0490(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<ECautionRivalType, class UMaterial*>     RivalNameMaterial;                                 // 0x04E0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 CautionIcon;                                       // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       InAnim;                                            // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OutAnim;                                           // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       DangerWaitAnim;                                    // 0x0560(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       MaxDangerWaitAnim;                                 // 0x0568(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0x18];                                     // 0x0570(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseProcessing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICaution">();
	}
	static class UUICaution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICaution>();
	}
};
static_assert(alignof(UUICaution) == 0x000008, "Wrong alignment on UUICaution");
static_assert(sizeof(UUICaution) == 0x000588, "Wrong size on UUICaution");
static_assert(offsetof(UUICaution, RivalIconTexture) == 0x000490, "Member 'UUICaution::RivalIconTexture' has a wrong offset!");
static_assert(offsetof(UUICaution, RivalNameMaterial) == 0x0004E0, "Member 'UUICaution::RivalNameMaterial' has a wrong offset!");
static_assert(offsetof(UUICaution, CautionIcon) == 0x000538, "Member 'UUICaution::CautionIcon' has a wrong offset!");
static_assert(offsetof(UUICaution, InAnim) == 0x000550, "Member 'UUICaution::InAnim' has a wrong offset!");
static_assert(offsetof(UUICaution, OutAnim) == 0x000558, "Member 'UUICaution::OutAnim' has a wrong offset!");
static_assert(offsetof(UUICaution, DangerWaitAnim) == 0x000560, "Member 'UUICaution::DangerWaitAnim' has a wrong offset!");
static_assert(offsetof(UUICaution, MaxDangerWaitAnim) == 0x000568, "Member 'UUICaution::MaxDangerWaitAnim' has a wrong offset!");

// Class DarwinGame.UICharAdd_01
// 0x0000 (0x0510 - 0x0510)
class UUICharAdd_01 : public UUICharAdd_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharAdd_01">();
	}
	static class UUICharAdd_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharAdd_01>();
	}
};
static_assert(alignof(UUICharAdd_01) == 0x000008, "Wrong alignment on UUICharAdd_01");
static_assert(sizeof(UUICharAdd_01) == 0x000510, "Wrong size on UUICharAdd_01");

// Class DarwinGame.UICoin_Detail_Win
// 0x0018 (0x04A8 - 0x0490)
class UUICoin_Detail_Win : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPartyMenu_PMR_Page_02*               Page02;                                            // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoin_Detail_Win">();
	}
	static class UUICoin_Detail_Win* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoin_Detail_Win>();
	}
};
static_assert(alignof(UUICoin_Detail_Win) == 0x000008, "Wrong alignment on UUICoin_Detail_Win");
static_assert(sizeof(UUICoin_Detail_Win) == 0x0004A8, "Wrong size on UUICoin_Detail_Win");
static_assert(offsetof(UUICoin_Detail_Win, Page02) == 0x0004A0, "Member 'UUICoin_Detail_Win::Page02' has a wrong offset!");

// Class DarwinGame.UICoinMenu_Coin_Color
// 0x0050 (0x04E0 - 0x0490)
class UUICoinMenu_Coin_Color : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_Coin_Color">();
	}
	static class UUICoinMenu_Coin_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_Coin_Color>();
	}
};
static_assert(alignof(UUICoinMenu_Coin_Color) == 0x000008, "Wrong alignment on UUICoinMenu_Coin_Color");
static_assert(sizeof(UUICoinMenu_Coin_Color) == 0x0004E0, "Wrong size on UUICoinMenu_Coin_Color");

// Class DarwinGame.UIQuest_WinDialog
// 0x0008 (0x0618 - 0x0610)
class UUIQuest_WinDialog : public UUIWinMenuTwoChoices
{
public:
	class UUIQuest_WinDialog_Text*                WinDialogText;                                     // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuest_WinDialog">();
	}
	static class UUIQuest_WinDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuest_WinDialog>();
	}
};
static_assert(alignof(UUIQuest_WinDialog) == 0x000008, "Wrong alignment on UUIQuest_WinDialog");
static_assert(sizeof(UUIQuest_WinDialog) == 0x000618, "Wrong size on UUIQuest_WinDialog");
static_assert(offsetof(UUIQuest_WinDialog, WinDialogText) == 0x000610, "Member 'UUIQuest_WinDialog::WinDialogText' has a wrong offset!");

// Class DarwinGame.UICoinMenu_Coin_Stock
// 0x0048 (0x0618 - 0x05D0)
class UUICoinMenu_Coin_Stock : public UUIScrollMenuBase
{
public:
	TArray<class FName>                           PanelNames;                                        // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HaveNumText;                                       // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HaveMaxText;                                       // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_SortIcon*                 SortIcon;                                          // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x20];                                     // 0x05F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_Coin_Stock">();
	}
	static class UUICoinMenu_Coin_Stock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_Coin_Stock>();
	}
};
static_assert(alignof(UUICoinMenu_Coin_Stock) == 0x000008, "Wrong alignment on UUICoinMenu_Coin_Stock");
static_assert(sizeof(UUICoinMenu_Coin_Stock) == 0x000618, "Wrong size on UUICoinMenu_Coin_Stock");
static_assert(offsetof(UUICoinMenu_Coin_Stock, PanelNames) == 0x0005D0, "Member 'UUICoinMenu_Coin_Stock::PanelNames' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_Coin_Stock, HaveNumText) == 0x0005E0, "Member 'UUICoinMenu_Coin_Stock::HaveNumText' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_Coin_Stock, HaveMaxText) == 0x0005E8, "Member 'UUICoinMenu_Coin_Stock::HaveMaxText' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_Coin_Stock, SortIcon) == 0x0005F0, "Member 'UUICoinMenu_Coin_Stock::SortIcon' has a wrong offset!");

// Class DarwinGame.UICoinMenu_CoinItemBase
// 0x0030 (0x0560 - 0x0530)
class UUICoinMenu_CoinItemBase : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 CoinBaseTexture;                                   // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MonsterTexture;                                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 StatusTexture;                                     // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICoinMenu_Coin_Color*                 ColorFrame;                                        // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_CoinItemBase">();
	}
	static class UUICoinMenu_CoinItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_CoinItemBase>();
	}
};
static_assert(alignof(UUICoinMenu_CoinItemBase) == 0x000008, "Wrong alignment on UUICoinMenu_CoinItemBase");
static_assert(sizeof(UUICoinMenu_CoinItemBase) == 0x000560, "Wrong size on UUICoinMenu_CoinItemBase");
static_assert(offsetof(UUICoinMenu_CoinItemBase, CoinBaseTexture) == 0x000538, "Member 'UUICoinMenu_CoinItemBase::CoinBaseTexture' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinItemBase, MonsterTexture) == 0x000540, "Member 'UUICoinMenu_CoinItemBase::MonsterTexture' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinItemBase, StatusTexture) == 0x000548, "Member 'UUICoinMenu_CoinItemBase::StatusTexture' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinItemBase, ColorFrame) == 0x000550, "Member 'UUICoinMenu_CoinItemBase::ColorFrame' has a wrong offset!");

// Class DarwinGame.UICoinMenu_CoinSet
// 0x0018 (0x0578 - 0x0560)
class UUICoinMenu_CoinSet : public UUICoinMenu_CoinItemBase
{
public:
	TArray<class UCanvasPanel*>                   StatusUpArray;                                     // 0x0560(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      EffCoinSet;                                        // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_CoinSet">();
	}
	static class UUICoinMenu_CoinSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_CoinSet>();
	}
};
static_assert(alignof(UUICoinMenu_CoinSet) == 0x000008, "Wrong alignment on UUICoinMenu_CoinSet");
static_assert(sizeof(UUICoinMenu_CoinSet) == 0x000578, "Wrong size on UUICoinMenu_CoinSet");
static_assert(offsetof(UUICoinMenu_CoinSet, StatusUpArray) == 0x000560, "Member 'UUICoinMenu_CoinSet::StatusUpArray' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinSet, EffCoinSet) == 0x000570, "Member 'UUICoinMenu_CoinSet::EffCoinSet' has a wrong offset!");

// Class DarwinGame.UICoinMenu_CoinSet_Stock
// 0x0038 (0x0598 - 0x0560)
class UUICoinMenu_CoinSet_Stock : public UUICoinMenu_CoinItemBase
{
public:
	class UImage*                                 ImageNew;                                          // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageTrash;                                        // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageParty;                                        // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageStock;                                        // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageShadow;                                       // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImageTrashRing;                                    // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_CoinSet_Stock">();
	}
	static class UUICoinMenu_CoinSet_Stock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_CoinSet_Stock>();
	}
};
static_assert(alignof(UUICoinMenu_CoinSet_Stock) == 0x000008, "Wrong alignment on UUICoinMenu_CoinSet_Stock");
static_assert(sizeof(UUICoinMenu_CoinSet_Stock) == 0x000598, "Wrong size on UUICoinMenu_CoinSet_Stock");
static_assert(offsetof(UUICoinMenu_CoinSet_Stock, ImageNew) == 0x000560, "Member 'UUICoinMenu_CoinSet_Stock::ImageNew' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinSet_Stock, ImageTrash) == 0x000568, "Member 'UUICoinMenu_CoinSet_Stock::ImageTrash' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinSet_Stock, ImageParty) == 0x000570, "Member 'UUICoinMenu_CoinSet_Stock::ImageParty' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinSet_Stock, ImageStock) == 0x000578, "Member 'UUICoinMenu_CoinSet_Stock::ImageStock' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinSet_Stock, ImageShadow) == 0x000580, "Member 'UUICoinMenu_CoinSet_Stock::ImageShadow' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_CoinSet_Stock, ImageTrashRing) == 0x000588, "Member 'UUICoinMenu_CoinSet_Stock::ImageTrashRing' has a wrong offset!");

// Class DarwinGame.UICoinMenu_EquipCoin
// 0x0010 (0x04A0 - 0x0490)
class UUICoinMenu_EquipCoin final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_EquipCoin">();
	}
	static class UUICoinMenu_EquipCoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_EquipCoin>();
	}
};
static_assert(alignof(UUICoinMenu_EquipCoin) == 0x000008, "Wrong alignment on UUICoinMenu_EquipCoin");
static_assert(sizeof(UUICoinMenu_EquipCoin) == 0x0004A0, "Wrong size on UUICoinMenu_EquipCoin");

// Class DarwinGame.UICoinMenu_WinAuto
// 0x0028 (0x05F8 - 0x05D0)
class UUICoinMenu_WinAuto : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     AutoIcons;                                         // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECoinAutoEquip                                Current;                                           // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x7];                                      // 0x05F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_WinAuto">();
	}
	static class UUICoinMenu_WinAuto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_WinAuto>();
	}
};
static_assert(alignof(UUICoinMenu_WinAuto) == 0x000008, "Wrong alignment on UUICoinMenu_WinAuto");
static_assert(sizeof(UUICoinMenu_WinAuto) == 0x0005F8, "Wrong size on UUICoinMenu_WinAuto");
static_assert(offsetof(UUICoinMenu_WinAuto, AutoIcons) == 0x0005E0, "Member 'UUICoinMenu_WinAuto::AutoIcons' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_WinAuto, Current) == 0x0005F0, "Member 'UUICoinMenu_WinAuto::Current' has a wrong offset!");

// Class DarwinGame.UIMenu_Setting
// 0x00B0 (0x0580 - 0x04D0)
class UUIMenu_Setting : public UUILeftMenuUseBase
{
public:
	TMap<ESettingMode, struct FST_SettingMenuCategoryList> SettingMenuCategoryList;                           // 0x04D0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UUIOperationWinPC*                      OperationWindow;                                   // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUISaveContent*                         UISaveContent;                                     // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILoadContent*                         UILoadContent;                                     // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionScreen*                        UIOptionScreen;                                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionSound*                         UIOptionSound;                                     // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionScreenPC*                      UIOptionScreenPC;                                  // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionGraphics*                      UIOptionGraphics;                                  // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionOperation*                     UIOptionOperation;                                 // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x18];                                     // 0x0568(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenu_Setting">();
	}
	static class UUIMenu_Setting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenu_Setting>();
	}
};
static_assert(alignof(UUIMenu_Setting) == 0x000008, "Wrong alignment on UUIMenu_Setting");
static_assert(sizeof(UUIMenu_Setting) == 0x000580, "Wrong size on UUIMenu_Setting");
static_assert(offsetof(UUIMenu_Setting, SettingMenuCategoryList) == 0x0004D0, "Member 'UUIMenu_Setting::SettingMenuCategoryList' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, OperationWindow) == 0x000520, "Member 'UUIMenu_Setting::OperationWindow' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UIUnderButton) == 0x000528, "Member 'UUIMenu_Setting::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UISaveContent) == 0x000530, "Member 'UUIMenu_Setting::UISaveContent' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UILoadContent) == 0x000538, "Member 'UUIMenu_Setting::UILoadContent' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UIOptionScreen) == 0x000540, "Member 'UUIMenu_Setting::UIOptionScreen' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UIOptionSound) == 0x000548, "Member 'UUIMenu_Setting::UIOptionSound' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UIOptionScreenPC) == 0x000550, "Member 'UUIMenu_Setting::UIOptionScreenPC' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UIOptionGraphics) == 0x000558, "Member 'UUIMenu_Setting::UIOptionGraphics' has a wrong offset!");
static_assert(offsetof(UUIMenu_Setting, UIOptionOperation) == 0x000560, "Member 'UUIMenu_Setting::UIOptionOperation' has a wrong offset!");

// Class DarwinGame.UICoinMenu_WinSort
// 0x0048 (0x0618 - 0x05D0)
class UUICoinMenu_WinSort : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     SortIcons;                                         // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIItemmenu_SortIconChoice*>     FileterIcons;                                      // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x18];                                     // 0x0600(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinMenu_WinSort">();
	}
	static class UUICoinMenu_WinSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinMenu_WinSort>();
	}
};
static_assert(alignof(UUICoinMenu_WinSort) == 0x000008, "Wrong alignment on UUICoinMenu_WinSort");
static_assert(sizeof(UUICoinMenu_WinSort) == 0x000618, "Wrong size on UUICoinMenu_WinSort");
static_assert(offsetof(UUICoinMenu_WinSort, SortIcons) == 0x0005E0, "Member 'UUICoinMenu_WinSort::SortIcons' has a wrong offset!");
static_assert(offsetof(UUICoinMenu_WinSort, FileterIcons) == 0x0005F0, "Member 'UUICoinMenu_WinSort::FileterIcons' has a wrong offset!");

// Class DarwinGame.UICoinRankIcon
// 0x0010 (0x04A0 - 0x0490)
class UUICoinRankIcon final : public UDarwinUserWidget
{
public:
	TArray<class UWidgetAnimation*>               RankAnimeArray;                                    // 0x0490(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitWidget(const TArray<class UWidgetAnimation*>& rankAnmAry);
	void SetData(int32 InParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICoinRankIcon">();
	}
	static class UUICoinRankIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICoinRankIcon>();
	}
};
static_assert(alignof(UUICoinRankIcon) == 0x000008, "Wrong alignment on UUICoinRankIcon");
static_assert(sizeof(UUICoinRankIcon) == 0x0004A0, "Wrong size on UUICoinRankIcon");
static_assert(offsetof(UUICoinRankIcon, RankAnimeArray) == 0x000490, "Member 'UUICoinRankIcon::RankAnimeArray' has a wrong offset!");

// Class DarwinGame.UICommonmenu_01
// 0x0058 (0x0628 - 0x05D0)
class UUICommonmenu_01 : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x28];                                     // 0x05D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICommonmenu_Sentence*                 DetailSentence;                                    // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_ItemName*                 DetailItemName;                                    // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIItemmenu_Artifact*                   DetailArtifact;                                    // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_SortIcon*                 SortIcon;                                          // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PanelSet;                                          // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_01">();
	}
	static class UUICommonmenu_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_01>();
	}
};
static_assert(alignof(UUICommonmenu_01) == 0x000008, "Wrong alignment on UUICommonmenu_01");
static_assert(sizeof(UUICommonmenu_01) == 0x000628, "Wrong size on UUICommonmenu_01");
static_assert(offsetof(UUICommonmenu_01, DetailSentence) == 0x0005F8, "Member 'UUICommonmenu_01::DetailSentence' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_01, DetailItemName) == 0x000600, "Member 'UUICommonmenu_01::DetailItemName' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_01, DetailArtifact) == 0x000608, "Member 'UUICommonmenu_01::DetailArtifact' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_01, SortIcon) == 0x000610, "Member 'UUICommonmenu_01::SortIcon' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_01, PanelSet) == 0x000618, "Member 'UUICommonmenu_01::PanelSet' has a wrong offset!");

// Class DarwinGame.UICommonmenu_02
// 0x0038 (0x0608 - 0x05D0)
class UUICommonmenu_02 final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICommonmenu_Sentence*                 Sentence;                                          // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIItemmenu_Material*                   Material;                                          // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x10];                                     // 0x05F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_02">();
	}
	static class UUICommonmenu_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_02>();
	}
};
static_assert(alignof(UUICommonmenu_02) == 0x000008, "Wrong alignment on UUICommonmenu_02");
static_assert(sizeof(UUICommonmenu_02) == 0x000608, "Wrong size on UUICommonmenu_02");
static_assert(offsetof(UUICommonmenu_02, Sentence) == 0x0005E8, "Member 'UUICommonmenu_02::Sentence' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_02, Material) == 0x0005F0, "Member 'UUICommonmenu_02::Material' has a wrong offset!");

// Class DarwinGame.UICommonmenu_03
// 0x0060 (0x0630 - 0x05D0)
class UUICommonmenu_03 final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x38];                                     // 0x05D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICommonmenu_SortIcon*                 SortIcon;                                          // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIItemmenu_BuySentence*                BuySentence;                                       // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUINowMoney*                            Buymoney;                                          // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_03">();
	}
	static class UUICommonmenu_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_03>();
	}
};
static_assert(alignof(UUICommonmenu_03) == 0x000008, "Wrong alignment on UUICommonmenu_03");
static_assert(sizeof(UUICommonmenu_03) == 0x000630, "Wrong size on UUICommonmenu_03");
static_assert(offsetof(UUICommonmenu_03, SortIcon) == 0x000608, "Member 'UUICommonmenu_03::SortIcon' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_03, BuySentence) == 0x000610, "Member 'UUICommonmenu_03::BuySentence' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_03, Buymoney) == 0x000618, "Member 'UUICommonmenu_03::Buymoney' has a wrong offset!");

// Class DarwinGame.UICommonmenu_ItemChoiceBase
// 0x0018 (0x0548 - 0x0530)
class UUICommonmenu_ItemChoiceBase : public UUIScrollMenuItemBase
{
public:
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_ItemIconBase*             ItemIcon;                                          // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x8];                                      // 0x0540(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_ItemChoiceBase">();
	}
	static class UUICommonmenu_ItemChoiceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_ItemChoiceBase>();
	}
};
static_assert(alignof(UUICommonmenu_ItemChoiceBase) == 0x000008, "Wrong alignment on UUICommonmenu_ItemChoiceBase");
static_assert(sizeof(UUICommonmenu_ItemChoiceBase) == 0x000548, "Wrong size on UUICommonmenu_ItemChoiceBase");
static_assert(offsetof(UUICommonmenu_ItemChoiceBase, Frame) == 0x000530, "Member 'UUICommonmenu_ItemChoiceBase::Frame' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoiceBase, ItemIcon) == 0x000538, "Member 'UUICommonmenu_ItemChoiceBase::ItemIcon' has a wrong offset!");

// Class DarwinGame.UIRewardWin_01
// 0x0010 (0x04A0 - 0x0490)
class UUIRewardWin_01 : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardWin_01">();
	}
	static class UUIRewardWin_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardWin_01>();
	}
};
static_assert(alignof(UUIRewardWin_01) == 0x000008, "Wrong alignment on UUIRewardWin_01");
static_assert(sizeof(UUIRewardWin_01) == 0x0004A0, "Wrong size on UUIRewardWin_01");

// Class DarwinGame.UICommonmenu_ItemChoice
// 0x0048 (0x0590 - 0x0548)
class UUICommonmenu_ItemChoice : public UUICommonmenu_ItemChoiceBase
{
public:
	uint8                                         Pad_548[0x10];                                     // 0x0548(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImageCheck;                                        // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageNew;                                          // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageDrop;                                         // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageTypeIcon;                                     // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageLockIcon;                                     // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageTreasureSetIcon;                              // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIItemmenu_HoldIcon*                   WidgetHoldIcon;                                    // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_ItemChoice">();
	}
	static class UUICommonmenu_ItemChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_ItemChoice>();
	}
};
static_assert(alignof(UUICommonmenu_ItemChoice) == 0x000008, "Wrong alignment on UUICommonmenu_ItemChoice");
static_assert(sizeof(UUICommonmenu_ItemChoice) == 0x000590, "Wrong size on UUICommonmenu_ItemChoice");
static_assert(offsetof(UUICommonmenu_ItemChoice, ImageCheck) == 0x000558, "Member 'UUICommonmenu_ItemChoice::ImageCheck' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoice, ImageNew) == 0x000560, "Member 'UUICommonmenu_ItemChoice::ImageNew' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoice, ImageDrop) == 0x000568, "Member 'UUICommonmenu_ItemChoice::ImageDrop' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoice, ImageTypeIcon) == 0x000570, "Member 'UUICommonmenu_ItemChoice::ImageTypeIcon' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoice, ImageLockIcon) == 0x000578, "Member 'UUICommonmenu_ItemChoice::ImageLockIcon' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoice, ImageTreasureSetIcon) == 0x000580, "Member 'UUICommonmenu_ItemChoice::ImageTreasureSetIcon' has a wrong offset!");
static_assert(offsetof(UUICommonmenu_ItemChoice, WidgetHoldIcon) == 0x000588, "Member 'UUICommonmenu_ItemChoice::WidgetHoldIcon' has a wrong offset!");

// Class DarwinGame.UICommonmenu_ItemName
// 0x0000 (0x0490 - 0x0490)
class UUICommonmenu_ItemName : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_ItemName">();
	}
	static class UUICommonmenu_ItemName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_ItemName>();
	}
};
static_assert(alignof(UUICommonmenu_ItemName) == 0x000008, "Wrong alignment on UUICommonmenu_ItemName");
static_assert(sizeof(UUICommonmenu_ItemName) == 0x000490, "Wrong size on UUICommonmenu_ItemName");

// Class DarwinGame.UICommonmenu_Sentence
// 0x0008 (0x0498 - 0x0490)
class UUICommonmenu_Sentence : public UUISentenceBase
{
public:
	class UAutoTextBlock*                         ItemNameText;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_Sentence">();
	}
	static class UUICommonmenu_Sentence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_Sentence>();
	}
};
static_assert(alignof(UUICommonmenu_Sentence) == 0x000008, "Wrong alignment on UUICommonmenu_Sentence");
static_assert(sizeof(UUICommonmenu_Sentence) == 0x000498, "Wrong size on UUICommonmenu_Sentence");
static_assert(offsetof(UUICommonmenu_Sentence, ItemNameText) == 0x000490, "Member 'UUICommonmenu_Sentence::ItemNameText' has a wrong offset!");

// Class DarwinGame.UICommonmenu_SortIcon
// 0x0000 (0x0490 - 0x0490)
class UUICommonmenu_SortIcon : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICommonmenu_SortIcon">();
	}
	static class UUICommonmenu_SortIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICommonmenu_SortIcon>();
	}
};
static_assert(alignof(UUICommonmenu_SortIcon) == 0x000008, "Wrong alignment on UUICommonmenu_SortIcon");
static_assert(sizeof(UUICommonmenu_SortIcon) == 0x000490, "Wrong size on UUICommonmenu_SortIcon");

// Class DarwinGame.UIComplete_Root
// 0x0050 (0x0520 - 0x04D0)
class alignas(0x10) UUIComplete_Root : public UUIInitWidget_Root
{
public:
	TArray<struct FST_ArtifactCompInfo>           ArtifactCompInfoList;                              // 0x04D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0x40];                                     // 0x04E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIComplete_Root">();
	}
	static class UUIComplete_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIComplete_Root>();
	}
};
static_assert(alignof(UUIComplete_Root) == 0x000010, "Wrong alignment on UUIComplete_Root");
static_assert(sizeof(UUIComplete_Root) == 0x000520, "Wrong size on UUIComplete_Root");
static_assert(offsetof(UUIComplete_Root, ArtifactCompInfoList) == 0x0004D0, "Member 'UUIComplete_Root::ArtifactCompInfoList' has a wrong offset!");

// Class DarwinGame.UIShot_IconReticle
// 0x0118 (0x05A8 - 0x0490)
class UUIShot_IconReticle : public UDarwinUserWidget
{
public:
	TMap<EButtonBaseMapping, class UTexture2D*>   ButtonBaseIcons;                                   // 0x0490(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FST_Reticle                            NormalReticle;                                     // 0x04E0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FST_Reticle                            AllyReticle;                                       // 0x0518(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FST_Reticle                            EnemyReticle;                                      // 0x0550(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UUIShot_MonsterName*                    MonsterName;                                       // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x18];                                     // 0x0590(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputDisable();
	void InputEnable();
	void PlayHoldOnAnimation(float PlaybackSpeed);
	void PlayInputLAnimation();
	void PlayInputRAnimation();
	void PlayLockWaitAnimation();
	void PlayShotAnimation();
	void SetAim(bool IsAim);
	void SetReticleVisibility(bool visible);
	void SlingShot();
	void StopHoldOnAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShot_IconReticle">();
	}
	static class UUIShot_IconReticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShot_IconReticle>();
	}
};
static_assert(alignof(UUIShot_IconReticle) == 0x000008, "Wrong alignment on UUIShot_IconReticle");
static_assert(sizeof(UUIShot_IconReticle) == 0x0005A8, "Wrong size on UUIShot_IconReticle");
static_assert(offsetof(UUIShot_IconReticle, ButtonBaseIcons) == 0x000490, "Member 'UUIShot_IconReticle::ButtonBaseIcons' has a wrong offset!");
static_assert(offsetof(UUIShot_IconReticle, NormalReticle) == 0x0004E0, "Member 'UUIShot_IconReticle::NormalReticle' has a wrong offset!");
static_assert(offsetof(UUIShot_IconReticle, AllyReticle) == 0x000518, "Member 'UUIShot_IconReticle::AllyReticle' has a wrong offset!");
static_assert(offsetof(UUIShot_IconReticle, EnemyReticle) == 0x000550, "Member 'UUIShot_IconReticle::EnemyReticle' has a wrong offset!");
static_assert(offsetof(UUIShot_IconReticle, MonsterName) == 0x000588, "Member 'UUIShot_IconReticle::MonsterName' has a wrong offset!");

// Class DarwinGame.UIContentMenu_Page03
// 0x0018 (0x0628 - 0x0610)
class UUIContentMenu_Page03 : public UUIPartyMenu_PMR_Page_Base
{
public:
	uint8                                         Pad_610[0x18];                                     // 0x0610(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Page03">();
	}
	static class UUIContentMenu_Page03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Page03>();
	}
};
static_assert(alignof(UUIContentMenu_Page03) == 0x000008, "Wrong alignment on UUIContentMenu_Page03");
static_assert(sizeof(UUIContentMenu_Page03) == 0x000628, "Wrong size on UUIContentMenu_Page03");

// Class DarwinGame.UIContentMenu_Page04
// 0x0018 (0x0628 - 0x0610)
class UUIContentMenu_Page04 : public UUIPartyMenu_PMR_Page_Base
{
public:
	uint8                                         Pad_610[0x18];                                     // 0x0610(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Page04">();
	}
	static class UUIContentMenu_Page04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Page04>();
	}
};
static_assert(alignof(UUIContentMenu_Page04) == 0x000008, "Wrong alignment on UUIContentMenu_Page04");
static_assert(sizeof(UUIContentMenu_Page04) == 0x000628, "Wrong size on UUIContentMenu_Page04");

// Class DarwinGame.UIContentMenu_Panel_01
// 0x0000 (0x0530 - 0x0530)
class UUIContentMenu_Panel_01 : public UUIPartyMenu_PM_Panel_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContentMenu_Panel_01">();
	}
	static class UUIContentMenu_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContentMenu_Panel_01>();
	}
};
static_assert(alignof(UUIContentMenu_Panel_01) == 0x000008, "Wrong alignment on UUIContentMenu_Panel_01");
static_assert(sizeof(UUIContentMenu_Panel_01) == 0x000530, "Wrong size on UUIContentMenu_Panel_01");

// Class DarwinGame.UIRival_03
// 0x0000 (0x0538 - 0x0538)
class UUIRival_03 : public UUIRivalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRival_03">();
	}
	static class UUIRival_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRival_03>();
	}
};
static_assert(alignof(UUIRival_03) == 0x000008, "Wrong alignment on UUIRival_03");
static_assert(sizeof(UUIRival_03) == 0x000538, "Wrong size on UUIRival_03");

// Class DarwinGame.UICursor_Partymenu_02
// 0x0000 (0x05F8 - 0x05F8)
class UUICursor_Partymenu_02 : public UUICursor_PartymenuFuelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_02">();
	}
	static class UUICursor_Partymenu_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_02>();
	}
};
static_assert(alignof(UUICursor_Partymenu_02) == 0x000008, "Wrong alignment on UUICursor_Partymenu_02");
static_assert(sizeof(UUICursor_Partymenu_02) == 0x0005F8, "Wrong size on UUICursor_Partymenu_02");

// Class DarwinGame.UICursor_Partymenu_03
// 0x0008 (0x05F0 - 0x05E8)
class UUICursor_Partymenu_03 : public UUICursor_PartymenuBase
{
public:
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_03">();
	}
	static class UUICursor_Partymenu_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_03>();
	}
};
static_assert(alignof(UUICursor_Partymenu_03) == 0x000008, "Wrong alignment on UUICursor_Partymenu_03");
static_assert(sizeof(UUICursor_Partymenu_03) == 0x0005F0, "Wrong size on UUICursor_Partymenu_03");

// Class DarwinGame.UICursor_Partymenu_07
// 0x0008 (0x05F0 - 0x05E8)
class UUICursor_Partymenu_07 : public UUICursor_PartymenuBase
{
public:
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICursor_Partymenu_07">();
	}
	static class UUICursor_Partymenu_07* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICursor_Partymenu_07>();
	}
};
static_assert(alignof(UUICursor_Partymenu_07) == 0x000008, "Wrong alignment on UUICursor_Partymenu_07");
static_assert(sizeof(UUICursor_Partymenu_07) == 0x0005F0, "Wrong size on UUICursor_Partymenu_07");

// Class DarwinGame.UIDelivery_Item_00
// 0x0058 (0x0668 - 0x0610)
class UUIDelivery_Item_00 final : public UUIWinMenuTwoChoices
{
public:
	uint8                                         Pad_610[0x28];                                     // 0x0610(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFreeScrollBase*                      FreeScrollList;                                    // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIIconChoice*                          ButtonOne;                                         // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x20];                                     // 0x0648(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_Item_00">();
	}
	static class UUIDelivery_Item_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_Item_00>();
	}
};
static_assert(alignof(UUIDelivery_Item_00) == 0x000008, "Wrong alignment on UUIDelivery_Item_00");
static_assert(sizeof(UUIDelivery_Item_00) == 0x000668, "Wrong size on UUIDelivery_Item_00");
static_assert(offsetof(UUIDelivery_Item_00, FreeScrollList) == 0x000638, "Member 'UUIDelivery_Item_00::FreeScrollList' has a wrong offset!");
static_assert(offsetof(UUIDelivery_Item_00, ButtonOne) == 0x000640, "Member 'UUIDelivery_Item_00::ButtonOne' has a wrong offset!");

// Class DarwinGame.UIPostUpdateWork
// 0x0000 (0x0228 - 0x0228)
class AUIPostUpdateWork final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPostUpdateWork">();
	}
	static class AUIPostUpdateWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPostUpdateWork>();
	}
};
static_assert(alignof(AUIPostUpdateWork) == 0x000008, "Wrong alignment on AUIPostUpdateWork");
static_assert(sizeof(AUIPostUpdateWork) == 0x000228, "Wrong size on AUIPostUpdateWork");

// Class DarwinGame.UIDelivery_ItemPanel_Mons
// 0x0000 (0x0490 - 0x0490)
class UUIDelivery_ItemPanel_Mons final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_ItemPanel_Mons">();
	}
	static class UUIDelivery_ItemPanel_Mons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_ItemPanel_Mons>();
	}
};
static_assert(alignof(UUIDelivery_ItemPanel_Mons) == 0x000008, "Wrong alignment on UUIDelivery_ItemPanel_Mons");
static_assert(sizeof(UUIDelivery_ItemPanel_Mons) == 0x000490, "Wrong size on UUIDelivery_ItemPanel_Mons");

// Class DarwinGame.UIDelivery_ItemPanel_Text
// 0x0000 (0x0490 - 0x0490)
class UUIDelivery_ItemPanel_Text final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_ItemPanel_Text">();
	}
	static class UUIDelivery_ItemPanel_Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_ItemPanel_Text>();
	}
};
static_assert(alignof(UUIDelivery_ItemPanel_Text) == 0x000008, "Wrong alignment on UUIDelivery_ItemPanel_Text");
static_assert(sizeof(UUIDelivery_ItemPanel_Text) == 0x000490, "Wrong size on UUIDelivery_ItemPanel_Text");

// Class DarwinGame.UIDelivery_List_Gold
// 0x0010 (0x0500 - 0x04F0)
class UUIDelivery_List_Gold final : public UUIFreeScrollBase
{
public:
	TArray<class UUIDelivery_ItemPanel_Gold*>     Panels;                                            // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_List_Gold">();
	}
	static class UUIDelivery_List_Gold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_List_Gold>();
	}
};
static_assert(alignof(UUIDelivery_List_Gold) == 0x000008, "Wrong alignment on UUIDelivery_List_Gold");
static_assert(sizeof(UUIDelivery_List_Gold) == 0x000500, "Wrong size on UUIDelivery_List_Gold");
static_assert(offsetof(UUIDelivery_List_Gold, Panels) == 0x0004F0, "Member 'UUIDelivery_List_Gold::Panels' has a wrong offset!");

// Class DarwinGame.UIDelivery_List_Mons
// 0x0010 (0x0500 - 0x04F0)
class UUIDelivery_List_Mons final : public UUIFreeScrollBase
{
public:
	TArray<class UUIDelivery_ItemPanel_Mons*>     Panels;                                            // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDelivery_List_Mons">();
	}
	static class UUIDelivery_List_Mons* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDelivery_List_Mons>();
	}
};
static_assert(alignof(UUIDelivery_List_Mons) == 0x000008, "Wrong alignment on UUIDelivery_List_Mons");
static_assert(sizeof(UUIDelivery_List_Mons) == 0x000500, "Wrong size on UUIDelivery_List_Mons");
static_assert(offsetof(UUIDelivery_List_Mons, Panels) == 0x0004F0, "Member 'UUIDelivery_List_Mons::Panels' has a wrong offset!");

// Class DarwinGame.UIDictMenuFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIDictMenuFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDictMenuFunctionLibrary">();
	}
	static class UUIDictMenuFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDictMenuFunctionLibrary>();
	}
};
static_assert(alignof(UUIDictMenuFunctionLibrary) == 0x000008, "Wrong alignment on UUIDictMenuFunctionLibrary");
static_assert(sizeof(UUIDictMenuFunctionLibrary) == 0x000030, "Wrong size on UUIDictMenuFunctionLibrary");

// Class DarwinGame.UIDiscovery_00
// 0x0010 (0x05C0 - 0x05B0)
class UUIDiscovery_00 : public UUI3DBase
{
public:
	uint8                                         Pad_5A8[0x18];                                     // 0x05A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGaugeData(float InNowDiscoveryPoint);
	void SetupData(class AActor* InTarget, float InMaxDiscoveryPoint, float InNowDiscoveryPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDiscovery_00">();
	}
	static class UUIDiscovery_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDiscovery_00>();
	}
};
static_assert(alignof(UUIDiscovery_00) == 0x000010, "Wrong alignment on UUIDiscovery_00");
static_assert(sizeof(UUIDiscovery_00) == 0x0005C0, "Wrong size on UUIDiscovery_00");

// Class DarwinGame.UIDiscovery_Icon
// 0x0000 (0x0490 - 0x0490)
class UUIDiscovery_Icon : public UDarwinUserWidget
{
public:
	void SetData(float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDiscovery_Icon">();
	}
	static class UUIDiscovery_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDiscovery_Icon>();
	}
};
static_assert(alignof(UUIDiscovery_Icon) == 0x000008, "Wrong alignment on UUIDiscovery_Icon");
static_assert(sizeof(UUIDiscovery_Icon) == 0x000490, "Wrong size on UUIDiscovery_Icon");

// Class DarwinGame.UIDispatch_CategoryIcon_Effect
// 0x0000 (0x0490 - 0x0490)
class UUIDispatch_CategoryIcon_Effect : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_CategoryIcon_Effect">();
	}
	static class UUIDispatch_CategoryIcon_Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_CategoryIcon_Effect>();
	}
};
static_assert(alignof(UUIDispatch_CategoryIcon_Effect) == 0x000008, "Wrong alignment on UUIDispatch_CategoryIcon_Effect");
static_assert(sizeof(UUIDispatch_CategoryIcon_Effect) == 0x000490, "Wrong size on UUIDispatch_CategoryIcon_Effect");

// Class DarwinGame.UIDispatch_Confirm
// 0x0010 (0x0620 - 0x0610)
class UUIDispatch_Confirm final : public UUIWinMenuTwoChoices
{
public:
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Confirm">();
	}
	static class UUIDispatch_Confirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Confirm>();
	}
};
static_assert(alignof(UUIDispatch_Confirm) == 0x000008, "Wrong alignment on UUIDispatch_Confirm");
static_assert(sizeof(UUIDispatch_Confirm) == 0x000620, "Wrong size on UUIDispatch_Confirm");

// Class DarwinGame.UIDispatch_Directing
// 0x0130 (0x05C0 - 0x0490)
class UUIDispatch_Directing final : public UDarwinUserWidget
{
public:
	float                                         WaitFlagTime;                                      // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrainToFadeTime;                                   // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDispatchTrainMovieType, class UObject*> TrainMovieTextureList;                             // 0x0498(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EDispatch_DirectingType, struct FDispatchDirectingEffectInfo> EffectList;                                        // 0x04E8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x80];                                     // 0x0538(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class ASofdecMoviePlayer*                     MoviePlayer;                                       // 0x05B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Directing">();
	}
	static class UUIDispatch_Directing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Directing>();
	}
};
static_assert(alignof(UUIDispatch_Directing) == 0x000008, "Wrong alignment on UUIDispatch_Directing");
static_assert(sizeof(UUIDispatch_Directing) == 0x0005C0, "Wrong size on UUIDispatch_Directing");
static_assert(offsetof(UUIDispatch_Directing, WaitFlagTime) == 0x000490, "Member 'UUIDispatch_Directing::WaitFlagTime' has a wrong offset!");
static_assert(offsetof(UUIDispatch_Directing, TrainToFadeTime) == 0x000494, "Member 'UUIDispatch_Directing::TrainToFadeTime' has a wrong offset!");
static_assert(offsetof(UUIDispatch_Directing, TrainMovieTextureList) == 0x000498, "Member 'UUIDispatch_Directing::TrainMovieTextureList' has a wrong offset!");
static_assert(offsetof(UUIDispatch_Directing, EffectList) == 0x0004E8, "Member 'UUIDispatch_Directing::EffectList' has a wrong offset!");
static_assert(offsetof(UUIDispatch_Directing, MoviePlayer) == 0x0005B8, "Member 'UUIDispatch_Directing::MoviePlayer' has a wrong offset!");

// Class DarwinGame.UIDispatch_Match_Eff
// 0x0068 (0x0560 - 0x04F8)
class UUIDispatch_Match_Eff : public UUIStartLoopAnimation
{
public:
	TMap<ECategoryMatchType, class UTexture2D*>   EffectDataList;                                    // 0x04F8(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         EffectList;                                        // 0x0548(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Match_Eff">();
	}
	static class UUIDispatch_Match_Eff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Match_Eff>();
	}
};
static_assert(alignof(UUIDispatch_Match_Eff) == 0x000008, "Wrong alignment on UUIDispatch_Match_Eff");
static_assert(sizeof(UUIDispatch_Match_Eff) == 0x000560, "Wrong size on UUIDispatch_Match_Eff");
static_assert(offsetof(UUIDispatch_Match_Eff, EffectDataList) == 0x0004F8, "Member 'UUIDispatch_Match_Eff::EffectDataList' has a wrong offset!");
static_assert(offsetof(UUIDispatch_Match_Eff, EffectList) == 0x000548, "Member 'UUIDispatch_Match_Eff::EffectList' has a wrong offset!");

// Class DarwinGame.UINGWordCheckFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUINGWordCheckFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINGWordCheckFunctionLibrary">();
	}
	static class UUINGWordCheckFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINGWordCheckFunctionLibrary>();
	}
};
static_assert(alignof(UUINGWordCheckFunctionLibrary) == 0x000008, "Wrong alignment on UUINGWordCheckFunctionLibrary");
static_assert(sizeof(UUINGWordCheckFunctionLibrary) == 0x000030, "Wrong size on UUINGWordCheckFunctionLibrary");

// Class DarwinGame.UIDispatch_Member
// 0x0050 (0x04E0 - 0x0490)
class UUIDispatch_Member final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Member">();
	}
	static class UUIDispatch_Member* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Member>();
	}
};
static_assert(alignof(UUIDispatch_Member) == 0x000008, "Wrong alignment on UUIDispatch_Member");
static_assert(sizeof(UUIDispatch_Member) == 0x0004E0, "Wrong size on UUIDispatch_Member");

// Class DarwinGame.UIDispatch_Member_Root
// 0x00A0 (0x0570 - 0x04D0)
class UUIDispatch_Member_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0xA0];                                     // 0x04D0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Member_Root">();
	}
	static class UUIDispatch_Member_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Member_Root>();
	}
};
static_assert(alignof(UUIDispatch_Member_Root) == 0x000008, "Wrong alignment on UUIDispatch_Member_Root");
static_assert(sizeof(UUIDispatch_Member_Root) == 0x000570, "Wrong size on UUIDispatch_Member_Root");

// Class DarwinGame.UIDispatch_Panel_00
// 0x0078 (0x05A8 - 0x0530)
class UUIDispatch_Panel_00 : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        MatchMaterialList;                                 // 0x0538(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x60];                                     // 0x0548(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Panel_00">();
	}
	static class UUIDispatch_Panel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Panel_00>();
	}
};
static_assert(alignof(UUIDispatch_Panel_00) == 0x000008, "Wrong alignment on UUIDispatch_Panel_00");
static_assert(sizeof(UUIDispatch_Panel_00) == 0x0005A8, "Wrong size on UUIDispatch_Panel_00");
static_assert(offsetof(UUIDispatch_Panel_00, MatchMaterialList) == 0x000538, "Member 'UUIDispatch_Panel_00::MatchMaterialList' has a wrong offset!");

// Class DarwinGame.UIDispatch_QuestLine
// 0x0020 (0x04B0 - 0x0490)
class UUIDispatch_QuestLine : public UDarwinUserWidget
{
public:
	TArray<class FName>                           PlayAnimList;                                      // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       NowPlayAnim;                                       // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_QuestLine">();
	}
	static class UUIDispatch_QuestLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_QuestLine>();
	}
};
static_assert(alignof(UUIDispatch_QuestLine) == 0x000008, "Wrong alignment on UUIDispatch_QuestLine");
static_assert(sizeof(UUIDispatch_QuestLine) == 0x0004B0, "Wrong size on UUIDispatch_QuestLine");
static_assert(offsetof(UUIDispatch_QuestLine, PlayAnimList) == 0x000490, "Member 'UUIDispatch_QuestLine::PlayAnimList' has a wrong offset!");
static_assert(offsetof(UUIDispatch_QuestLine, NowPlayAnim) == 0x0004A0, "Member 'UUIDispatch_QuestLine::NowPlayAnim' has a wrong offset!");

// Class DarwinGame.UIDispatch_Result_Root
// 0x0080 (0x0550 - 0x04D0)
class UUIDispatch_Result_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x80];                                     // 0x04D0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Result_Root">();
	}
	static class UUIDispatch_Result_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Result_Root>();
	}
};
static_assert(alignof(UUIDispatch_Result_Root) == 0x000008, "Wrong alignment on UUIDispatch_Result_Root");
static_assert(sizeof(UUIDispatch_Result_Root) == 0x000550, "Wrong size on UUIDispatch_Result_Root");

// Class DarwinGame.UIDispatch_Root
// 0x0010 (0x04E0 - 0x04D0)
class UUIDispatch_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Root">();
	}
	static class UUIDispatch_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Root>();
	}
};
static_assert(alignof(UUIDispatch_Root) == 0x000008, "Wrong alignment on UUIDispatch_Root");
static_assert(sizeof(UUIDispatch_Root) == 0x0004E0, "Wrong size on UUIDispatch_Root");

// Class DarwinGame.UIDispatch_Screen_02
// 0x0010 (0x04A0 - 0x0490)
class UUIDispatch_Screen_02 final : public UDarwinUserWidget
{
public:
	TArray<class FName>                           LoopAnimPartsList;                                 // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_Screen_02">();
	}
	static class UUIDispatch_Screen_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_Screen_02>();
	}
};
static_assert(alignof(UUIDispatch_Screen_02) == 0x000008, "Wrong alignment on UUIDispatch_Screen_02");
static_assert(sizeof(UUIDispatch_Screen_02) == 0x0004A0, "Wrong size on UUIDispatch_Screen_02");
static_assert(offsetof(UUIDispatch_Screen_02, LoopAnimPartsList) == 0x000490, "Member 'UUIDispatch_Screen_02::LoopAnimPartsList' has a wrong offset!");

// Class DarwinGame.UIDispatch_StationStatus
// 0x0000 (0x0518 - 0x0518)
class UUIDispatch_StationStatus final : public UUIDispatch_TeamStatusBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDispatch_StationStatus">();
	}
	static class UUIDispatch_StationStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDispatch_StationStatus>();
	}
};
static_assert(alignof(UUIDispatch_StationStatus) == 0x000008, "Wrong alignment on UUIDispatch_StationStatus");
static_assert(sizeof(UUIDispatch_StationStatus) == 0x000518, "Wrong size on UUIDispatch_StationStatus");

// Class DarwinGame.UIQuestQueueSystem
// 0x0030 (0x0060 - 0x0030)
class UUIQuestQueueSystem : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetQueueProcess(EUIQuestQueueProcessType InType, class FName InQuestID, bool bInIsDirecting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestQueueSystem">();
	}
	static class UUIQuestQueueSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestQueueSystem>();
	}
};
static_assert(alignof(UUIQuestQueueSystem) == 0x000008, "Wrong alignment on UUIQuestQueueSystem");
static_assert(sizeof(UUIQuestQueueSystem) == 0x000060, "Wrong size on UUIQuestQueueSystem");

// Class DarwinGame.UIEstimate_Appraise
// 0x0070 (0x0500 - 0x0490)
class UUIEstimate_Appraise : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x70];                                     // 0x0490(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_Appraise">();
	}
	static class UUIEstimate_Appraise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_Appraise>();
	}
};
static_assert(alignof(UUIEstimate_Appraise) == 0x000008, "Wrong alignment on UUIEstimate_Appraise");
static_assert(sizeof(UUIEstimate_Appraise) == 0x000500, "Wrong size on UUIEstimate_Appraise");

// Class DarwinGame.UIEstimate_BonusDialog
// 0x0030 (0x04C0 - 0x0490)
class UUIEstimate_BonusDialog final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIEstimate_HaveArtifact*>       HaveArtifactList;                                  // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_BonusEqual*                 BonusEqual;                                        // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_BonusText*                  BonusText;                                         // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_BonusDialog">();
	}
	static class UUIEstimate_BonusDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_BonusDialog>();
	}
};
static_assert(alignof(UUIEstimate_BonusDialog) == 0x000008, "Wrong alignment on UUIEstimate_BonusDialog");
static_assert(sizeof(UUIEstimate_BonusDialog) == 0x0004C0, "Wrong size on UUIEstimate_BonusDialog");
static_assert(offsetof(UUIEstimate_BonusDialog, HaveArtifactList) == 0x0004A0, "Member 'UUIEstimate_BonusDialog::HaveArtifactList' has a wrong offset!");
static_assert(offsetof(UUIEstimate_BonusDialog, BonusEqual) == 0x0004B0, "Member 'UUIEstimate_BonusDialog::BonusEqual' has a wrong offset!");
static_assert(offsetof(UUIEstimate_BonusDialog, BonusText) == 0x0004B8, "Member 'UUIEstimate_BonusDialog::BonusText' has a wrong offset!");

// Class DarwinGame.UIEstimate_BonusEqual
// 0x0000 (0x04A0 - 0x04A0)
class UUIEstimate_BonusEqual final : public UUIEstimate_BonusDialogItemBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_BonusEqual">();
	}
	static class UUIEstimate_BonusEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_BonusEqual>();
	}
};
static_assert(alignof(UUIEstimate_BonusEqual) == 0x000008, "Wrong alignment on UUIEstimate_BonusEqual");
static_assert(sizeof(UUIEstimate_BonusEqual) == 0x0004A0, "Wrong size on UUIEstimate_BonusEqual");

// Class DarwinGame.UIEstimate_BonusText
// 0x0020 (0x04C0 - 0x04A0)
class UUIEstimate_BonusText final : public UUIEstimate_BonusDialogItemBase
{
public:
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutoTextBlock*                         TextBlock;                                         // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        MaterialList;                                      // 0x04B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_BonusText">();
	}
	static class UUIEstimate_BonusText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_BonusText>();
	}
};
static_assert(alignof(UUIEstimate_BonusText) == 0x000008, "Wrong alignment on UUIEstimate_BonusText");
static_assert(sizeof(UUIEstimate_BonusText) == 0x0004C0, "Wrong size on UUIEstimate_BonusText");
static_assert(offsetof(UUIEstimate_BonusText, TextBlock) == 0x0004A8, "Member 'UUIEstimate_BonusText::TextBlock' has a wrong offset!");
static_assert(offsetof(UUIEstimate_BonusText, MaterialList) == 0x0004B0, "Member 'UUIEstimate_BonusText::MaterialList' has a wrong offset!");

// Class DarwinGame.UIEstimate_ItemPanel_00
// 0x00B8 (0x0548 - 0x0490)
class UUIEstimate_ItemPanel_00 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      ReplicaMaterial;                                   // 0x04B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ArtifactIcon;                                      // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_Effect*                     CursorEffect;                                      // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIEstimate_Effect*                     FlashEffect;                                       // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       InAnim;                                            // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x50];                                     // 0x04F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCsrFlashAnim();
	void EndInAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_ItemPanel_00">();
	}
	static class UUIEstimate_ItemPanel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_ItemPanel_00>();
	}
};
static_assert(alignof(UUIEstimate_ItemPanel_00) == 0x000008, "Wrong alignment on UUIEstimate_ItemPanel_00");
static_assert(sizeof(UUIEstimate_ItemPanel_00) == 0x000548, "Wrong size on UUIEstimate_ItemPanel_00");
static_assert(offsetof(UUIEstimate_ItemPanel_00, ReplicaMaterial) == 0x0004B0, "Member 'UUIEstimate_ItemPanel_00::ReplicaMaterial' has a wrong offset!");
static_assert(offsetof(UUIEstimate_ItemPanel_00, ArtifactIcon) == 0x0004D8, "Member 'UUIEstimate_ItemPanel_00::ArtifactIcon' has a wrong offset!");
static_assert(offsetof(UUIEstimate_ItemPanel_00, CursorEffect) == 0x0004E0, "Member 'UUIEstimate_ItemPanel_00::CursorEffect' has a wrong offset!");
static_assert(offsetof(UUIEstimate_ItemPanel_00, FlashEffect) == 0x0004E8, "Member 'UUIEstimate_ItemPanel_00::FlashEffect' has a wrong offset!");
static_assert(offsetof(UUIEstimate_ItemPanel_00, InAnim) == 0x0004F0, "Member 'UUIEstimate_ItemPanel_00::InAnim' has a wrong offset!");

// Class DarwinGame.UIEstimate_Opening
// 0x0018 (0x04A8 - 0x0490)
class UUIEstimate_Opening final : public UDarwinUserWidget
{
public:
	class UAtomComponent*                         InSe;                                              // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_Opening">();
	}
	static class UUIEstimate_Opening* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_Opening>();
	}
};
static_assert(alignof(UUIEstimate_Opening) == 0x000008, "Wrong alignment on UUIEstimate_Opening");
static_assert(sizeof(UUIEstimate_Opening) == 0x0004A8, "Wrong size on UUIEstimate_Opening");
static_assert(offsetof(UUIEstimate_Opening, InSe) == 0x000490, "Member 'UUIEstimate_Opening::InSe' has a wrong offset!");

// Class DarwinGame.UIEstimate_Thomasson_01
// 0x0008 (0x0498 - 0x0490)
class UUIEstimate_Thomasson_01 final : public UDarwinUserWidget
{
public:
	class UUIEstimate_WordBase*                   WordBase;                                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EndInAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_Thomasson_01">();
	}
	static class UUIEstimate_Thomasson_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_Thomasson_01>();
	}
};
static_assert(alignof(UUIEstimate_Thomasson_01) == 0x000008, "Wrong alignment on UUIEstimate_Thomasson_01");
static_assert(sizeof(UUIEstimate_Thomasson_01) == 0x000498, "Wrong size on UUIEstimate_Thomasson_01");
static_assert(offsetof(UUIEstimate_Thomasson_01, WordBase) == 0x000490, "Member 'UUIEstimate_Thomasson_01::WordBase' has a wrong offset!");

// Class DarwinGame.UIEstimate_ValuePanel_00
// 0x0038 (0x04C8 - 0x0490)
class UUIEstimate_ValuePanel_00 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             EffectDataTable;                                   // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FlashAnim;                                         // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BonusFlashAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimate_ValuePanel_00">();
	}
	static class UUIEstimate_ValuePanel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimate_ValuePanel_00>();
	}
};
static_assert(alignof(UUIEstimate_ValuePanel_00) == 0x000008, "Wrong alignment on UUIEstimate_ValuePanel_00");
static_assert(sizeof(UUIEstimate_ValuePanel_00) == 0x0004C8, "Wrong size on UUIEstimate_ValuePanel_00");
static_assert(offsetof(UUIEstimate_ValuePanel_00, EffectDataTable) == 0x0004A0, "Member 'UUIEstimate_ValuePanel_00::EffectDataTable' has a wrong offset!");
static_assert(offsetof(UUIEstimate_ValuePanel_00, FlashAnim) == 0x0004B0, "Member 'UUIEstimate_ValuePanel_00::FlashAnim' has a wrong offset!");

// Class DarwinGame.UIEstimatedPriceUpPerformance
// 0x0038 (0x0590 - 0x0558)
class UUIEstimatedPriceUpPerformance final : public UUIEstimatePerformanceBase
{
public:
	class UDarwinSceneCaptureImage*               CaptureImage;                                      // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x30];                                     // 0x0560(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimatedPriceUpPerformance">();
	}
	static class UUIEstimatedPriceUpPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimatedPriceUpPerformance>();
	}
};
static_assert(alignof(UUIEstimatedPriceUpPerformance) == 0x000008, "Wrong alignment on UUIEstimatedPriceUpPerformance");
static_assert(sizeof(UUIEstimatedPriceUpPerformance) == 0x000590, "Wrong size on UUIEstimatedPriceUpPerformance");
static_assert(offsetof(UUIEstimatedPriceUpPerformance, CaptureImage) == 0x000558, "Member 'UUIEstimatedPriceUpPerformance::CaptureImage' has a wrong offset!");

// Class DarwinGame.UIItemmenu_ItemIconRankBase
// 0x0008 (0x0498 - 0x0490)
class UUIItemmenu_ItemIconRankBase : public UDarwinUserWidget
{
public:
	class UImage*                                 ImgIconItem;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_ItemIconRankBase">();
	}
	static class UUIItemmenu_ItemIconRankBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_ItemIconRankBase>();
	}
};
static_assert(alignof(UUIItemmenu_ItemIconRankBase) == 0x000008, "Wrong alignment on UUIItemmenu_ItemIconRankBase");
static_assert(sizeof(UUIItemmenu_ItemIconRankBase) == 0x000498, "Wrong size on UUIItemmenu_ItemIconRankBase");
static_assert(offsetof(UUIItemmenu_ItemIconRankBase, ImgIconItem) == 0x000490, "Member 'UUIItemmenu_ItemIconRankBase::ImgIconItem' has a wrong offset!");

// Class DarwinGame.UIItemmenu_WinDetail
// 0x0018 (0x04B0 - 0x0498)
class UUIItemmenu_WinDetail final : public UUIItemmenu_ItemIconRankBase
{
public:
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_WinList*>            WinListArray;                                      // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinDetail">();
	}
	static class UUIItemmenu_WinDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinDetail>();
	}
};
static_assert(alignof(UUIItemmenu_WinDetail) == 0x000008, "Wrong alignment on UUIItemmenu_WinDetail");
static_assert(sizeof(UUIItemmenu_WinDetail) == 0x0004B0, "Wrong size on UUIItemmenu_WinDetail");
static_assert(offsetof(UUIItemmenu_WinDetail, WinListArray) == 0x0004A0, "Member 'UUIItemmenu_WinDetail::WinListArray' has a wrong offset!");

// Class DarwinGame.UIEstimatedPriceUpPerformance_Root
// 0x0048 (0x0518 - 0x04D0)
class UUIEstimatedPriceUpPerformance_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x48];                                     // 0x04D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEstimatedPriceUpPerformance_Root">();
	}
	static class UUIEstimatedPriceUpPerformance_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEstimatedPriceUpPerformance_Root>();
	}
};
static_assert(alignof(UUIEstimatedPriceUpPerformance_Root) == 0x000008, "Wrong alignment on UUIEstimatedPriceUpPerformance_Root");
static_assert(sizeof(UUIEstimatedPriceUpPerformance_Root) == 0x000518, "Wrong size on UUIEstimatedPriceUpPerformance_Root");

// Class DarwinGame.UIEvent_FullScreenImageNear
// 0x0000 (0x04A0 - 0x04A0)
class UUIEvent_FullScreenImageNear : public UUIEvent_FullScreenImageBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEvent_FullScreenImageNear">();
	}
	static class UUIEvent_FullScreenImageNear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEvent_FullScreenImageNear>();
	}
};
static_assert(alignof(UUIEvent_FullScreenImageNear) == 0x000008, "Wrong alignment on UUIEvent_FullScreenImageNear");
static_assert(sizeof(UUIEvent_FullScreenImageNear) == 0x0004A0, "Wrong size on UUIEvent_FullScreenImageNear");

// Class DarwinGame.UIEvent_Subtitles
// 0x0010 (0x04A0 - 0x0490)
class UUIEvent_Subtitles : public UDarwinUserWidget
{
public:
	class UTextWidget*                            Text;                                              // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidgetData*                        textData;                                          // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEvent_Subtitles">();
	}
	static class UUIEvent_Subtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEvent_Subtitles>();
	}
};
static_assert(alignof(UUIEvent_Subtitles) == 0x000008, "Wrong alignment on UUIEvent_Subtitles");
static_assert(sizeof(UUIEvent_Subtitles) == 0x0004A0, "Wrong size on UUIEvent_Subtitles");
static_assert(offsetof(UUIEvent_Subtitles, Text) == 0x000490, "Member 'UUIEvent_Subtitles::Text' has a wrong offset!");
static_assert(offsetof(UUIEvent_Subtitles, textData) == 0x000498, "Member 'UUIEvent_Subtitles::textData' has a wrong offset!");

// Class DarwinGame.UIFacility_CategoryArea
// 0x0000 (0x0490 - 0x0490)
class UUIFacility_CategoryArea : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_CategoryArea">();
	}
	static class UUIFacility_CategoryArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_CategoryArea>();
	}
};
static_assert(alignof(UUIFacility_CategoryArea) == 0x000008, "Wrong alignment on UUIFacility_CategoryArea");
static_assert(sizeof(UUIFacility_CategoryArea) == 0x000490, "Wrong size on UUIFacility_CategoryArea");

// Class DarwinGame.UIFacility_Choice
// 0x0030 (0x0560 - 0x0530)
class UUIFacility_Choice final : public UUIScrollMenuItemBase
{
public:
	class FText                                   DefaultButtonText;                                 // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UImage*                                 FocusImg;                                          // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAutoTextBlock*                         BtnText;                                           // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_Choice">();
	}
	static class UUIFacility_Choice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_Choice>();
	}
};
static_assert(alignof(UUIFacility_Choice) == 0x000008, "Wrong alignment on UUIFacility_Choice");
static_assert(sizeof(UUIFacility_Choice) == 0x000560, "Wrong size on UUIFacility_Choice");
static_assert(offsetof(UUIFacility_Choice, DefaultButtonText) == 0x000530, "Member 'UUIFacility_Choice::DefaultButtonText' has a wrong offset!");
static_assert(offsetof(UUIFacility_Choice, FocusImg) == 0x000548, "Member 'UUIFacility_Choice::FocusImg' has a wrong offset!");
static_assert(offsetof(UUIFacility_Choice, BtnText) == 0x000550, "Member 'UUIFacility_Choice::BtnText' has a wrong offset!");

// Class DarwinGame.UIFacility_EscapeContent
// 0x0050 (0x04E0 - 0x0490)
class UUIFacility_EscapeContent final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_EscapeContent">();
	}
	static class UUIFacility_EscapeContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_EscapeContent>();
	}
};
static_assert(alignof(UUIFacility_EscapeContent) == 0x000008, "Wrong alignment on UUIFacility_EscapeContent");
static_assert(sizeof(UUIFacility_EscapeContent) == 0x0004E0, "Wrong size on UUIFacility_EscapeContent");

// Class DarwinGame.UIFacility_MonsterIcon
// 0x0070 (0x0500 - 0x0490)
class UUIFacility_MonsterIcon final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x68];                                     // 0x0490(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 FieldLinkIcon;                                     // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_MonsterIcon">();
	}
	static class UUIFacility_MonsterIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_MonsterIcon>();
	}
};
static_assert(alignof(UUIFacility_MonsterIcon) == 0x000008, "Wrong alignment on UUIFacility_MonsterIcon");
static_assert(sizeof(UUIFacility_MonsterIcon) == 0x000500, "Wrong size on UUIFacility_MonsterIcon");
static_assert(offsetof(UUIFacility_MonsterIcon, FieldLinkIcon) == 0x0004F8, "Member 'UUIFacility_MonsterIcon::FieldLinkIcon' has a wrong offset!");

// Class DarwinGame.UIFacility_MonsterIconChoice
// 0x0040 (0x0570 - 0x0530)
class UUIFacility_MonsterIconChoice final : public UUIScrollMenuItemBase
{
public:
	class UImage*                                 ImageNew;                                          // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageCustom;                                       // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITeamIcon_Set*                        TeamIcon;                                          // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFacility_MonsterIcon*                MonsterIcon;                                       // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MotivationUpIcon;                                  // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 JourneyIcon;                                       // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_MonsterIconChoice">();
	}
	static class UUIFacility_MonsterIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_MonsterIconChoice>();
	}
};
static_assert(alignof(UUIFacility_MonsterIconChoice) == 0x000008, "Wrong alignment on UUIFacility_MonsterIconChoice");
static_assert(sizeof(UUIFacility_MonsterIconChoice) == 0x000570, "Wrong size on UUIFacility_MonsterIconChoice");
static_assert(offsetof(UUIFacility_MonsterIconChoice, ImageNew) == 0x000530, "Member 'UUIFacility_MonsterIconChoice::ImageNew' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterIconChoice, ImageCustom) == 0x000538, "Member 'UUIFacility_MonsterIconChoice::ImageCustom' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterIconChoice, TeamIcon) == 0x000540, "Member 'UUIFacility_MonsterIconChoice::TeamIcon' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterIconChoice, Frame) == 0x000548, "Member 'UUIFacility_MonsterIconChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterIconChoice, MonsterIcon) == 0x000550, "Member 'UUIFacility_MonsterIconChoice::MonsterIcon' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterIconChoice, MotivationUpIcon) == 0x000558, "Member 'UUIFacility_MonsterIconChoice::MotivationUpIcon' has a wrong offset!");
static_assert(offsetof(UUIFacility_MonsterIconChoice, JourneyIcon) == 0x000560, "Member 'UUIFacility_MonsterIconChoice::JourneyIcon' has a wrong offset!");

// Class DarwinGame.UIFacility_MonsterName
// 0x0058 (0x04E8 - 0x0490)
class UUIFacility_MonsterName final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 FieldLinkIcon;                                     // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_MonsterName">();
	}
	static class UUIFacility_MonsterName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_MonsterName>();
	}
};
static_assert(alignof(UUIFacility_MonsterName) == 0x000008, "Wrong alignment on UUIFacility_MonsterName");
static_assert(sizeof(UUIFacility_MonsterName) == 0x0004E8, "Wrong size on UUIFacility_MonsterName");
static_assert(offsetof(UUIFacility_MonsterName, FieldLinkIcon) == 0x0004E0, "Member 'UUIFacility_MonsterName::FieldLinkIcon' has a wrong offset!");

// Class DarwinGame.UIFacility_WinChoice
// 0x0050 (0x0620 - 0x05D0)
class UUIFacility_WinChoice final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x50];                                     // 0x05D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_WinChoice">();
	}
	static class UUIFacility_WinChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_WinChoice>();
	}
};
static_assert(alignof(UUIFacility_WinChoice) == 0x000008, "Wrong alignment on UUIFacility_WinChoice");
static_assert(sizeof(UUIFacility_WinChoice) == 0x000620, "Wrong size on UUIFacility_WinChoice");

// Class DarwinGame.UIMonsterDict_Content_Trivia
// 0x0000 (0x0490 - 0x0490)
class UUIMonsterDict_Content_Trivia : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_Trivia">();
	}
	static class UUIMonsterDict_Content_Trivia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_Trivia>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_Trivia) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_Trivia");
static_assert(sizeof(UUIMonsterDict_Content_Trivia) == 0x000490, "Wrong size on UUIMonsterDict_Content_Trivia");

// Class DarwinGame.UIFacility_WinEscape
// 0x0008 (0x0618 - 0x0610)
class UUIFacility_WinEscape final : public UUIWinMenuTwoChoices
{
public:
	class UUIFacility_EscapeContent*              Content;                                           // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacility_WinEscape">();
	}
	static class UUIFacility_WinEscape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacility_WinEscape>();
	}
};
static_assert(alignof(UUIFacility_WinEscape) == 0x000008, "Wrong alignment on UUIFacility_WinEscape");
static_assert(sizeof(UUIFacility_WinEscape) == 0x000618, "Wrong size on UUIFacility_WinEscape");
static_assert(offsetof(UUIFacility_WinEscape, Content) == 0x000610, "Member 'UUIFacility_WinEscape::Content' has a wrong offset!");

// Class DarwinGame.UIFacilityBulletItem
// 0x0000 (0x0030 - 0x0030)
class UUIFacilityBulletItem final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityBulletItem">();
	}
	static class UUIFacilityBulletItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityBulletItem>();
	}
};
static_assert(alignof(UUIFacilityBulletItem) == 0x000008, "Wrong alignment on UUIFacilityBulletItem");
static_assert(sizeof(UUIFacilityBulletItem) == 0x000030, "Wrong size on UUIFacilityBulletItem");

// Class DarwinGame.UIFacilityMenuBase
// 0x0018 (0x04A8 - 0x0490)
class UUIFacilityMenuBase : public UDarwinUserWidget
{
public:
	class UUIFacilityMenu_Set*                    UIMonsterFacility;                                 // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityMenuBase">();
	}
	static class UUIFacilityMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityMenuBase>();
	}
};
static_assert(alignof(UUIFacilityMenuBase) == 0x000008, "Wrong alignment on UUIFacilityMenuBase");
static_assert(sizeof(UUIFacilityMenuBase) == 0x0004A8, "Wrong size on UUIFacilityMenuBase");
static_assert(offsetof(UUIFacilityMenuBase, UIMonsterFacility) == 0x000490, "Member 'UUIFacilityMenuBase::UIMonsterFacility' has a wrong offset!");

// Class DarwinGame.UIFacilityMenu
// 0x0008 (0x04B0 - 0x04A8)
class UUIFacilityMenu final : public UUIFacilityMenuBase
{
public:
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityMenu">();
	}
	static class UUIFacilityMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityMenu>();
	}
};
static_assert(alignof(UUIFacilityMenu) == 0x000008, "Wrong alignment on UUIFacilityMenu");
static_assert(sizeof(UUIFacilityMenu) == 0x0004B0, "Wrong size on UUIFacilityMenu");

// Class DarwinGame.UIFacilityMenu_Quest
// 0x0030 (0x04D8 - 0x04A8)
class UUIFacilityMenu_Quest final : public UUIFacilityMenuBase
{
public:
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             EmptyDescription;                                  // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MonsterIconListWidget;                             // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityMenu_Quest">();
	}
	static class UUIFacilityMenu_Quest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityMenu_Quest>();
	}
};
static_assert(alignof(UUIFacilityMenu_Quest) == 0x000008, "Wrong alignment on UUIFacilityMenu_Quest");
static_assert(sizeof(UUIFacilityMenu_Quest) == 0x0004D8, "Wrong size on UUIFacilityMenu_Quest");
static_assert(offsetof(UUIFacilityMenu_Quest, EmptyDescription) == 0x0004B8, "Member 'UUIFacilityMenu_Quest::EmptyDescription' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Quest, MonsterIconListWidget) == 0x0004C0, "Member 'UUIFacilityMenu_Quest::MonsterIconListWidget' has a wrong offset!");

// Class DarwinGame.UIFacilityMenu_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIFacilityMenu_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityMenu_Root">();
	}
	static class UUIFacilityMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityMenu_Root>();
	}
};
static_assert(alignof(UUIFacilityMenu_Root) == 0x000008, "Wrong alignment on UUIFacilityMenu_Root");
static_assert(sizeof(UUIFacilityMenu_Root) == 0x0004D8, "Wrong size on UUIFacilityMenu_Root");

// Class DarwinGame.UIFacilityMenu_Set
// 0x00A8 (0x0678 - 0x05D0)
class UUIFacilityMenu_Set final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIFacility_MonsterIcon*>        ItemIcons;                                         // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFacility_MonsterName*                MonsterName;                                       // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_SortIcon*                 SortIcon;                                          // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EMonsterSort                                  DefaultSort;                                       // 0x0610(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMonsterSort>                          SortArray;                                         // 0x0618(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIHeader_01*                           UIHeader;                                          // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNewAllHide;                                     // 0x0638(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_639[0x2F];                                     // 0x0639(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_MonsterIconTextures>        MonsterIconTextures;                               // 0x0668(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFacilityMenu_Set">();
	}
	static class UUIFacilityMenu_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFacilityMenu_Set>();
	}
};
static_assert(alignof(UUIFacilityMenu_Set) == 0x000008, "Wrong alignment on UUIFacilityMenu_Set");
static_assert(sizeof(UUIFacilityMenu_Set) == 0x000678, "Wrong size on UUIFacilityMenu_Set");
static_assert(offsetof(UUIFacilityMenu_Set, ItemIcons) == 0x0005E0, "Member 'UUIFacilityMenu_Set::ItemIcons' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, MonsterName) == 0x0005F0, "Member 'UUIFacilityMenu_Set::MonsterName' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, SortIcon) == 0x0005F8, "Member 'UUIFacilityMenu_Set::SortIcon' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, DefaultSort) == 0x000610, "Member 'UUIFacilityMenu_Set::DefaultSort' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, SortArray) == 0x000618, "Member 'UUIFacilityMenu_Set::SortArray' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, UIHeader) == 0x000628, "Member 'UUIFacilityMenu_Set::UIHeader' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, UIUnderButton) == 0x000630, "Member 'UUIFacilityMenu_Set::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, bIsNewAllHide) == 0x000638, "Member 'UUIFacilityMenu_Set::bIsNewAllHide' has a wrong offset!");
static_assert(offsetof(UUIFacilityMenu_Set, MonsterIconTextures) == 0x000668, "Member 'UUIFacilityMenu_Set::MonsterIconTextures' has a wrong offset!");

// Class DarwinGame.UIFade
// 0x0038 (0x04C8 - 0x0490)
class UUIFade : public UUIResidentWidgetBase
{
public:
	bool                                          bIsFade;                                           // 0x0490(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIFadeType                                   FadeType;                                          // 0x0491(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_492[0x36];                                     // 0x0492(0x0036)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadCastFadeInDelegate();
	void BroadCastFadeOutDelegate();
	void FadeInScreen(float Time);
	void FadeOutScreen(float Time, const struct FLinearColor& Color, EFadeZOrderType ZorderType);
	void FadeOutScreenKeepAlpha(float Time, const struct FLinearColor& Color, EFadeZOrderType ZorderType);
	bool IsFadeActive();
	void ReAddViewPort(EFadeZOrderType ZorderType);

	float GetCurrentFrameRate() const;
	EUIFadeType GetFadeType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFade">();
	}
	static class UUIFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFade>();
	}
};
static_assert(alignof(UUIFade) == 0x000008, "Wrong alignment on UUIFade");
static_assert(sizeof(UUIFade) == 0x0004C8, "Wrong size on UUIFade");
static_assert(offsetof(UUIFade, bIsFade) == 0x000490, "Member 'UUIFade::bIsFade' has a wrong offset!");
static_assert(offsetof(UUIFade, FadeType) == 0x000491, "Member 'UUIFade::FadeType' has a wrong offset!");

// Class DarwinGame.UIField_ActionIcon_SquatPoint
// 0x0000 (0x05B0 - 0x05B0)
class UUIField_ActionIcon_SquatPoint : public UUIField_ActionIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_ActionIcon_SquatPoint">();
	}
	static class UUIField_ActionIcon_SquatPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_ActionIcon_SquatPoint>();
	}
};
static_assert(alignof(UUIField_ActionIcon_SquatPoint) == 0x000010, "Wrong alignment on UUIField_ActionIcon_SquatPoint");
static_assert(sizeof(UUIField_ActionIcon_SquatPoint) == 0x0005B0, "Wrong size on UUIField_ActionIcon_SquatPoint");

// Class DarwinGame.UIField_IconLink
// 0x00F0 (0x0580 - 0x0490)
class UUIField_IconLink : public UDarwinUserWidget
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      GuideCautinoIconList;                              // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x40];                                     // 0x04A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAxisMappingType, class UWidgetAnimation*> CautionOnPlayAnim;                                 // 0x04E0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EAxisMappingType, class UWidgetAnimation*> CautionOffPlayAnim;                                // 0x0530(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ResetButtonData(EAxisMappingType Button);
	void SetCanUseButton(ELinkType Type, EAxisMappingType Button, bool bCanUse, bool bIsRecast);
	void SetLinkType(ELinkType Type);
	void SetMonsterIcon(EAxisMappingType Button, class FName KindId);
	void SetRecastPercent(ELinkType Type, EAxisMappingType Button, float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_IconLink">();
	}
	static class UUIField_IconLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_IconLink>();
	}
};
static_assert(alignof(UUIField_IconLink) == 0x000008, "Wrong alignment on UUIField_IconLink");
static_assert(sizeof(UUIField_IconLink) == 0x000580, "Wrong size on UUIField_IconLink");
static_assert(offsetof(UUIField_IconLink, GuideCautinoIconList) == 0x000490, "Member 'UUIField_IconLink::GuideCautinoIconList' has a wrong offset!");
static_assert(offsetof(UUIField_IconLink, CautionOnPlayAnim) == 0x0004E0, "Member 'UUIField_IconLink::CautionOnPlayAnim' has a wrong offset!");
static_assert(offsetof(UUIField_IconLink, CautionOffPlayAnim) == 0x000530, "Member 'UUIField_IconLink::CautionOffPlayAnim' has a wrong offset!");

// Class DarwinGame.UIQMR_Page_03
// 0x0010 (0x0500 - 0x04F0)
class UUIQMR_Page_03 : public UUIFreeScrollBase
{
public:
	TArray<class UUIQM_Panel_04*>                 Items;                                             // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQMR_Page_03">();
	}
	static class UUIQMR_Page_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQMR_Page_03>();
	}
};
static_assert(alignof(UUIQMR_Page_03) == 0x000008, "Wrong alignment on UUIQMR_Page_03");
static_assert(sizeof(UUIQMR_Page_03) == 0x000500, "Wrong size on UUIQMR_Page_03");
static_assert(offsetof(UUIQMR_Page_03, Items) == 0x0004F0, "Member 'UUIQMR_Page_03::Items' has a wrong offset!");

// Class DarwinGame.UIField_IconStamp_CompositeBase
// 0x0020 (0x05D0 - 0x05B0)
class UUIField_IconStamp_CompositeBase : public UUI3DBase
{
public:
	class UWidgetAnimation*                       OpenAnim;                                          // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x20];                                     // 0x05B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_IconStamp_CompositeBase">();
	}
	static class UUIField_IconStamp_CompositeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_IconStamp_CompositeBase>();
	}
};
static_assert(alignof(UUIField_IconStamp_CompositeBase) == 0x000010, "Wrong alignment on UUIField_IconStamp_CompositeBase");
static_assert(sizeof(UUIField_IconStamp_CompositeBase) == 0x0005D0, "Wrong size on UUIField_IconStamp_CompositeBase");
static_assert(offsetof(UUIField_IconStamp_CompositeBase, OpenAnim) == 0x0005A8, "Member 'UUIField_IconStamp_CompositeBase::OpenAnim' has a wrong offset!");

// Class DarwinGame.UIField_Mouse_Action
// 0x0070 (0x0500 - 0x0490)
class UUIField_Mouse_Action : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     ActionIcons;                                       // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     BaseIcons;                                         // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x50];                                     // 0x04B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_Mouse_Action">();
	}
	static class UUIField_Mouse_Action* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_Mouse_Action>();
	}
};
static_assert(alignof(UUIField_Mouse_Action) == 0x000008, "Wrong alignment on UUIField_Mouse_Action");
static_assert(sizeof(UUIField_Mouse_Action) == 0x000500, "Wrong size on UUIField_Mouse_Action");
static_assert(offsetof(UUIField_Mouse_Action, ActionIcons) == 0x000490, "Member 'UUIField_Mouse_Action::ActionIcons' has a wrong offset!");
static_assert(offsetof(UUIField_Mouse_Action, BaseIcons) == 0x0004A0, "Member 'UUIField_Mouse_Action::BaseIcons' has a wrong offset!");

// Class DarwinGame.UIField_QuestConfirmation
// 0x0090 (0x0520 - 0x0490)
class alignas(0x10) UUIField_QuestConfirmation : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x78];                                     // 0x0490(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             GuideTextBlock;                                    // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 GuideButton;                                       // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x8];                                      // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_QuestConfirmation">();
	}
	static class UUIField_QuestConfirmation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_QuestConfirmation>();
	}
};
static_assert(alignof(UUIField_QuestConfirmation) == 0x000010, "Wrong alignment on UUIField_QuestConfirmation");
static_assert(sizeof(UUIField_QuestConfirmation) == 0x000520, "Wrong size on UUIField_QuestConfirmation");
static_assert(offsetof(UUIField_QuestConfirmation, GuideTextBlock) == 0x000508, "Member 'UUIField_QuestConfirmation::GuideTextBlock' has a wrong offset!");
static_assert(offsetof(UUIField_QuestConfirmation, GuideButton) == 0x000510, "Member 'UUIField_QuestConfirmation::GuideButton' has a wrong offset!");

// Class DarwinGame.UIField_SearchPoint
// 0x0000 (0x05B0 - 0x05B0)
class UUIField_SearchPoint : public UUI3DBase
{
public:
	class UWidgetAnimation*                       WaitAnimation;                                     // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetCanAccess(bool bCanAccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_SearchPoint">();
	}
	static class UUIField_SearchPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_SearchPoint>();
	}
};
static_assert(alignof(UUIField_SearchPoint) == 0x000010, "Wrong alignment on UUIField_SearchPoint");
static_assert(sizeof(UUIField_SearchPoint) == 0x0005B0, "Wrong size on UUIField_SearchPoint");
static_assert(offsetof(UUIField_SearchPoint, WaitAnimation) == 0x0005A8, "Member 'UUIField_SearchPoint::WaitAnimation' has a wrong offset!");

// Class DarwinGame.UIField_Status
// 0x0088 (0x0518 - 0x0490)
class UUIField_Status : public UDarwinUserWidget
{
public:
	bool                                          bIsBattlingFlag;                                   // 0x0490(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMoveingFlag;                                    // 0x0491(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAllyShotHoldFlag;                               // 0x0492(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_493[0x5];                                      // 0x0493(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIField_WinPStatus*                    PlayerStatus;                                      // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIField_WinFStatus*>            FriendStatusList;                                  // 0x04A0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIField_WinQuest*                      QuestWindow;                                       // 0x04B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMap_WinStatus*                       NaviMap;                                           // 0x04B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIField_Mouse_Action*                  LeftMouseIndicator;                                // 0x04C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MainMenuGuide;                                     // 0x04C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WindowInCountMax;                                  // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WindowOutCountMax;                                 // 0x04D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x20];                                     // 0x04D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                ButtonUpWidget;                                    // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             GuideTeamWidget;                                   // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             GuideTextBlock;                                    // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUIArtifactList_Field* GetArtifactIconList();
	class UUIField_WinBoss* GetBossStatus();
	class UUIAlert_01* GetBottomCautionAlert();
	class UUICaution* GetCaution();
	class UUIField_WinFStatus* GetFriendStatus(int32 Index_0);
	class UUIField_WinLogbox* GetLogWindow();
	class UUIMap_WinStatus* GetMapStatus();
	class UUIVision_Field* GetMonsterVision();
	class UUIField_WinPStatus* GetPlayerStatus();
	class UUIField_QuestConfirmation* GetQuestConfirmation();
	class UUIField_WinQuest* GetQuestWindow();
	class UUIField_WinSkillbox* GetSkillChainWindow();
	class UUIAlert_00* GetTopCautionAlert();
	void GetUnusedFriendStatus(class UUIField_WinFStatus** OutWidget, int32* ResultIndex);
	void SetAllyShotHoldFlag(bool bFlag);
	void SetBattlingFlag(bool bFlag);
	void SetMoveingFlag(bool bFlag);
	void UpdateEventFlagVisible();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_Status">();
	}
	static class UUIField_Status* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_Status>();
	}
};
static_assert(alignof(UUIField_Status) == 0x000008, "Wrong alignment on UUIField_Status");
static_assert(sizeof(UUIField_Status) == 0x000518, "Wrong size on UUIField_Status");
static_assert(offsetof(UUIField_Status, bIsBattlingFlag) == 0x000490, "Member 'UUIField_Status::bIsBattlingFlag' has a wrong offset!");
static_assert(offsetof(UUIField_Status, bIsMoveingFlag) == 0x000491, "Member 'UUIField_Status::bIsMoveingFlag' has a wrong offset!");
static_assert(offsetof(UUIField_Status, bIsAllyShotHoldFlag) == 0x000492, "Member 'UUIField_Status::bIsAllyShotHoldFlag' has a wrong offset!");
static_assert(offsetof(UUIField_Status, PlayerStatus) == 0x000498, "Member 'UUIField_Status::PlayerStatus' has a wrong offset!");
static_assert(offsetof(UUIField_Status, FriendStatusList) == 0x0004A0, "Member 'UUIField_Status::FriendStatusList' has a wrong offset!");
static_assert(offsetof(UUIField_Status, QuestWindow) == 0x0004B0, "Member 'UUIField_Status::QuestWindow' has a wrong offset!");
static_assert(offsetof(UUIField_Status, NaviMap) == 0x0004B8, "Member 'UUIField_Status::NaviMap' has a wrong offset!");
static_assert(offsetof(UUIField_Status, LeftMouseIndicator) == 0x0004C0, "Member 'UUIField_Status::LeftMouseIndicator' has a wrong offset!");
static_assert(offsetof(UUIField_Status, MainMenuGuide) == 0x0004C8, "Member 'UUIField_Status::MainMenuGuide' has a wrong offset!");
static_assert(offsetof(UUIField_Status, WindowInCountMax) == 0x0004D0, "Member 'UUIField_Status::WindowInCountMax' has a wrong offset!");
static_assert(offsetof(UUIField_Status, WindowOutCountMax) == 0x0004D4, "Member 'UUIField_Status::WindowOutCountMax' has a wrong offset!");
static_assert(offsetof(UUIField_Status, ButtonUpWidget) == 0x0004F8, "Member 'UUIField_Status::ButtonUpWidget' has a wrong offset!");
static_assert(offsetof(UUIField_Status, GuideTeamWidget) == 0x000500, "Member 'UUIField_Status::GuideTeamWidget' has a wrong offset!");
static_assert(offsetof(UUIField_Status, GuideTextBlock) == 0x000508, "Member 'UUIField_Status::GuideTextBlock' has a wrong offset!");

// Class DarwinGame.UIField_Win_Message
// 0x0070 (0x0500 - 0x0490)
class UUIField_Win_Message : public UDarwinUserWidget
{
public:
	class UDataTable*                             DataTable;                                         // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x68];                                     // 0x0498(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InAnimEnd();
	void InButtonAnimEnd();
	void OutAnimEnd();
	void SetData(class FName GroupName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_Win_Message">();
	}
	static class UUIField_Win_Message* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_Win_Message>();
	}
};
static_assert(alignof(UUIField_Win_Message) == 0x000008, "Wrong alignment on UUIField_Win_Message");
static_assert(sizeof(UUIField_Win_Message) == 0x000500, "Wrong size on UUIField_Win_Message");
static_assert(offsetof(UUIField_Win_Message, DataTable) == 0x000490, "Member 'UUIField_Win_Message::DataTable' has a wrong offset!");

// Class DarwinGame.UIField_WinAction
// 0x0060 (0x04F0 - 0x0490)
class alignas(0x10) UUIField_WinAction : public UDarwinUserWidget
{
public:
	class UDataTable*                             ActionCmdTable;                                    // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFieldAction_Caution_04*              CautionTextWidget;                                 // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x50];                                     // 0x04A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayOneshotCautionAnim(const EInputGuideCaution& CautionType);
	void SetActionType(EInputGuideType Type, EInputGuideType LongActionType, bool IsGaugeMaxCloseType);
	void SetPercent(float Percent, bool HasInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinAction">();
	}
	static class UUIField_WinAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinAction>();
	}
};
static_assert(alignof(UUIField_WinAction) == 0x000010, "Wrong alignment on UUIField_WinAction");
static_assert(sizeof(UUIField_WinAction) == 0x0004F0, "Wrong size on UUIField_WinAction");
static_assert(offsetof(UUIField_WinAction, ActionCmdTable) == 0x000490, "Member 'UUIField_WinAction::ActionCmdTable' has a wrong offset!");
static_assert(offsetof(UUIField_WinAction, CautionTextWidget) == 0x000498, "Member 'UUIField_WinAction::CautionTextWidget' has a wrong offset!");

// Class DarwinGame.UIField_WinBoss
// 0x00B8 (0x0548 - 0x0490)
class UUIField_WinBoss : public UDarwinUserWidget
{
public:
	class UDataTable*                             LevelColorTable;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x78];                                     // 0x0498(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIGaugeBase*                           BossGauge;                                         // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextLevel;                                         // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextLevelNum;                                      // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextBossName;                                      // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         IconList;                                          // 0x0530(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISpirit_Gauge*                        SpiritGauge;                                       // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank);
	void ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList);
	void DeleteAllStatusIcon();
	void DeleteStatusIcon(const class FName& StatusParameterID);
	class UUISpirit_Gauge* GetSpiritGauge();
	void SetBossNameText(const class FText& Text);
	void SetHP(int32 InHP);
	void SetLevel(int32 InLevel);
	void SetMaxHP(int32 InMaxHP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinBoss">();
	}
	static class UUIField_WinBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinBoss>();
	}
};
static_assert(alignof(UUIField_WinBoss) == 0x000008, "Wrong alignment on UUIField_WinBoss");
static_assert(sizeof(UUIField_WinBoss) == 0x000548, "Wrong size on UUIField_WinBoss");
static_assert(offsetof(UUIField_WinBoss, LevelColorTable) == 0x000490, "Member 'UUIField_WinBoss::LevelColorTable' has a wrong offset!");
static_assert(offsetof(UUIField_WinBoss, BossGauge) == 0x000510, "Member 'UUIField_WinBoss::BossGauge' has a wrong offset!");
static_assert(offsetof(UUIField_WinBoss, TextLevel) == 0x000518, "Member 'UUIField_WinBoss::TextLevel' has a wrong offset!");
static_assert(offsetof(UUIField_WinBoss, TextLevelNum) == 0x000520, "Member 'UUIField_WinBoss::TextLevelNum' has a wrong offset!");
static_assert(offsetof(UUIField_WinBoss, TextBossName) == 0x000528, "Member 'UUIField_WinBoss::TextBossName' has a wrong offset!");
static_assert(offsetof(UUIField_WinBoss, IconList) == 0x000530, "Member 'UUIField_WinBoss::IconList' has a wrong offset!");
static_assert(offsetof(UUIField_WinBoss, SpiritGauge) == 0x000540, "Member 'UUIField_WinBoss::SpiritGauge' has a wrong offset!");

// Class DarwinGame.UIField_WinFriend
// 0x0170 (0x0720 - 0x05B0)
class UUIField_WinFriend : public UUI3DBase
{
public:
	float                                         StampTimer;                                        // 0x05A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AC[0x4];                                      // 0x05AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         IconList;                                          // 0x05B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISpirit_Gauge*                        SpiritGauge;                                       // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGaugeBase*                           HPGauge;                                           // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x88];                                     // 0x05D0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EStampIconType, class UUIField_IconStamp*> StampWidgetList;                                   // 0x0658(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x78];                                     // 0x06A8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank);
	void ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList);
	void DeleteAllStatusIcon();
	void DeleteStatusIcon(const class FName& StatusParameterID);
	void EndLink();
	void ExecCarryingArtifacts(bool bCanDropOff);
	class UUISpirit_Gauge* GetSpiritGauge();
	void HideMonster();
	void InitData(int32 InHP, int32 InMaxHP, int32 InLevel, const class FText& InName, int32 InPartyIndex);
	void PlayDangerStamp();
	void PlayDeathStamp();
	void PlayLeaveArtifactStamp(EArtifactType InArtifactType, int32 InPartyIndex);
	void PlayNearArtifactStamp(EArtifactType InArtifactType, int32 InPartyIndex);
	void SetHP(int32 NewHP);
	void SetLevel(int32 NewLevel);
	void SetMaxHP(int32 NewMaxHP);
	void SetName(const class FText& CharacterName);
	void SetPartyIndex(int32 InPartyIndex);
	void SpiritGaugeCloseExec();
	void SpiritGaugeOpenExec();
	void StartLink();
	void StopDangerStamp();
	void StopDeathStamp();
	void StopLeaveArtifactStamp(EArtifactType InArtifactType);
	void StopNearArtifactStamp(EArtifactType InArtifactType);
	void Targeted();
	void UnTargeted();
	void VisibleMonster();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinFriend">();
	}
	static class UUIField_WinFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinFriend>();
	}
};
static_assert(alignof(UUIField_WinFriend) == 0x000010, "Wrong alignment on UUIField_WinFriend");
static_assert(sizeof(UUIField_WinFriend) == 0x000720, "Wrong size on UUIField_WinFriend");
static_assert(offsetof(UUIField_WinFriend, StampTimer) == 0x0005A8, "Member 'UUIField_WinFriend::StampTimer' has a wrong offset!");
static_assert(offsetof(UUIField_WinFriend, IconList) == 0x0005B0, "Member 'UUIField_WinFriend::IconList' has a wrong offset!");
static_assert(offsetof(UUIField_WinFriend, SpiritGauge) == 0x0005C0, "Member 'UUIField_WinFriend::SpiritGauge' has a wrong offset!");
static_assert(offsetof(UUIField_WinFriend, HPGauge) == 0x0005C8, "Member 'UUIField_WinFriend::HPGauge' has a wrong offset!");
static_assert(offsetof(UUIField_WinFriend, StampWidgetList) == 0x000658, "Member 'UUIField_WinFriend::StampWidgetList' has a wrong offset!");

// Class DarwinGame.UIItemmenu_content
// 0x0020 (0x04B0 - 0x0490)
class UUIItemmenu_content final : public UDarwinUserWidget
{
public:
	class UImage*                                 ImgIconRank;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImgItemIcon;                                       // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIItemmenu_Efficacy*>           EfficacyArray;                                     // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_content">();
	}
	static class UUIItemmenu_content* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_content>();
	}
};
static_assert(alignof(UUIItemmenu_content) == 0x000008, "Wrong alignment on UUIItemmenu_content");
static_assert(sizeof(UUIItemmenu_content) == 0x0004B0, "Wrong size on UUIItemmenu_content");
static_assert(offsetof(UUIItemmenu_content, ImgIconRank) == 0x000490, "Member 'UUIItemmenu_content::ImgIconRank' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_content, ImgItemIcon) == 0x000498, "Member 'UUIItemmenu_content::ImgItemIcon' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_content, EfficacyArray) == 0x0004A0, "Member 'UUIItemmenu_content::EfficacyArray' has a wrong offset!");

// Class DarwinGame.UIField_WinStatusBase
// 0x00A8 (0x0538 - 0x0490)
class UUIField_WinStatusBase : public UDarwinUserWidget
{
public:
	class UUISign_IconLvupStatus*                 LvupStatus;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUISign_IconLvup*                       LvupWidget;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         IconList;                                          // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x80];                                     // 0x04B0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIGaugeBase*                           GaugeMPWidget;                                     // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank);
	void ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList);
	void DeleteAllStatusIcon();
	void DeleteStatusIcon(const class FName& StatusParameterID);
	void SetHP(int32 InHP, bool IsDamage, bool IsPlayAnim);
	void SetMaxHP(int32 InMaxHP);
	void SetMaxMP(int32 InMaxMP);
	void SetMP(int32 InMP);
	void UpdateMP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinStatusBase">();
	}
	static class UUIField_WinStatusBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinStatusBase>();
	}
};
static_assert(alignof(UUIField_WinStatusBase) == 0x000008, "Wrong alignment on UUIField_WinStatusBase");
static_assert(sizeof(UUIField_WinStatusBase) == 0x000538, "Wrong size on UUIField_WinStatusBase");
static_assert(offsetof(UUIField_WinStatusBase, LvupStatus) == 0x000490, "Member 'UUIField_WinStatusBase::LvupStatus' has a wrong offset!");
static_assert(offsetof(UUIField_WinStatusBase, LvupWidget) == 0x000498, "Member 'UUIField_WinStatusBase::LvupWidget' has a wrong offset!");
static_assert(offsetof(UUIField_WinStatusBase, IconList) == 0x0004A0, "Member 'UUIField_WinStatusBase::IconList' has a wrong offset!");
static_assert(offsetof(UUIField_WinStatusBase, GaugeMPWidget) == 0x000530, "Member 'UUIField_WinStatusBase::GaugeMPWidget' has a wrong offset!");

// Class DarwinGame.UIField_WinFStatus
// 0x0110 (0x0648 - 0x0538)
class UUIField_WinFStatus : public UUIField_WinStatusBase
{
public:
	uint8                                         Pad_538[0x48];                                     // 0x0538(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             StatusTexture;                                     // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DangerTexture;                                     // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_590[0x30];                                     // 0x0590(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIGaugeBase*                           HPGauge;                                           // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             HPText;                                            // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x50];                                     // 0x05D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SmallIcon;                                         // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FST_MonsterIconTextures                MidIconTextures;                                   // 0x0628(0x0020)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	void BroadcastDamage();
	void BroadcastLvup();
	void DamageAnimEndExec();
	void EndLevelUpAnim();
	void ExecLevelUp(int32 UpLevel, int32 Index_0);
	void HoldShotTarget();
	void InitData(int32 InHP, int32 InMaxHP, int32 InMP, int32 InMaxMP, const class FName& InKindID, const struct FCustomEquipmentType& InCustomEquipment, ERivalTeamForce InRivalTeam, bool bInIsRivalTeamLeader, int32 InLevel, const class FText& InName, int32 InUid);
	bool IsSetID();
	void OnEndLvupExec();
	void OnStartLvupExec();
	void PlayLevelUpAnim();
	void ReleaseShotTarget();
	void ReviveAnimEndExec();
	void SetID(class FName InKindID, const struct FCustomEquipmentType& InCustomEquipment, ERivalTeamForce InRivalTeam, bool bInIsRivalTeamLeader);
	void SetLevel(int32 NewLevel);
	void SetName(const class FText& InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinFStatus">();
	}
	static class UUIField_WinFStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinFStatus>();
	}
};
static_assert(alignof(UUIField_WinFStatus) == 0x000008, "Wrong alignment on UUIField_WinFStatus");
static_assert(sizeof(UUIField_WinFStatus) == 0x000648, "Wrong size on UUIField_WinFStatus");
static_assert(offsetof(UUIField_WinFStatus, StatusTexture) == 0x000580, "Member 'UUIField_WinFStatus::StatusTexture' has a wrong offset!");
static_assert(offsetof(UUIField_WinFStatus, DangerTexture) == 0x000588, "Member 'UUIField_WinFStatus::DangerTexture' has a wrong offset!");
static_assert(offsetof(UUIField_WinFStatus, HPGauge) == 0x0005C0, "Member 'UUIField_WinFStatus::HPGauge' has a wrong offset!");
static_assert(offsetof(UUIField_WinFStatus, HPText) == 0x0005C8, "Member 'UUIField_WinFStatus::HPText' has a wrong offset!");
static_assert(offsetof(UUIField_WinFStatus, SmallIcon) == 0x000620, "Member 'UUIField_WinFStatus::SmallIcon' has a wrong offset!");
static_assert(offsetof(UUIField_WinFStatus, MidIconTextures) == 0x000628, "Member 'UUIField_WinFStatus::MidIconTextures' has a wrong offset!");

// Class DarwinGame.UIField_WinLinkEff
// 0x0000 (0x0490 - 0x0490)
class UUIField_WinLinkEff : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinLinkEff">();
	}
	static class UUIField_WinLinkEff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinLinkEff>();
	}
};
static_assert(alignof(UUIField_WinLinkEff) == 0x000008, "Wrong alignment on UUIField_WinLinkEff");
static_assert(sizeof(UUIField_WinLinkEff) == 0x000490, "Wrong size on UUIField_WinLinkEff");

// Class DarwinGame.UIField_WinLinkKey
// 0x0000 (0x0490 - 0x0490)
class UUIField_WinLinkKey : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinLinkKey">();
	}
	static class UUIField_WinLinkKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinLinkKey>();
	}
};
static_assert(alignof(UUIField_WinLinkKey) == 0x000008, "Wrong alignment on UUIField_WinLinkKey");
static_assert(sizeof(UUIField_WinLinkKey) == 0x000490, "Wrong size on UUIField_WinLinkKey");

// Class DarwinGame.UIField_WinLog
// 0x00D8 (0x0568 - 0x0490)
class UUIField_WinLog : public UDarwinUserWidget
{
public:
	TArray<class UTextWidget*>                    TextWidgetList;                                    // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LogBase;                                           // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconBase;                                          // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ELogDataPanelColor, class UTexture2D*>   PanelTexture;                                      // 0x04B0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<ELogDataPanelColor, class UTexture2D*>   IconPanelTexture;                                  // 0x0500(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinLog">();
	}
	static class UUIField_WinLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinLog>();
	}
};
static_assert(alignof(UUIField_WinLog) == 0x000008, "Wrong alignment on UUIField_WinLog");
static_assert(sizeof(UUIField_WinLog) == 0x000568, "Wrong size on UUIField_WinLog");
static_assert(offsetof(UUIField_WinLog, TextWidgetList) == 0x000490, "Member 'UUIField_WinLog::TextWidgetList' has a wrong offset!");
static_assert(offsetof(UUIField_WinLog, LogBase) == 0x0004A0, "Member 'UUIField_WinLog::LogBase' has a wrong offset!");
static_assert(offsetof(UUIField_WinLog, IconBase) == 0x0004A8, "Member 'UUIField_WinLog::IconBase' has a wrong offset!");
static_assert(offsetof(UUIField_WinLog, PanelTexture) == 0x0004B0, "Member 'UUIField_WinLog::PanelTexture' has a wrong offset!");
static_assert(offsetof(UUIField_WinLog, IconPanelTexture) == 0x000500, "Member 'UUIField_WinLog::IconPanelTexture' has a wrong offset!");

// Class DarwinGame.UIField_WinPStatus
// 0x0070 (0x05A8 - 0x0538)
class UUIField_WinPStatus : public UUIField_WinStatusBase
{
public:
	uint8                                         Pad_538[0x40];                                     // 0x0538(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPlayerSp_Stock*                      SpStock;                                           // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x18];                                     // 0x0580(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SmallIcon;                                         // 0x0598(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             MidIcon;                                           // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastDamage();
	void BroadcastLvup();
	void EndRecovery();
	void ExecLvup(int32 UpLevel, bool ComboUP);
	class FName GetID();
	void InitData(int32 InHP, int32 InMaxHP, int32 InMP, int32 InMaxMP, int32 InLevel, const class FName& InName);
	void OnEndLvupExec();
	void OnStartLvupExec();
	void SetID(class FName InKindID);
	void SetLevel(int32 NewLevel);
	void SetName(const class FText& InName);
	void SetSpValue(int32 InValue);
	void StartRecovery();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinPStatus">();
	}
	static class UUIField_WinPStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinPStatus>();
	}
};
static_assert(alignof(UUIField_WinPStatus) == 0x000008, "Wrong alignment on UUIField_WinPStatus");
static_assert(sizeof(UUIField_WinPStatus) == 0x0005A8, "Wrong size on UUIField_WinPStatus");
static_assert(offsetof(UUIField_WinPStatus, SpStock) == 0x000578, "Member 'UUIField_WinPStatus::SpStock' has a wrong offset!");
static_assert(offsetof(UUIField_WinPStatus, SmallIcon) == 0x000598, "Member 'UUIField_WinPStatus::SmallIcon' has a wrong offset!");
static_assert(offsetof(UUIField_WinPStatus, MidIcon) == 0x0005A0, "Member 'UUIField_WinPStatus::MidIcon' has a wrong offset!");

// Class DarwinGame.UIField_WinQuest
// 0x0100 (0x0590 - 0x0490)
class alignas(0x10) UUIField_WinQuest : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateWindowWaitSeconds;                           // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SortAfterWaitSeconds;                              // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x40];                                     // 0x04B0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       BaseInAnim;                                        // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       BaseOutAnim;                                       // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AnotherInAnim;                                     // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       AnotherOutAnim;                                    // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PlayingInOutAnim;                                  // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ClearOnAnim;                                       // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIQuest_Data*>                  QuestDataWidget;                                   // 0x0530(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x40];                                     // 0x0540(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class USideScrollTextBlock*                   TitleScrollBlock;                                  // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndTaskProcess();
	void InOutWindowProcess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinQuest">();
	}
	static class UUIField_WinQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinQuest>();
	}
};
static_assert(alignof(UUIField_WinQuest) == 0x000010, "Wrong alignment on UUIField_WinQuest");
static_assert(sizeof(UUIField_WinQuest) == 0x000590, "Wrong size on UUIField_WinQuest");
static_assert(offsetof(UUIField_WinQuest, UpdateWindowWaitSeconds) == 0x0004A8, "Member 'UUIField_WinQuest::UpdateWindowWaitSeconds' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, SortAfterWaitSeconds) == 0x0004AC, "Member 'UUIField_WinQuest::SortAfterWaitSeconds' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, BaseInAnim) == 0x0004F0, "Member 'UUIField_WinQuest::BaseInAnim' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, BaseOutAnim) == 0x0004F8, "Member 'UUIField_WinQuest::BaseOutAnim' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, AnotherInAnim) == 0x000500, "Member 'UUIField_WinQuest::AnotherInAnim' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, AnotherOutAnim) == 0x000508, "Member 'UUIField_WinQuest::AnotherOutAnim' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, PlayingInOutAnim) == 0x000510, "Member 'UUIField_WinQuest::PlayingInOutAnim' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, ClearOnAnim) == 0x000518, "Member 'UUIField_WinQuest::ClearOnAnim' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, QuestDataWidget) == 0x000530, "Member 'UUIField_WinQuest::QuestDataWidget' has a wrong offset!");
static_assert(offsetof(UUIField_WinQuest, TitleScrollBlock) == 0x000580, "Member 'UUIField_WinQuest::TitleScrollBlock' has a wrong offset!");

// Class DarwinGame.UIField_WinSkillbox
// 0x0068 (0x04F8 - 0x0490)
class UUIField_WinSkillbox : public UDarwinUserWidget
{
public:
	TArray<class UUINextChain*>                   NextIcons;                                         // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIField_SkillChainPanel*>       PanelArray;                                        // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChainCountText;                                    // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x40];                                     // 0x04B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddChain(bool bIsNewChain, class FName KindId, const struct FCustomEquipmentType& CustomEquipment, ERivalTeamForce RivalTeam, bool IsRivalTeamLeader, EResistanceType Type, const class FText& ActionName, const TArray<EResistanceType>& NextChainTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIField_WinSkillbox">();
	}
	static class UUIField_WinSkillbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIField_WinSkillbox>();
	}
};
static_assert(alignof(UUIField_WinSkillbox) == 0x000008, "Wrong alignment on UUIField_WinSkillbox");
static_assert(sizeof(UUIField_WinSkillbox) == 0x0004F8, "Wrong size on UUIField_WinSkillbox");
static_assert(offsetof(UUIField_WinSkillbox, NextIcons) == 0x000490, "Member 'UUIField_WinSkillbox::NextIcons' has a wrong offset!");
static_assert(offsetof(UUIField_WinSkillbox, PanelArray) == 0x0004A0, "Member 'UUIField_WinSkillbox::PanelArray' has a wrong offset!");
static_assert(offsetof(UUIField_WinSkillbox, ChainCountText) == 0x0004B0, "Member 'UUIField_WinSkillbox::ChainCountText' has a wrong offset!");

// Class DarwinGame.UIFieldAction_Caution_00
// 0x0028 (0x04D0 - 0x04A8)
class UUIFieldAction_Caution_00 : public UUIFieldAction_Caution_Base
{
public:
	float                                         WaitTime;                                          // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AC[0x24];                                     // 0x04AC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Caution_00">();
	}
	static class UUIFieldAction_Caution_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Caution_00>();
	}
};
static_assert(alignof(UUIFieldAction_Caution_00) == 0x000008, "Wrong alignment on UUIFieldAction_Caution_00");
static_assert(sizeof(UUIFieldAction_Caution_00) == 0x0004D0, "Wrong size on UUIFieldAction_Caution_00");
static_assert(offsetof(UUIFieldAction_Caution_00, WaitTime) == 0x0004A8, "Member 'UUIFieldAction_Caution_00::WaitTime' has a wrong offset!");

// Class DarwinGame.UIFieldAction_Caution_01
// 0x0000 (0x04A8 - 0x04A8)
class UUIFieldAction_Caution_01 final : public UUIFieldAction_Caution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Caution_01">();
	}
	static class UUIFieldAction_Caution_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Caution_01>();
	}
};
static_assert(alignof(UUIFieldAction_Caution_01) == 0x000008, "Wrong alignment on UUIFieldAction_Caution_01");
static_assert(sizeof(UUIFieldAction_Caution_01) == 0x0004A8, "Wrong size on UUIFieldAction_Caution_01");

// Class DarwinGame.UIFieldAction_Caution_03
// 0x0000 (0x04A8 - 0x04A8)
class UUIFieldAction_Caution_03 final : public UUIFieldAction_Caution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Caution_03">();
	}
	static class UUIFieldAction_Caution_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Caution_03>();
	}
};
static_assert(alignof(UUIFieldAction_Caution_03) == 0x000008, "Wrong alignment on UUIFieldAction_Caution_03");
static_assert(sizeof(UUIFieldAction_Caution_03) == 0x0004A8, "Wrong size on UUIFieldAction_Caution_03");

// Class DarwinGame.UIMenu_WinComposite
// 0x0000 (0x04C0 - 0x04C0)
class UUIMenu_WinComposite final : public UUIMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenu_WinComposite">();
	}
	static class UUIMenu_WinComposite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenu_WinComposite>();
	}
};
static_assert(alignof(UUIMenu_WinComposite) == 0x000008, "Wrong alignment on UUIMenu_WinComposite");
static_assert(sizeof(UUIMenu_WinComposite) == 0x0004C0, "Wrong size on UUIMenu_WinComposite");

// Class DarwinGame.UIFieldAction_Caution_04
// 0x0000 (0x04A8 - 0x04A8)
class UUIFieldAction_Caution_04 : public UUIFieldAction_Caution_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Caution_04">();
	}
	static class UUIFieldAction_Caution_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Caution_04>();
	}
};
static_assert(alignof(UUIFieldAction_Caution_04) == 0x000008, "Wrong alignment on UUIFieldAction_Caution_04");
static_assert(sizeof(UUIFieldAction_Caution_04) == 0x0004A8, "Wrong size on UUIFieldAction_Caution_04");

// Class DarwinGame.UIFieldAction_Glut
// 0x0020 (0x04B0 - 0x0490)
class UUIFieldAction_Glut : public UDarwinUserWidget
{
public:
	TArray<class UImage*>                         MemoryWidgets;                                     // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           MemoryWidgetNames;                                 // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldAction_Glut">();
	}
	static class UUIFieldAction_Glut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldAction_Glut>();
	}
};
static_assert(alignof(UUIFieldAction_Glut) == 0x000008, "Wrong alignment on UUIFieldAction_Glut");
static_assert(sizeof(UUIFieldAction_Glut) == 0x0004B0, "Wrong size on UUIFieldAction_Glut");
static_assert(offsetof(UUIFieldAction_Glut, MemoryWidgets) == 0x000490, "Member 'UUIFieldAction_Glut::MemoryWidgets' has a wrong offset!");
static_assert(offsetof(UUIFieldAction_Glut, MemoryWidgetNames) == 0x0004A0, "Member 'UUIFieldAction_Glut::MemoryWidgetNames' has a wrong offset!");

// Class DarwinGame.UIFieldQueueStampSystem
// 0x0030 (0x0060 - 0x0030)
class alignas(0x10) UUIFieldQueueStampSystem : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIField_IconStamp*                     StampComposite;                                    // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFieldQueueStampSystem">();
	}
	static class UUIFieldQueueStampSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFieldQueueStampSystem>();
	}
};
static_assert(alignof(UUIFieldQueueStampSystem) == 0x000010, "Wrong alignment on UUIFieldQueueStampSystem");
static_assert(sizeof(UUIFieldQueueStampSystem) == 0x000060, "Wrong size on UUIFieldQueueStampSystem");
static_assert(offsetof(UUIFieldQueueStampSystem, StampComposite) == 0x000048, "Member 'UUIFieldQueueStampSystem::StampComposite' has a wrong offset!");

// Class DarwinGame.UIFlagChoice
// 0x0028 (0x0558 - 0x0530)
class UUIFlagChoice : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ImageNew;                                          // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                SettingFrame;                                      // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFlagChoice_Panel_01*                 FlagIcon;                                          // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlagChoice">();
	}
	static class UUIFlagChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlagChoice>();
	}
};
static_assert(alignof(UUIFlagChoice) == 0x000008, "Wrong alignment on UUIFlagChoice");
static_assert(sizeof(UUIFlagChoice) == 0x000558, "Wrong size on UUIFlagChoice");
static_assert(offsetof(UUIFlagChoice, Frame) == 0x000538, "Member 'UUIFlagChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUIFlagChoice, ImageNew) == 0x000540, "Member 'UUIFlagChoice::ImageNew' has a wrong offset!");
static_assert(offsetof(UUIFlagChoice, SettingFrame) == 0x000548, "Member 'UUIFlagChoice::SettingFrame' has a wrong offset!");
static_assert(offsetof(UUIFlagChoice, FlagIcon) == 0x000550, "Member 'UUIFlagChoice::FlagIcon' has a wrong offset!");

// Class DarwinGame.UIStation_Chara
// 0x0020 (0x04B0 - 0x0490)
class UUIStation_Chara final : public UDarwinUserWidget
{
public:
	class UDataTable*                             CharaDataTable;                                    // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         ImageList;                                         // 0x0498(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_Chara">();
	}
	static class UUIStation_Chara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_Chara>();
	}
};
static_assert(alignof(UUIStation_Chara) == 0x000008, "Wrong alignment on UUIStation_Chara");
static_assert(sizeof(UUIStation_Chara) == 0x0004B0, "Wrong size on UUIStation_Chara");
static_assert(offsetof(UUIStation_Chara, CharaDataTable) == 0x000490, "Member 'UUIStation_Chara::CharaDataTable' has a wrong offset!");
static_assert(offsetof(UUIStation_Chara, ImageList) == 0x000498, "Member 'UUIStation_Chara::ImageList' has a wrong offset!");

// Class DarwinGame.UIFlagChoice_Panel_01
// 0x0008 (0x0498 - 0x0490)
class UUIFlagChoice_Panel_01 : public UDarwinUserWidget
{
public:
	class UImage*                                 IconImage;                                         // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlagChoice_Panel_01">();
	}
	static class UUIFlagChoice_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlagChoice_Panel_01>();
	}
};
static_assert(alignof(UUIFlagChoice_Panel_01) == 0x000008, "Wrong alignment on UUIFlagChoice_Panel_01");
static_assert(sizeof(UUIFlagChoice_Panel_01) == 0x000498, "Wrong size on UUIFlagChoice_Panel_01");
static_assert(offsetof(UUIFlagChoice_Panel_01, IconImage) == 0x000490, "Member 'UUIFlagChoice_Panel_01::IconImage' has a wrong offset!");

// Class DarwinGame.UIFood_Detail
// 0x0000 (0x0490 - 0x0490)
class UUIFood_Detail final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFood_Detail">();
	}
	static class UUIFood_Detail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFood_Detail>();
	}
};
static_assert(alignof(UUIFood_Detail) == 0x000008, "Wrong alignment on UUIFood_Detail");
static_assert(sizeof(UUIFood_Detail) == 0x000490, "Wrong size on UUIFood_Detail");

// Class DarwinGame.UIItemmenu_MaterialList
// 0x0018 (0x04A8 - 0x0490)
class UUIItemmenu_MaterialList final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_MaterialList">();
	}
	static class UUIItemmenu_MaterialList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_MaterialList>();
	}
};
static_assert(alignof(UUIItemmenu_MaterialList) == 0x000008, "Wrong alignment on UUIItemmenu_MaterialList");
static_assert(sizeof(UUIItemmenu_MaterialList) == 0x0004A8, "Wrong size on UUIItemmenu_MaterialList");

// Class DarwinGame.UIFoodEffectDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIFoodEffectDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFoodEffectDataTable">();
	}
	static class UUIFoodEffectDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFoodEffectDataTable>();
	}
};
static_assert(alignof(UUIFoodEffectDataTable) == 0x000008, "Wrong alignment on UUIFoodEffectDataTable");
static_assert(sizeof(UUIFoodEffectDataTable) == 0x000030, "Wrong size on UUIFoodEffectDataTable");

// Class DarwinGame.UIGameOver_Blur
// 0x0000 (0x0490 - 0x0490)
class UUIGameOver_Blur final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGameOver_Blur">();
	}
	static class UUIGameOver_Blur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGameOver_Blur>();
	}
};
static_assert(alignof(UUIGameOver_Blur) == 0x000008, "Wrong alignment on UUIGameOver_Blur");
static_assert(sizeof(UUIGameOver_Blur) == 0x000490, "Wrong size on UUIGameOver_Blur");

// Class DarwinGame.UIGameOver_Choice
// 0x0018 (0x0548 - 0x0530)
class UUIGameOver_Choice final : public UUIScrollMenuItemBase
{
public:
	class FText                                   DefaultButtonText;                                 // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGameOver_Choice">();
	}
	static class UUIGameOver_Choice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGameOver_Choice>();
	}
};
static_assert(alignof(UUIGameOver_Choice) == 0x000008, "Wrong alignment on UUIGameOver_Choice");
static_assert(sizeof(UUIGameOver_Choice) == 0x000548, "Wrong size on UUIGameOver_Choice");
static_assert(offsetof(UUIGameOver_Choice, DefaultButtonText) == 0x000530, "Member 'UUIGameOver_Choice::DefaultButtonText' has a wrong offset!");

// Class DarwinGame.UIGaugeBase
// 0x0060 (0x04F0 - 0x0490)
class UUIGaugeBase : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USizeFixProgressBar*                    MyGauge_Base_Base;                                 // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeFixProgressBar*                    MyGauge_Gradually_Base;                            // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USizeFixProgressBar*                    MyGauge_Param_Base;                                // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FST_GaugeData                          GaugeParam;                                        // 0x04C0(0x0018)(Edit, DisableEditOnTemplate, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FST_GaugeData                          GaugeDamage;                                       // 0x04D8(0x0018)(Edit, DisableEditOnTemplate, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void InitWithParam(float InParam, float InMaxParam);
	void InitWithPercent(float InParam);
	void SetMaxParam(float InMaxParam);
	void SetParam(float InParam);
	void SetShowParam(float InShowParam);
	void UpdateWithParam(float InParam, float InMaxParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGaugeBase">();
	}
	static class UUIGaugeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGaugeBase>();
	}
};
static_assert(alignof(UUIGaugeBase) == 0x000008, "Wrong alignment on UUIGaugeBase");
static_assert(sizeof(UUIGaugeBase) == 0x0004F0, "Wrong size on UUIGaugeBase");
static_assert(offsetof(UUIGaugeBase, MyGauge_Base_Base) == 0x0004A8, "Member 'UUIGaugeBase::MyGauge_Base_Base' has a wrong offset!");
static_assert(offsetof(UUIGaugeBase, MyGauge_Gradually_Base) == 0x0004B0, "Member 'UUIGaugeBase::MyGauge_Gradually_Base' has a wrong offset!");
static_assert(offsetof(UUIGaugeBase, MyGauge_Param_Base) == 0x0004B8, "Member 'UUIGaugeBase::MyGauge_Param_Base' has a wrong offset!");
static_assert(offsetof(UUIGaugeBase, GaugeParam) == 0x0004C0, "Member 'UUIGaugeBase::GaugeParam' has a wrong offset!");
static_assert(offsetof(UUIGaugeBase, GaugeDamage) == 0x0004D8, "Member 'UUIGaugeBase::GaugeDamage' has a wrong offset!");

// Class DarwinGame.UIGlut_IconFood
// 0x0090 (0x05C0 - 0x0530)
class UUIGlut_IconFood final : public UUIScrollMenuItemBase
{
public:
	class UWidgetAnimation*                       OnAnimation;                                       // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OffGroupAnimation;                                 // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OffCategoryAnimation;                              // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base01Image;                                       // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base02Image;                                       // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base03Image;                                       // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGlutGauge_01*                        GlutGauge;                                         // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NumberText;                                        // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnLikeAnimation;                                   // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OffLikeGroupAnimation;                             // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OffLikeCategoryAnimation;                          // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base01LikeImage;                                   // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base02LikeImage;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base03LikeImage;                                   // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0x18];                                     // 0x05A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clip(float InX, float InY);
	bool IsFavoriteFood();
	void SetDataUid(const class FName& InItemId, const int32& InUid);
	void SetIsCategory(bool bInIsCategory);
	void UpdateData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlut_IconFood">();
	}
	static class UUIGlut_IconFood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlut_IconFood>();
	}
};
static_assert(alignof(UUIGlut_IconFood) == 0x000008, "Wrong alignment on UUIGlut_IconFood");
static_assert(sizeof(UUIGlut_IconFood) == 0x0005C0, "Wrong size on UUIGlut_IconFood");
static_assert(offsetof(UUIGlut_IconFood, OnAnimation) == 0x000530, "Member 'UUIGlut_IconFood::OnAnimation' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, OffGroupAnimation) == 0x000538, "Member 'UUIGlut_IconFood::OffGroupAnimation' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, OffCategoryAnimation) == 0x000540, "Member 'UUIGlut_IconFood::OffCategoryAnimation' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, Base01Image) == 0x000548, "Member 'UUIGlut_IconFood::Base01Image' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, Base02Image) == 0x000550, "Member 'UUIGlut_IconFood::Base02Image' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, Base03Image) == 0x000558, "Member 'UUIGlut_IconFood::Base03Image' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, ItemImage) == 0x000560, "Member 'UUIGlut_IconFood::ItemImage' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, GlutGauge) == 0x000568, "Member 'UUIGlut_IconFood::GlutGauge' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, NumberText) == 0x000570, "Member 'UUIGlut_IconFood::NumberText' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, OnLikeAnimation) == 0x000578, "Member 'UUIGlut_IconFood::OnLikeAnimation' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, OffLikeGroupAnimation) == 0x000580, "Member 'UUIGlut_IconFood::OffLikeGroupAnimation' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, OffLikeCategoryAnimation) == 0x000588, "Member 'UUIGlut_IconFood::OffLikeCategoryAnimation' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, Base01LikeImage) == 0x000590, "Member 'UUIGlut_IconFood::Base01LikeImage' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, Base02LikeImage) == 0x000598, "Member 'UUIGlut_IconFood::Base02LikeImage' has a wrong offset!");
static_assert(offsetof(UUIGlut_IconFood, Base03LikeImage) == 0x0005A0, "Member 'UUIGlut_IconFood::Base03LikeImage' has a wrong offset!");

// Class DarwinGame.UIGlut_WinStatus
// 0x00C8 (0x0698 - 0x05D0)
class UUIGlut_WinStatus final : public UUIScrollMenuBase
{
public:
	class UTextBlock*                             ItemName;                                          // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGlut_IconRange*                      GroupSelectMenu;                                   // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIButtonArrow*>                 ArrowArray;                                        // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FavoriteIcon;                                      // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFood_Detail*                         ItemInfoDetail;                                    // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFieldAction_Glut*                    FieldAction_Glut;                                  // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CautionIcon;                                       // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         CmdOnSe;                                           // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x80];                                     // 0x0618(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetUid(const int32 InUid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlut_WinStatus">();
	}
	static class UUIGlut_WinStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlut_WinStatus>();
	}
};
static_assert(alignof(UUIGlut_WinStatus) == 0x000008, "Wrong alignment on UUIGlut_WinStatus");
static_assert(sizeof(UUIGlut_WinStatus) == 0x000698, "Wrong size on UUIGlut_WinStatus");
static_assert(offsetof(UUIGlut_WinStatus, ItemName) == 0x0005D0, "Member 'UUIGlut_WinStatus::ItemName' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, GroupSelectMenu) == 0x0005D8, "Member 'UUIGlut_WinStatus::GroupSelectMenu' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, ArrowArray) == 0x0005E0, "Member 'UUIGlut_WinStatus::ArrowArray' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, FavoriteIcon) == 0x0005F0, "Member 'UUIGlut_WinStatus::FavoriteIcon' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, ItemInfoDetail) == 0x0005F8, "Member 'UUIGlut_WinStatus::ItemInfoDetail' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, FieldAction_Glut) == 0x000600, "Member 'UUIGlut_WinStatus::FieldAction_Glut' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, CautionIcon) == 0x000608, "Member 'UUIGlut_WinStatus::CautionIcon' has a wrong offset!");
static_assert(offsetof(UUIGlut_WinStatus, CmdOnSe) == 0x000610, "Member 'UUIGlut_WinStatus::CmdOnSe' has a wrong offset!");

// Class DarwinGame.UIGlut_WinStatus_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIGlut_WinStatus_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGlut_WinStatus_Root">();
	}
	static class UUIGlut_WinStatus_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGlut_WinStatus_Root>();
	}
};
static_assert(alignof(UUIGlut_WinStatus_Root) == 0x000008, "Wrong alignment on UUIGlut_WinStatus_Root");
static_assert(sizeof(UUIGlut_WinStatus_Root) == 0x0004D8, "Wrong size on UUIGlut_WinStatus_Root");

// Class DarwinGame.UIGood
// 0x0110 (0x05A0 - 0x0490)
class alignas(0x10) UUIGood final : public UDarwinUserWidget
{
public:
	class UUIGood_Gauge*                          GoodGauge;                                         // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGood_Count*                          GoodCount;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGood_Heart*                          GoodHeart;                                         // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIGood_GoodIcon*>               GoodIconList;                                      // 0x04A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoodIconNum;                                       // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       HeartOutAnim;                                      // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0xD8];                                     // 0x04C8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HeartOutAnimEnd();
	void PlayHeartResultEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood">();
	}
	static class UUIGood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood>();
	}
};
static_assert(alignof(UUIGood) == 0x000010, "Wrong alignment on UUIGood");
static_assert(sizeof(UUIGood) == 0x0005A0, "Wrong size on UUIGood");
static_assert(offsetof(UUIGood, GoodGauge) == 0x000490, "Member 'UUIGood::GoodGauge' has a wrong offset!");
static_assert(offsetof(UUIGood, GoodCount) == 0x000498, "Member 'UUIGood::GoodCount' has a wrong offset!");
static_assert(offsetof(UUIGood, GoodHeart) == 0x0004A0, "Member 'UUIGood::GoodHeart' has a wrong offset!");
static_assert(offsetof(UUIGood, GoodIconList) == 0x0004A8, "Member 'UUIGood::GoodIconList' has a wrong offset!");
static_assert(offsetof(UUIGood, GoodIconNum) == 0x0004B8, "Member 'UUIGood::GoodIconNum' has a wrong offset!");
static_assert(offsetof(UUIGood, HeartOutAnim) == 0x0004C0, "Member 'UUIGood::HeartOutAnim' has a wrong offset!");

// Class DarwinGame.UIStationPanel_00
// 0x00B0 (0x05E0 - 0x0530)
class UUIStationPanel_00 final : public UUIScrollMenuItemBase
{
public:
	TMap<EAreaType, struct FST_StationPanelData>  IslandTextColorData;                               // 0x0530(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EAreaType, struct FST_StationPanelData>  AreaTextColorData;                                 // 0x0580(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USideScrollTextBlock*                   SideScrollText;                                    // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AreaNameText;                                      // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationPanel_00">();
	}
	static class UUIStationPanel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationPanel_00>();
	}
};
static_assert(alignof(UUIStationPanel_00) == 0x000008, "Wrong alignment on UUIStationPanel_00");
static_assert(sizeof(UUIStationPanel_00) == 0x0005E0, "Wrong size on UUIStationPanel_00");
static_assert(offsetof(UUIStationPanel_00, IslandTextColorData) == 0x000530, "Member 'UUIStationPanel_00::IslandTextColorData' has a wrong offset!");
static_assert(offsetof(UUIStationPanel_00, AreaTextColorData) == 0x000580, "Member 'UUIStationPanel_00::AreaTextColorData' has a wrong offset!");
static_assert(offsetof(UUIStationPanel_00, SideScrollText) == 0x0005D0, "Member 'UUIStationPanel_00::SideScrollText' has a wrong offset!");
static_assert(offsetof(UUIStationPanel_00, AreaNameText) == 0x0005D8, "Member 'UUIStationPanel_00::AreaNameText' has a wrong offset!");

// Class DarwinGame.UIGood_Count
// 0x00B0 (0x0540 - 0x0490)
class alignas(0x10) UUIGood_Count final : public UDarwinUserWidget
{
public:
	class UWidgetAnimation*                       CountOnAnim;                                       // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       StopOnAnim;                                        // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0xA0];                                     // 0x04A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCountOnAnim();
	void EndStopOnAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_Count">();
	}
	static class UUIGood_Count* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_Count>();
	}
};
static_assert(alignof(UUIGood_Count) == 0x000010, "Wrong alignment on UUIGood_Count");
static_assert(sizeof(UUIGood_Count) == 0x000540, "Wrong size on UUIGood_Count");
static_assert(offsetof(UUIGood_Count, CountOnAnim) == 0x000490, "Member 'UUIGood_Count::CountOnAnim' has a wrong offset!");
static_assert(offsetof(UUIGood_Count, StopOnAnim) == 0x000498, "Member 'UUIGood_Count::StopOnAnim' has a wrong offset!");

// Class DarwinGame.UIGood_Gauge
// 0x0060 (0x04F0 - 0x0490)
class alignas(0x10) UUIGood_Gauge final : public UDarwinUserWidget
{
public:
	class UImage*                                 GaugeImg;                                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       GaugeCloseAnim;                                    // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x50];                                     // 0x04A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GaugeCloseAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_Gauge">();
	}
	static class UUIGood_Gauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_Gauge>();
	}
};
static_assert(alignof(UUIGood_Gauge) == 0x000010, "Wrong alignment on UUIGood_Gauge");
static_assert(sizeof(UUIGood_Gauge) == 0x0004F0, "Wrong size on UUIGood_Gauge");
static_assert(offsetof(UUIGood_Gauge, GaugeImg) == 0x000490, "Member 'UUIGood_Gauge::GaugeImg' has a wrong offset!");
static_assert(offsetof(UUIGood_Gauge, GaugeCloseAnim) == 0x000498, "Member 'UUIGood_Gauge::GaugeCloseAnim' has a wrong offset!");

// Class DarwinGame.UIKnowledgeMenu_Page_Base
// 0x0008 (0x04F8 - 0x04F0)
class UUIKnowledgeMenu_Page_Base : public UUIFreeScrollBase
{
public:
	class UTextWidgetData*                        textData;                                          // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKnowledgeMenu_Page_Base">();
	}
	static class UUIKnowledgeMenu_Page_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKnowledgeMenu_Page_Base>();
	}
};
static_assert(alignof(UUIKnowledgeMenu_Page_Base) == 0x000008, "Wrong alignment on UUIKnowledgeMenu_Page_Base");
static_assert(sizeof(UUIKnowledgeMenu_Page_Base) == 0x0004F8, "Wrong size on UUIKnowledgeMenu_Page_Base");
static_assert(offsetof(UUIKnowledgeMenu_Page_Base, textData) == 0x0004F0, "Member 'UUIKnowledgeMenu_Page_Base::textData' has a wrong offset!");

// Class DarwinGame.UIKnowledgeMenu_Page02
// 0x0008 (0x0500 - 0x04F8)
class UUIKnowledgeMenu_Page02 : public UUIKnowledgeMenu_Page_Base
{
public:
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKnowledgeMenu_Page02">();
	}
	static class UUIKnowledgeMenu_Page02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKnowledgeMenu_Page02>();
	}
};
static_assert(alignof(UUIKnowledgeMenu_Page02) == 0x000008, "Wrong alignment on UUIKnowledgeMenu_Page02");
static_assert(sizeof(UUIKnowledgeMenu_Page02) == 0x000500, "Wrong size on UUIKnowledgeMenu_Page02");

// Class DarwinGame.UIGood_GoodIcon
// 0x0060 (0x04F0 - 0x0490)
class UUIGood_GoodIcon final : public UDarwinUserWidget
{
public:
	class UAutoTextBlock*                         CountText1;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAutoTextBlock*                         CountText2;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnAnim;                                            // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     GoodTexList;                                       // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 GoodIconImg;                                       // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_GoodIconInfo>               GoodIconInfoList;                                  // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGoodStateEffect*                     GoodStateEffect;                                   // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAnimFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_GoodIcon">();
	}
	static class UUIGood_GoodIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_GoodIcon>();
	}
};
static_assert(alignof(UUIGood_GoodIcon) == 0x000008, "Wrong alignment on UUIGood_GoodIcon");
static_assert(sizeof(UUIGood_GoodIcon) == 0x0004F0, "Wrong size on UUIGood_GoodIcon");
static_assert(offsetof(UUIGood_GoodIcon, CountText1) == 0x000490, "Member 'UUIGood_GoodIcon::CountText1' has a wrong offset!");
static_assert(offsetof(UUIGood_GoodIcon, CountText2) == 0x000498, "Member 'UUIGood_GoodIcon::CountText2' has a wrong offset!");
static_assert(offsetof(UUIGood_GoodIcon, OnAnim) == 0x0004A0, "Member 'UUIGood_GoodIcon::OnAnim' has a wrong offset!");
static_assert(offsetof(UUIGood_GoodIcon, GoodTexList) == 0x0004A8, "Member 'UUIGood_GoodIcon::GoodTexList' has a wrong offset!");
static_assert(offsetof(UUIGood_GoodIcon, GoodIconImg) == 0x0004B8, "Member 'UUIGood_GoodIcon::GoodIconImg' has a wrong offset!");
static_assert(offsetof(UUIGood_GoodIcon, GoodIconInfoList) == 0x0004C0, "Member 'UUIGood_GoodIcon::GoodIconInfoList' has a wrong offset!");
static_assert(offsetof(UUIGood_GoodIcon, GoodStateEffect) == 0x0004D0, "Member 'UUIGood_GoodIcon::GoodStateEffect' has a wrong offset!");

// Class DarwinGame.UIGood_TopLayer
// 0x00D0 (0x0560 - 0x0490)
class alignas(0x10) UUIGood_TopLayer final : public UDarwinUserWidget
{
public:
	class UUIGood_Gauge*                          GoodGauge;                                         // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGood_Count*                          GoodCount;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0xC0];                                     // 0x04A0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGood_TopLayer">();
	}
	static class UUIGood_TopLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGood_TopLayer>();
	}
};
static_assert(alignof(UUIGood_TopLayer) == 0x000010, "Wrong alignment on UUIGood_TopLayer");
static_assert(sizeof(UUIGood_TopLayer) == 0x000560, "Wrong size on UUIGood_TopLayer");
static_assert(offsetof(UUIGood_TopLayer, GoodGauge) == 0x000490, "Member 'UUIGood_TopLayer::GoodGauge' has a wrong offset!");
static_assert(offsetof(UUIGood_TopLayer, GoodCount) == 0x000498, "Member 'UUIGood_TopLayer::GoodCount' has a wrong offset!");

// Class DarwinGame.UIGoodLotteryFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIGoodLotteryFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGoodLotteryFunctionLibrary">();
	}
	static class UUIGoodLotteryFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGoodLotteryFunctionLibrary>();
	}
};
static_assert(alignof(UUIGoodLotteryFunctionLibrary) == 0x000008, "Wrong alignment on UUIGoodLotteryFunctionLibrary");
static_assert(sizeof(UUIGoodLotteryFunctionLibrary) == 0x000030, "Wrong size on UUIGoodLotteryFunctionLibrary");

// Class DarwinGame.UIGoodStateEffect
// 0x0048 (0x04D8 - 0x0490)
class UUIGoodStateEffect final : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     EffectGoldTexList;                                 // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     EffectRedTexList;                                  // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     EffectRainbowTexList;                              // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         EffectImgList;                                     // 0x04C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGoodStateEffect">();
	}
	static class UUIGoodStateEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGoodStateEffect>();
	}
};
static_assert(alignof(UUIGoodStateEffect) == 0x000008, "Wrong alignment on UUIGoodStateEffect");
static_assert(sizeof(UUIGoodStateEffect) == 0x0004D8, "Wrong size on UUIGoodStateEffect");
static_assert(offsetof(UUIGoodStateEffect, EffectGoldTexList) == 0x000490, "Member 'UUIGoodStateEffect::EffectGoldTexList' has a wrong offset!");
static_assert(offsetof(UUIGoodStateEffect, EffectRedTexList) == 0x0004A0, "Member 'UUIGoodStateEffect::EffectRedTexList' has a wrong offset!");
static_assert(offsetof(UUIGoodStateEffect, EffectRainbowTexList) == 0x0004B0, "Member 'UUIGoodStateEffect::EffectRainbowTexList' has a wrong offset!");
static_assert(offsetof(UUIGoodStateEffect, EffectImgList) == 0x0004C8, "Member 'UUIGoodStateEffect::EffectImgList' has a wrong offset!");

// Class DarwinGame.UIHidePlacePanel
// 0x0030 (0x0060 - 0x0030)
class UUIHidePlacePanel final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITreasureHidePanel*                   TreasureHidePanel;                                 // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHidePlacePanel">();
	}
	static class UUIHidePlacePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHidePlacePanel>();
	}
};
static_assert(alignof(UUIHidePlacePanel) == 0x000008, "Wrong alignment on UUIHidePlacePanel");
static_assert(sizeof(UUIHidePlacePanel) == 0x000060, "Wrong size on UUIHidePlacePanel");
static_assert(offsetof(UUIHidePlacePanel, TreasureHidePanel) == 0x000040, "Member 'UUIHidePlacePanel::TreasureHidePanel' has a wrong offset!");

// Class DarwinGame.UIMultiBase_NextIcon
// 0x0000 (0x0490 - 0x0490)
class UUIMultiBase_NextIcon : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMultiBase_NextIcon">();
	}
	static class UUIMultiBase_NextIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMultiBase_NextIcon>();
	}
};
static_assert(alignof(UUIMultiBase_NextIcon) == 0x000008, "Wrong alignment on UUIMultiBase_NextIcon");
static_assert(sizeof(UUIMultiBase_NextIcon) == 0x000490, "Wrong size on UUIMultiBase_NextIcon");

// Class DarwinGame.UIHub_ArtifactPoint
// 0x0080 (0x0510 - 0x0490)
class UUIHub_ArtifactPoint : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     NumTextureList;                                    // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             GoldTexture;                                       // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CommaTexture;                                      // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUICountBase*>                   CountList;                                         // 0x04B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUICountBase*>                   CommaList;                                         // 0x04C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICountBase*                           Count_G;                                           // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUICountBase*>                   EffectCountList;                                   // 0x04D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUICountBase*>                   EffectCommaList;                                   // 0x04E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICountBase*                           EffectCount_G;                                     // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_ArtifactPoint">();
	}
	static class UUIHub_ArtifactPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_ArtifactPoint>();
	}
};
static_assert(alignof(UUIHub_ArtifactPoint) == 0x000008, "Wrong alignment on UUIHub_ArtifactPoint");
static_assert(sizeof(UUIHub_ArtifactPoint) == 0x000510, "Wrong size on UUIHub_ArtifactPoint");
static_assert(offsetof(UUIHub_ArtifactPoint, NumTextureList) == 0x000490, "Member 'UUIHub_ArtifactPoint::NumTextureList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, GoldTexture) == 0x0004A0, "Member 'UUIHub_ArtifactPoint::GoldTexture' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, CommaTexture) == 0x0004A8, "Member 'UUIHub_ArtifactPoint::CommaTexture' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, CountList) == 0x0004B0, "Member 'UUIHub_ArtifactPoint::CountList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, CommaList) == 0x0004C0, "Member 'UUIHub_ArtifactPoint::CommaList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, Count_G) == 0x0004D0, "Member 'UUIHub_ArtifactPoint::Count_G' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, EffectCountList) == 0x0004D8, "Member 'UUIHub_ArtifactPoint::EffectCountList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, EffectCommaList) == 0x0004E8, "Member 'UUIHub_ArtifactPoint::EffectCommaList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint, EffectCount_G) == 0x0004F8, "Member 'UUIHub_ArtifactPoint::EffectCount_G' has a wrong offset!");

// Class DarwinGame.UIHub_ArtifactPoint02
// 0x0058 (0x04E8 - 0x0490)
class UUIHub_ArtifactPoint02 : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     NumTextureList;                                    // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             GoldTexture;                                       // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CommaTexture;                                      // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIHub_PointCount02*>            CountList;                                         // 0x04B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIHub_PointCount02*>            CommaList;                                         // 0x04C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHub_PointCount02*                    Count_G;                                           // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x10];                                     // 0x04D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_ArtifactPoint02">();
	}
	static class UUIHub_ArtifactPoint02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_ArtifactPoint02>();
	}
};
static_assert(alignof(UUIHub_ArtifactPoint02) == 0x000008, "Wrong alignment on UUIHub_ArtifactPoint02");
static_assert(sizeof(UUIHub_ArtifactPoint02) == 0x0004E8, "Wrong size on UUIHub_ArtifactPoint02");
static_assert(offsetof(UUIHub_ArtifactPoint02, NumTextureList) == 0x000490, "Member 'UUIHub_ArtifactPoint02::NumTextureList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint02, GoldTexture) == 0x0004A0, "Member 'UUIHub_ArtifactPoint02::GoldTexture' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint02, CommaTexture) == 0x0004A8, "Member 'UUIHub_ArtifactPoint02::CommaTexture' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint02, CountList) == 0x0004B0, "Member 'UUIHub_ArtifactPoint02::CountList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint02, CommaList) == 0x0004C0, "Member 'UUIHub_ArtifactPoint02::CommaList' has a wrong offset!");
static_assert(offsetof(UUIHub_ArtifactPoint02, Count_G) == 0x0004D0, "Member 'UUIHub_ArtifactPoint02::Count_G' has a wrong offset!");

// Class DarwinGame.UIHub_Coin_02
// 0x0040 (0x04D0 - 0x0490)
class UUIHub_Coin_02 : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x40];                                     // 0x0490(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayEndCoinFallAnimCallBack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_Coin_02">();
	}
	static class UUIHub_Coin_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_Coin_02>();
	}
};
static_assert(alignof(UUIHub_Coin_02) == 0x000008, "Wrong alignment on UUIHub_Coin_02");
static_assert(sizeof(UUIHub_Coin_02) == 0x0004D0, "Wrong size on UUIHub_Coin_02");

// Class DarwinGame.UIHub_CoinWindow
// 0x0020 (0x04B0 - 0x0490)
class UUIHub_CoinWindow : public UDarwinUserWidget
{
public:
	class UDataTable*                             SoftResourceData;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASofdecMoviePlayer*                     MoviePlayer;                                       // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FrameBaseEffLoopAnim;                              // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void EffectMovieRequestDataExec(class UManaComponent* ManaComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_CoinWindow">();
	}
	static class UUIHub_CoinWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_CoinWindow>();
	}
};
static_assert(alignof(UUIHub_CoinWindow) == 0x000008, "Wrong alignment on UUIHub_CoinWindow");
static_assert(sizeof(UUIHub_CoinWindow) == 0x0004B0, "Wrong size on UUIHub_CoinWindow");
static_assert(offsetof(UUIHub_CoinWindow, SoftResourceData) == 0x000490, "Member 'UUIHub_CoinWindow::SoftResourceData' has a wrong offset!");
static_assert(offsetof(UUIHub_CoinWindow, MoviePlayer) == 0x0004A0, "Member 'UUIHub_CoinWindow::MoviePlayer' has a wrong offset!");
static_assert(offsetof(UUIHub_CoinWindow, FrameBaseEffLoopAnim) == 0x0004A8, "Member 'UUIHub_CoinWindow::FrameBaseEffLoopAnim' has a wrong offset!");

// Class DarwinGame.UIHub_ListPanel
// 0x0000 (0x0490 - 0x0490)
class UUIHub_ListPanel : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_ListPanel">();
	}
	static class UUIHub_ListPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_ListPanel>();
	}
};
static_assert(alignof(UUIHub_ListPanel) == 0x000008, "Wrong alignment on UUIHub_ListPanel");
static_assert(sizeof(UUIHub_ListPanel) == 0x000490, "Wrong size on UUIHub_ListPanel");

// Class DarwinGame.UIHub_PointUp
// 0x0018 (0x04A8 - 0x0490)
class UUIHub_PointUp : public UDarwinUserWidget
{
public:
	class UUIHub_ArtifactPoint02*                 ArtifactPoint;                                     // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASofdecMoviePlayer*                     MoviePlayer;                                       // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_PointUp">();
	}
	static class UUIHub_PointUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_PointUp>();
	}
};
static_assert(alignof(UUIHub_PointUp) == 0x000008, "Wrong alignment on UUIHub_PointUp");
static_assert(sizeof(UUIHub_PointUp) == 0x0004A8, "Wrong size on UUIHub_PointUp");
static_assert(offsetof(UUIHub_PointUp, ArtifactPoint) == 0x000490, "Member 'UUIHub_PointUp::ArtifactPoint' has a wrong offset!");
static_assert(offsetof(UUIHub_PointUp, MoviePlayer) == 0x000498, "Member 'UUIHub_PointUp::MoviePlayer' has a wrong offset!");

// Class DarwinGame.UIHub_RankUp
// 0x00C0 (0x0550 - 0x0490)
class alignas(0x10) UUIHub_RankUp final : public UDarwinUserWidget
{
public:
	TArray<class FName>                           AnimWidgetNameList;                                // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UManaTexture*                           MovieTexture;                                      // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIHub_Coin_01*                         CoinWidget;                                        // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHub_StatusTitle*                     BeforeStatusTitle;                                 // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHub_StatusTitle*                     AfterStatusTitle;                                  // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 InEffectWidget;                                    // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 LoopEffectWidget;                                  // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ASofdecMoviePlayer*                     MoviePlayer;                                       // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x68];                                     // 0x04E8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EffectMovieChangeStateExec(EManaComponentStatus Status, class UManaComponent* ManaComponent);
	void EffectMovieRequestDataExec(class UManaComponent* ManaComponent);
	void PlayNewRankAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_RankUp">();
	}
	static class UUIHub_RankUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_RankUp>();
	}
};
static_assert(alignof(UUIHub_RankUp) == 0x000010, "Wrong alignment on UUIHub_RankUp");
static_assert(sizeof(UUIHub_RankUp) == 0x000550, "Wrong size on UUIHub_RankUp");
static_assert(offsetof(UUIHub_RankUp, AnimWidgetNameList) == 0x000490, "Member 'UUIHub_RankUp::AnimWidgetNameList' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, MovieTexture) == 0x0004A0, "Member 'UUIHub_RankUp::MovieTexture' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, CoinWidget) == 0x0004A8, "Member 'UUIHub_RankUp::CoinWidget' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, BeforeStatusTitle) == 0x0004B0, "Member 'UUIHub_RankUp::BeforeStatusTitle' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, AfterStatusTitle) == 0x0004B8, "Member 'UUIHub_RankUp::AfterStatusTitle' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, InEffectWidget) == 0x0004C0, "Member 'UUIHub_RankUp::InEffectWidget' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, LoopEffectWidget) == 0x0004C8, "Member 'UUIHub_RankUp::LoopEffectWidget' has a wrong offset!");
static_assert(offsetof(UUIHub_RankUp, MoviePlayer) == 0x0004E0, "Member 'UUIHub_RankUp::MoviePlayer' has a wrong offset!");

// Class DarwinGame.UIHub_RewardList
// 0x0030 (0x0520 - 0x04F0)
class UUIHub_RewardList : public UUIFreeScrollBase
{
public:
	struct FLinearColor                           NormalTextColor;                                   // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           UnlockTextColor;                                   // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIHub_ListPanel*>               Items;                                             // 0x0510(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_RewardList">();
	}
	static class UUIHub_RewardList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_RewardList>();
	}
};
static_assert(alignof(UUIHub_RewardList) == 0x000008, "Wrong alignment on UUIHub_RewardList");
static_assert(sizeof(UUIHub_RewardList) == 0x000520, "Wrong size on UUIHub_RewardList");
static_assert(offsetof(UUIHub_RewardList, NormalTextColor) == 0x0004F0, "Member 'UUIHub_RewardList::NormalTextColor' has a wrong offset!");
static_assert(offsetof(UUIHub_RewardList, UnlockTextColor) == 0x000500, "Member 'UUIHub_RewardList::UnlockTextColor' has a wrong offset!");
static_assert(offsetof(UUIHub_RewardList, Items) == 0x000510, "Member 'UUIHub_RewardList::Items' has a wrong offset!");

// Class DarwinGame.UIHub_StatusTitle
// 0x0010 (0x04A0 - 0x0490)
class UUIHub_StatusTitle : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     PlateTextureList;                                  // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_StatusTitle">();
	}
	static class UUIHub_StatusTitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_StatusTitle>();
	}
};
static_assert(alignof(UUIHub_StatusTitle) == 0x000008, "Wrong alignment on UUIHub_StatusTitle");
static_assert(sizeof(UUIHub_StatusTitle) == 0x0004A0, "Wrong size on UUIHub_StatusTitle");
static_assert(offsetof(UUIHub_StatusTitle, PlateTextureList) == 0x000490, "Member 'UUIHub_StatusTitle::PlateTextureList' has a wrong offset!");

// Class DarwinGame.UIHub_StatusTitleRank
// 0x0000 (0x0490 - 0x0490)
class UUIHub_StatusTitleRank : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_StatusTitleRank">();
	}
	static class UUIHub_StatusTitleRank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_StatusTitleRank>();
	}
};
static_assert(alignof(UUIHub_StatusTitleRank) == 0x000008, "Wrong alignment on UUIHub_StatusTitleRank");
static_assert(sizeof(UUIHub_StatusTitleRank) == 0x000490, "Wrong size on UUIHub_StatusTitleRank");

// Class DarwinGame.UIHub_Talk_00
// 0x0088 (0x0518 - 0x0490)
class UUIHub_Talk_00 final : public UDarwinUserWidget
{
public:
	EDisplayHubType                               HubType;                                           // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidget*                            TextWidget;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x78];                                     // 0x04A0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_Talk_00">();
	}
	static class UUIHub_Talk_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_Talk_00>();
	}
};
static_assert(alignof(UUIHub_Talk_00) == 0x000008, "Wrong alignment on UUIHub_Talk_00");
static_assert(sizeof(UUIHub_Talk_00) == 0x000518, "Wrong size on UUIHub_Talk_00");
static_assert(offsetof(UUIHub_Talk_00, HubType) == 0x000490, "Member 'UUIHub_Talk_00::HubType' has a wrong offset!");
static_assert(offsetof(UUIHub_Talk_00, TextWidget) == 0x000498, "Member 'UUIHub_Talk_00::TextWidget' has a wrong offset!");

// Class DarwinGame.UIHub_Thomasson01
// 0x0080 (0x0510 - 0x0490)
class UUIHub_Thomasson01 : public UDarwinUserWidget
{
public:
	class UDataTable*                             SoftResourceData;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x68];                                     // 0x0498(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       NowAnim;                                           // 0x0500(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_Thomasson01">();
	}
	static class UUIHub_Thomasson01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_Thomasson01>();
	}
};
static_assert(alignof(UUIHub_Thomasson01) == 0x000008, "Wrong alignment on UUIHub_Thomasson01");
static_assert(sizeof(UUIHub_Thomasson01) == 0x000510, "Wrong size on UUIHub_Thomasson01");
static_assert(offsetof(UUIHub_Thomasson01, SoftResourceData) == 0x000490, "Member 'UUIHub_Thomasson01::SoftResourceData' has a wrong offset!");
static_assert(offsetof(UUIHub_Thomasson01, NowAnim) == 0x000500, "Member 'UUIHub_Thomasson01::NowAnim' has a wrong offset!");
static_assert(offsetof(UUIHub_Thomasson01, WaitAnim) == 0x000508, "Member 'UUIHub_Thomasson01::WaitAnim' has a wrong offset!");

// Class DarwinGame.UIHub_WinReward
// 0x0008 (0x05D8 - 0x05D0)
class UUIHub_WinReward : public UUIScrollMenuBase
{
public:
	class UUIHub_RewardList*                      RewardList;                                        // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_WinReward">();
	}
	static class UUIHub_WinReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_WinReward>();
	}
};
static_assert(alignof(UUIHub_WinReward) == 0x000008, "Wrong alignment on UUIHub_WinReward");
static_assert(sizeof(UUIHub_WinReward) == 0x0005D8, "Wrong size on UUIHub_WinReward");
static_assert(offsetof(UUIHub_WinReward, RewardList) == 0x0005D0, "Member 'UUIHub_WinReward::RewardList' has a wrong offset!");

// Class DarwinGame.UIMap_PlayerIconBase
// 0x0010 (0x04A0 - 0x0490)
class UUIMap_PlayerIconBase : public UDarwinUserWidget
{
public:
	class UImage*                                 PlayerIcon;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CameraIcon;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_PlayerIconBase">();
	}
	static class UUIMap_PlayerIconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_PlayerIconBase>();
	}
};
static_assert(alignof(UUIMap_PlayerIconBase) == 0x000008, "Wrong alignment on UUIMap_PlayerIconBase");
static_assert(sizeof(UUIMap_PlayerIconBase) == 0x0004A0, "Wrong size on UUIMap_PlayerIconBase");
static_assert(offsetof(UUIMap_PlayerIconBase, PlayerIcon) == 0x000490, "Member 'UUIMap_PlayerIconBase::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UUIMap_PlayerIconBase, CameraIcon) == 0x000498, "Member 'UUIMap_PlayerIconBase::CameraIcon' has a wrong offset!");

// Class DarwinGame.UIMap_IconNavip
// 0x0000 (0x04A0 - 0x04A0)
class UUIMap_IconNavip : public UUIMap_PlayerIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_IconNavip">();
	}
	static class UUIMap_IconNavip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_IconNavip>();
	}
};
static_assert(alignof(UUIMap_IconNavip) == 0x000008, "Wrong alignment on UUIMap_IconNavip");
static_assert(sizeof(UUIMap_IconNavip) == 0x0004A0, "Wrong size on UUIMap_IconNavip");

// Class DarwinGame.UIHub_WordBase
// 0x0018 (0x04A8 - 0x0490)
class UUIHub_WordBase : public UDarwinUserWidget
{
public:
	class UDataTable*                             MyTeamFukidashiDataTable;                          // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHub_WordBase">();
	}
	static class UUIHub_WordBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHub_WordBase>();
	}
};
static_assert(alignof(UUIHub_WordBase) == 0x000008, "Wrong alignment on UUIHub_WordBase");
static_assert(sizeof(UUIHub_WordBase) == 0x0004A8, "Wrong size on UUIHub_WordBase");
static_assert(offsetof(UUIHub_WordBase, MyTeamFukidashiDataTable) == 0x000490, "Member 'UUIHub_WordBase::MyTeamFukidashiDataTable' has a wrong offset!");

// Class DarwinGame.UIHubMenu_Category
// 0x0020 (0x0550 - 0x0530)
class UUIHubMenu_Category final : public UUIScrollMenuItemBase
{
public:
	class FText                                   TextCategory;                                      // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ImageCategory;                                     // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHubMenu_Category">();
	}
	static class UUIHubMenu_Category* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHubMenu_Category>();
	}
};
static_assert(alignof(UUIHubMenu_Category) == 0x000008, "Wrong alignment on UUIHubMenu_Category");
static_assert(sizeof(UUIHubMenu_Category) == 0x000550, "Wrong size on UUIHubMenu_Category");
static_assert(offsetof(UUIHubMenu_Category, TextCategory) == 0x000530, "Member 'UUIHubMenu_Category::TextCategory' has a wrong offset!");
static_assert(offsetof(UUIHubMenu_Category, ImageCategory) == 0x000548, "Member 'UUIHubMenu_Category::ImageCategory' has a wrong offset!");

// Class DarwinGame.UIInputGuideCautionDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIInputGuideCautionDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInputGuideCautionDataTable">();
	}
	static class UUIInputGuideCautionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInputGuideCautionDataTable>();
	}
};
static_assert(alignof(UUIInputGuideCautionDataTable) == 0x000008, "Wrong alignment on UUIInputGuideCautionDataTable");
static_assert(sizeof(UUIInputGuideCautionDataTable) == 0x000030, "Wrong size on UUIInputGuideCautionDataTable");

// Class DarwinGame.UIItemget_NewItem
// 0x0000 (0x0490 - 0x0490)
class UUIItemget_NewItem : public UDarwinUserWidget
{
public:
	void SetItemData(class FName InItemId);
	void SetItemTitleText();
	void SetRecipeTitleText();

	bool IsDecideVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemget_NewItem">();
	}
	static class UUIItemget_NewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemget_NewItem>();
	}
};
static_assert(alignof(UUIItemget_NewItem) == 0x000008, "Wrong alignment on UUIItemget_NewItem");
static_assert(sizeof(UUIItemget_NewItem) == 0x000490, "Wrong size on UUIItemget_NewItem");

// Class DarwinGame.UIItemmenu
// 0x00B0 (0x0580 - 0x04D0)
class alignas(0x10) UUIItemmenu : public UUILeftMenuUseBase
{
public:
	class UUICommonmenu_01*                       Commonmenu_01;                                     // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RightPanel;                                        // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_ItemMenuType>               ItemMenuTypeList;                                  // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x20];                                     // 0x04F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_518[0x68];                                     // 0x0518(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ItemChangeFocusCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu">();
	}
	static class UUIItemmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu>();
	}
};
static_assert(alignof(UUIItemmenu) == 0x000010, "Wrong alignment on UUIItemmenu");
static_assert(sizeof(UUIItemmenu) == 0x000580, "Wrong size on UUIItemmenu");
static_assert(offsetof(UUIItemmenu, Commonmenu_01) == 0x0004D0, "Member 'UUIItemmenu::Commonmenu_01' has a wrong offset!");
static_assert(offsetof(UUIItemmenu, RightPanel) == 0x0004D8, "Member 'UUIItemmenu::RightPanel' has a wrong offset!");
static_assert(offsetof(UUIItemmenu, ItemMenuTypeList) == 0x0004E0, "Member 'UUIItemmenu::ItemMenuTypeList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu, UIUnderButton) == 0x000510, "Member 'UUIItemmenu::UIUnderButton' has a wrong offset!");

// Class DarwinGame.UIItemmenu_02_03
// 0x00B0 (0x0580 - 0x04D0)
class UUIItemmenu_02_03 final : public UUILeftMenuUseBase
{
public:
	TArray<struct FST_BulletFoodFacilityMenu>     BulletMenuTop;                                     // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_BulletFoodFacilityMenu>     FoodMenuTop;                                       // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FST_BulletFoodFacilityBackGround       BackGroundTex;                                     // 0x04F0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIHub_Talk_00*                         HubTalk;                                           // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIItemmenu_02*                         SynthesisMenu;                                     // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIItemmenu_03*                         YorozuMenu;                                        // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPartyMenu_BG*                        BackGround;                                        // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UnderButton;                                       // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EFacilityMenuType GetFacilityType();
	void ItemChangeFocusCallback();
	void SetFacilityType(EFacilityMenuType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_02_03">();
	}
	static class UUIItemmenu_02_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_02_03>();
	}
};
static_assert(alignof(UUIItemmenu_02_03) == 0x000008, "Wrong alignment on UUIItemmenu_02_03");
static_assert(sizeof(UUIItemmenu_02_03) == 0x000580, "Wrong size on UUIItemmenu_02_03");
static_assert(offsetof(UUIItemmenu_02_03, BulletMenuTop) == 0x0004D0, "Member 'UUIItemmenu_02_03::BulletMenuTop' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, FoodMenuTop) == 0x0004E0, "Member 'UUIItemmenu_02_03::FoodMenuTop' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, BackGroundTex) == 0x0004F0, "Member 'UUIItemmenu_02_03::BackGroundTex' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, HubTalk) == 0x000550, "Member 'UUIItemmenu_02_03::HubTalk' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, SynthesisMenu) == 0x000558, "Member 'UUIItemmenu_02_03::SynthesisMenu' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, YorozuMenu) == 0x000560, "Member 'UUIItemmenu_02_03::YorozuMenu' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, BackGround) == 0x000568, "Member 'UUIItemmenu_02_03::BackGround' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_02_03, UnderButton) == 0x000570, "Member 'UUIItemmenu_02_03::UnderButton' has a wrong offset!");

// Class DarwinGame.UIManager
// 0x0410 (0x0448 - 0x0038)
class UUIManager : public UManagerBase
{
public:
	TMap<uint32, class UUserWidgetArray*>         ManagedWidgetObject;                               // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TipsOpenConditionsCheckerClass;                    // 0x0088(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTipsOpenConditionsChecker*             TipsOpenCondtionsChecker;                          // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TipsOpenerClass;                                   // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTipsOpener*                            TipsOpener;                                        // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   UIQuestQueueSystemClass;                           // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIQuestQueueSystem*                    UIQuestQueueSystem;                                // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   UIFieldStampSystemClass;                           // 0x0118(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFieldQueueStampSystem*               UIFieldStampSystem;                                // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   UIArtifactGetSystemClass;                          // 0x0148(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIArtifactGetSystem*                   UIArtifactGetSystem;                               // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   UIARMarkerSystemClass;                             // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIARMarkerSystem*                      UIARMarkerSystem;                                  // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DarwinFrameCaptureClass;                           // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinFrameCapture*                    DarwinFrameCapture;                                // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FUIOneShotWidgetClass> OneShotWidgetClass;                                // 0x01D8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FUIOneShotWidget>          OneShotWidgetInstance;                             // 0x0228(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              SilhouetteMaterial;                                // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              ReplicaMaterial;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DefaultZOrderTable;                                // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ManagedWidgetTable;                                // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0xF8];                                     // 0x02A0(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIPostUpdateWork*                      PostUpdateWork;                                    // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x40];                                     // 0x03A0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FST_ReserveDestroyWidget> ReserveDestroyWidgetList;                          // 0x03E0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x18];                                     // 0x0430(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UUIManager* GetInstance();

	class UDarwinUserWidget* DynamicCreateWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32* OutIndex);
	class UDarwinUserWidget* GetReUseWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32* OutIndex);
	class UDarwinUserWidget* GetUnusedWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32* OutIndex);
	class UDarwinUserWidget* GetWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32 Index_0);
	class UUserWidgetArray* GetWidgetArray(TSubclassOf<class UDarwinUserWidget> Class_0);
	int32 LoadOneShot(class FName OneShotName);
	bool PauseGame();
	void PlayOneShot(int32 OneShotId, float WaitTime);
	void ResetResidentWidgetViewPort();
	void SetCanOpenMainMenu(bool bCanOpen);
	void SetHideFlagAtDungeon(bool bIsHide);
	void SetHideFlagAtEvent(bool bIsHide);
	void SetHideFlagAtForcedBattle(bool bIsHide);
	void SetHideFlagAtGeneralSequence(bool bIsHide);
	void SetHideFlagAtQuest(bool bIsHide);
	void SetHideFlagAtQuestOrder(bool bIsHide);
	void SetHideFlagAtRankUpSequence(bool bIsHide);
	void SetHideFlagAtSpecialAbility(bool bIsHide);
	void SetQueueSystemCanEnqueue(bool bCanEnqueue);
	void SetQueueSystemUpdateEnable(bool bIsEnable);
	void UnloadOneShot(int32 OneShotId);
	bool UnPauseGame();

	bool CanOpenMainMenu() const;
	class UDarwinFrameCapture* GetDarwinFrameCapture() const;
	class UTipsOpenConditionsChecker* GetTipsOpenConditionsChecker() const;
	class UTipsOpener* GetTipsOpener() const;
	class UUIARMarkerSystem* GetUIARMarkerSystem() const;
	class UUIArtifactGetSystem* GetUIArtifactGetSystem() const;
	class UUIFieldQueueStampSystem* GetUIFieldStamp() const;
	class UUIQuestQueueSystem* GetUIQuestQueueSystem() const;
	bool IsLoadedOneShot(int32 OneShotId) const;
	bool IsQuestSystemPauseDirecting() const;
	bool WidgetCanAction(class UDarwinUserWidget* Target, EWidgetAction Action) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIManager">();
	}
	static class UUIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIManager>();
	}
};
static_assert(alignof(UUIManager) == 0x000008, "Wrong alignment on UUIManager");
static_assert(sizeof(UUIManager) == 0x000448, "Wrong size on UUIManager");
static_assert(offsetof(UUIManager, ManagedWidgetObject) == 0x000038, "Member 'UUIManager::ManagedWidgetObject' has a wrong offset!");
static_assert(offsetof(UUIManager, TipsOpenConditionsCheckerClass) == 0x000088, "Member 'UUIManager::TipsOpenConditionsCheckerClass' has a wrong offset!");
static_assert(offsetof(UUIManager, TipsOpenCondtionsChecker) == 0x0000B0, "Member 'UUIManager::TipsOpenCondtionsChecker' has a wrong offset!");
static_assert(offsetof(UUIManager, TipsOpenerClass) == 0x0000B8, "Member 'UUIManager::TipsOpenerClass' has a wrong offset!");
static_assert(offsetof(UUIManager, TipsOpener) == 0x0000E0, "Member 'UUIManager::TipsOpener' has a wrong offset!");
static_assert(offsetof(UUIManager, UIQuestQueueSystemClass) == 0x0000E8, "Member 'UUIManager::UIQuestQueueSystemClass' has a wrong offset!");
static_assert(offsetof(UUIManager, UIQuestQueueSystem) == 0x000110, "Member 'UUIManager::UIQuestQueueSystem' has a wrong offset!");
static_assert(offsetof(UUIManager, UIFieldStampSystemClass) == 0x000118, "Member 'UUIManager::UIFieldStampSystemClass' has a wrong offset!");
static_assert(offsetof(UUIManager, UIFieldStampSystem) == 0x000140, "Member 'UUIManager::UIFieldStampSystem' has a wrong offset!");
static_assert(offsetof(UUIManager, UIArtifactGetSystemClass) == 0x000148, "Member 'UUIManager::UIArtifactGetSystemClass' has a wrong offset!");
static_assert(offsetof(UUIManager, UIArtifactGetSystem) == 0x000170, "Member 'UUIManager::UIArtifactGetSystem' has a wrong offset!");
static_assert(offsetof(UUIManager, UIARMarkerSystemClass) == 0x000178, "Member 'UUIManager::UIARMarkerSystemClass' has a wrong offset!");
static_assert(offsetof(UUIManager, UIARMarkerSystem) == 0x0001A0, "Member 'UUIManager::UIARMarkerSystem' has a wrong offset!");
static_assert(offsetof(UUIManager, DarwinFrameCaptureClass) == 0x0001A8, "Member 'UUIManager::DarwinFrameCaptureClass' has a wrong offset!");
static_assert(offsetof(UUIManager, DarwinFrameCapture) == 0x0001D0, "Member 'UUIManager::DarwinFrameCapture' has a wrong offset!");
static_assert(offsetof(UUIManager, OneShotWidgetClass) == 0x0001D8, "Member 'UUIManager::OneShotWidgetClass' has a wrong offset!");
static_assert(offsetof(UUIManager, OneShotWidgetInstance) == 0x000228, "Member 'UUIManager::OneShotWidgetInstance' has a wrong offset!");
static_assert(offsetof(UUIManager, SilhouetteMaterial) == 0x000280, "Member 'UUIManager::SilhouetteMaterial' has a wrong offset!");
static_assert(offsetof(UUIManager, ReplicaMaterial) == 0x000288, "Member 'UUIManager::ReplicaMaterial' has a wrong offset!");
static_assert(offsetof(UUIManager, DefaultZOrderTable) == 0x000290, "Member 'UUIManager::DefaultZOrderTable' has a wrong offset!");
static_assert(offsetof(UUIManager, ManagedWidgetTable) == 0x000298, "Member 'UUIManager::ManagedWidgetTable' has a wrong offset!");
static_assert(offsetof(UUIManager, PostUpdateWork) == 0x000398, "Member 'UUIManager::PostUpdateWork' has a wrong offset!");
static_assert(offsetof(UUIManager, ReserveDestroyWidgetList) == 0x0003E0, "Member 'UUIManager::ReserveDestroyWidgetList' has a wrong offset!");

// Class DarwinGame.UIItemmenu_02_03_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIItemmenu_02_03_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFacilityType(EFacilityMenuType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_02_03_Root">();
	}
	static class UUIItemmenu_02_03_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_02_03_Root>();
	}
};
static_assert(alignof(UUIItemmenu_02_03_Root) == 0x000008, "Wrong alignment on UUIItemmenu_02_03_Root");
static_assert(sizeof(UUIItemmenu_02_03_Root) == 0x0004D8, "Wrong size on UUIItemmenu_02_03_Root");

// Class DarwinGame.UIItemmenu_03
// 0x0430 (0x0900 - 0x04D0)
class UUIItemmenu_03 final : public UUILeftMenuUseBase
{
public:
	TArray<class FText>                           SortButtonText;                                    // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E0[0x20];                                     // 0x04E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETradeCategory, struct FST_ShopMenu>     ShopMenuDataList_01;                               // 0x0500(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FST_ShopMenu>                   ShopMenuDataList_02;                               // 0x0550(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EShopItemCategory, struct FST_ShopMenu>  ShopMenuDataList_Buy;                              // 0x0560(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EShopItemCategory, struct FST_ShopMenu>  ShopMenuDataList_Sell;                             // 0x05B0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EBulletItemCategory, struct FST_ShopMenu> ShopMenuDataList_Bullet;                           // 0x0600(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EFoodItemCategory, struct FST_ShopMenu>  ShopMenuDataList_Food;                             // 0x0650(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             ShopItemTable;                                     // 0x06A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ShopArtifactTable;                                 // 0x06A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ETradePlace, TSoftObjectPtr<class UTexture2D>> BackGroundTexture;                                 // 0x06B0(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<int32, TSoftObjectPtr<class UTexture2D>> DungeonBackGroundTexture;                          // 0x0700(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<ETradePlace>                           NewChangePlace;                                    // 0x0750(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICommonmenu_03*                       Commonmenu;                                        // 0x0760(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UnderButton;                                       // 0x0768(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_770[0x190];                                    // 0x0770(0x0190)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_03">();
	}
	static class UUIItemmenu_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_03>();
	}
};
static_assert(alignof(UUIItemmenu_03) == 0x000008, "Wrong alignment on UUIItemmenu_03");
static_assert(sizeof(UUIItemmenu_03) == 0x000900, "Wrong size on UUIItemmenu_03");
static_assert(offsetof(UUIItemmenu_03, SortButtonText) == 0x0004D0, "Member 'UUIItemmenu_03::SortButtonText' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopMenuDataList_01) == 0x000500, "Member 'UUIItemmenu_03::ShopMenuDataList_01' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopMenuDataList_02) == 0x000550, "Member 'UUIItemmenu_03::ShopMenuDataList_02' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopMenuDataList_Buy) == 0x000560, "Member 'UUIItemmenu_03::ShopMenuDataList_Buy' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopMenuDataList_Sell) == 0x0005B0, "Member 'UUIItemmenu_03::ShopMenuDataList_Sell' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopMenuDataList_Bullet) == 0x000600, "Member 'UUIItemmenu_03::ShopMenuDataList_Bullet' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopMenuDataList_Food) == 0x000650, "Member 'UUIItemmenu_03::ShopMenuDataList_Food' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopItemTable) == 0x0006A0, "Member 'UUIItemmenu_03::ShopItemTable' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, ShopArtifactTable) == 0x0006A8, "Member 'UUIItemmenu_03::ShopArtifactTable' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, BackGroundTexture) == 0x0006B0, "Member 'UUIItemmenu_03::BackGroundTexture' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, DungeonBackGroundTexture) == 0x000700, "Member 'UUIItemmenu_03::DungeonBackGroundTexture' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, NewChangePlace) == 0x000750, "Member 'UUIItemmenu_03::NewChangePlace' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, Commonmenu) == 0x000760, "Member 'UUIItemmenu_03::Commonmenu' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_03, UnderButton) == 0x000768, "Member 'UUIItemmenu_03::UnderButton' has a wrong offset!");

// Class DarwinGame.UIItemmenu_Artifact
// 0x0028 (0x04B8 - 0x0490)
class UUIItemmenu_Artifact : public UDarwinUserWidget
{
public:
	TArray<class FName>                           CategoryIconNameList;                              // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         CategoryIconList;                                  // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIItemmenu_HaveArtifact*               HaveArtifact;                                      // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_Artifact">();
	}
	static class UUIItemmenu_Artifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_Artifact>();
	}
};
static_assert(alignof(UUIItemmenu_Artifact) == 0x000008, "Wrong alignment on UUIItemmenu_Artifact");
static_assert(sizeof(UUIItemmenu_Artifact) == 0x0004B8, "Wrong size on UUIItemmenu_Artifact");
static_assert(offsetof(UUIItemmenu_Artifact, CategoryIconNameList) == 0x000490, "Member 'UUIItemmenu_Artifact::CategoryIconNameList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_Artifact, CategoryIconList) == 0x0004A0, "Member 'UUIItemmenu_Artifact::CategoryIconList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_Artifact, HaveArtifact) == 0x0004B0, "Member 'UUIItemmenu_Artifact::HaveArtifact' has a wrong offset!");

// Class DarwinGame.UIItemmenu_BuyIcon
// 0x00A0 (0x0530 - 0x0490)
class UUIItemmenu_BuyIcon final : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     FrameDataList;                                     // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      ReplicaMaterial;                                   // 0x04A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      UnknownArtifactMaterial;                           // 0x04C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x40];                                     // 0x04F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_BuyIcon">();
	}
	static class UUIItemmenu_BuyIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_BuyIcon>();
	}
};
static_assert(alignof(UUIItemmenu_BuyIcon) == 0x000008, "Wrong alignment on UUIItemmenu_BuyIcon");
static_assert(sizeof(UUIItemmenu_BuyIcon) == 0x000530, "Wrong size on UUIItemmenu_BuyIcon");
static_assert(offsetof(UUIItemmenu_BuyIcon, FrameDataList) == 0x000490, "Member 'UUIItemmenu_BuyIcon::FrameDataList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_BuyIcon, ReplicaMaterial) == 0x0004A0, "Member 'UUIItemmenu_BuyIcon::ReplicaMaterial' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_BuyIcon, UnknownArtifactMaterial) == 0x0004C8, "Member 'UUIItemmenu_BuyIcon::UnknownArtifactMaterial' has a wrong offset!");

// Class DarwinGame.UIItemmenu_BuyIconChoice
// 0x0040 (0x0570 - 0x0530)
class UUIItemmenu_BuyIconChoice final : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIItemmenu_BuyIcon*                    Itemmenu_BuyIcon;                                  // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIItemmenu_HoldIcon*                   Itemmenu_HoldIcon;                                 // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Lock_Icon;                                         // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_BuyIconChoice">();
	}
	static class UUIItemmenu_BuyIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_BuyIconChoice>();
	}
};
static_assert(alignof(UUIItemmenu_BuyIconChoice) == 0x000008, "Wrong alignment on UUIItemmenu_BuyIconChoice");
static_assert(sizeof(UUIItemmenu_BuyIconChoice) == 0x000570, "Wrong size on UUIItemmenu_BuyIconChoice");
static_assert(offsetof(UUIItemmenu_BuyIconChoice, Frame) == 0x000540, "Member 'UUIItemmenu_BuyIconChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_BuyIconChoice, Itemmenu_BuyIcon) == 0x000548, "Member 'UUIItemmenu_BuyIconChoice::Itemmenu_BuyIcon' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_BuyIconChoice, Itemmenu_HoldIcon) == 0x000550, "Member 'UUIItemmenu_BuyIconChoice::Itemmenu_HoldIcon' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_BuyIconChoice, Lock_Icon) == 0x000558, "Member 'UUIItemmenu_BuyIconChoice::Lock_Icon' has a wrong offset!");

// Class DarwinGame.UIItemmenu_BuySentence
// 0x0000 (0x0490 - 0x0490)
class UUIItemmenu_BuySentence final : public UUISentenceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_BuySentence">();
	}
	static class UUIItemmenu_BuySentence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_BuySentence>();
	}
};
static_assert(alignof(UUIItemmenu_BuySentence) == 0x000008, "Wrong alignment on UUIItemmenu_BuySentence");
static_assert(sizeof(UUIItemmenu_BuySentence) == 0x000490, "Wrong size on UUIItemmenu_BuySentence");

// Class DarwinGame.UIItemmenu_ChoiceUpdown
// 0x0018 (0x0548 - 0x0530)
class UUIItemmenu_ChoiceUpdown final : public UUIScrollMenuItemBase
{
public:
	class FText                                   DefaultButtonText;                                 // 0x0530(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_ChoiceUpdown">();
	}
	static class UUIItemmenu_ChoiceUpdown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_ChoiceUpdown>();
	}
};
static_assert(alignof(UUIItemmenu_ChoiceUpdown) == 0x000008, "Wrong alignment on UUIItemmenu_ChoiceUpdown");
static_assert(sizeof(UUIItemmenu_ChoiceUpdown) == 0x000548, "Wrong size on UUIItemmenu_ChoiceUpdown");
static_assert(offsetof(UUIItemmenu_ChoiceUpdown, DefaultButtonText) == 0x000530, "Member 'UUIItemmenu_ChoiceUpdown::DefaultButtonText' has a wrong offset!");

// Class DarwinGame.UIItemmenu_HaveArtifact
// 0x0000 (0x0490 - 0x0490)
class UUIItemmenu_HaveArtifact : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_HaveArtifact">();
	}
	static class UUIItemmenu_HaveArtifact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_HaveArtifact>();
	}
};
static_assert(alignof(UUIItemmenu_HaveArtifact) == 0x000008, "Wrong alignment on UUIItemmenu_HaveArtifact");
static_assert(sizeof(UUIItemmenu_HaveArtifact) == 0x000490, "Wrong size on UUIItemmenu_HaveArtifact");

// Class DarwinGame.UIItemmenu_ItemIcon
// 0x0000 (0x0498 - 0x0498)
class UUIItemmenu_ItemIcon final : public UUIItemmenu_ItemIconRankBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_ItemIcon">();
	}
	static class UUIItemmenu_ItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_ItemIcon>();
	}
};
static_assert(alignof(UUIItemmenu_ItemIcon) == 0x000008, "Wrong alignment on UUIItemmenu_ItemIcon");
static_assert(sizeof(UUIItemmenu_ItemIcon) == 0x000498, "Wrong size on UUIItemmenu_ItemIcon");

// Class DarwinGame.UIItemmenu_ListIcon
// 0x0010 (0x04A8 - 0x0498)
class UUIItemmenu_ListIcon final : public UUIItemmenu_ItemIconRankBase
{
public:
	class UTextBlock*                             NameTextBlock;                                     // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USideScrollTextBlock*                   SideScroll;                                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_ListIcon">();
	}
	static class UUIItemmenu_ListIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_ListIcon>();
	}
};
static_assert(alignof(UUIItemmenu_ListIcon) == 0x000008, "Wrong alignment on UUIItemmenu_ListIcon");
static_assert(sizeof(UUIItemmenu_ListIcon) == 0x0004A8, "Wrong size on UUIItemmenu_ListIcon");
static_assert(offsetof(UUIItemmenu_ListIcon, NameTextBlock) == 0x000498, "Member 'UUIItemmenu_ListIcon::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_ListIcon, SideScroll) == 0x0004A0, "Member 'UUIItemmenu_ListIcon::SideScroll' has a wrong offset!");

// Class DarwinGame.UIItemmenu_Material
// 0x0018 (0x04A8 - 0x0490)
class UUIItemmenu_Material final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_Material">();
	}
	static class UUIItemmenu_Material* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_Material>();
	}
};
static_assert(alignof(UUIItemmenu_Material) == 0x000008, "Wrong alignment on UUIItemmenu_Material");
static_assert(sizeof(UUIItemmenu_Material) == 0x0004A8, "Wrong size on UUIItemmenu_Material");

// Class DarwinGame.UIItemmenu_SatisfactIcon
// 0x0000 (0x0490 - 0x0490)
class UUIItemmenu_SatisfactIcon : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_SatisfactIcon">();
	}
	static class UUIItemmenu_SatisfactIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_SatisfactIcon>();
	}
};
static_assert(alignof(UUIItemmenu_SatisfactIcon) == 0x000008, "Wrong alignment on UUIItemmenu_SatisfactIcon");
static_assert(sizeof(UUIItemmenu_SatisfactIcon) == 0x000490, "Wrong size on UUIItemmenu_SatisfactIcon");

// Class DarwinGame.UIItemmenu_WinAllBuy
// 0x0000 (0x0610 - 0x0610)
class UUIItemmenu_WinAllBuy final : public UUIWinMenuTwoChoices
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinAllBuy">();
	}
	static class UUIItemmenu_WinAllBuy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinAllBuy>();
	}
};
static_assert(alignof(UUIItemmenu_WinAllBuy) == 0x000008, "Wrong alignment on UUIItemmenu_WinAllBuy");
static_assert(sizeof(UUIItemmenu_WinAllBuy) == 0x000610, "Wrong size on UUIItemmenu_WinAllBuy");

// Class DarwinGame.UINumDecideWindowBase
// 0x0080 (0x0650 - 0x05D0)
class UUINumDecideWindowBase : public UUIScrollMenuBase
{
public:
	int32                                         CountItemMin;                                      // 0x05D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CountItemMax;                                      // 0x05D4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CountItemNum;                                      // 0x05D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NormalPressCount;                                  // 0x05DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LongPressCount;                                    // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      ReplicaMaterial;                                   // 0x05E8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      UnknownArtifactMaterial;                           // 0x0610(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_638[0x18];                                     // 0x0638(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINumDecideWindowBase">();
	}
	static class UUINumDecideWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINumDecideWindowBase>();
	}
};
static_assert(alignof(UUINumDecideWindowBase) == 0x000008, "Wrong alignment on UUINumDecideWindowBase");
static_assert(sizeof(UUINumDecideWindowBase) == 0x000650, "Wrong size on UUINumDecideWindowBase");
static_assert(offsetof(UUINumDecideWindowBase, CountItemMin) == 0x0005D0, "Member 'UUINumDecideWindowBase::CountItemMin' has a wrong offset!");
static_assert(offsetof(UUINumDecideWindowBase, CountItemMax) == 0x0005D4, "Member 'UUINumDecideWindowBase::CountItemMax' has a wrong offset!");
static_assert(offsetof(UUINumDecideWindowBase, CountItemNum) == 0x0005D8, "Member 'UUINumDecideWindowBase::CountItemNum' has a wrong offset!");
static_assert(offsetof(UUINumDecideWindowBase, NormalPressCount) == 0x0005DC, "Member 'UUINumDecideWindowBase::NormalPressCount' has a wrong offset!");
static_assert(offsetof(UUINumDecideWindowBase, LongPressCount) == 0x0005E0, "Member 'UUINumDecideWindowBase::LongPressCount' has a wrong offset!");
static_assert(offsetof(UUINumDecideWindowBase, ReplicaMaterial) == 0x0005E8, "Member 'UUINumDecideWindowBase::ReplicaMaterial' has a wrong offset!");
static_assert(offsetof(UUINumDecideWindowBase, UnknownArtifactMaterial) == 0x000610, "Member 'UUINumDecideWindowBase::UnknownArtifactMaterial' has a wrong offset!");

// Class DarwinGame.UIItemmenu_WinBuy
// 0x0028 (0x0678 - 0x0650)
class UUIItemmenu_WinBuy final : public UUINumDecideWindowBase
{
public:
	uint8                                         Pad_650[0x20];                                     // 0x0650(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIItemmenu_BuyIconChoice*              BuyItemChoice;                                     // 0x0670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinBuy">();
	}
	static class UUIItemmenu_WinBuy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinBuy>();
	}
};
static_assert(alignof(UUIItemmenu_WinBuy) == 0x000008, "Wrong alignment on UUIItemmenu_WinBuy");
static_assert(sizeof(UUIItemmenu_WinBuy) == 0x000678, "Wrong size on UUIItemmenu_WinBuy");
static_assert(offsetof(UUIItemmenu_WinBuy, BuyItemChoice) == 0x000670, "Member 'UUIItemmenu_WinBuy::BuyItemChoice' has a wrong offset!");

// Class DarwinGame.UIItemmenu_WinCookBase
// 0x0018 (0x05E8 - 0x05D0)
class UUIItemmenu_WinCookBase final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinCookBase">();
	}
	static class UUIItemmenu_WinCookBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinCookBase>();
	}
};
static_assert(alignof(UUIItemmenu_WinCookBase) == 0x000008, "Wrong alignment on UUIItemmenu_WinCookBase");
static_assert(sizeof(UUIItemmenu_WinCookBase) == 0x0005E8, "Wrong size on UUIItemmenu_WinCookBase");

// Class DarwinGame.UIItemmenu_WinMake
// 0x0078 (0x06C8 - 0x0650)
class UUIItemmenu_WinMake final : public UUINumDecideWindowBase
{
public:
	uint8                                         Pad_650[0x58];                                     // 0x0650(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             NameTextBlock;                                     // 0x06A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USideScrollTextBlock*                   SideScroll;                                        // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIItemmenu_MaterialList*               MaterialList;                                      // 0x06B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICommonmenu_ItemChoice*               ItemChoice;                                        // 0x06C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinMake">();
	}
	static class UUIItemmenu_WinMake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinMake>();
	}
};
static_assert(alignof(UUIItemmenu_WinMake) == 0x000008, "Wrong alignment on UUIItemmenu_WinMake");
static_assert(sizeof(UUIItemmenu_WinMake) == 0x0006C8, "Wrong size on UUIItemmenu_WinMake");
static_assert(offsetof(UUIItemmenu_WinMake, NameTextBlock) == 0x0006A8, "Member 'UUIItemmenu_WinMake::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_WinMake, SideScroll) == 0x0006B0, "Member 'UUIItemmenu_WinMake::SideScroll' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_WinMake, MaterialList) == 0x0006B8, "Member 'UUIItemmenu_WinMake::MaterialList' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_WinMake, ItemChoice) == 0x0006C0, "Member 'UUIItemmenu_WinMake::ItemChoice' has a wrong offset!");

// Class DarwinGame.UIItemmenu_WinMakeDirecting
// 0x0028 (0x04B8 - 0x0490)
class UUIItemmenu_WinMakeDirecting final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         MakeSound;                                         // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         MakingVoice;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayMakingSound();
	void ResultWindowCloseEndCallBack();
	void ResultWindowOpenEndCallBack();
	void SetMakeDirecting(EFacilityMenuType InMenuType, class FName InItemId, int32 InItemNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinMakeDirecting">();
	}
	static class UUIItemmenu_WinMakeDirecting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinMakeDirecting>();
	}
};
static_assert(alignof(UUIItemmenu_WinMakeDirecting) == 0x000008, "Wrong alignment on UUIItemmenu_WinMakeDirecting");
static_assert(sizeof(UUIItemmenu_WinMakeDirecting) == 0x0004B8, "Wrong size on UUIItemmenu_WinMakeDirecting");
static_assert(offsetof(UUIItemmenu_WinMakeDirecting, MakeSound) == 0x0004A0, "Member 'UUIItemmenu_WinMakeDirecting::MakeSound' has a wrong offset!");
static_assert(offsetof(UUIItemmenu_WinMakeDirecting, MakingVoice) == 0x0004A8, "Member 'UUIItemmenu_WinMakeDirecting::MakingVoice' has a wrong offset!");

// Class DarwinGame.UIItemmenu_WinResult
// 0x0010 (0x04A0 - 0x0490)
class UUIItemmenu_WinResult final : public UDarwinUserWidget
{
public:
	class UImage*                                 ItemIconImage;                                     // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemmenu_WinResult">();
	}
	static class UUIItemmenu_WinResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemmenu_WinResult>();
	}
};
static_assert(alignof(UUIItemmenu_WinResult) == 0x000008, "Wrong alignment on UUIItemmenu_WinResult");
static_assert(sizeof(UUIItemmenu_WinResult) == 0x0004A0, "Wrong size on UUIItemmenu_WinResult");
static_assert(offsetof(UUIItemmenu_WinResult, ItemIconImage) == 0x000490, "Member 'UUIItemmenu_WinResult::ItemIconImage' has a wrong offset!");

// Class DarwinGame.UIItemName
// 0x0030 (0x04C0 - 0x0490)
class UUIItemName : public UDarwinUserWidget
{
public:
	class UTexture2D*                             ArtifactTexture;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TreasureMapTexture;                                // 0x0498(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CoinTexture;                                       // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIconWidget;                                    // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameTextBlock;                                     // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USideScrollTextBlock*                   SideScroll;                                        // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemName">();
	}
	static class UUIItemName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemName>();
	}
};
static_assert(alignof(UUIItemName) == 0x000008, "Wrong alignment on UUIItemName");
static_assert(sizeof(UUIItemName) == 0x0004C0, "Wrong size on UUIItemName");
static_assert(offsetof(UUIItemName, ArtifactTexture) == 0x000490, "Member 'UUIItemName::ArtifactTexture' has a wrong offset!");
static_assert(offsetof(UUIItemName, TreasureMapTexture) == 0x000498, "Member 'UUIItemName::TreasureMapTexture' has a wrong offset!");
static_assert(offsetof(UUIItemName, CoinTexture) == 0x0004A0, "Member 'UUIItemName::CoinTexture' has a wrong offset!");
static_assert(offsetof(UUIItemName, ItemIconWidget) == 0x0004A8, "Member 'UUIItemName::ItemIconWidget' has a wrong offset!");
static_assert(offsetof(UUIItemName, NameTextBlock) == 0x0004B0, "Member 'UUIItemName::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UUIItemName, SideScroll) == 0x0004B8, "Member 'UUIItemName::SideScroll' has a wrong offset!");

// Class DarwinGame.UIKnowledgeMenu
// 0x0078 (0x0548 - 0x04D0)
class UUIKnowledgeMenu : public UUILeftMenuUseBase
{
public:
	uint8                                         Pad_4D0[0x78];                                     // 0x04D0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKnowledgeMenu">();
	}
	static class UUIKnowledgeMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKnowledgeMenu>();
	}
};
static_assert(alignof(UUIKnowledgeMenu) == 0x000008, "Wrong alignment on UUIKnowledgeMenu");
static_assert(sizeof(UUIKnowledgeMenu) == 0x000548, "Wrong size on UUIKnowledgeMenu");

// Class DarwinGame.UILeftMenu
// 0x0000 (0x0650 - 0x0650)
class UUILeftMenu : public UUILeftMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu">();
	}
	static class UUILeftMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu>();
	}
};
static_assert(alignof(UUILeftMenu) == 0x000008, "Wrong alignment on UUILeftMenu");
static_assert(sizeof(UUILeftMenu) == 0x000650, "Wrong size on UUILeftMenu");

// Class DarwinGame.UILeftMenu_5
// 0x0020 (0x0670 - 0x0650)
class UUILeftMenu_5 final : public UUILeftMenuBase
{
public:
	uint8                                         Pad_650[0x20];                                     // 0x0650(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_5">();
	}
	static class UUILeftMenu_5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_5>();
	}
};
static_assert(alignof(UUILeftMenu_5) == 0x000008, "Wrong alignment on UUILeftMenu_5");
static_assert(sizeof(UUILeftMenu_5) == 0x000670, "Wrong size on UUILeftMenu_5");

// Class DarwinGame.UILeftMenu_6
// 0x0008 (0x0658 - 0x0650)
class UUILeftMenu_6 final : public UUILeftMenuBase
{
public:
	uint8                                         Pad_650[0x8];                                      // 0x0650(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILeftMenu_6">();
	}
	static class UUILeftMenu_6* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILeftMenu_6>();
	}
};
static_assert(alignof(UUILeftMenu_6) == 0x000008, "Wrong alignment on UUILeftMenu_6");
static_assert(sizeof(UUILeftMenu_6) == 0x000658, "Wrong size on UUILeftMenu_6");

// Class DarwinGame.UILineBase
// 0x0008 (0x0498 - 0x0490)
class UUILineBase final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILineBase">();
	}
	static class UUILineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILineBase>();
	}
};
static_assert(alignof(UUILineBase) == 0x000008, "Wrong alignment on UUILineBase");
static_assert(sizeof(UUILineBase) == 0x000498, "Wrong size on UUILineBase");

// Class DarwinGame.UILineFade_00
// 0x0058 (0x04E8 - 0x0490)
class UUILineFade_00 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FadeInAnim;                                        // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FadeOutAnim;                                       // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x28];                                     // 0x04C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndFadeIn();
	void EndFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILineFade_00">();
	}
	static class UUILineFade_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILineFade_00>();
	}
};
static_assert(alignof(UUILineFade_00) == 0x000008, "Wrong alignment on UUILineFade_00");
static_assert(sizeof(UUILineFade_00) == 0x0004E8, "Wrong size on UUILineFade_00");
static_assert(offsetof(UUILineFade_00, FadeInAnim) == 0x0004B0, "Member 'UUILineFade_00::FadeInAnim' has a wrong offset!");
static_assert(offsetof(UUILineFade_00, FadeOutAnim) == 0x0004B8, "Member 'UUILineFade_00::FadeOutAnim' has a wrong offset!");

// Class DarwinGame.UILinkGauge_Icon
// 0x0010 (0x05C0 - 0x05B0)
class UUILinkGauge_Icon : public UUI3DBase
{
public:
	class UUIGaugeBase*                           LinkGauge;                                         // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPercent(float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILinkGauge_Icon">();
	}
	static class UUILinkGauge_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILinkGauge_Icon>();
	}
};
static_assert(alignof(UUILinkGauge_Icon) == 0x000010, "Wrong alignment on UUILinkGauge_Icon");
static_assert(sizeof(UUILinkGauge_Icon) == 0x0005C0, "Wrong size on UUILinkGauge_Icon");
static_assert(offsetof(UUILinkGauge_Icon, LinkGauge) == 0x0005A8, "Member 'UUILinkGauge_Icon::LinkGauge' has a wrong offset!");

// Class DarwinGame.UILoading
// 0x0038 (0x04C8 - 0x0490)
class UUILoading : public UUIResidentWidgetBase
{
public:
	float                                         DrawTipsTimeMin;                                   // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_494[0x34];                                     // 0x0494(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoading">();
	}
	static class UUILoading* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoading>();
	}
};
static_assert(alignof(UUILoading) == 0x000008, "Wrong alignment on UUILoading");
static_assert(sizeof(UUILoading) == 0x0004C8, "Wrong size on UUILoading");
static_assert(offsetof(UUILoading, DrawTipsTimeMin) == 0x000490, "Member 'UUILoading::DrawTipsTimeMin' has a wrong offset!");

// Class DarwinGame.UILoading_Win_Tutorial
// 0x00A8 (0x0538 - 0x0490)
class UUILoading_Win_Tutorial : public UDarwinUserWidget
{
public:
	int32                                         PointIconNum;                                      // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectTipsMax;                                     // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x50];                                     // 0x0498(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextWidgetData*                        textData;                                          // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     PreLoadImageList;                                  // 0x04F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x38];                                     // 0x0500(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InAnimEnd();
	void OutAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoading_Win_Tutorial">();
	}
	static class UUILoading_Win_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoading_Win_Tutorial>();
	}
};
static_assert(alignof(UUILoading_Win_Tutorial) == 0x000008, "Wrong alignment on UUILoading_Win_Tutorial");
static_assert(sizeof(UUILoading_Win_Tutorial) == 0x000538, "Wrong size on UUILoading_Win_Tutorial");
static_assert(offsetof(UUILoading_Win_Tutorial, PointIconNum) == 0x000490, "Member 'UUILoading_Win_Tutorial::PointIconNum' has a wrong offset!");
static_assert(offsetof(UUILoading_Win_Tutorial, SelectTipsMax) == 0x000494, "Member 'UUILoading_Win_Tutorial::SelectTipsMax' has a wrong offset!");
static_assert(offsetof(UUILoading_Win_Tutorial, textData) == 0x0004E8, "Member 'UUILoading_Win_Tutorial::textData' has a wrong offset!");
static_assert(offsetof(UUILoading_Win_Tutorial, PreLoadImageList) == 0x0004F0, "Member 'UUILoading_Win_Tutorial::PreLoadImageList' has a wrong offset!");

// Class DarwinGame.UIMainMenu_Root
// 0x0000 (0x04D0 - 0x04D0)
class UUIMainMenu_Root : public UUIInitWidget_Root
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainMenu_Root">();
	}
	static class UUIMainMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainMenu_Root>();
	}
};
static_assert(alignof(UUIMainMenu_Root) == 0x000008, "Wrong alignment on UUIMainMenu_Root");
static_assert(sizeof(UUIMainMenu_Root) == 0x0004D0, "Wrong size on UUIMainMenu_Root");

// Class DarwinGame.UIMainMenuHomeDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIMainMenuHomeDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainMenuHomeDataTable">();
	}
	static class UUIMainMenuHomeDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainMenuHomeDataTable>();
	}
};
static_assert(alignof(UUIMainMenuHomeDataTable) == 0x000008, "Wrong alignment on UUIMainMenuHomeDataTable");
static_assert(sizeof(UUIMainMenuHomeDataTable) == 0x000030, "Wrong size on UUIMainMenuHomeDataTable");

// Class DarwinGame.UIManagementPanelBase
// 0x0070 (0x00A0 - 0x0030)
class alignas(0x10) UUIManagementPanelBase : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITreasureHidePanel*                   TreasureHidePanel;                                 // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIManagementPanelBase">();
	}
	static class UUIManagementPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIManagementPanelBase>();
	}
};
static_assert(alignof(UUIManagementPanelBase) == 0x000010, "Wrong alignment on UUIManagementPanelBase");
static_assert(sizeof(UUIManagementPanelBase) == 0x0000A0, "Wrong size on UUIManagementPanelBase");
static_assert(offsetof(UUIManagementPanelBase, TreasureHidePanel) == 0x000050, "Member 'UUIManagementPanelBase::TreasureHidePanel' has a wrong offset!");

// Class DarwinGame.UIManagementMonsterPanel
// 0x0010 (0x00B0 - 0x00A0)
class UUIManagementMonsterPanel final : public UUIManagementPanelBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIManagementMonsterPanel">();
	}
	static class UUIManagementMonsterPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIManagementMonsterPanel>();
	}
};
static_assert(alignof(UUIManagementMonsterPanel) == 0x000010, "Wrong alignment on UUIManagementMonsterPanel");
static_assert(sizeof(UUIManagementMonsterPanel) == 0x0000B0, "Wrong size on UUIManagementMonsterPanel");

// Class DarwinGame.UIManagementTreasurePanel
// 0x0010 (0x00B0 - 0x00A0)
class UUIManagementTreasurePanel final : public UUIManagementPanelBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIManagementTreasurePanel">();
	}
	static class UUIManagementTreasurePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIManagementTreasurePanel>();
	}
};
static_assert(alignof(UUIManagementTreasurePanel) == 0x000010, "Wrong alignment on UUIManagementTreasurePanel");
static_assert(sizeof(UUIManagementTreasurePanel) == 0x0000B0, "Wrong size on UUIManagementTreasurePanel");

// Class DarwinGame.UIMap_BoxCursor
// 0x0048 (0x04D8 - 0x0490)
class UUIMap_BoxCursor final : public UDarwinUserWidget
{
public:
	float                                         BoxCursorSpaceSize;                                // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpacerSize;                                        // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x20];                                     // 0x0498(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             SymbolTextBlock;                                   // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USideScrollTextBlock*                   ScrollSymbolTextBlock;                             // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_BoxCursor">();
	}
	static class UUIMap_BoxCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_BoxCursor>();
	}
};
static_assert(alignof(UUIMap_BoxCursor) == 0x000008, "Wrong alignment on UUIMap_BoxCursor");
static_assert(sizeof(UUIMap_BoxCursor) == 0x0004D8, "Wrong size on UUIMap_BoxCursor");
static_assert(offsetof(UUIMap_BoxCursor, BoxCursorSpaceSize) == 0x000490, "Member 'UUIMap_BoxCursor::BoxCursorSpaceSize' has a wrong offset!");
static_assert(offsetof(UUIMap_BoxCursor, SpacerSize) == 0x000494, "Member 'UUIMap_BoxCursor::SpacerSize' has a wrong offset!");
static_assert(offsetof(UUIMap_BoxCursor, SymbolTextBlock) == 0x0004B8, "Member 'UUIMap_BoxCursor::SymbolTextBlock' has a wrong offset!");
static_assert(offsetof(UUIMap_BoxCursor, ScrollSymbolTextBlock) == 0x0004C0, "Member 'UUIMap_BoxCursor::ScrollSymbolTextBlock' has a wrong offset!");

// Class DarwinGame.UIMap_Friend_Coffin_Icon
// 0x0000 (0x04A8 - 0x04A8)
class UUIMap_Friend_Coffin_Icon final : public UUIMap_SymbolBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_Friend_Coffin_Icon">();
	}
	static class UUIMap_Friend_Coffin_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_Friend_Coffin_Icon>();
	}
};
static_assert(alignof(UUIMap_Friend_Coffin_Icon) == 0x000008, "Wrong alignment on UUIMap_Friend_Coffin_Icon");
static_assert(sizeof(UUIMap_Friend_Coffin_Icon) == 0x0004A8, "Wrong size on UUIMap_Friend_Coffin_Icon");

// Class DarwinGame.UIMap_IconManager
// 0x0220 (0x0250 - 0x0030)
class UUIMap_IconManager : public UObject
{
public:
	uint8                                         Pad_30[0x220];                                     // 0x0030(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_IconManager">();
	}
	static class UUIMap_IconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_IconManager>();
	}
};
static_assert(alignof(UUIMap_IconManager) == 0x000008, "Wrong alignment on UUIMap_IconManager");
static_assert(sizeof(UUIMap_IconManager) == 0x000250, "Wrong size on UUIMap_IconManager");

// Class DarwinGame.UIMap_MenuIconManager
// 0x0008 (0x0258 - 0x0250)
class UUIMap_MenuIconManager final : public UUIMap_IconManager
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_MenuIconManager">();
	}
	static class UUIMap_MenuIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_MenuIconManager>();
	}
};
static_assert(alignof(UUIMap_MenuIconManager) == 0x000008, "Wrong alignment on UUIMap_MenuIconManager");
static_assert(sizeof(UUIMap_MenuIconManager) == 0x000258, "Wrong size on UUIMap_MenuIconManager");

// Class DarwinGame.UIMap_NaviIconManager
// 0x0000 (0x0250 - 0x0250)
class UUIMap_NaviIconManager final : public UUIMap_IconManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_NaviIconManager">();
	}
	static class UUIMap_NaviIconManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_NaviIconManager>();
	}
};
static_assert(alignof(UUIMap_NaviIconManager) == 0x000008, "Wrong alignment on UUIMap_NaviIconManager");
static_assert(sizeof(UUIMap_NaviIconManager) == 0x000250, "Wrong size on UUIMap_NaviIconManager");

// Class DarwinGame.UIMap_Player
// 0x0000 (0x04A0 - 0x04A0)
class UUIMap_Player final : public UUIMap_PlayerIconBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_Player">();
	}
	static class UUIMap_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_Player>();
	}
};
static_assert(alignof(UUIMap_Player) == 0x000008, "Wrong alignment on UUIMap_Player");
static_assert(sizeof(UUIMap_Player) == 0x0004A0, "Wrong size on UUIMap_Player");

// Class DarwinGame.UIMap_Quest_IconBase
// 0x0008 (0x04B0 - 0x04A8)
class UUIMap_Quest_IconBase final : public UUIMap_SymbolBase
{
public:
	class UWidgetAnimation*                       LayerWaitAnim;                                     // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_Quest_IconBase">();
	}
	static class UUIMap_Quest_IconBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_Quest_IconBase>();
	}
};
static_assert(alignof(UUIMap_Quest_IconBase) == 0x000008, "Wrong alignment on UUIMap_Quest_IconBase");
static_assert(sizeof(UUIMap_Quest_IconBase) == 0x0004B0, "Wrong size on UUIMap_Quest_IconBase");
static_assert(offsetof(UUIMap_Quest_IconBase, LayerWaitAnim) == 0x0004A8, "Member 'UUIMap_Quest_IconBase::LayerWaitAnim' has a wrong offset!");

// Class DarwinGame.UIMap_Quest_IconCircleBase
// 0x0000 (0x0498 - 0x0498)
class UUIMap_Quest_IconCircleBase final : public UUIMap_Area_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_Quest_IconCircleBase">();
	}
	static class UUIMap_Quest_IconCircleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_Quest_IconCircleBase>();
	}
};
static_assert(alignof(UUIMap_Quest_IconCircleBase) == 0x000008, "Wrong alignment on UUIMap_Quest_IconCircleBase");
static_assert(sizeof(UUIMap_Quest_IconCircleBase) == 0x000498, "Wrong size on UUIMap_Quest_IconCircleBase");

// Class DarwinGame.UIMapBase
// 0x0350 (0x07E0 - 0x0490)
class UUIMapBase : public UDarwinUserWidget
{
public:
	int32                                         MapScaleIndex;                                     // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x44];                                     // 0x0494(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 MapScaleTable;                                     // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 MapImageScaleTable;                                // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              WindowSize;                                        // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapFullSize;                                       // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              OneImageSize;                                      // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Offset;                                            // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MapFloorResourceTable;                             // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DarknessBoard;                                     // 0x0520(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x20];                                     // 0x0548(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMap_PlayerIconBase*                  PlayerIcon;                                        // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FST_MapIconDefaultSettingData          DefaultSettingData;                                // 0x0570(0x0020)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      EnterAreaMaterial;                                 // 0x0590(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaskSize;                                          // 0x05B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MapKindDataTable;                                  // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     LoadMapTextureList;                                // 0x05C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0xD0];                                     // 0x05D8(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UWidget*>                   DarknessBoardFloorPanel;                           // 0x06A8(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F8[0x80];                                     // 0x06F8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MapPlaceDataResource;                              // 0x0778(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MapPlaceData;                                      // 0x0780(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_788[0x58];                                     // 0x0788(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapBase">();
	}
	static class UUIMapBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapBase>();
	}
};
static_assert(alignof(UUIMapBase) == 0x000008, "Wrong alignment on UUIMapBase");
static_assert(sizeof(UUIMapBase) == 0x0007E0, "Wrong size on UUIMapBase");
static_assert(offsetof(UUIMapBase, MapScaleIndex) == 0x000490, "Member 'UUIMapBase::MapScaleIndex' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapScaleTable) == 0x0004D8, "Member 'UUIMapBase::MapScaleTable' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapImageScaleTable) == 0x0004E8, "Member 'UUIMapBase::MapImageScaleTable' has a wrong offset!");
static_assert(offsetof(UUIMapBase, WindowSize) == 0x0004F8, "Member 'UUIMapBase::WindowSize' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapFullSize) == 0x000500, "Member 'UUIMapBase::MapFullSize' has a wrong offset!");
static_assert(offsetof(UUIMapBase, OneImageSize) == 0x000508, "Member 'UUIMapBase::OneImageSize' has a wrong offset!");
static_assert(offsetof(UUIMapBase, Offset) == 0x000510, "Member 'UUIMapBase::Offset' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapFloorResourceTable) == 0x000518, "Member 'UUIMapBase::MapFloorResourceTable' has a wrong offset!");
static_assert(offsetof(UUIMapBase, DarknessBoard) == 0x000520, "Member 'UUIMapBase::DarknessBoard' has a wrong offset!");
static_assert(offsetof(UUIMapBase, PlayerIcon) == 0x000568, "Member 'UUIMapBase::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UUIMapBase, DefaultSettingData) == 0x000570, "Member 'UUIMapBase::DefaultSettingData' has a wrong offset!");
static_assert(offsetof(UUIMapBase, EnterAreaMaterial) == 0x000590, "Member 'UUIMapBase::EnterAreaMaterial' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MaskSize) == 0x0005B8, "Member 'UUIMapBase::MaskSize' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapKindDataTable) == 0x0005C0, "Member 'UUIMapBase::MapKindDataTable' has a wrong offset!");
static_assert(offsetof(UUIMapBase, LoadMapTextureList) == 0x0005C8, "Member 'UUIMapBase::LoadMapTextureList' has a wrong offset!");
static_assert(offsetof(UUIMapBase, DarknessBoardFloorPanel) == 0x0006A8, "Member 'UUIMapBase::DarknessBoardFloorPanel' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapPlaceDataResource) == 0x000778, "Member 'UUIMapBase::MapPlaceDataResource' has a wrong offset!");
static_assert(offsetof(UUIMapBase, MapPlaceData) == 0x000780, "Member 'UUIMapBase::MapPlaceData' has a wrong offset!");

// Class DarwinGame.UIMap_WinStatus
// 0x0068 (0x0848 - 0x07E0)
class UUIMap_WinStatus : public UUIMapBase
{
public:
	class UMaterialInterface*                     NaviMapMaterial;                                   // 0x07E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AreaMapMaterial;                                   // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   IconManagerSoftClass;                              // 0x07F0(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMap_NaviIconManager*                 IconManager;                                       // 0x0818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BGImage;                                           // 0x0820(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AreaJudgeTable;                                    // 0x0828(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             AreaJudgeTexture;                                  // 0x0830(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x10];                                     // 0x0838(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMap_WinStatus">();
	}
	static class UUIMap_WinStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMap_WinStatus>();
	}
};
static_assert(alignof(UUIMap_WinStatus) == 0x000008, "Wrong alignment on UUIMap_WinStatus");
static_assert(sizeof(UUIMap_WinStatus) == 0x000848, "Wrong size on UUIMap_WinStatus");
static_assert(offsetof(UUIMap_WinStatus, NaviMapMaterial) == 0x0007E0, "Member 'UUIMap_WinStatus::NaviMapMaterial' has a wrong offset!");
static_assert(offsetof(UUIMap_WinStatus, AreaMapMaterial) == 0x0007E8, "Member 'UUIMap_WinStatus::AreaMapMaterial' has a wrong offset!");
static_assert(offsetof(UUIMap_WinStatus, IconManagerSoftClass) == 0x0007F0, "Member 'UUIMap_WinStatus::IconManagerSoftClass' has a wrong offset!");
static_assert(offsetof(UUIMap_WinStatus, IconManager) == 0x000818, "Member 'UUIMap_WinStatus::IconManager' has a wrong offset!");
static_assert(offsetof(UUIMap_WinStatus, BGImage) == 0x000820, "Member 'UUIMap_WinStatus::BGImage' has a wrong offset!");
static_assert(offsetof(UUIMap_WinStatus, AreaJudgeTable) == 0x000828, "Member 'UUIMap_WinStatus::AreaJudgeTable' has a wrong offset!");
static_assert(offsetof(UUIMap_WinStatus, AreaJudgeTexture) == 0x000830, "Member 'UUIMap_WinStatus::AreaJudgeTexture' has a wrong offset!");

// Class DarwinGame.UIMapMenu
// 0x02D8 (0x0AB8 - 0x07E0)
class UUIMapMenu final : public UUIMapBase
{
public:
	float                                         AttachRate;                                        // 0x07E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapMoveSpeed;                                      // 0x07E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetAttachMoveRate;                              // 0x07E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EC[0x4];                                      // 0x07EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             HitAreaDataTable;                                  // 0x07F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              HitAreaSoftTexture;                                // 0x07F8(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BGImage;                                           // 0x0820(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MapCursorJumpPointData;                            // 0x0828(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   IconManagerSoftClass;                              // 0x0830(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMap_MenuIconManager*                 IconManager;                                       // 0x0858(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        OperateWindow;                                     // 0x0860(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMapSymbolType, class UTexture2D*>       MapSignTextureList;                                // 0x0868(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	float                                         DummySignFadeSpeed;                                // 0x08B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      AreaMapMaterial;                                   // 0x08C0(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUIMap_BoxCursor>           QuestBoxCursorClass;                               // 0x08E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              QuestBoxCursorSize;                                // 0x08F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              QuestBoxCursorAlignment;                           // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuestBoxCursorMax;                                 // 0x0900(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_904[0xC];                                      // 0x0904(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         AtomComp;                                          // 0x0910(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_918[0x8];                                      // 0x0918(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUICategory_Set_Area*                   CategoryIcon;                                      // 0x0920(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISign_BoxCursor*                      BoxCursorIcon;                                     // 0x0928(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISign_Log*                            MapSignLog;                                        // 0x0930(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIMap_BoxCursor*>               QuestBoxCursorList;                                // 0x0938(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_948[0x158];                                    // 0x0948(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           QuestBoxCursorPanel;                               // 0x0AA0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA8[0x10];                                     // 0x0AA8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawDebug3DPos(const struct FVector& Pos);
	void DrawDebugPos(const struct FVector2D& Pos);
	void DrawDebugSignSymbolLog(const struct FVector& Pos, class FName AreaID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenu">();
	}
	static class UUIMapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenu>();
	}
};
static_assert(alignof(UUIMapMenu) == 0x000008, "Wrong alignment on UUIMapMenu");
static_assert(sizeof(UUIMapMenu) == 0x000AB8, "Wrong size on UUIMapMenu");
static_assert(offsetof(UUIMapMenu, AttachRate) == 0x0007E0, "Member 'UUIMapMenu::AttachRate' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, MapMoveSpeed) == 0x0007E4, "Member 'UUIMapMenu::MapMoveSpeed' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, OffsetAttachMoveRate) == 0x0007E8, "Member 'UUIMapMenu::OffsetAttachMoveRate' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, HitAreaDataTable) == 0x0007F0, "Member 'UUIMapMenu::HitAreaDataTable' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, HitAreaSoftTexture) == 0x0007F8, "Member 'UUIMapMenu::HitAreaSoftTexture' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, BGImage) == 0x000820, "Member 'UUIMapMenu::BGImage' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, MapCursorJumpPointData) == 0x000828, "Member 'UUIMapMenu::MapCursorJumpPointData' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, IconManagerSoftClass) == 0x000830, "Member 'UUIMapMenu::IconManagerSoftClass' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, IconManager) == 0x000858, "Member 'UUIMapMenu::IconManager' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, OperateWindow) == 0x000860, "Member 'UUIMapMenu::OperateWindow' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, MapSignTextureList) == 0x000868, "Member 'UUIMapMenu::MapSignTextureList' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, DummySignFadeSpeed) == 0x0008B8, "Member 'UUIMapMenu::DummySignFadeSpeed' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, AreaMapMaterial) == 0x0008C0, "Member 'UUIMapMenu::AreaMapMaterial' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, QuestBoxCursorClass) == 0x0008E8, "Member 'UUIMapMenu::QuestBoxCursorClass' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, QuestBoxCursorSize) == 0x0008F0, "Member 'UUIMapMenu::QuestBoxCursorSize' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, QuestBoxCursorAlignment) == 0x0008F8, "Member 'UUIMapMenu::QuestBoxCursorAlignment' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, QuestBoxCursorMax) == 0x000900, "Member 'UUIMapMenu::QuestBoxCursorMax' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, AtomComp) == 0x000910, "Member 'UUIMapMenu::AtomComp' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, CategoryIcon) == 0x000920, "Member 'UUIMapMenu::CategoryIcon' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, BoxCursorIcon) == 0x000928, "Member 'UUIMapMenu::BoxCursorIcon' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, MapSignLog) == 0x000930, "Member 'UUIMapMenu::MapSignLog' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, QuestBoxCursorList) == 0x000938, "Member 'UUIMapMenu::QuestBoxCursorList' has a wrong offset!");
static_assert(offsetof(UUIMapMenu, QuestBoxCursorPanel) == 0x000AA0, "Member 'UUIMapMenu::QuestBoxCursorPanel' has a wrong offset!");

// Class DarwinGame.UIMapMenu_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIMapMenu_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapMenu_Root">();
	}
	static class UUIMapMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapMenu_Root>();
	}
};
static_assert(alignof(UUIMapMenu_Root) == 0x000008, "Wrong alignment on UUIMapMenu_Root");
static_assert(sizeof(UUIMapMenu_Root) == 0x0004D8, "Wrong size on UUIMapMenu_Root");

// Class DarwinGame.UIMapPlace_01
// 0x0000 (0x0498 - 0x0498)
class UUIMapPlace_01 final : public UUIMapPlaceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapPlace_01">();
	}
	static class UUIMapPlace_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapPlace_01>();
	}
};
static_assert(alignof(UUIMapPlace_01) == 0x000008, "Wrong alignment on UUIMapPlace_01");
static_assert(sizeof(UUIMapPlace_01) == 0x000498, "Wrong size on UUIMapPlace_01");

// Class DarwinGame.UIMapPlace_02
// 0x0000 (0x0498 - 0x0498)
class UUIMapPlace_02 final : public UUIMapPlaceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMapPlace_02">();
	}
	static class UUIMapPlace_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMapPlace_02>();
	}
};
static_assert(alignof(UUIMapPlace_02) == 0x000008, "Wrong alignment on UUIMapPlace_02");
static_assert(sizeof(UUIMapPlace_02) == 0x000498, "Wrong size on UUIMapPlace_02");

// Class DarwinGame.UIMemberPanel
// 0x0058 (0x0588 - 0x0530)
class UUIMemberPanel : public UUIScrollMenuItemBase
{
public:
	TArray<struct FST_SceneCapture2DLight>        DirectionalLights;                                 // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 FinalColorRenderTarget;                            // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CaptureOffset;                                     // 0x0550(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinTwoSceneCaptureImage*            CaptureImage;                                      // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGlutGaugeBase*                       GlutGauge;                                         // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 GlutIcon;                                          // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x10];                                     // 0x0578(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMemberPanel">();
	}
	static class UUIMemberPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMemberPanel>();
	}
};
static_assert(alignof(UUIMemberPanel) == 0x000008, "Wrong alignment on UUIMemberPanel");
static_assert(sizeof(UUIMemberPanel) == 0x000588, "Wrong size on UUIMemberPanel");
static_assert(offsetof(UUIMemberPanel, DirectionalLights) == 0x000530, "Member 'UUIMemberPanel::DirectionalLights' has a wrong offset!");
static_assert(offsetof(UUIMemberPanel, RenderTarget) == 0x000540, "Member 'UUIMemberPanel::RenderTarget' has a wrong offset!");
static_assert(offsetof(UUIMemberPanel, FinalColorRenderTarget) == 0x000548, "Member 'UUIMemberPanel::FinalColorRenderTarget' has a wrong offset!");
static_assert(offsetof(UUIMemberPanel, CaptureOffset) == 0x000550, "Member 'UUIMemberPanel::CaptureOffset' has a wrong offset!");
static_assert(offsetof(UUIMemberPanel, CaptureImage) == 0x000560, "Member 'UUIMemberPanel::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIMemberPanel, GlutGauge) == 0x000568, "Member 'UUIMemberPanel::GlutGauge' has a wrong offset!");
static_assert(offsetof(UUIMemberPanel, GlutIcon) == 0x000570, "Member 'UUIMemberPanel::GlutIcon' has a wrong offset!");

// Class DarwinGame.UIMenu_WinTextSort
// 0x0038 (0x0608 - 0x05D0)
class UUIMenu_WinTextSort final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     mSortIcons;                                        // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x18];                                     // 0x05F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenu_WinTextSort">();
	}
	static class UUIMenu_WinTextSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenu_WinTextSort>();
	}
};
static_assert(alignof(UUIMenu_WinTextSort) == 0x000008, "Wrong alignment on UUIMenu_WinTextSort");
static_assert(sizeof(UUIMenu_WinTextSort) == 0x000608, "Wrong size on UUIMenu_WinTextSort");
static_assert(offsetof(UUIMenu_WinTextSort, mSortIcons) == 0x0005E0, "Member 'UUIMenu_WinTextSort::mSortIcons' has a wrong offset!");

// Class DarwinGame.UIMenuNumberBase
// 0x0028 (0x04B8 - 0x0490)
class UUIMenuNumberBase final : public UDarwinUserWidget
{
public:
	int32                                         ValueMin;                                          // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ValueMax;                                          // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ValueLoop;                                         // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkipValues;                                        // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 ChangeValue(EAxisMappingType Key, int32 Add, bool isLeftStick, bool isRightStick);
	int32 GetValue();
	bool IsSelectable(int32 Value);
	void SetRange(int32 Min, int32 Max);
	void SetSkipValues(const TArray<int32>& Values);
	void SetValue(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenuNumberBase">();
	}
	static class UUIMenuNumberBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenuNumberBase>();
	}
};
static_assert(alignof(UUIMenuNumberBase) == 0x000008, "Wrong alignment on UUIMenuNumberBase");
static_assert(sizeof(UUIMenuNumberBase) == 0x0004B8, "Wrong size on UUIMenuNumberBase");
static_assert(offsetof(UUIMenuNumberBase, ValueMin) == 0x000490, "Member 'UUIMenuNumberBase::ValueMin' has a wrong offset!");
static_assert(offsetof(UUIMenuNumberBase, ValueMax) == 0x000494, "Member 'UUIMenuNumberBase::ValueMax' has a wrong offset!");
static_assert(offsetof(UUIMenuNumberBase, ValueLoop) == 0x000498, "Member 'UUIMenuNumberBase::ValueLoop' has a wrong offset!");
static_assert(offsetof(UUIMenuNumberBase, SkipValues) == 0x0004A0, "Member 'UUIMenuNumberBase::SkipValues' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_Content_01
// 0x0008 (0x04A8 - 0x04A0)
class UUIMonsterDict_Content_01 : public UUIMonsterDict_ContentBase
{
public:
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_01">();
	}
	static class UUIMonsterDict_Content_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_01>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_01) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_01");
static_assert(sizeof(UUIMonsterDict_Content_01) == 0x0004A8, "Wrong size on UUIMonsterDict_Content_01");

// Class DarwinGame.UIMonsterDict_Content_03
// 0x0020 (0x04C0 - 0x04A0)
class UUIMonsterDict_Content_03 : public UUIMonsterDict_ContentBase
{
public:
	uint8                                         Pad_4A0[0x20];                                     // 0x04A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_03">();
	}
	static class UUIMonsterDict_Content_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_03>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_03) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_03");
static_assert(sizeof(UUIMonsterDict_Content_03) == 0x0004C0, "Wrong size on UUIMonsterDict_Content_03");

// Class DarwinGame.UIMonsterDict_Content_04
// 0x0018 (0x04B8 - 0x04A0)
class UUIMonsterDict_Content_04 : public UUIMonsterDict_ContentBase
{
public:
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_04">();
	}
	static class UUIMonsterDict_Content_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_04>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_04) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_04");
static_assert(sizeof(UUIMonsterDict_Content_04) == 0x0004B8, "Wrong size on UUIMonsterDict_Content_04");

// Class DarwinGame.UIMonsterDict_Content_05
// 0x0018 (0x04B8 - 0x04A0)
class UUIMonsterDict_Content_05 : public UUIMonsterDict_ContentBase
{
public:
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_05">();
	}
	static class UUIMonsterDict_Content_05* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_05>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_05) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_05");
static_assert(sizeof(UUIMonsterDict_Content_05) == 0x0004B8, "Wrong size on UUIMonsterDict_Content_05");

// Class DarwinGame.UIMonsterDict_Content_07
// 0x0020 (0x04B0 - 0x0490)
class UUIMonsterDict_Content_07 : public UDarwinUserWidget
{
public:
	class UTexture2D*                             LeftTitleIconTexture;                              // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             RightTitleIconTexture;                             // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x10];                                     // 0x04A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_07">();
	}
	static class UUIMonsterDict_Content_07* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_07>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_07) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_07");
static_assert(sizeof(UUIMonsterDict_Content_07) == 0x0004B0, "Wrong size on UUIMonsterDict_Content_07");
static_assert(offsetof(UUIMonsterDict_Content_07, LeftTitleIconTexture) == 0x000490, "Member 'UUIMonsterDict_Content_07::LeftTitleIconTexture' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_Content_07, RightTitleIconTexture) == 0x000498, "Member 'UUIMonsterDict_Content_07::RightTitleIconTexture' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_Content_13
// 0x0000 (0x04A0 - 0x04A0)
class UUIMonsterDict_Content_13 : public UUIMonsterDict_ContentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_13">();
	}
	static class UUIMonsterDict_Content_13* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_13>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_13) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_13");
static_assert(sizeof(UUIMonsterDict_Content_13) == 0x0004A0, "Wrong size on UUIMonsterDict_Content_13");

// Class DarwinGame.UIMonsterDict_Content_14
// 0x0000 (0x04A0 - 0x04A0)
class UUIMonsterDict_Content_14 : public UUIMonsterDict_ContentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_14">();
	}
	static class UUIMonsterDict_Content_14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_14>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_14) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_14");
static_assert(sizeof(UUIMonsterDict_Content_14) == 0x0004A0, "Wrong size on UUIMonsterDict_Content_14");

// Class DarwinGame.UIMonsterDict_Content_15
// 0x0020 (0x04B0 - 0x0490)
class UUIMonsterDict_Content_15 : public UDarwinUserWidget
{
public:
	class UTexture2D*                             LeftTitleIconTexture;                              // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             RightTitleIconTexture;                             // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMonsterDict_Content_13*              Content_13;                                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMonsterDict_Content_14*              Content_14;                                        // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_15">();
	}
	static class UUIMonsterDict_Content_15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_15>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_15) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_15");
static_assert(sizeof(UUIMonsterDict_Content_15) == 0x0004B0, "Wrong size on UUIMonsterDict_Content_15");
static_assert(offsetof(UUIMonsterDict_Content_15, LeftTitleIconTexture) == 0x000490, "Member 'UUIMonsterDict_Content_15::LeftTitleIconTexture' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_Content_15, RightTitleIconTexture) == 0x000498, "Member 'UUIMonsterDict_Content_15::RightTitleIconTexture' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_Content_15, Content_13) == 0x0004A0, "Member 'UUIMonsterDict_Content_15::Content_13' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_Content_15, Content_14) == 0x0004A8, "Member 'UUIMonsterDict_Content_15::Content_14' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_Content_16
// 0x0000 (0x04A0 - 0x04A0)
class UUIMonsterDict_Content_16 : public UUIMonsterDict_ContentBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Content_16">();
	}
	static class UUIMonsterDict_Content_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Content_16>();
	}
};
static_assert(alignof(UUIMonsterDict_Content_16) == 0x000008, "Wrong alignment on UUIMonsterDict_Content_16");
static_assert(sizeof(UUIMonsterDict_Content_16) == 0x0004A0, "Wrong size on UUIMonsterDict_Content_16");

// Class DarwinGame.UIMonsterDict_DropItem
// 0x0008 (0x0498 - 0x0490)
class UUIMonsterDict_DropItem : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_DropItem">();
	}
	static class UUIMonsterDict_DropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_DropItem>();
	}
};
static_assert(alignof(UUIMonsterDict_DropItem) == 0x000008, "Wrong alignment on UUIMonsterDict_DropItem");
static_assert(sizeof(UUIMonsterDict_DropItem) == 0x000498, "Wrong size on UUIMonsterDict_DropItem");

// Class DarwinGame.UIMonsterDict_Habitat
// 0x0028 (0x04B8 - 0x0490)
class UUIMonsterDict_Habitat : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     HabitatTimeTex;                                    // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_Habitat">();
	}
	static class UUIMonsterDict_Habitat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_Habitat>();
	}
};
static_assert(alignof(UUIMonsterDict_Habitat) == 0x000008, "Wrong alignment on UUIMonsterDict_Habitat");
static_assert(sizeof(UUIMonsterDict_Habitat) == 0x0004B8, "Wrong size on UUIMonsterDict_Habitat");
static_assert(offsetof(UUIMonsterDict_Habitat, HabitatTimeTex) == 0x000490, "Member 'UUIMonsterDict_Habitat::HabitatTimeTex' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_MonsterIcon
// 0x0090 (0x0520 - 0x0490)
class UUIMonsterDict_MonsterIcon : public UDarwinUserWidget
{
public:
	TSoftObjectPtr<class UTexture2D>              UnknownIcon;                                       // 0x0490(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FST_MonsterIconParts                   MonsterIconParts;                                  // 0x04B8(0x0050)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MonsterImageMaterial;                              // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x10];                                     // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_MonsterIcon">();
	}
	static class UUIMonsterDict_MonsterIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_MonsterIcon>();
	}
};
static_assert(alignof(UUIMonsterDict_MonsterIcon) == 0x000008, "Wrong alignment on UUIMonsterDict_MonsterIcon");
static_assert(sizeof(UUIMonsterDict_MonsterIcon) == 0x000520, "Wrong size on UUIMonsterDict_MonsterIcon");
static_assert(offsetof(UUIMonsterDict_MonsterIcon, UnknownIcon) == 0x000490, "Member 'UUIMonsterDict_MonsterIcon::UnknownIcon' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_MonsterIcon, MonsterIconParts) == 0x0004B8, "Member 'UUIMonsterDict_MonsterIcon::MonsterIconParts' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_MonsterIcon, MonsterImageMaterial) == 0x000508, "Member 'UUIMonsterDict_MonsterIcon::MonsterImageMaterial' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_MonsterIconChoice
// 0x0028 (0x0558 - 0x0530)
class UUIMonsterDict_MonsterIconChoice : public UUIScrollMenuItemBase
{
public:
	class UImage*                                 ImageNew;                                          // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageCompIcon;                                     // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStartLoopAnimation*                  Frame;                                             // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMonsterDict_MonsterIcon*             MonsterIcon;                                       // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_MonsterIconChoice">();
	}
	static class UUIMonsterDict_MonsterIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_MonsterIconChoice>();
	}
};
static_assert(alignof(UUIMonsterDict_MonsterIconChoice) == 0x000008, "Wrong alignment on UUIMonsterDict_MonsterIconChoice");
static_assert(sizeof(UUIMonsterDict_MonsterIconChoice) == 0x000558, "Wrong size on UUIMonsterDict_MonsterIconChoice");
static_assert(offsetof(UUIMonsterDict_MonsterIconChoice, ImageNew) == 0x000530, "Member 'UUIMonsterDict_MonsterIconChoice::ImageNew' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_MonsterIconChoice, ImageCompIcon) == 0x000538, "Member 'UUIMonsterDict_MonsterIconChoice::ImageCompIcon' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_MonsterIconChoice, Frame) == 0x000540, "Member 'UUIMonsterDict_MonsterIconChoice::Frame' has a wrong offset!");
static_assert(offsetof(UUIMonsterDict_MonsterIconChoice, MonsterIcon) == 0x000548, "Member 'UUIMonsterDict_MonsterIconChoice::MonsterIcon' has a wrong offset!");

// Class DarwinGame.UIMonsterDict_MonsterName
// 0x0000 (0x0490 - 0x0490)
class UUIMonsterDict_MonsterName : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_MonsterName">();
	}
	static class UUIMonsterDict_MonsterName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_MonsterName>();
	}
};
static_assert(alignof(UUIMonsterDict_MonsterName) == 0x000008, "Wrong alignment on UUIMonsterDict_MonsterName");
static_assert(sizeof(UUIMonsterDict_MonsterName) == 0x000490, "Wrong size on UUIMonsterDict_MonsterName");

// Class DarwinGame.UIMonsterDict_SelectMenu
// 0x0028 (0x05F8 - 0x05D0)
class UUIMonsterDict_SelectMenu : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x28];                                     // 0x05D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDict_SelectMenu">();
	}
	static class UUIMonsterDict_SelectMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDict_SelectMenu>();
	}
};
static_assert(alignof(UUIMonsterDict_SelectMenu) == 0x000008, "Wrong alignment on UUIMonsterDict_SelectMenu");
static_assert(sizeof(UUIMonsterDict_SelectMenu) == 0x0005F8, "Wrong size on UUIMonsterDict_SelectMenu");

// Class DarwinGame.UIMonsterDictHabitatDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIMonsterDictHabitatDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDictHabitatDataTable">();
	}
	static class UUIMonsterDictHabitatDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDictHabitatDataTable>();
	}
};
static_assert(alignof(UUIMonsterDictHabitatDataTable) == 0x000008, "Wrong alignment on UUIMonsterDictHabitatDataTable");
static_assert(sizeof(UUIMonsterDictHabitatDataTable) == 0x000030, "Wrong size on UUIMonsterDictHabitatDataTable");

// Class DarwinGame.UIMonsterDictInfoDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIMonsterDictInfoDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterDictInfoDataTable">();
	}
	static class UUIMonsterDictInfoDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterDictInfoDataTable>();
	}
};
static_assert(alignof(UUIMonsterDictInfoDataTable) == 0x000008, "Wrong alignment on UUIMonsterDictInfoDataTable");
static_assert(sizeof(UUIMonsterDictInfoDataTable) == 0x000030, "Wrong size on UUIMonsterDictInfoDataTable");

// Class DarwinGame.UIMonsterFacilityFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIMonsterFacilityFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterFacilityFunctionLibrary">();
	}
	static class UUIMonsterFacilityFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterFacilityFunctionLibrary>();
	}
};
static_assert(alignof(UUIMonsterFacilityFunctionLibrary) == 0x000008, "Wrong alignment on UUIMonsterFacilityFunctionLibrary");
static_assert(sizeof(UUIMonsterFacilityFunctionLibrary) == 0x000030, "Wrong size on UUIMonsterFacilityFunctionLibrary");

// Class DarwinGame.UIMonsterSpecialAbilityName
// 0x0000 (0x0490 - 0x0490)
class UUIMonsterSpecialAbilityName final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterSpecialAbilityName">();
	}
	static class UUIMonsterSpecialAbilityName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterSpecialAbilityName>();
	}
};
static_assert(alignof(UUIMonsterSpecialAbilityName) == 0x000008, "Wrong alignment on UUIMonsterSpecialAbilityName");
static_assert(sizeof(UUIMonsterSpecialAbilityName) == 0x000490, "Wrong size on UUIMonsterSpecialAbilityName");

// Class DarwinGame.UIMonsterSpecialAbilityNameComposite
// 0x0010 (0x04A0 - 0x0490)
class UUIMonsterSpecialAbilityNameComposite : public UDarwinUserWidget
{
public:
	class UDarwinUserWidget*                      m_CurrentWidget;                                   // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterSpecialAbilityNameComposite">();
	}
	static class UUIMonsterSpecialAbilityNameComposite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterSpecialAbilityNameComposite>();
	}
};
static_assert(alignof(UUIMonsterSpecialAbilityNameComposite) == 0x000008, "Wrong alignment on UUIMonsterSpecialAbilityNameComposite");
static_assert(sizeof(UUIMonsterSpecialAbilityNameComposite) == 0x0004A0, "Wrong size on UUIMonsterSpecialAbilityNameComposite");
static_assert(offsetof(UUIMonsterSpecialAbilityNameComposite, m_CurrentWidget) == 0x000490, "Member 'UUIMonsterSpecialAbilityNameComposite::m_CurrentWidget' has a wrong offset!");

// Class DarwinGame.UIMonsterSpecialAbilityNameDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIMonsterSpecialAbilityNameDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMonsterSpecialAbilityNameDataTable">();
	}
	static class UUIMonsterSpecialAbilityNameDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMonsterSpecialAbilityNameDataTable>();
	}
};
static_assert(alignof(UUIMonsterSpecialAbilityNameDataTable) == 0x000008, "Wrong alignment on UUIMonsterSpecialAbilityNameDataTable");
static_assert(sizeof(UUIMonsterSpecialAbilityNameDataTable) == 0x000030, "Wrong size on UUIMonsterSpecialAbilityNameDataTable");

// Class DarwinGame.UIMovieScreen
// 0x0000 (0x0490 - 0x0490)
class UUIMovieScreen : public UDarwinUserWidget
{
public:
	void FadeIn(float Time);
	void FadeOut(float Time);
	void SetMovieTexture(class UManaTexture* MovieTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMovieScreen">();
	}
	static class UUIMovieScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMovieScreen>();
	}
};
static_assert(alignof(UUIMovieScreen) == 0x000008, "Wrong alignment on UUIMovieScreen");
static_assert(sizeof(UUIMovieScreen) == 0x000490, "Wrong size on UUIMovieScreen");

// Class DarwinGame.UIMyArtifact_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIMyArtifact_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMyArtifact_Root">();
	}
	static class UUIMyArtifact_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMyArtifact_Root>();
	}
};
static_assert(alignof(UUIMyArtifact_Root) == 0x000008, "Wrong alignment on UUIMyArtifact_Root");
static_assert(sizeof(UUIMyArtifact_Root) == 0x0004D8, "Wrong size on UUIMyArtifact_Root");

// Class DarwinGame.UIMyTeamFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIMyTeamFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMyTeamFunctionLibrary">();
	}
	static class UUIMyTeamFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMyTeamFunctionLibrary>();
	}
};
static_assert(alignof(UUIMyTeamFunctionLibrary) == 0x000008, "Wrong alignment on UUIMyTeamFunctionLibrary");
static_assert(sizeof(UUIMyTeamFunctionLibrary) == 0x000030, "Wrong size on UUIMyTeamFunctionLibrary");

// Class DarwinGame.UINameBoxBase
// 0x0068 (0x0598 - 0x0530)
class UUINameBoxBase : public UUIScrollMenuItemBase
{
public:
	class UEditableText*                          EditableBox;                                       // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x60];                                     // 0x0538(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OffFocus(const class FText& InText, ETextCommit CommitMethod);
	void OnFloatingScreenKeyboardDismissed();
	void OnScreenKeyboardDismissed(bool IsTextCallbackSuccessful, const class FText& CallbackText);
	void OnTextChanged(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINameBoxBase">();
	}
	static class UUINameBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINameBoxBase>();
	}
};
static_assert(alignof(UUINameBoxBase) == 0x000008, "Wrong alignment on UUINameBoxBase");
static_assert(sizeof(UUINameBoxBase) == 0x000598, "Wrong size on UUINameBoxBase");
static_assert(offsetof(UUINameBoxBase, EditableBox) == 0x000530, "Member 'UUINameBoxBase::EditableBox' has a wrong offset!");

// Class DarwinGame.UINetwork_TreasureHide_Inf
// 0x0098 (0x0668 - 0x05D0)
class UUINetwork_TreasureHide_Inf final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinArtifactCaptureImage*            Treasure_CaptureImage;                             // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHidePanel*                   TreasureHidePaneTreasure;                          // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHidePanel*                   TreasureHidePanePlace;                             // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHidePanel*                   TreasureHidePanePassword;                          // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasurePanel*                       TreasurePanel;                                     // 0x0600(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHidePlacePanel*                      PlacePanel;                                        // 0x0608(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPasswordPanel*                       PasswordPanel;                                     // 0x0610(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         RiseValue;                                         // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         RiseValueNumber;                                   // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         RiseValueGold;                                     // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         RisePlus;                                          // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_640[0x10];                                     // 0x0640(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ValueBlueColor;                                    // 0x0650(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x8];                                      // 0x0660(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetwork_TreasureHide_Inf">();
	}
	static class UUINetwork_TreasureHide_Inf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetwork_TreasureHide_Inf>();
	}
};
static_assert(alignof(UUINetwork_TreasureHide_Inf) == 0x000008, "Wrong alignment on UUINetwork_TreasureHide_Inf");
static_assert(sizeof(UUINetwork_TreasureHide_Inf) == 0x000668, "Wrong size on UUINetwork_TreasureHide_Inf");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, Treasure_CaptureImage) == 0x0005E0, "Member 'UUINetwork_TreasureHide_Inf::Treasure_CaptureImage' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, TreasureHidePaneTreasure) == 0x0005E8, "Member 'UUINetwork_TreasureHide_Inf::TreasureHidePaneTreasure' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, TreasureHidePanePlace) == 0x0005F0, "Member 'UUINetwork_TreasureHide_Inf::TreasureHidePanePlace' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, TreasureHidePanePassword) == 0x0005F8, "Member 'UUINetwork_TreasureHide_Inf::TreasureHidePanePassword' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, TreasurePanel) == 0x000600, "Member 'UUINetwork_TreasureHide_Inf::TreasurePanel' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, PlacePanel) == 0x000608, "Member 'UUINetwork_TreasureHide_Inf::PlacePanel' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, PasswordPanel) == 0x000610, "Member 'UUINetwork_TreasureHide_Inf::PasswordPanel' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, RiseValue) == 0x000618, "Member 'UUINetwork_TreasureHide_Inf::RiseValue' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, RiseValueNumber) == 0x000620, "Member 'UUINetwork_TreasureHide_Inf::RiseValueNumber' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, RiseValueGold) == 0x000628, "Member 'UUINetwork_TreasureHide_Inf::RiseValueGold' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, RisePlus) == 0x000630, "Member 'UUINetwork_TreasureHide_Inf::RisePlus' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, UIUnderButton) == 0x000638, "Member 'UUINetwork_TreasureHide_Inf::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUINetwork_TreasureHide_Inf, ValueBlueColor) == 0x000650, "Member 'UUINetwork_TreasureHide_Inf::ValueBlueColor' has a wrong offset!");

// Class DarwinGame.UINetWork_WinSearch
// 0x0068 (0x0638 - 0x05D0)
class UUINetWork_WinSearch final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINameBoxBase*                         NameBox_Id;                                        // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUINameBoxBase*                         NameBox_Pass;                                      // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x40];                                     // 0x05F8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWork_WinSearch">();
	}
	static class UUINetWork_WinSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWork_WinSearch>();
	}
};
static_assert(alignof(UUINetWork_WinSearch) == 0x000008, "Wrong alignment on UUINetWork_WinSearch");
static_assert(sizeof(UUINetWork_WinSearch) == 0x000638, "Wrong size on UUINetWork_WinSearch");
static_assert(offsetof(UUINetWork_WinSearch, NameBox_Id) == 0x0005E8, "Member 'UUINetWork_WinSearch::NameBox_Id' has a wrong offset!");
static_assert(offsetof(UUINetWork_WinSearch, NameBox_Pass) == 0x0005F0, "Member 'UUINetWork_WinSearch::NameBox_Pass' has a wrong offset!");

// Class DarwinGame.UINetworkConnection
// 0x0020 (0x04B0 - 0x0490)
class UUINetworkConnection : public UUIResidentWidgetBase
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkConnection">();
	}
	static class UUINetworkConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkConnection>();
	}
};
static_assert(alignof(UUINetworkConnection) == 0x000008, "Wrong alignment on UUINetworkConnection");
static_assert(sizeof(UUINetworkConnection) == 0x0004B0, "Wrong size on UUINetworkConnection");

// Class DarwinGame.UINetWorkCursor
// 0x0078 (0x0660 - 0x05E8)
class UUINetWorkCursor final : public UUICursor_PartymenuBase
{
public:
	TArray<class UTexture2D*>                     NetworkOnlineBaseTex;                              // 0x05E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x68];                                     // 0x05F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkCursor">();
	}
	static class UUINetWorkCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkCursor>();
	}
};
static_assert(alignof(UUINetWorkCursor) == 0x000008, "Wrong alignment on UUINetWorkCursor");
static_assert(sizeof(UUINetWorkCursor) == 0x000660, "Wrong size on UUINetWorkCursor");
static_assert(offsetof(UUINetWorkCursor, NetworkOnlineBaseTex) == 0x0005E8, "Member 'UUINetWorkCursor::NetworkOnlineBaseTex' has a wrong offset!");

// Class DarwinGame.UINetWorkLeftMenu
// 0x0000 (0x0650 - 0x0650)
class UUINetWorkLeftMenu final : public UUILeftMenuBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkLeftMenu">();
	}
	static class UUINetWorkLeftMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkLeftMenu>();
	}
};
static_assert(alignof(UUINetWorkLeftMenu) == 0x000008, "Wrong alignment on UUINetWorkLeftMenu");
static_assert(sizeof(UUINetWorkLeftMenu) == 0x000650, "Wrong size on UUINetWorkLeftMenu");

// Class DarwinGame.UINetWorkManagement
// 0x0080 (0x0550 - 0x04D0)
class alignas(0x10) UUINetWorkManagement final : public UUILeftMenuUseBase
{
public:
	uint8                                         Pad_4D0[0x58];                                     // 0x04D0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIUnder_Button*                        UnderButton;                                       // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x20];                                     // 0x0530(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkManagement">();
	}
	static class UUINetWorkManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkManagement>();
	}
};
static_assert(alignof(UUINetWorkManagement) == 0x000010, "Wrong alignment on UUINetWorkManagement");
static_assert(sizeof(UUINetWorkManagement) == 0x000550, "Wrong size on UUINetWorkManagement");
static_assert(offsetof(UUINetWorkManagement, UnderButton) == 0x000528, "Member 'UUINetWorkManagement::UnderButton' has a wrong offset!");

// Class DarwinGame.UINetWorkManagementWinReturnMonster
// 0x0208 (0x0698 - 0x0490)
class UUINetWorkManagementWinReturnMonster final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarwinTwoSceneCaptureImage*            CaptureImage;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x1E0];                                    // 0x04A8(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITalk_WinStatusBase*                  TalkWinStatus;                                     // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_690[0x8];                                      // 0x0690(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkManagementWinReturnMonster">();
	}
	static class UUINetWorkManagementWinReturnMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkManagementWinReturnMonster>();
	}
};
static_assert(alignof(UUINetWorkManagementWinReturnMonster) == 0x000008, "Wrong alignment on UUINetWorkManagementWinReturnMonster");
static_assert(sizeof(UUINetWorkManagementWinReturnMonster) == 0x000698, "Wrong size on UUINetWorkManagementWinReturnMonster");
static_assert(offsetof(UUINetWorkManagementWinReturnMonster, CaptureImage) == 0x0004A0, "Member 'UUINetWorkManagementWinReturnMonster::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementWinReturnMonster, TalkWinStatus) == 0x000688, "Member 'UUINetWorkManagementWinReturnMonster::TalkWinStatus' has a wrong offset!");

// Class DarwinGame.UINetWorkManagementDetails
// 0x0270 (0x0840 - 0x05D0)
class alignas(0x10) UUINetWorkManagementDetails final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIIconChoice*                          ChoiceButton;                                      // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIManagementMonsterPanel*              MonsterPanel;                                      // 0x05E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIManagementTreasurePanel*             TreasurePanel;                                     // 0x05F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPasswordPanel*                       PasswordPanel;                                     // 0x05F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         OnlineIDText;                                      // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           OnlineIDCanvas;                                    // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWinMenu_S_03*                        SavingDialog;                                      // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x228];                                    // 0x0618(0x0228)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkManagementDetails">();
	}
	static class UUINetWorkManagementDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkManagementDetails>();
	}
};
static_assert(alignof(UUINetWorkManagementDetails) == 0x000010, "Wrong alignment on UUINetWorkManagementDetails");
static_assert(sizeof(UUINetWorkManagementDetails) == 0x000840, "Wrong size on UUINetWorkManagementDetails");
static_assert(offsetof(UUINetWorkManagementDetails, ChoiceButton) == 0x0005E0, "Member 'UUINetWorkManagementDetails::ChoiceButton' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementDetails, MonsterPanel) == 0x0005E8, "Member 'UUINetWorkManagementDetails::MonsterPanel' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementDetails, TreasurePanel) == 0x0005F0, "Member 'UUINetWorkManagementDetails::TreasurePanel' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementDetails, PasswordPanel) == 0x0005F8, "Member 'UUINetWorkManagementDetails::PasswordPanel' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementDetails, OnlineIDText) == 0x000600, "Member 'UUINetWorkManagementDetails::OnlineIDText' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementDetails, OnlineIDCanvas) == 0x000608, "Member 'UUINetWorkManagementDetails::OnlineIDCanvas' has a wrong offset!");
static_assert(offsetof(UUINetWorkManagementDetails, SavingDialog) == 0x000610, "Member 'UUINetWorkManagementDetails::SavingDialog' has a wrong offset!");

// Class DarwinGame.UINetworkMapHidePanel
// 0x0070 (0x05A0 - 0x0530)
class UUINetworkMapHidePanel final : public UUIScrollMenuItemBase
{
public:
	TMap<EMapSymbolType, class UTexture2D*>       IconImageList;                                     // 0x0530(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	class UTexture2D*                             GrayIconImage;                                     // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 IconImage;                                         // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 DifficultyImage;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkMapHidePanel">();
	}
	static class UUINetworkMapHidePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkMapHidePanel>();
	}
};
static_assert(alignof(UUINetworkMapHidePanel) == 0x000008, "Wrong alignment on UUINetworkMapHidePanel");
static_assert(sizeof(UUINetworkMapHidePanel) == 0x0005A0, "Wrong size on UUINetworkMapHidePanel");
static_assert(offsetof(UUINetworkMapHidePanel, IconImageList) == 0x000530, "Member 'UUINetworkMapHidePanel::IconImageList' has a wrong offset!");
static_assert(offsetof(UUINetworkMapHidePanel, GrayIconImage) == 0x000580, "Member 'UUINetworkMapHidePanel::GrayIconImage' has a wrong offset!");
static_assert(offsetof(UUINetworkMapHidePanel, IconImage) == 0x000590, "Member 'UUINetworkMapHidePanel::IconImage' has a wrong offset!");
static_assert(offsetof(UUINetworkMapHidePanel, DifficultyImage) == 0x000598, "Member 'UUINetworkMapHidePanel::DifficultyImage' has a wrong offset!");

// Class DarwinGame.UINetworkMemberSend_Artifact_Root
// 0x0120 (0x05F0 - 0x04D0)
class UUINetworkMemberSend_Artifact_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x120];                                    // 0x04D0(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkMemberSend_Artifact_Root">();
	}
	static class UUINetworkMemberSend_Artifact_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkMemberSend_Artifact_Root>();
	}
};
static_assert(alignof(UUINetworkMemberSend_Artifact_Root) == 0x000008, "Wrong alignment on UUINetworkMemberSend_Artifact_Root");
static_assert(sizeof(UUINetworkMemberSend_Artifact_Root) == 0x0005F0, "Wrong size on UUINetworkMemberSend_Artifact_Root");

// Class DarwinGame.UINetworkMemberSend_Root
// 0x0040 (0x0510 - 0x04D0)
class UUINetworkMemberSend_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x40];                                     // 0x04D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkMemberSend_Root">();
	}
	static class UUINetworkMemberSend_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkMemberSend_Root>();
	}
};
static_assert(alignof(UUINetworkMemberSend_Root) == 0x000008, "Wrong alignment on UUINetworkMemberSend_Root");
static_assert(sizeof(UUINetworkMemberSend_Root) == 0x000510, "Wrong size on UUINetworkMemberSend_Root");

// Class DarwinGame.UINetworkSignalIcon
// 0x0030 (0x04C0 - 0x0490)
class UUINetworkSignalIcon : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x28];                                     // 0x0490(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutoTextBlock*                         TextBlock;                                         // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkSignalIcon">();
	}
	static class UUINetworkSignalIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkSignalIcon>();
	}
};
static_assert(alignof(UUINetworkSignalIcon) == 0x000008, "Wrong alignment on UUINetworkSignalIcon");
static_assert(sizeof(UUINetworkSignalIcon) == 0x0004C0, "Wrong size on UUINetworkSignalIcon");
static_assert(offsetof(UUINetworkSignalIcon, TextBlock) == 0x0004B8, "Member 'UUINetworkSignalIcon::TextBlock' has a wrong offset!");

// Class DarwinGame.UINetWorkTop
// 0x0148 (0x0618 - 0x04D0)
class UUINetWorkTop final : public UUILeftMenuUseBase
{
public:
	TArray<struct FST_NetworkMenuCategory>        NetworkMenuMainCategoryList;                       // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_NetworkMenuCategory>        NetworkMenuTreasureCategoryList;                   // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_NetworkMenuCategory>        NetworkMenuTravellerCategoryList;                  // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_NetworkMenuCategory>        NetworkMenuProfileCategoryList;                    // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture_Morning;                         // 0x0510(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture_DayTime;                         // 0x0538(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture_Evening;                         // 0x0560(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              BackgroundTexture_Night;                           // 0x0588(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TravellerCanReturnHubMessage;                      // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ChimeraWingGetDLCount;                             // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIHub_Talk_00*                         HubTalk;                                           // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x18];                                     // 0x05C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x28];                                     // 0x05E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EOpenNetworkUIType                            OpenNetworkUIType;                                 // 0x0610(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkTop">();
	}
	static class UUINetWorkTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkTop>();
	}
};
static_assert(alignof(UUINetWorkTop) == 0x000008, "Wrong alignment on UUINetWorkTop");
static_assert(sizeof(UUINetWorkTop) == 0x000618, "Wrong size on UUINetWorkTop");
static_assert(offsetof(UUINetWorkTop, NetworkMenuMainCategoryList) == 0x0004D0, "Member 'UUINetWorkTop::NetworkMenuMainCategoryList' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, NetworkMenuTreasureCategoryList) == 0x0004E0, "Member 'UUINetWorkTop::NetworkMenuTreasureCategoryList' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, NetworkMenuTravellerCategoryList) == 0x0004F0, "Member 'UUINetWorkTop::NetworkMenuTravellerCategoryList' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, NetworkMenuProfileCategoryList) == 0x000500, "Member 'UUINetWorkTop::NetworkMenuProfileCategoryList' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, BackgroundTexture_Morning) == 0x000510, "Member 'UUINetWorkTop::BackgroundTexture_Morning' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, BackgroundTexture_DayTime) == 0x000538, "Member 'UUINetWorkTop::BackgroundTexture_DayTime' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, BackgroundTexture_Evening) == 0x000560, "Member 'UUINetWorkTop::BackgroundTexture_Evening' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, BackgroundTexture_Night) == 0x000588, "Member 'UUINetWorkTop::BackgroundTexture_Night' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, TravellerCanReturnHubMessage) == 0x0005B0, "Member 'UUINetWorkTop::TravellerCanReturnHubMessage' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, ChimeraWingGetDLCount) == 0x0005B8, "Member 'UUINetWorkTop::ChimeraWingGetDLCount' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, HubTalk) == 0x0005C0, "Member 'UUINetWorkTop::HubTalk' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, UIUnderButton) == 0x0005E0, "Member 'UUINetWorkTop::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUINetWorkTop, OpenNetworkUIType) == 0x000610, "Member 'UUINetWorkTop::OpenNetworkUIType' has a wrong offset!");

// Class DarwinGame.UINetworkTop_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUINetworkTop_Root : public UUIInitWidget_Root
{
public:
	EOpenNetworkUIType                            OpenNetworkUIType;                                 // 0x04D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkTop_Root">();
	}
	static class UUINetworkTop_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkTop_Root>();
	}
};
static_assert(alignof(UUINetworkTop_Root) == 0x000008, "Wrong alignment on UUINetworkTop_Root");
static_assert(sizeof(UUINetworkTop_Root) == 0x0004D8, "Wrong size on UUINetworkTop_Root");
static_assert(offsetof(UUINetworkTop_Root, OpenNetworkUIType) == 0x0004D0, "Member 'UUINetworkTop_Root::OpenNetworkUIType' has a wrong offset!");

// Class DarwinGame.UINetworkTreasureHide_Inf_Root
// 0x0060 (0x0530 - 0x04D0)
class UUINetworkTreasureHide_Inf_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x60];                                     // 0x04D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkTreasureHide_Inf_Root">();
	}
	static class UUINetworkTreasureHide_Inf_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkTreasureHide_Inf_Root>();
	}
};
static_assert(alignof(UUINetworkTreasureHide_Inf_Root) == 0x000008, "Wrong alignment on UUINetworkTreasureHide_Inf_Root");
static_assert(sizeof(UUINetworkTreasureHide_Inf_Root) == 0x000530, "Wrong size on UUINetworkTreasureHide_Inf_Root");

// Class DarwinGame.UINetworkTreasureHideMap
// 0x0070 (0x0640 - 0x05D0)
class alignas(0x10) UUINetworkTreasureHideMap final : public UUIScrollMenuBase
{
public:
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUINetworkTresureSignMap*               NetworkTresureSignMap;                             // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             RegionName;                                        // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             AreaName;                                          // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x50];                                     // 0x05F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkTreasureHideMap">();
	}
	static class UUINetworkTreasureHideMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkTreasureHideMap>();
	}
};
static_assert(alignof(UUINetworkTreasureHideMap) == 0x000010, "Wrong alignment on UUINetworkTreasureHideMap");
static_assert(sizeof(UUINetworkTreasureHideMap) == 0x000640, "Wrong size on UUINetworkTreasureHideMap");
static_assert(offsetof(UUINetworkTreasureHideMap, UIUnderButton) == 0x0005D0, "Member 'UUINetworkTreasureHideMap::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHideMap, NetworkTresureSignMap) == 0x0005D8, "Member 'UUINetworkTreasureHideMap::NetworkTresureSignMap' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHideMap, RegionName) == 0x0005E0, "Member 'UUINetworkTreasureHideMap::RegionName' has a wrong offset!");
static_assert(offsetof(UUINetworkTreasureHideMap, AreaName) == 0x0005E8, "Member 'UUINetworkTreasureHideMap::AreaName' has a wrong offset!");

// Class DarwinGame.UINetworkTresureSignMap
// 0x0018 (0x07F8 - 0x07E0)
class UUINetworkTresureSignMap final : public UUIMapBase
{
public:
	class UTexture2D*                             BGImage;                                           // 0x07E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      CursorIcon;                                        // 0x07E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISign_Icon*                           SignIcon;                                          // 0x07F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkTresureSignMap">();
	}
	static class UUINetworkTresureSignMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkTresureSignMap>();
	}
};
static_assert(alignof(UUINetworkTresureSignMap) == 0x000008, "Wrong alignment on UUINetworkTresureSignMap");
static_assert(sizeof(UUINetworkTresureSignMap) == 0x0007F8, "Wrong size on UUINetworkTresureSignMap");
static_assert(offsetof(UUINetworkTresureSignMap, BGImage) == 0x0007E0, "Member 'UUINetworkTresureSignMap::BGImage' has a wrong offset!");
static_assert(offsetof(UUINetworkTresureSignMap, CursorIcon) == 0x0007E8, "Member 'UUINetworkTresureSignMap::CursorIcon' has a wrong offset!");
static_assert(offsetof(UUINetworkTresureSignMap, SignIcon) == 0x0007F0, "Member 'UUINetworkTresureSignMap::SignIcon' has a wrong offset!");

// Class DarwinGame.UINetworkUserProfile_Root
// 0x00F0 (0x05C0 - 0x04D0)
class UUINetworkUserProfile_Root final : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0xF0];                                     // 0x04D0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkUserProfile_Root">();
	}
	static class UUINetworkUserProfile_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkUserProfile_Root>();
	}
};
static_assert(alignof(UUINetworkUserProfile_Root) == 0x000008, "Wrong alignment on UUINetworkUserProfile_Root");
static_assert(sizeof(UUINetworkUserProfile_Root) == 0x0005C0, "Wrong size on UUINetworkUserProfile_Root");

// Class DarwinGame.UINetworkWinPassword
// 0x0070 (0x0640 - 0x05D0)
class UUINetworkWinPassword final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINameBoxBase*                         InputBox;                                          // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x38];                                     // 0x05F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TitleLabel;                                        // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UComputeTextBlock*                      InfoLabel;                                         // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetworkWinPassword">();
	}
	static class UUINetworkWinPassword* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetworkWinPassword>();
	}
};
static_assert(alignof(UUINetworkWinPassword) == 0x000008, "Wrong alignment on UUINetworkWinPassword");
static_assert(sizeof(UUINetworkWinPassword) == 0x000640, "Wrong size on UUINetworkWinPassword");
static_assert(offsetof(UUINetworkWinPassword, InputBox) == 0x0005E8, "Member 'UUINetworkWinPassword::InputBox' has a wrong offset!");
static_assert(offsetof(UUINetworkWinPassword, TitleLabel) == 0x000628, "Member 'UUINetworkWinPassword::TitleLabel' has a wrong offset!");
static_assert(offsetof(UUINetworkWinPassword, InfoLabel) == 0x000630, "Member 'UUINetworkWinPassword::InfoLabel' has a wrong offset!");

// Class DarwinGame.UINetWorkWinTerms
// 0x0030 (0x0600 - 0x05D0)
class UUINetWorkWinTerms final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIIconChoice*                          ButtonTwo[0x2];                                    // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINetWorkWinTermsText*                 TermsText;                                         // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkWinTerms">();
	}
	static class UUINetWorkWinTerms* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkWinTerms>();
	}
};
static_assert(alignof(UUINetWorkWinTerms) == 0x000008, "Wrong alignment on UUINetWorkWinTerms");
static_assert(sizeof(UUINetWorkWinTerms) == 0x000600, "Wrong size on UUINetWorkWinTerms");
static_assert(offsetof(UUINetWorkWinTerms, ButtonTwo) == 0x0005E0, "Member 'UUINetWorkWinTerms::ButtonTwo' has a wrong offset!");
static_assert(offsetof(UUINetWorkWinTerms, TermsText) == 0x0005F8, "Member 'UUINetWorkWinTerms::TermsText' has a wrong offset!");

// Class DarwinGame.UINetWorkWinTerms_Root
// 0x0010 (0x04E0 - 0x04D0)
class UUINetWorkWinTerms_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkWinTerms_Root">();
	}
	static class UUINetWorkWinTerms_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkWinTerms_Root>();
	}
};
static_assert(alignof(UUINetWorkWinTerms_Root) == 0x000008, "Wrong alignment on UUINetWorkWinTerms_Root");
static_assert(sizeof(UUINetWorkWinTerms_Root) == 0x0004E0, "Wrong size on UUINetWorkWinTerms_Root");

// Class DarwinGame.UINetWorkWinTermsText
// 0x0010 (0x0500 - 0x04F0)
class UUINetWorkWinTermsText final : public UUIFreeScrollBase
{
public:
	uint8                                         Pad_4F0[0x10];                                     // 0x04F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINetWorkWinTermsText">();
	}
	static class UUINetWorkWinTermsText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINetWorkWinTermsText>();
	}
};
static_assert(alignof(UUINetWorkWinTermsText) == 0x000008, "Wrong alignment on UUINetWorkWinTermsText");
static_assert(sizeof(UUINetWorkWinTermsText) == 0x000500, "Wrong size on UUINetWorkWinTermsText");

// Class DarwinGame.UINextChain
// 0x0000 (0x0490 - 0x0490)
class UUINextChain : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINextChain">();
	}
	static class UUINextChain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINextChain>();
	}
};
static_assert(alignof(UUINextChain) == 0x000008, "Wrong alignment on UUINextChain");
static_assert(sizeof(UUINextChain) == 0x000490, "Wrong size on UUINextChain");

// Class DarwinGame.UINonCategory_WinSort
// 0x0028 (0x05F8 - 0x05D0)
class UUINonCategory_WinSort final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     SortIconList;                                      // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x8];                                      // 0x05F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINonCategory_WinSort">();
	}
	static class UUINonCategory_WinSort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINonCategory_WinSort>();
	}
};
static_assert(alignof(UUINonCategory_WinSort) == 0x000008, "Wrong alignment on UUINonCategory_WinSort");
static_assert(sizeof(UUINonCategory_WinSort) == 0x0005F8, "Wrong size on UUINonCategory_WinSort");
static_assert(offsetof(UUINonCategory_WinSort, SortIconList) == 0x0005E0, "Member 'UUINonCategory_WinSort::SortIconList' has a wrong offset!");

// Class DarwinGame.UINowMoney
// 0x0000 (0x0490 - 0x0490)
class UUINowMoney : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINowMoney">();
	}
	static class UUINowMoney* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINowMoney>();
	}
};
static_assert(alignof(UUINowMoney) == 0x000008, "Wrong alignment on UUINowMoney");
static_assert(sizeof(UUINowMoney) == 0x000490, "Wrong size on UUINowMoney");

// Class DarwinGame.UiNpcDataDataTable
// 0x0000 (0x0030 - 0x0030)
class UUiNpcDataDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UiNpcDataDataTable">();
	}
	static class UUiNpcDataDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUiNpcDataDataTable>();
	}
};
static_assert(alignof(UUiNpcDataDataTable) == 0x000008, "Wrong alignment on UUiNpcDataDataTable");
static_assert(sizeof(UUiNpcDataDataTable) == 0x000030, "Wrong size on UUiNpcDataDataTable");

// Class DarwinGame.UIOperationWin
// 0x0058 (0x04E8 - 0x0490)
class UUIOperationWin : public UDarwinUserWidget
{
public:
	TMap<class FName, class UTextWidgetData*>     ButtonTextMap;                                     // 0x0490(0x0050)(NativeAccessSpecifierPrivate)
	class UTextWidgetData*                        BtnLBTextWidgetData;                               // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOperationWin">();
	}
	static class UUIOperationWin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOperationWin>();
	}
};
static_assert(alignof(UUIOperationWin) == 0x000008, "Wrong alignment on UUIOperationWin");
static_assert(sizeof(UUIOperationWin) == 0x0004E8, "Wrong size on UUIOperationWin");
static_assert(offsetof(UUIOperationWin, ButtonTextMap) == 0x000490, "Member 'UUIOperationWin::ButtonTextMap' has a wrong offset!");
static_assert(offsetof(UUIOperationWin, BtnLBTextWidgetData) == 0x0004E0, "Member 'UUIOperationWin::BtnLBTextWidgetData' has a wrong offset!");

// Class DarwinGame.UIOperationWinPC
// 0x00F0 (0x0580 - 0x0490)
class UUIOperationWinPC : public UDarwinUserWidget
{
public:
	TMap<class FName, class UTextWidgetData*>     ButtonTextMouseMap;                                // 0x0490(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class UTextWidgetData*>     ButtonTextControllerMap;                           // 0x04E0(0x0050)(NativeAccessSpecifierPrivate)
	class UTextWidgetData*                        BtnLBTextWidgetData;                               // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x48];                                     // 0x0538(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOperationWinPC">();
	}
	static class UUIOperationWinPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOperationWinPC>();
	}
};
static_assert(alignof(UUIOperationWinPC) == 0x000008, "Wrong alignment on UUIOperationWinPC");
static_assert(sizeof(UUIOperationWinPC) == 0x000580, "Wrong size on UUIOperationWinPC");
static_assert(offsetof(UUIOperationWinPC, ButtonTextMouseMap) == 0x000490, "Member 'UUIOperationWinPC::ButtonTextMouseMap' has a wrong offset!");
static_assert(offsetof(UUIOperationWinPC, ButtonTextControllerMap) == 0x0004E0, "Member 'UUIOperationWinPC::ButtonTextControllerMap' has a wrong offset!");
static_assert(offsetof(UUIOperationWinPC, BtnLBTextWidgetData) == 0x000530, "Member 'UUIOperationWinPC::BtnLBTextWidgetData' has a wrong offset!");

// Class DarwinGame.UIOptionOperation
// 0x00A8 (0x0688 - 0x05E0)
class UUIOptionOperation : public UUIOptionScreenSoundBase
{
public:
	TArray<struct FST_OptionPanelData>            OptionPanelData;                                   // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIOptionPanel*>                 OptionOperationPanels;                             // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         ControllerButton;                                  // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         ControllerIconButton;                              // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         KeyboardButton;                                    // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         KeyboardLayoutButton;                              // 0x0618(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         CameraLeftRightButtons;                            // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         CameraUpDownButtons;                               // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         CameraLRSpeedVolume;                               // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         CameraUDSpeedVolume;                               // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_640[0x48];                                     // 0x0640(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionOperation">();
	}
	static class UUIOptionOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionOperation>();
	}
};
static_assert(alignof(UUIOptionOperation) == 0x000008, "Wrong alignment on UUIOptionOperation");
static_assert(sizeof(UUIOptionOperation) == 0x000688, "Wrong size on UUIOptionOperation");
static_assert(offsetof(UUIOptionOperation, OptionPanelData) == 0x0005E0, "Member 'UUIOptionOperation::OptionPanelData' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, OptionOperationPanels) == 0x0005F0, "Member 'UUIOptionOperation::OptionOperationPanels' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, ControllerButton) == 0x000600, "Member 'UUIOptionOperation::ControllerButton' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, ControllerIconButton) == 0x000608, "Member 'UUIOptionOperation::ControllerIconButton' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, KeyboardButton) == 0x000610, "Member 'UUIOptionOperation::KeyboardButton' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, KeyboardLayoutButton) == 0x000618, "Member 'UUIOptionOperation::KeyboardLayoutButton' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, CameraLeftRightButtons) == 0x000620, "Member 'UUIOptionOperation::CameraLeftRightButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, CameraUpDownButtons) == 0x000628, "Member 'UUIOptionOperation::CameraUpDownButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, CameraLRSpeedVolume) == 0x000630, "Member 'UUIOptionOperation::CameraLRSpeedVolume' has a wrong offset!");
static_assert(offsetof(UUIOptionOperation, CameraUDSpeedVolume) == 0x000638, "Member 'UUIOptionOperation::CameraUDSpeedVolume' has a wrong offset!");

// Class DarwinGame.UIOptionPanel
// 0x0068 (0x0598 - 0x0530)
class UUIOptionPanel : public UUIScrollMenuItemBase
{
public:
	class UTextBlock*                             TitleHeader;                                       // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICommonmenu_OptionChoiceBase_Base*    OneButton;                                         // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICommonmenu_OptionChoiceBase_Base*    OneButtonPopup;                                    // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUICommonmenu_OptionChoiceBase_Base*> TwoButtons;                                        // 0x0548(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUICommonmenu_OptionChoiceBase_Base*> ThreeButtons;                                      // 0x0558(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIVolume_01*                           VolumeLowPanel;                                    // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIVolume_01*                           VolumePanel;                                       // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIVolume_01*                           VolumeHighPanel;                                   // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x18];                                     // 0x0580(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionPanel">();
	}
	static class UUIOptionPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionPanel>();
	}
};
static_assert(alignof(UUIOptionPanel) == 0x000008, "Wrong alignment on UUIOptionPanel");
static_assert(sizeof(UUIOptionPanel) == 0x000598, "Wrong size on UUIOptionPanel");
static_assert(offsetof(UUIOptionPanel, TitleHeader) == 0x000530, "Member 'UUIOptionPanel::TitleHeader' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, OneButton) == 0x000538, "Member 'UUIOptionPanel::OneButton' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, OneButtonPopup) == 0x000540, "Member 'UUIOptionPanel::OneButtonPopup' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, TwoButtons) == 0x000548, "Member 'UUIOptionPanel::TwoButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, ThreeButtons) == 0x000558, "Member 'UUIOptionPanel::ThreeButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, VolumeLowPanel) == 0x000568, "Member 'UUIOptionPanel::VolumeLowPanel' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, VolumePanel) == 0x000570, "Member 'UUIOptionPanel::VolumePanel' has a wrong offset!");
static_assert(offsetof(UUIOptionPanel, VolumeHighPanel) == 0x000578, "Member 'UUIOptionPanel::VolumeHighPanel' has a wrong offset!");

// Class DarwinGame.UIOptionScreen
// 0x0048 (0x0628 - 0x05E0)
class UUIOptionScreen : public UUIOptionScreenSoundBase
{
public:
	TArray<class UUICommonmenu_OptionChoiceBase_Base*> SubtitlesButtons;                                  // 0x05E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUICommonmenu_OptionChoiceBase_Base*> CameraLeftRightButtons;                            // 0x05F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUICommonmenu_OptionChoiceBase_Base*> CameraUpDownButtons;                               // 0x0600(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIVolume_01*>                   CameraSpeedVolumes;                                // 0x0610(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionScreen">();
	}
	static class UUIOptionScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionScreen>();
	}
};
static_assert(alignof(UUIOptionScreen) == 0x000008, "Wrong alignment on UUIOptionScreen");
static_assert(sizeof(UUIOptionScreen) == 0x000628, "Wrong size on UUIOptionScreen");
static_assert(offsetof(UUIOptionScreen, SubtitlesButtons) == 0x0005E0, "Member 'UUIOptionScreen::SubtitlesButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionScreen, CameraLeftRightButtons) == 0x0005F0, "Member 'UUIOptionScreen::CameraLeftRightButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionScreen, CameraUpDownButtons) == 0x000600, "Member 'UUIOptionScreen::CameraUpDownButtons' has a wrong offset!");
static_assert(offsetof(UUIOptionScreen, CameraSpeedVolumes) == 0x000610, "Member 'UUIOptionScreen::CameraSpeedVolumes' has a wrong offset!");

// Class DarwinGame.UIOptionScreenPC
// 0x0138 (0x0718 - 0x05E0)
class UUIOptionScreenPC : public UUIOptionScreenSoundBase
{
public:
	class UUIOptionPanel*                         WindowModeButton;                                  // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         ResolutionButton;                                  // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         FPSButton;                                         // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIOptionPanel*                         BrightnessVolume;                                  // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_OptionPanelData>            OptionPanelData;                                   // 0x0600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIOptionPanel*>                 OptionScreenPCPanels;                              // 0x0610(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0xF8];                                     // 0x0620(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIOptionScreenPC">();
	}
	static class UUIOptionScreenPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIOptionScreenPC>();
	}
};
static_assert(alignof(UUIOptionScreenPC) == 0x000008, "Wrong alignment on UUIOptionScreenPC");
static_assert(sizeof(UUIOptionScreenPC) == 0x000718, "Wrong size on UUIOptionScreenPC");
static_assert(offsetof(UUIOptionScreenPC, WindowModeButton) == 0x0005E0, "Member 'UUIOptionScreenPC::WindowModeButton' has a wrong offset!");
static_assert(offsetof(UUIOptionScreenPC, ResolutionButton) == 0x0005E8, "Member 'UUIOptionScreenPC::ResolutionButton' has a wrong offset!");
static_assert(offsetof(UUIOptionScreenPC, FPSButton) == 0x0005F0, "Member 'UUIOptionScreenPC::FPSButton' has a wrong offset!");
static_assert(offsetof(UUIOptionScreenPC, BrightnessVolume) == 0x0005F8, "Member 'UUIOptionScreenPC::BrightnessVolume' has a wrong offset!");
static_assert(offsetof(UUIOptionScreenPC, OptionPanelData) == 0x000600, "Member 'UUIOptionScreenPC::OptionPanelData' has a wrong offset!");
static_assert(offsetof(UUIOptionScreenPC, OptionScreenPCPanels) == 0x000610, "Member 'UUIOptionScreenPC::OptionScreenPCPanels' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_02
// 0x0030 (0x0640 - 0x0610)
class UUIPartyMenu_PMR_Page_02 : public UUIPartyMenu_PMR_Page_Base
{
public:
	class FText                                   EmptyText;                                         // 0x0610(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPanelTypeNormalOnly;                            // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CursorEnable;                                      // 0x0629(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62A[0x16];                                     // 0x062A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_02">();
	}
	static class UUIPartyMenu_PMR_Page_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_02>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_02) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_02");
static_assert(sizeof(UUIPartyMenu_PMR_Page_02) == 0x000640, "Wrong size on UUIPartyMenu_PMR_Page_02");
static_assert(offsetof(UUIPartyMenu_PMR_Page_02, EmptyText) == 0x000610, "Member 'UUIPartyMenu_PMR_Page_02::EmptyText' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_02, bIsPanelTypeNormalOnly) == 0x000628, "Member 'UUIPartyMenu_PMR_Page_02::bIsPanelTypeNormalOnly' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_02, CursorEnable) == 0x000629, "Member 'UUIPartyMenu_PMR_Page_02::CursorEnable' has a wrong offset!");

// Class DarwinGame.UIPage_CoinAbility
// 0x0000 (0x0640 - 0x0640)
class UUIPage_CoinAbility : public UUIPartyMenu_PMR_Page_02
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPage_CoinAbility">();
	}
	static class UUIPage_CoinAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPage_CoinAbility>();
	}
};
static_assert(alignof(UUIPage_CoinAbility) == 0x000008, "Wrong alignment on UUIPage_CoinAbility");
static_assert(sizeof(UUIPage_CoinAbility) == 0x000640, "Wrong size on UUIPage_CoinAbility");

// Class DarwinGame.UIPage_CoinDetail
// 0x0000 (0x0640 - 0x0640)
class UUIPage_CoinDetail : public UUIPartyMenu_PMR_Page_02
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPage_CoinDetail">();
	}
	static class UUIPage_CoinDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPage_CoinDetail>();
	}
};
static_assert(alignof(UUIPage_CoinDetail) == 0x000008, "Wrong alignment on UUIPage_CoinDetail");
static_assert(sizeof(UUIPage_CoinDetail) == 0x000640, "Wrong size on UUIPage_CoinDetail");

// Class DarwinGame.UIPanel_CoinDetail
// 0x0010 (0x0560 - 0x0550)
class UUIPanel_CoinDetail : public UUIPartyMenu_PM_Panel_02
{
public:
	class UTextBlock*                             ScrollBaseTextDesc;                                // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USideScrollTextBlock*                   ScrollTextDesc;                                    // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanel_CoinDetail">();
	}
	static class UUIPanel_CoinDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanel_CoinDetail>();
	}
};
static_assert(alignof(UUIPanel_CoinDetail) == 0x000008, "Wrong alignment on UUIPanel_CoinDetail");
static_assert(sizeof(UUIPanel_CoinDetail) == 0x000560, "Wrong size on UUIPanel_CoinDetail");
static_assert(offsetof(UUIPanel_CoinDetail, ScrollBaseTextDesc) == 0x000550, "Member 'UUIPanel_CoinDetail::ScrollBaseTextDesc' has a wrong offset!");
static_assert(offsetof(UUIPanel_CoinDetail, ScrollTextDesc) == 0x000558, "Member 'UUIPanel_CoinDetail::ScrollTextDesc' has a wrong offset!");

// Class DarwinGame.UIPanelControllerMapping
// 0x0020 (0x0550 - 0x0530)
class UUIPanelControllerMapping : public UUIScrollMenuItemBase
{
public:
	class UUIButtonMapping*                       SettingButton;                                     // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleNameText;                                     // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameText;                                          // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelControllerMapping">();
	}
	static class UUIPanelControllerMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelControllerMapping>();
	}
};
static_assert(alignof(UUIPanelControllerMapping) == 0x000008, "Wrong alignment on UUIPanelControllerMapping");
static_assert(sizeof(UUIPanelControllerMapping) == 0x000550, "Wrong size on UUIPanelControllerMapping");
static_assert(offsetof(UUIPanelControllerMapping, SettingButton) == 0x000530, "Member 'UUIPanelControllerMapping::SettingButton' has a wrong offset!");
static_assert(offsetof(UUIPanelControllerMapping, TitleNameText) == 0x000538, "Member 'UUIPanelControllerMapping::TitleNameText' has a wrong offset!");
static_assert(offsetof(UUIPanelControllerMapping, NameText) == 0x000540, "Member 'UUIPanelControllerMapping::NameText' has a wrong offset!");

// Class DarwinGame.UIPanelKeyboardMapping
// 0x0050 (0x0580 - 0x0530)
class UUIPanelKeyboardMapping : public UUIScrollMenuItemBase
{
public:
	class UTextBlock*                             TitleHeader;                                       // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIButtonMapping*>               ButtonMappings;                                    // 0x0538(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameText;                                          // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_550[0x30];                                     // 0x0550(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPanelKeyboardMapping">();
	}
	static class UUIPanelKeyboardMapping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPanelKeyboardMapping>();
	}
};
static_assert(alignof(UUIPanelKeyboardMapping) == 0x000008, "Wrong alignment on UUIPanelKeyboardMapping");
static_assert(sizeof(UUIPanelKeyboardMapping) == 0x000580, "Wrong size on UUIPanelKeyboardMapping");
static_assert(offsetof(UUIPanelKeyboardMapping, TitleHeader) == 0x000530, "Member 'UUIPanelKeyboardMapping::TitleHeader' has a wrong offset!");
static_assert(offsetof(UUIPanelKeyboardMapping, ButtonMappings) == 0x000538, "Member 'UUIPanelKeyboardMapping::ButtonMappings' has a wrong offset!");
static_assert(offsetof(UUIPanelKeyboardMapping, NameText) == 0x000548, "Member 'UUIPanelKeyboardMapping::NameText' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Icon_00
// 0x0018 (0x04A8 - 0x0490)
class UUIPartyMenu_PM_Icon_00 : public UDarwinUserWidget
{
public:
	class UImage*                                 ImageSingle;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageDouble1;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageDouble2;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Icon_00">();
	}
	static class UUIPartyMenu_PM_Icon_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Icon_00>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Icon_00) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Icon_00");
static_assert(sizeof(UUIPartyMenu_PM_Icon_00) == 0x0004A8, "Wrong size on UUIPartyMenu_PM_Icon_00");
static_assert(offsetof(UUIPartyMenu_PM_Icon_00, ImageSingle) == 0x000490, "Member 'UUIPartyMenu_PM_Icon_00::ImageSingle' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Icon_00, ImageDouble1) == 0x000498, "Member 'UUIPartyMenu_PM_Icon_00::ImageDouble1' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Icon_00, ImageDouble2) == 0x0004A0, "Member 'UUIPartyMenu_PM_Icon_00::ImageDouble2' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_00
// 0x0008 (0x0538 - 0x0530)
class UUIPartyMenu_PM_Panel_00 : public UUIPartyMenu_PM_Panel_StatusChangeBase
{
public:
	class UUIPartyMenu_PM_Icon_00*                Icon;                                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_00">();
	}
	static class UUIPartyMenu_PM_Panel_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_00>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_00) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_00");
static_assert(sizeof(UUIPartyMenu_PM_Panel_00) == 0x000538, "Wrong size on UUIPartyMenu_PM_Panel_00");
static_assert(offsetof(UUIPartyMenu_PM_Panel_00, Icon) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_00::Icon' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_00_Artifact_1
// 0x0000 (0x0530 - 0x0530)
class UUIPartyMenu_PM_Panel_00_Artifact_1 : public UUIPartyMenu_PM_Panel_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_00_Artifact_1">();
	}
	static class UUIPartyMenu_PM_Panel_00_Artifact_1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_00_Artifact_1>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_00_Artifact_1) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_00_Artifact_1");
static_assert(sizeof(UUIPartyMenu_PM_Panel_00_Artifact_1) == 0x000530, "Wrong size on UUIPartyMenu_PM_Panel_00_Artifact_1");

// Class DarwinGame.UIPartyMenu_PM_Panel_00_Artifact_2
// 0x0000 (0x0530 - 0x0530)
class UUIPartyMenu_PM_Panel_00_Artifact_2 : public UUIPartyMenu_PM_Panel_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_00_Artifact_2">();
	}
	static class UUIPartyMenu_PM_Panel_00_Artifact_2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_00_Artifact_2>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_00_Artifact_2) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_00_Artifact_2");
static_assert(sizeof(UUIPartyMenu_PM_Panel_00_Artifact_2) == 0x000530, "Wrong size on UUIPartyMenu_PM_Panel_00_Artifact_2");

// Class DarwinGame.UIPartyMenu_PM_Panel_01
// 0x0018 (0x0548 - 0x0530)
class UUIPartyMenu_PM_Panel_01 : public UUIPartyMenu_PM_Panel_Base
{
public:
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             ActionNameBlock;                                   // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USideScrollTextBlock*                   ScrollTextBlock;                                   // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_01">();
	}
	static class UUIPartyMenu_PM_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_01>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_01) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_01");
static_assert(sizeof(UUIPartyMenu_PM_Panel_01) == 0x000548, "Wrong size on UUIPartyMenu_PM_Panel_01");
static_assert(offsetof(UUIPartyMenu_PM_Panel_01, ActionNameBlock) == 0x000538, "Member 'UUIPartyMenu_PM_Panel_01::ActionNameBlock' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Panel_01, ScrollTextBlock) == 0x000540, "Member 'UUIPartyMenu_PM_Panel_01::ScrollTextBlock' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_03
// 0x0008 (0x0538 - 0x0530)
class UUIPartyMenu_PM_Panel_03 : public UUIPartyMenu_PM_Panel_Base
{
public:
	class UUIPartyMenu_PM_Icon_00*                Icon;                                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_03">();
	}
	static class UUIPartyMenu_PM_Panel_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_03>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_03) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_03");
static_assert(sizeof(UUIPartyMenu_PM_Panel_03) == 0x000538, "Wrong size on UUIPartyMenu_PM_Panel_03");
static_assert(offsetof(UUIPartyMenu_PM_Panel_03, Icon) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_03::Icon' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_04
// 0x0008 (0x0538 - 0x0530)
class UUIPartyMenu_PM_Panel_04 : public UUIPartyMenu_PM_Panel_Base
{
public:
	class UUIPartyMenu_PM_Icon_00*                Icon;                                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_04">();
	}
	static class UUIPartyMenu_PM_Panel_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_04>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_04) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_04");
static_assert(sizeof(UUIPartyMenu_PM_Panel_04) == 0x000538, "Wrong size on UUIPartyMenu_PM_Panel_04");
static_assert(offsetof(UUIPartyMenu_PM_Panel_04, Icon) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_04::Icon' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_06
// 0x0028 (0x0558 - 0x0530)
class UUIPartyMenu_PM_Panel_06 final : public UUIPartyMenu_PM_Panel_Base
{
public:
	class UImage*                                 ImgIconItem;                                       // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x20];                                     // 0x0538(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_06">();
	}
	static class UUIPartyMenu_PM_Panel_06* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_06>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_06) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_06");
static_assert(sizeof(UUIPartyMenu_PM_Panel_06) == 0x000558, "Wrong size on UUIPartyMenu_PM_Panel_06");
static_assert(offsetof(UUIPartyMenu_PM_Panel_06, ImgIconItem) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_06::ImgIconItem' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Panel_12
// 0x0008 (0x0538 - 0x0530)
class UUIPartyMenu_PM_Panel_12 : public UUIPartyMenu_PM_Panel_StatusChangeBase
{
public:
	class UUIPartyMenu_PM_Icon_00*                Icon;                                              // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Panel_12">();
	}
	static class UUIPartyMenu_PM_Panel_12* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Panel_12>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Panel_12) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Panel_12");
static_assert(sizeof(UUIPartyMenu_PM_Panel_12) == 0x000538, "Wrong size on UUIPartyMenu_PM_Panel_12");
static_assert(offsetof(UUIPartyMenu_PM_Panel_12, Icon) == 0x000530, "Member 'UUIPartyMenu_PM_Panel_12::Icon' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PM_Win_00
// 0x0038 (0x04C8 - 0x0490)
class UUIPartyMenu_PM_Win_00 : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 ImgIcon_C_2;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImgIcon_HA_1;                                      // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImgIcon_HB_1;                                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PM_Win_00">();
	}
	static class UUIPartyMenu_PM_Win_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PM_Win_00>();
	}
};
static_assert(alignof(UUIPartyMenu_PM_Win_00) == 0x000008, "Wrong alignment on UUIPartyMenu_PM_Win_00");
static_assert(sizeof(UUIPartyMenu_PM_Win_00) == 0x0004C8, "Wrong size on UUIPartyMenu_PM_Win_00");
static_assert(offsetof(UUIPartyMenu_PM_Win_00, ImgIcon_C_2) == 0x0004A8, "Member 'UUIPartyMenu_PM_Win_00::ImgIcon_C_2' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Win_00, ImgIcon_HA_1) == 0x0004B0, "Member 'UUIPartyMenu_PM_Win_00::ImgIcon_HA_1' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PM_Win_00, ImgIcon_HB_1) == 0x0004B8, "Member 'UUIPartyMenu_PM_Win_00::ImgIcon_HB_1' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_00
// 0x0070 (0x0680 - 0x0610)
class UUIPartyMenu_PMR_Page_00 : public UUIPartyMenu_PMR_Page_Base
{
public:
	class UUIUnder_Button*                        UnderButton;                                       // 0x0610(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FST_StatusMenuType>             StatusTextureArray;                                // 0x0618(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x48];                                     // 0x0628(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           MonsterKindViewCanvas;                             // 0x0670(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         MonsterKindTextBlock;                              // 0x0678(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_00">();
	}
	static class UUIPartyMenu_PMR_Page_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_00>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_00) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_00");
static_assert(sizeof(UUIPartyMenu_PMR_Page_00) == 0x000680, "Wrong size on UUIPartyMenu_PMR_Page_00");
static_assert(offsetof(UUIPartyMenu_PMR_Page_00, UnderButton) == 0x000610, "Member 'UUIPartyMenu_PMR_Page_00::UnderButton' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_00, StatusTextureArray) == 0x000618, "Member 'UUIPartyMenu_PMR_Page_00::StatusTextureArray' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_00, MonsterKindViewCanvas) == 0x000670, "Member 'UUIPartyMenu_PMR_Page_00::MonsterKindViewCanvas' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_00, MonsterKindTextBlock) == 0x000678, "Member 'UUIPartyMenu_PMR_Page_00::MonsterKindTextBlock' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_01
// 0x0040 (0x0650 - 0x0610)
class UUIPartyMenu_PMR_Page_01 : public UUIPartyMenu_PMR_Page_Base
{
public:
	TArray<class UUIPartyMenu_PM_Panel_01*>       ActionInfoPanels;                                  // 0x0610(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x28];                                     // 0x0620(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIUnder_Button*                        UnderButton;                                       // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_01">();
	}
	static class UUIPartyMenu_PMR_Page_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_01>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_01) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_01");
static_assert(sizeof(UUIPartyMenu_PMR_Page_01) == 0x000650, "Wrong size on UUIPartyMenu_PMR_Page_01");
static_assert(offsetof(UUIPartyMenu_PMR_Page_01, ActionInfoPanels) == 0x000610, "Member 'UUIPartyMenu_PMR_Page_01::ActionInfoPanels' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_PMR_Page_01, UnderButton) == 0x000648, "Member 'UUIPartyMenu_PMR_Page_01::UnderButton' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_04
// 0x0010 (0x0620 - 0x0610)
class UUIPartyMenu_PMR_Page_04 : public UUIPartyMenu_PMR_Page_Base
{
public:
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_04">();
	}
	static class UUIPartyMenu_PMR_Page_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_04>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_04) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_04");
static_assert(sizeof(UUIPartyMenu_PMR_Page_04) == 0x000620, "Wrong size on UUIPartyMenu_PMR_Page_04");

// Class DarwinGame.UIPartyMenu_PMR_Page_07
// 0x0018 (0x0628 - 0x0610)
class UUIPartyMenu_PMR_Page_07 final : public UUIPartyMenu_PMR_Page_Base
{
public:
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBoardmenu_MonsterIconChoice*         MonsterIconChoice;                                 // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_07">();
	}
	static class UUIPartyMenu_PMR_Page_07* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_07>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_07) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_07");
static_assert(sizeof(UUIPartyMenu_PMR_Page_07) == 0x000628, "Wrong size on UUIPartyMenu_PMR_Page_07");
static_assert(offsetof(UUIPartyMenu_PMR_Page_07, MonsterIconChoice) == 0x000620, "Member 'UUIPartyMenu_PMR_Page_07::MonsterIconChoice' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_PMR_Page_12
// 0x0070 (0x0680 - 0x0610)
class UUIPartyMenu_PMR_Page_12 : public UUIPartyMenu_PMR_Page_Base
{
public:
	TArray<struct FST_CoinStatusMenuType>         StatusTextureArray;                                // 0x0610(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x60];                                     // 0x0620(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_PMR_Page_12">();
	}
	static class UUIPartyMenu_PMR_Page_12* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_PMR_Page_12>();
	}
};
static_assert(alignof(UUIPartyMenu_PMR_Page_12) == 0x000008, "Wrong alignment on UUIPartyMenu_PMR_Page_12");
static_assert(sizeof(UUIPartyMenu_PMR_Page_12) == 0x000680, "Wrong size on UUIPartyMenu_PMR_Page_12");
static_assert(offsetof(UUIPartyMenu_PMR_Page_12, StatusTextureArray) == 0x000610, "Member 'UUIPartyMenu_PMR_Page_12::StatusTextureArray' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_Top
// 0x0048 (0x0550 - 0x0508)
class UUIPartyMenu_Top : public UUIStatusBase
{
public:
	class UUIPartyMenu_Tsuyosa*                   TopStatus;                                         // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_BG*                        BackImage;                                         // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_00*               Page00;                                            // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_01*               Page01;                                            // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_02*               Page02;                                            // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_03*               Page03;                                            // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_PMR_Page_04*               Page04;                                            // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_Top">();
	}
	static class UUIPartyMenu_Top* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_Top>();
	}
};
static_assert(alignof(UUIPartyMenu_Top) == 0x000008, "Wrong alignment on UUIPartyMenu_Top");
static_assert(sizeof(UUIPartyMenu_Top) == 0x000550, "Wrong size on UUIPartyMenu_Top");
static_assert(offsetof(UUIPartyMenu_Top, TopStatus) == 0x000508, "Member 'UUIPartyMenu_Top::TopStatus' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, BackImage) == 0x000510, "Member 'UUIPartyMenu_Top::BackImage' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, Page00) == 0x000518, "Member 'UUIPartyMenu_Top::Page00' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, Page01) == 0x000520, "Member 'UUIPartyMenu_Top::Page01' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, Page02) == 0x000528, "Member 'UUIPartyMenu_Top::Page02' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, Page03) == 0x000530, "Member 'UUIPartyMenu_Top::Page03' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, Page04) == 0x000538, "Member 'UUIPartyMenu_Top::Page04' has a wrong offset!");
static_assert(offsetof(UUIPartyMenu_Top, UIUnderButton) == 0x000540, "Member 'UUIPartyMenu_Top::UIUnderButton' has a wrong offset!");

// Class DarwinGame.UIPartyMenu_Tsuyosa
// 0x0010 (0x04A0 - 0x0490)
class UUIPartyMenu_Tsuyosa : public UDarwinUserWidget
{
public:
	class UDarwinTwoSceneCaptureImage*            CaptureImage;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyMenu_Tsuyosa">();
	}
	static class UUIPartyMenu_Tsuyosa* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyMenu_Tsuyosa>();
	}
};
static_assert(alignof(UUIPartyMenu_Tsuyosa) == 0x000008, "Wrong alignment on UUIPartyMenu_Tsuyosa");
static_assert(sizeof(UUIPartyMenu_Tsuyosa) == 0x0004A0, "Wrong size on UUIPartyMenu_Tsuyosa");
static_assert(offsetof(UUIPartyMenu_Tsuyosa, CaptureImage) == 0x000490, "Member 'UUIPartyMenu_Tsuyosa::CaptureImage' has a wrong offset!");

// Class DarwinGame.UIPasswordPanel
// 0x0070 (0x00A0 - 0x0030)
class alignas(0x10) UUIPasswordPanel final : public UObject
{
public:
	class UUITreasureHidePanel*                   TreasureHidePanel;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPasswordPanel">();
	}
	static class UUIPasswordPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPasswordPanel>();
	}
};
static_assert(alignof(UUIPasswordPanel) == 0x000010, "Wrong alignment on UUIPasswordPanel");
static_assert(sizeof(UUIPasswordPanel) == 0x0000A0, "Wrong size on UUIPasswordPanel");
static_assert(offsetof(UUIPasswordPanel, TreasureHidePanel) == 0x000030, "Member 'UUIPasswordPanel::TreasureHidePanel' has a wrong offset!");

// Class DarwinGame.UIPlayerSp_Stock
// 0x0118 (0x05A8 - 0x0490)
class UUIPlayerSp_Stock : public UDarwinUserWidget
{
public:
	TMap<int32, class FName>                      StockOnAnimationNames;                             // 0x0490(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<int32, class FName>                      StockOffAnimationNames;                            // 0x04E0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<int32, class FName>                      StockWaitAnimationNames;                           // 0x0530(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                         Pad_580[0x8];                                      // 0x0580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       NowStockAnim;                                      // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       NowWaitAnim;                                       // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x10];                                     // 0x0598(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayAnimEnd();
	void SetSpValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPlayerSp_Stock">();
	}
	static class UUIPlayerSp_Stock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPlayerSp_Stock>();
	}
};
static_assert(alignof(UUIPlayerSp_Stock) == 0x000008, "Wrong alignment on UUIPlayerSp_Stock");
static_assert(sizeof(UUIPlayerSp_Stock) == 0x0005A8, "Wrong size on UUIPlayerSp_Stock");
static_assert(offsetof(UUIPlayerSp_Stock, StockOnAnimationNames) == 0x000490, "Member 'UUIPlayerSp_Stock::StockOnAnimationNames' has a wrong offset!");
static_assert(offsetof(UUIPlayerSp_Stock, StockOffAnimationNames) == 0x0004E0, "Member 'UUIPlayerSp_Stock::StockOffAnimationNames' has a wrong offset!");
static_assert(offsetof(UUIPlayerSp_Stock, StockWaitAnimationNames) == 0x000530, "Member 'UUIPlayerSp_Stock::StockWaitAnimationNames' has a wrong offset!");
static_assert(offsetof(UUIPlayerSp_Stock, NowStockAnim) == 0x000588, "Member 'UUIPlayerSp_Stock::NowStockAnim' has a wrong offset!");
static_assert(offsetof(UUIPlayerSp_Stock, NowWaitAnim) == 0x000590, "Member 'UUIPlayerSp_Stock::NowWaitAnim' has a wrong offset!");

// Class DarwinGame.UIProfile_ItemIcon
// 0x0000 (0x04C8 - 0x04C8)
class UUIProfile_ItemIcon : public UUIArtifact_ItemIcon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProfile_ItemIcon">();
	}
	static class UUIProfile_ItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProfile_ItemIcon>();
	}
};
static_assert(alignof(UUIProfile_ItemIcon) == 0x000008, "Wrong alignment on UUIProfile_ItemIcon");
static_assert(sizeof(UUIProfile_ItemIcon) == 0x0004C8, "Wrong size on UUIProfile_ItemIcon");

// Class DarwinGame.UIProfile_Personal
// 0x0060 (0x0630 - 0x05D0)
class UUIProfile_Personal : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFlagChoice_Panel_01*                 FlagPanel;                                         // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIArtifact_ItemChoice*>         ArtifactIconList;                                  // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIProfile_ItemIcon*                    IconPanel;                                         // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x18];                                     // 0x0600(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MaxTextColor;                                      // 0x0618(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProfile_Personal">();
	}
	static class UUIProfile_Personal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProfile_Personal>();
	}
};
static_assert(alignof(UUIProfile_Personal) == 0x000008, "Wrong alignment on UUIProfile_Personal");
static_assert(sizeof(UUIProfile_Personal) == 0x000630, "Wrong size on UUIProfile_Personal");
static_assert(offsetof(UUIProfile_Personal, FlagPanel) == 0x0005E0, "Member 'UUIProfile_Personal::FlagPanel' has a wrong offset!");
static_assert(offsetof(UUIProfile_Personal, ArtifactIconList) == 0x0005E8, "Member 'UUIProfile_Personal::ArtifactIconList' has a wrong offset!");
static_assert(offsetof(UUIProfile_Personal, IconPanel) == 0x0005F8, "Member 'UUIProfile_Personal::IconPanel' has a wrong offset!");
static_assert(offsetof(UUIProfile_Personal, MaxTextColor) == 0x000618, "Member 'UUIProfile_Personal::MaxTextColor' has a wrong offset!");

// Class DarwinGame.UIProfile_RankBase
// 0x0030 (0x0560 - 0x0530)
class UUIProfile_RankBase : public UUIScrollMenuItemBase
{
public:
	struct FLinearColor                           MaxTextColor;                                      // 0x0530(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FocusAnimation;                                    // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OutFocusAnimation;                                 // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIProfile_ItemIcon*                    ItemIcon;                                          // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProfile_RankBase">();
	}
	static class UUIProfile_RankBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProfile_RankBase>();
	}
};
static_assert(alignof(UUIProfile_RankBase) == 0x000008, "Wrong alignment on UUIProfile_RankBase");
static_assert(sizeof(UUIProfile_RankBase) == 0x000560, "Wrong size on UUIProfile_RankBase");
static_assert(offsetof(UUIProfile_RankBase, MaxTextColor) == 0x000530, "Member 'UUIProfile_RankBase::MaxTextColor' has a wrong offset!");
static_assert(offsetof(UUIProfile_RankBase, FocusAnimation) == 0x000540, "Member 'UUIProfile_RankBase::FocusAnimation' has a wrong offset!");
static_assert(offsetof(UUIProfile_RankBase, OutFocusAnimation) == 0x000548, "Member 'UUIProfile_RankBase::OutFocusAnimation' has a wrong offset!");
static_assert(offsetof(UUIProfile_RankBase, ItemIcon) == 0x000550, "Member 'UUIProfile_RankBase::ItemIcon' has a wrong offset!");

// Class DarwinGame.UIProfile_Top
// 0x0120 (0x06F0 - 0x05D0)
class alignas(0x10) UUIProfile_Top : public UUIScrollMenuBase
{
public:
	class UUIProfile_Treasure*                    TreasureMenu;                                      // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIProfile_Personal*                    PersonalMenu;                                      // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UnderButton;                                       // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIProfile_TopBar*                      Topbar;                                            // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 ImgFlagIcon;                                       // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0xF8];                                     // 0x05F8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProfile_Top">();
	}
	static class UUIProfile_Top* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProfile_Top>();
	}
};
static_assert(alignof(UUIProfile_Top) == 0x000010, "Wrong alignment on UUIProfile_Top");
static_assert(sizeof(UUIProfile_Top) == 0x0006F0, "Wrong size on UUIProfile_Top");
static_assert(offsetof(UUIProfile_Top, TreasureMenu) == 0x0005D0, "Member 'UUIProfile_Top::TreasureMenu' has a wrong offset!");
static_assert(offsetof(UUIProfile_Top, PersonalMenu) == 0x0005D8, "Member 'UUIProfile_Top::PersonalMenu' has a wrong offset!");
static_assert(offsetof(UUIProfile_Top, UnderButton) == 0x0005E0, "Member 'UUIProfile_Top::UnderButton' has a wrong offset!");
static_assert(offsetof(UUIProfile_Top, Topbar) == 0x0005E8, "Member 'UUIProfile_Top::Topbar' has a wrong offset!");
static_assert(offsetof(UUIProfile_Top, ImgFlagIcon) == 0x0005F0, "Member 'UUIProfile_Top::ImgFlagIcon' has a wrong offset!");

// Class DarwinGame.UIQM_Panel_01
// 0x0000 (0x05A0 - 0x05A0)
class UUIQM_Panel_01 : public UUIQM_PanelQuestName
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_01">();
	}
	static class UUIQM_Panel_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_01>();
	}
};
static_assert(alignof(UUIQM_Panel_01) == 0x000008, "Wrong alignment on UUIQM_Panel_01");
static_assert(sizeof(UUIQM_Panel_01) == 0x0005A0, "Wrong size on UUIQM_Panel_01");

// Class DarwinGame.UIQM_Panel_QuestInfoBase
// 0x0060 (0x04F0 - 0x0490)
class UUIQM_Panel_QuestInfoBase : public UDarwinUserWidget
{
public:
	class UWidget*                                BasePanel;                                         // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EQuestRank, class UTexture2D*>           RankTexture;                                       // 0x0498(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 rankIcon;                                          // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_QuestInfoBase">();
	}
	static class UUIQM_Panel_QuestInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_QuestInfoBase>();
	}
};
static_assert(alignof(UUIQM_Panel_QuestInfoBase) == 0x000008, "Wrong alignment on UUIQM_Panel_QuestInfoBase");
static_assert(sizeof(UUIQM_Panel_QuestInfoBase) == 0x0004F0, "Wrong size on UUIQM_Panel_QuestInfoBase");
static_assert(offsetof(UUIQM_Panel_QuestInfoBase, BasePanel) == 0x000490, "Member 'UUIQM_Panel_QuestInfoBase::BasePanel' has a wrong offset!");
static_assert(offsetof(UUIQM_Panel_QuestInfoBase, RankTexture) == 0x000498, "Member 'UUIQM_Panel_QuestInfoBase::RankTexture' has a wrong offset!");
static_assert(offsetof(UUIQM_Panel_QuestInfoBase, rankIcon) == 0x0004E8, "Member 'UUIQM_Panel_QuestInfoBase::rankIcon' has a wrong offset!");

// Class DarwinGame.UIQM_Panel_03
// 0x0000 (0x04F0 - 0x04F0)
class UUIQM_Panel_03 : public UUIQM_Panel_QuestInfoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_03">();
	}
	static class UUIQM_Panel_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_03>();
	}
};
static_assert(alignof(UUIQM_Panel_03) == 0x000008, "Wrong alignment on UUIQM_Panel_03");
static_assert(sizeof(UUIQM_Panel_03) == 0x0004F0, "Wrong size on UUIQM_Panel_03");

// Class DarwinGame.UIQM_Panel_08
// 0x0000 (0x04F0 - 0x04F0)
class UUIQM_Panel_08 : public UUIQM_Panel_QuestInfoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQM_Panel_08">();
	}
	static class UUIQM_Panel_08* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQM_Panel_08>();
	}
};
static_assert(alignof(UUIQM_Panel_08) == 0x000008, "Wrong alignment on UUIQM_Panel_08");
static_assert(sizeof(UUIQM_Panel_08) == 0x0004F0, "Wrong size on UUIQM_Panel_08");

// Class DarwinGame.UIQMR_Page_BtmBase
// 0x0010 (0x05E0 - 0x05D0)
class UUIQMR_Page_BtmBase : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQMR_Page_BtmBase">();
	}
	static class UUIQMR_Page_BtmBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQMR_Page_BtmBase>();
	}
};
static_assert(alignof(UUIQMR_Page_BtmBase) == 0x000008, "Wrong alignment on UUIQMR_Page_BtmBase");
static_assert(sizeof(UUIQMR_Page_BtmBase) == 0x0005E0, "Wrong size on UUIQMR_Page_BtmBase");

// Class DarwinGame.UIQMR_Page_Btm_01
// 0x0000 (0x05E0 - 0x05E0)
class UUIQMR_Page_Btm_01 : public UUIQMR_Page_BtmBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQMR_Page_Btm_01">();
	}
	static class UUIQMR_Page_Btm_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQMR_Page_Btm_01>();
	}
};
static_assert(alignof(UUIQMR_Page_Btm_01) == 0x000008, "Wrong alignment on UUIQMR_Page_Btm_01");
static_assert(sizeof(UUIQMR_Page_Btm_01) == 0x0005E0, "Wrong size on UUIQMR_Page_Btm_01");

// Class DarwinGame.UIQMR_Page_Btm_02
// 0x0048 (0x0628 - 0x05E0)
class UUIQMR_Page_Btm_02 : public UUIQMR_Page_BtmBase
{
public:
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIQM_Panel_00*                         MainQuestPanel;                                    // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIQM_Panel_01*>                 SubQuestPanel;                                     // 0x05F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x20];                                     // 0x0608(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQMR_Page_Btm_02">();
	}
	static class UUIQMR_Page_Btm_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQMR_Page_Btm_02>();
	}
};
static_assert(alignof(UUIQMR_Page_Btm_02) == 0x000008, "Wrong alignment on UUIQMR_Page_Btm_02");
static_assert(sizeof(UUIQMR_Page_Btm_02) == 0x000628, "Wrong size on UUIQMR_Page_Btm_02");
static_assert(offsetof(UUIQMR_Page_Btm_02, MainQuestPanel) == 0x0005F0, "Member 'UUIQMR_Page_Btm_02::MainQuestPanel' has a wrong offset!");
static_assert(offsetof(UUIQMR_Page_Btm_02, SubQuestPanel) == 0x0005F8, "Member 'UUIQMR_Page_Btm_02::SubQuestPanel' has a wrong offset!");

// Class DarwinGame.UIQualityUp
// 0x0000 (0x0490 - 0x0490)
class UUIQualityUp final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQualityUp">();
	}
	static class UUIQualityUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQualityUp>();
	}
};
static_assert(alignof(UUIQualityUp) == 0x000008, "Wrong alignment on UUIQualityUp");
static_assert(sizeof(UUIQualityUp) == 0x000490, "Wrong size on UUIQualityUp");

// Class DarwinGame.UIQuest_WinDialog_Text
// 0x0020 (0x0510 - 0x04F0)
class UUIQuest_WinDialog_Text : public UUIFreeScrollBase
{
public:
	TArray<class UUIQM_Panel_07*>                 ProgressPanels;                                    // 0x04F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIQM_Panel_08*>                 InfoPanels;                                        // 0x0500(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuest_WinDialog_Text">();
	}
	static class UUIQuest_WinDialog_Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuest_WinDialog_Text>();
	}
};
static_assert(alignof(UUIQuest_WinDialog_Text) == 0x000008, "Wrong alignment on UUIQuest_WinDialog_Text");
static_assert(sizeof(UUIQuest_WinDialog_Text) == 0x000510, "Wrong size on UUIQuest_WinDialog_Text");
static_assert(offsetof(UUIQuest_WinDialog_Text, ProgressPanels) == 0x0004F0, "Member 'UUIQuest_WinDialog_Text::ProgressPanels' has a wrong offset!");
static_assert(offsetof(UUIQuest_WinDialog_Text, InfoPanels) == 0x000500, "Member 'UUIQuest_WinDialog_Text::InfoPanels' has a wrong offset!");

// Class DarwinGame.UIQuestFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIQuestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DebugClearQuest(class FName QuestID);
	static void DebugOpenQuest(class FName QuestID);
	static void DebugOrderQuest(class FName QuestID);
	static bool HasClearedQuest(class FName QuestID);
	static bool HasOpenedQuest(class FName QuestID);
	static bool HasOrderQuest(class FName QuestID);
	static bool IsOfficialNetworkQuest(class FName QuestID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestFunctionLibrary">();
	}
	static class UUIQuestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestFunctionLibrary>();
	}
};
static_assert(alignof(UUIQuestFunctionLibrary) == 0x000008, "Wrong alignment on UUIQuestFunctionLibrary");
static_assert(sizeof(UUIQuestFunctionLibrary) == 0x000030, "Wrong size on UUIQuestFunctionLibrary");

// Class DarwinGame.UIQuestMenu
// 0x0088 (0x0558 - 0x04D0)
class UUIQuestMenu : public UUILeftMenuUseBase
{
public:
	TArray<struct FST_QuestMenuCategory>          QuestMenuCategoryList;                             // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x30];                                     // 0x04E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIQMR_Page_Btm_01*                     Btm_01;                                            // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIQMR_Page_Btm_02*                     Btm_02;                                            // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIQMR_Page_02*                         Page02;                                            // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIQMR_Page_03*                         Page03;                                            // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITopbar_00*                           Topbar;                                            // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x20];                                     // 0x0538(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChildQuestChangeFocusCallback();
	void MainQuestChangeFocusCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestMenu">();
	}
	static class UUIQuestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestMenu>();
	}
};
static_assert(alignof(UUIQuestMenu) == 0x000008, "Wrong alignment on UUIQuestMenu");
static_assert(sizeof(UUIQuestMenu) == 0x000558, "Wrong size on UUIQuestMenu");
static_assert(offsetof(UUIQuestMenu, QuestMenuCategoryList) == 0x0004D0, "Member 'UUIQuestMenu::QuestMenuCategoryList' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, Btm_01) == 0x000510, "Member 'UUIQuestMenu::Btm_01' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, Btm_02) == 0x000518, "Member 'UUIQuestMenu::Btm_02' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, Page02) == 0x000520, "Member 'UUIQuestMenu::Page02' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, Page03) == 0x000528, "Member 'UUIQuestMenu::Page03' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, Topbar) == 0x000530, "Member 'UUIQuestMenu::Topbar' has a wrong offset!");

// Class DarwinGame.UIQuestMenu_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUIQuestMenu_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestMenu_Root">();
	}
	static class UUIQuestMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestMenu_Root>();
	}
};
static_assert(alignof(UUIQuestMenu_Root) == 0x000008, "Wrong alignment on UUIQuestMenu_Root");
static_assert(sizeof(UUIQuestMenu_Root) == 0x0004D8, "Wrong size on UUIQuestMenu_Root");

// Class DarwinGame.UIQuestOverviewDictDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIQuestOverviewDictDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestOverviewDictDataTable">();
	}
	static class UUIQuestOverviewDictDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestOverviewDictDataTable>();
	}
};
static_assert(alignof(UUIQuestOverviewDictDataTable) == 0x000008, "Wrong alignment on UUIQuestOverviewDictDataTable");
static_assert(sizeof(UUIQuestOverviewDictDataTable) == 0x000030, "Wrong size on UUIQuestOverviewDictDataTable");

// Class DarwinGame.UIQuestOverviewDictMenu
// 0x0050 (0x0520 - 0x04D0)
class UUIQuestOverviewDictMenu : public UUILeftMenuUseBase
{
public:
	uint8                                         Pad_4D0[0x50];                                     // 0x04D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestOverviewDictMenu">();
	}
	static class UUIQuestOverviewDictMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestOverviewDictMenu>();
	}
};
static_assert(alignof(UUIQuestOverviewDictMenu) == 0x000008, "Wrong alignment on UUIQuestOverviewDictMenu");
static_assert(sizeof(UUIQuestOverviewDictMenu) == 0x000520, "Wrong size on UUIQuestOverviewDictMenu");

// Class DarwinGame.UIResistanceDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIResistanceDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIResistanceDataTable">();
	}
	static class UUIResistanceDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIResistanceDataTable>();
	}
};
static_assert(alignof(UUIResistanceDataTable) == 0x000008, "Wrong alignment on UUIResistanceDataTable");
static_assert(sizeof(UUIResistanceDataTable) == 0x000030, "Wrong size on UUIResistanceDataTable");

// Class DarwinGame.UIReward_CoinSet
// 0x0000 (0x0490 - 0x0490)
class UUIReward_CoinSet final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIReward_CoinSet">();
	}
	static class UUIReward_CoinSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIReward_CoinSet>();
	}
};
static_assert(alignof(UUIReward_CoinSet) == 0x000008, "Wrong alignment on UUIReward_CoinSet");
static_assert(sizeof(UUIReward_CoinSet) == 0x000490, "Wrong size on UUIReward_CoinSet");

// Class DarwinGame.UIReward_ItemChoice
// 0x0008 (0x0550 - 0x0548)
class UUIReward_ItemChoice final : public UUICommonmenu_ItemChoiceBase
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIReward_ItemChoice">();
	}
	static class UUIReward_ItemChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIReward_ItemChoice>();
	}
};
static_assert(alignof(UUIReward_ItemChoice) == 0x000008, "Wrong alignment on UUIReward_ItemChoice");
static_assert(sizeof(UUIReward_ItemChoice) == 0x000550, "Wrong size on UUIReward_ItemChoice");

// Class DarwinGame.UIReward_ItemIcon
// 0x0060 (0x0518 - 0x04B8)
class UUIReward_ItemIcon final : public UUICommonmenu_ItemIconBase
{
public:
	class UImage*                                 ImgMonsterItem;                                    // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x58];                                     // 0x04C0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIReward_ItemIcon">();
	}
	static class UUIReward_ItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIReward_ItemIcon>();
	}
};
static_assert(alignof(UUIReward_ItemIcon) == 0x000008, "Wrong alignment on UUIReward_ItemIcon");
static_assert(sizeof(UUIReward_ItemIcon) == 0x000518, "Wrong size on UUIReward_ItemIcon");
static_assert(offsetof(UUIReward_ItemIcon, ImgMonsterItem) == 0x0004B8, "Member 'UUIReward_ItemIcon::ImgMonsterItem' has a wrong offset!");

// Class DarwinGame.UIRewardWin_00
// 0x01F8 (0x07F0 - 0x05F8)
class UUIRewardWin_00 : public UUIRewardItemListBase
{
public:
	uint8                                         Pad_5F8[0x20];                                     // 0x05F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNotScrollBar;                                     // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0x1AF];                                    // 0x0619(0x01AF)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBoardmenu_MonsterIconChoice*         MonsterBoard;                                      // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D0[0x8];                                      // 0x07D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       OutAnim;                                           // 0x07D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DecideKey;                                         // 0x07E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E8[0x8];                                      // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenItem();
	void OpenSentence();
	void OpenWindow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardWin_00">();
	}
	static class UUIRewardWin_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardWin_00>();
	}
};
static_assert(alignof(UUIRewardWin_00) == 0x000008, "Wrong alignment on UUIRewardWin_00");
static_assert(sizeof(UUIRewardWin_00) == 0x0007F0, "Wrong size on UUIRewardWin_00");
static_assert(offsetof(UUIRewardWin_00, bNotScrollBar) == 0x000618, "Member 'UUIRewardWin_00::bNotScrollBar' has a wrong offset!");
static_assert(offsetof(UUIRewardWin_00, MonsterBoard) == 0x0007C8, "Member 'UUIRewardWin_00::MonsterBoard' has a wrong offset!");
static_assert(offsetof(UUIRewardWin_00, OutAnim) == 0x0007D8, "Member 'UUIRewardWin_00::OutAnim' has a wrong offset!");
static_assert(offsetof(UUIRewardWin_00, DecideKey) == 0x0007E0, "Member 'UUIRewardWin_00::DecideKey' has a wrong offset!");

// Class DarwinGame.UIRewardWin_02
// 0x0000 (0x07F0 - 0x07F0)
class UUIRewardWin_02 final : public UUIRewardWin_00
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardWin_02">();
	}
	static class UUIRewardWin_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardWin_02>();
	}
};
static_assert(alignof(UUIRewardWin_02) == 0x000008, "Wrong alignment on UUIRewardWin_02");
static_assert(sizeof(UUIRewardWin_02) == 0x0007F0, "Wrong size on UUIRewardWin_02");

// Class DarwinGame.UIRewardWin_02_Root
// 0x0128 (0x05F8 - 0x04D0)
class UUIRewardWin_02_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x128];                                    // 0x04D0(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRewardWin_02_Root">();
	}
	static class UUIRewardWin_02_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRewardWin_02_Root>();
	}
};
static_assert(alignof(UUIRewardWin_02_Root) == 0x000008, "Wrong alignment on UUIRewardWin_02_Root");
static_assert(sizeof(UUIRewardWin_02_Root) == 0x0005F8, "Wrong size on UUIRewardWin_02_Root");

// Class DarwinGame.UIRivalCautionFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIRivalCautionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRivalCautionFunctionLibrary">();
	}
	static class UUIRivalCautionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRivalCautionFunctionLibrary>();
	}
};
static_assert(alignof(UUIRivalCautionFunctionLibrary) == 0x000008, "Wrong alignment on UUIRivalCautionFunctionLibrary");
static_assert(sizeof(UUIRivalCautionFunctionLibrary) == 0x000030, "Wrong size on UUIRivalCautionFunctionLibrary");

// Class DarwinGame.UIRival_01
// 0x0000 (0x0538 - 0x0538)
class UUIRival_01 : public UUIRivalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRival_01">();
	}
	static class UUIRival_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRival_01>();
	}
};
static_assert(alignof(UUIRival_01) == 0x000008, "Wrong alignment on UUIRival_01");
static_assert(sizeof(UUIRival_01) == 0x000538, "Wrong size on UUIRival_01");

// Class DarwinGame.UISaveContent
// 0x0118 (0x06F0 - 0x05D8)
class UUISaveContent : public UUISaveLoadContentBase
{
public:
	float                                         SaveDialogDispMinTime;                             // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_SaveLoadContentData                SaveData;                                          // 0x05E0(0x00C0)(NativeAccessSpecifierPrivate)
	class UImage*                                 CaptureImage;                                      // 0x06A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      SaveArrowWidget;                                   // 0x06A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       ArrowWaitAnim;                                     // 0x06B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       WaitAnim;                                          // 0x06C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0x8];                                      // 0x06C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUISaveFacePanel*>               SaveFacePanelList;                                 // 0x06D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIWinMenu_S_03*                        SavingDialog;                                      // 0x06E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenSaveEndCallback();
	void SaveDialogCallback(bool IsYes);
	void SaveEndCallback();
	void SaveEndDialogCallback(bool IsYes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveContent">();
	}
	static class UUISaveContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveContent>();
	}
};
static_assert(alignof(UUISaveContent) == 0x000008, "Wrong alignment on UUISaveContent");
static_assert(sizeof(UUISaveContent) == 0x0006F0, "Wrong size on UUISaveContent");
static_assert(offsetof(UUISaveContent, SaveDialogDispMinTime) == 0x0005D8, "Member 'UUISaveContent::SaveDialogDispMinTime' has a wrong offset!");
static_assert(offsetof(UUISaveContent, SaveData) == 0x0005E0, "Member 'UUISaveContent::SaveData' has a wrong offset!");
static_assert(offsetof(UUISaveContent, CaptureImage) == 0x0006A0, "Member 'UUISaveContent::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUISaveContent, SaveArrowWidget) == 0x0006A8, "Member 'UUISaveContent::SaveArrowWidget' has a wrong offset!");
static_assert(offsetof(UUISaveContent, ArrowWaitAnim) == 0x0006B0, "Member 'UUISaveContent::ArrowWaitAnim' has a wrong offset!");
static_assert(offsetof(UUISaveContent, WaitAnim) == 0x0006C0, "Member 'UUISaveContent::WaitAnim' has a wrong offset!");
static_assert(offsetof(UUISaveContent, SaveFacePanelList) == 0x0006D0, "Member 'UUISaveContent::SaveFacePanelList' has a wrong offset!");
static_assert(offsetof(UUISaveContent, SavingDialog) == 0x0006E0, "Member 'UUISaveContent::SavingDialog' has a wrong offset!");

// Class DarwinGame.UISaveFacePanel
// 0x0000 (0x0548 - 0x0548)
class UUISaveFacePanel : public UUISaveLoadFacePanelBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveFacePanel">();
	}
	static class UUISaveFacePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveFacePanel>();
	}
};
static_assert(alignof(UUISaveFacePanel) == 0x000008, "Wrong alignment on UUISaveFacePanel");
static_assert(sizeof(UUISaveFacePanel) == 0x000548, "Wrong size on UUISaveFacePanel");

// Class DarwinGame.UISaveIcon
// 0x0000 (0x0490 - 0x0490)
class UUISaveIcon : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveIcon">();
	}
	static class UUISaveIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveIcon>();
	}
};
static_assert(alignof(UUISaveIcon) == 0x000008, "Wrong alignment on UUISaveIcon");
static_assert(sizeof(UUISaveIcon) == 0x000490, "Wrong size on UUISaveIcon");

// Class DarwinGame.UISettingMenuFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUISettingMenuFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISettingMenuFunctionLibrary">();
	}
	static class UUISettingMenuFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISettingMenuFunctionLibrary>();
	}
};
static_assert(alignof(UUISettingMenuFunctionLibrary) == 0x000008, "Wrong alignment on UUISettingMenuFunctionLibrary");
static_assert(sizeof(UUISettingMenuFunctionLibrary) == 0x000030, "Wrong size on UUISettingMenuFunctionLibrary");

// Class DarwinGame.UIShot_IconBullet
// 0x0068 (0x0598 - 0x0530)
class UUIShot_IconBullet : public UUIScrollMenuItemBase
{
public:
	class UWidgetAnimation*                       OnAnimation;                                       // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       SelectModeAnimAnimation;                           // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OffGroupAnimation;                                 // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OffCategoryAnimation;                              // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base01Image;                                       // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base02Image;                                       // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Base03Image;                                       // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NumberText;                                        // 0x0570(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMaterialParameterInfo                 ImageMaterialTextureParam;                         // 0x0578(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x10];                                     // 0x0588(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clip(float InX, float InY);
	void SetData(const class FName& InItemId);
	void SetIsCategory(bool bInIsCategory);
	void UpdateData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShot_IconBullet">();
	}
	static class UUIShot_IconBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShot_IconBullet>();
	}
};
static_assert(alignof(UUIShot_IconBullet) == 0x000008, "Wrong alignment on UUIShot_IconBullet");
static_assert(sizeof(UUIShot_IconBullet) == 0x000598, "Wrong size on UUIShot_IconBullet");
static_assert(offsetof(UUIShot_IconBullet, OnAnimation) == 0x000530, "Member 'UUIShot_IconBullet::OnAnimation' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, SelectModeAnimAnimation) == 0x000538, "Member 'UUIShot_IconBullet::SelectModeAnimAnimation' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, OffGroupAnimation) == 0x000540, "Member 'UUIShot_IconBullet::OffGroupAnimation' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, OffCategoryAnimation) == 0x000548, "Member 'UUIShot_IconBullet::OffCategoryAnimation' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, Base01Image) == 0x000550, "Member 'UUIShot_IconBullet::Base01Image' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, Base02Image) == 0x000558, "Member 'UUIShot_IconBullet::Base02Image' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, Base03Image) == 0x000560, "Member 'UUIShot_IconBullet::Base03Image' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, ItemImage) == 0x000568, "Member 'UUIShot_IconBullet::ItemImage' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, NumberText) == 0x000570, "Member 'UUIShot_IconBullet::NumberText' has a wrong offset!");
static_assert(offsetof(UUIShot_IconBullet, ImageMaterialTextureParam) == 0x000578, "Member 'UUIShot_IconBullet::ImageMaterialTextureParam' has a wrong offset!");

// Class DarwinGame.UIShot_MonsterName
// 0x0018 (0x04A8 - 0x0490)
class UUIShot_MonsterName : public UDarwinUserWidget
{
public:
	class UTextBlock*                             NameText;                                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         NameBox;                                           // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NameBase;                                          // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShot_MonsterName">();
	}
	static class UUIShot_MonsterName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShot_MonsterName>();
	}
};
static_assert(alignof(UUIShot_MonsterName) == 0x000008, "Wrong alignment on UUIShot_MonsterName");
static_assert(sizeof(UUIShot_MonsterName) == 0x0004A8, "Wrong size on UUIShot_MonsterName");
static_assert(offsetof(UUIShot_MonsterName, NameText) == 0x000490, "Member 'UUIShot_MonsterName::NameText' has a wrong offset!");
static_assert(offsetof(UUIShot_MonsterName, NameBox) == 0x000498, "Member 'UUIShot_MonsterName::NameBox' has a wrong offset!");
static_assert(offsetof(UUIShot_MonsterName, NameBase) == 0x0004A0, "Member 'UUIShot_MonsterName::NameBase' has a wrong offset!");

// Class DarwinGame.UISign_BoxCursor
// 0x0080 (0x0510 - 0x0490)
class UUISign_BoxCursor final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x80];                                     // 0x0490(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCursorTargetAnim();
	void EndCursorUnTargetAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_BoxCursor">();
	}
	static class UUISign_BoxCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_BoxCursor>();
	}
};
static_assert(alignof(UUISign_BoxCursor) == 0x000008, "Wrong alignment on UUISign_BoxCursor");
static_assert(sizeof(UUISign_BoxCursor) == 0x000510, "Wrong size on UUISign_BoxCursor");

// Class DarwinGame.UISign_Icon
// 0x0148 (0x05F0 - 0x04A8)
class alignas(0x10) UUISign_Icon final : public UUIMap_SymbolBase
{
public:
	TMap<EMapSignColorType, class UTexture2D*>    ImageOneList;                                      // 0x04A8(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TMap<EMapSignColorType, class UTexture2D*>    ImageTwoList;                                      // 0x04F8(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TMap<EMapSignColorType, class UTexture2D*>    ImageThreeList;                                    // 0x0548(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	EMapSignColorType                             ColorType;                                         // 0x0598(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_599[0x57];                                     // 0x0599(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_Icon">();
	}
	static class UUISign_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_Icon>();
	}
};
static_assert(alignof(UUISign_Icon) == 0x000010, "Wrong alignment on UUISign_Icon");
static_assert(sizeof(UUISign_Icon) == 0x0005F0, "Wrong size on UUISign_Icon");
static_assert(offsetof(UUISign_Icon, ImageOneList) == 0x0004A8, "Member 'UUISign_Icon::ImageOneList' has a wrong offset!");
static_assert(offsetof(UUISign_Icon, ImageTwoList) == 0x0004F8, "Member 'UUISign_Icon::ImageTwoList' has a wrong offset!");
static_assert(offsetof(UUISign_Icon, ImageThreeList) == 0x000548, "Member 'UUISign_Icon::ImageThreeList' has a wrong offset!");
static_assert(offsetof(UUISign_Icon, ColorType) == 0x000598, "Member 'UUISign_Icon::ColorType' has a wrong offset!");

// Class DarwinGame.UISign_IconAll
// 0x0050 (0x04E0 - 0x0490)
class UUISign_IconAll final : public UDarwinUserWidget
{
public:
	TMap<EMapSignColorType, class UUISign_Icon*>  SignIconList;                                      // 0x0490(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconAll">();
	}
	static class UUISign_IconAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconAll>();
	}
};
static_assert(alignof(UUISign_IconAll) == 0x000008, "Wrong alignment on UUISign_IconAll");
static_assert(sizeof(UUISign_IconAll) == 0x0004E0, "Wrong size on UUISign_IconAll");
static_assert(offsetof(UUISign_IconAll, SignIconList) == 0x000490, "Member 'UUISign_IconAll::SignIconList' has a wrong offset!");

// Class DarwinGame.UISign_IconArea01
// 0x0000 (0x0498 - 0x0498)
class UUISign_IconArea01 final : public UUISign_IconAreaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconArea01">();
	}
	static class UUISign_IconArea01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconArea01>();
	}
};
static_assert(alignof(UUISign_IconArea01) == 0x000008, "Wrong alignment on UUISign_IconArea01");
static_assert(sizeof(UUISign_IconArea01) == 0x000498, "Wrong size on UUISign_IconArea01");

// Class DarwinGame.UISign_IconDamageBase
// 0x0060 (0x0610 - 0x05B0)
class UUISign_IconDamageBase : public UUI3DBase
{
public:
	class UTexture2D*                             FriendDamageFrame;                                 // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EnemyDamageFrame;                                  // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDamageSizeType, class UObject*>         DamageTextTextures;                                // 0x05B8(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAnimExec();
	void SetBelongType(const struct FGameplayTag& Belong);
	void SetDamageValue(float Value);
	void SetData(float Value, const struct FGameplayTag& Belong, EDamageSizeType SizeType);
	void SetSizeType(EDamageSizeType SizeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconDamageBase">();
	}
	static class UUISign_IconDamageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconDamageBase>();
	}
};
static_assert(alignof(UUISign_IconDamageBase) == 0x000010, "Wrong alignment on UUISign_IconDamageBase");
static_assert(sizeof(UUISign_IconDamageBase) == 0x000610, "Wrong size on UUISign_IconDamageBase");
static_assert(offsetof(UUISign_IconDamageBase, FriendDamageFrame) == 0x0005A8, "Member 'UUISign_IconDamageBase::FriendDamageFrame' has a wrong offset!");
static_assert(offsetof(UUISign_IconDamageBase, EnemyDamageFrame) == 0x0005B0, "Member 'UUISign_IconDamageBase::EnemyDamageFrame' has a wrong offset!");
static_assert(offsetof(UUISign_IconDamageBase, DamageTextTextures) == 0x0005B8, "Member 'UUISign_IconDamageBase::DamageTextTextures' has a wrong offset!");

// Class DarwinGame.UISign_IconExp
// 0x0000 (0x05B0 - 0x05B0)
class UUISign_IconExp : public UUI3DBase
{
public:
	void SetExpValue(int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconExp">();
	}
	static class UUISign_IconExp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconExp>();
	}
};
static_assert(alignof(UUISign_IconExp) == 0x000010, "Wrong alignment on UUISign_IconExp");
static_assert(sizeof(UUISign_IconExp) == 0x0005B0, "Wrong size on UUISign_IconExp");

// Class DarwinGame.UISign_IconHeal
// 0x00A0 (0x0650 - 0x05B0)
class UUISign_IconHeal : public UUI3DBase
{
public:
	TMap<EUIHealPopType, class UTexture2D*>       HealTexture;                                       // 0x05A8(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<EUIHealPopType, class UObject*>          HealTextMaterial;                                  // 0x05F8(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(float Value, const struct FVector& TargetLocation, EUIHealPopType HealPopType);
	void SetHealPopType(EUIHealPopType HealPopType);
	void SetHealValue(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconHeal">();
	}
	static class UUISign_IconHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconHeal>();
	}
};
static_assert(alignof(UUISign_IconHeal) == 0x000010, "Wrong alignment on UUISign_IconHeal");
static_assert(sizeof(UUISign_IconHeal) == 0x000650, "Wrong size on UUISign_IconHeal");
static_assert(offsetof(UUISign_IconHeal, HealTexture) == 0x0005A8, "Member 'UUISign_IconHeal::HealTexture' has a wrong offset!");
static_assert(offsetof(UUISign_IconHeal, HealTextMaterial) == 0x0005F8, "Member 'UUISign_IconHeal::HealTextMaterial' has a wrong offset!");

// Class DarwinGame.UISign_IconItemname
// 0x0000 (0x05B0 - 0x05B0)
class UUISign_IconItemname : public UUI3DBase
{
public:
	void SetItem(class FName ID, EItemDataType NewParam);
	void SetNameFromCoinParam(const struct FST_CoinParam& CoinParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconItemname">();
	}
	static class UUISign_IconItemname* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconItemname>();
	}
};
static_assert(alignof(UUISign_IconItemname) == 0x000010, "Wrong alignment on UUISign_IconItemname");
static_assert(sizeof(UUISign_IconItemname) == 0x0005B0, "Wrong size on UUISign_IconItemname");

// Class DarwinGame.UISign_IconLvup
// 0x0010 (0x05C0 - 0x05B0)
class UUISign_IconLvup : public UUI3DBase
{
public:
	TMulticastInlineDelegate<void()>              EndAnim;                                           // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayLvupAnim();
	void PlayOneShotLvUp();
	void SetData(bool IsComboUp);
	void SetIsStatusIcon(bool IsIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconLvup">();
	}
	static class UUISign_IconLvup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconLvup>();
	}
};
static_assert(alignof(UUISign_IconLvup) == 0x000010, "Wrong alignment on UUISign_IconLvup");
static_assert(sizeof(UUISign_IconLvup) == 0x0005C0, "Wrong size on UUISign_IconLvup");
static_assert(offsetof(UUISign_IconLvup, EndAnim) == 0x0005A8, "Member 'UUISign_IconLvup::EndAnim' has a wrong offset!");

// Class DarwinGame.UISign_IconQuest
// 0x0000 (0x05B0 - 0x05B0)
class UUISign_IconQuest : public UUI3DBase
{
public:
	class UDataTable*                             BalloonDataTable;                                  // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetBalloonData(class FName QuestID);
	void SetBalloonType(EBalloonIconType Type);
	void SetLayer(bool IsAnother);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconQuest">();
	}
	static class UUISign_IconQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconQuest>();
	}
};
static_assert(alignof(UUISign_IconQuest) == 0x000010, "Wrong alignment on UUISign_IconQuest");
static_assert(sizeof(UUISign_IconQuest) == 0x0005B0, "Wrong size on UUISign_IconQuest");
static_assert(offsetof(UUISign_IconQuest, BalloonDataTable) == 0x0005A8, "Member 'UUISign_IconQuest::BalloonDataTable' has a wrong offset!");

// Class DarwinGame.UISign_IconRival
// 0x0000 (0x05B0 - 0x05B0)
class UUISign_IconRival : public UUI3DBase
{
public:
	class UAtomComponent*                         mLoopSe;                                           // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_IconRival">();
	}
	static class UUISign_IconRival* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_IconRival>();
	}
};
static_assert(alignof(UUISign_IconRival) == 0x000010, "Wrong alignment on UUISign_IconRival");
static_assert(sizeof(UUISign_IconRival) == 0x0005B0, "Wrong size on UUISign_IconRival");
static_assert(offsetof(UUISign_IconRival, mLoopSe) == 0x0005A8, "Member 'UUISign_IconRival::mLoopSe' has a wrong offset!");

// Class DarwinGame.UISign_Log
// 0x0008 (0x0498 - 0x0490)
class UUISign_Log final : public UDarwinUserWidget
{
public:
	float                                         LogDrawTime;                                       // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISign_Log">();
	}
	static class UUISign_Log* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISign_Log>();
	}
};
static_assert(alignof(UUISign_Log) == 0x000008, "Wrong alignment on UUISign_Log");
static_assert(sizeof(UUISign_Log) == 0x000498, "Wrong size on UUISign_Log");
static_assert(offsetof(UUISign_Log, LogDrawTime) == 0x000490, "Member 'UUISign_Log::LogDrawTime' has a wrong offset!");

// Class DarwinGame.UISkillName
// 0x0050 (0x0600 - 0x05B0)
class UUISkillName : public UUI3DBase
{
public:
	class UDataTable*                             SkillNameDataTable;                                // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BalloonImage;                                      // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       ImageSlot;                                         // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             SkillText;                                         // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidget*                                ContentsBox;                                       // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x30];                                     // 0x05D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSkillNameData(class FName OverviewID, float InCloseTime, bool IsFriend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISkillName">();
	}
	static class UUISkillName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISkillName>();
	}
};
static_assert(alignof(UUISkillName) == 0x000010, "Wrong alignment on UUISkillName");
static_assert(sizeof(UUISkillName) == 0x000600, "Wrong size on UUISkillName");
static_assert(offsetof(UUISkillName, SkillNameDataTable) == 0x0005A8, "Member 'UUISkillName::SkillNameDataTable' has a wrong offset!");
static_assert(offsetof(UUISkillName, BalloonImage) == 0x0005B0, "Member 'UUISkillName::BalloonImage' has a wrong offset!");
static_assert(offsetof(UUISkillName, ImageSlot) == 0x0005B8, "Member 'UUISkillName::ImageSlot' has a wrong offset!");
static_assert(offsetof(UUISkillName, SkillText) == 0x0005C0, "Member 'UUISkillName::SkillText' has a wrong offset!");
static_assert(offsetof(UUISkillName, ContentsBox) == 0x0005C8, "Member 'UUISkillName::ContentsBox' has a wrong offset!");

// Class DarwinGame.UISkillPop_00
// 0x0030 (0x04C0 - 0x0490)
class UUISkillPop_00 : public UDarwinUserWidget
{
public:
	TArray<class UUISkillPop_Count_00*>           NumberArray;                                       // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUISkillPop_Count_00_Add*>       NumberAddArray;                                    // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      NumberTextureList;                                 // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISkillPop_00">();
	}
	static class UUISkillPop_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISkillPop_00>();
	}
};
static_assert(alignof(UUISkillPop_00) == 0x000008, "Wrong alignment on UUISkillPop_00");
static_assert(sizeof(UUISkillPop_00) == 0x0004C0, "Wrong size on UUISkillPop_00");
static_assert(offsetof(UUISkillPop_00, NumberArray) == 0x000490, "Member 'UUISkillPop_00::NumberArray' has a wrong offset!");
static_assert(offsetof(UUISkillPop_00, NumberAddArray) == 0x0004A0, "Member 'UUISkillPop_00::NumberAddArray' has a wrong offset!");
static_assert(offsetof(UUISkillPop_00, NumberTextureList) == 0x0004B0, "Member 'UUISkillPop_00::NumberTextureList' has a wrong offset!");

// Class DarwinGame.UISpirit_Gauge
// 0x0070 (0x0620 - 0x05B0)
class UUISpirit_Gauge : public UUI3DBase
{
public:
	uint8                                         Pad_5A8[0x30];                                     // 0x05A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     TextureList;                                       // 0x05D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DefaultFaceTexture;                                // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GaugeMoveRate;                                     // 0x05F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F4[0x2C];                                     // 0x05F4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEndPercentAnim();
	void SetPercent(float Percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpirit_Gauge">();
	}
	static class UUISpirit_Gauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpirit_Gauge>();
	}
};
static_assert(alignof(UUISpirit_Gauge) == 0x000010, "Wrong alignment on UUISpirit_Gauge");
static_assert(sizeof(UUISpirit_Gauge) == 0x000620, "Wrong size on UUISpirit_Gauge");
static_assert(offsetof(UUISpirit_Gauge, TextureList) == 0x0005D8, "Member 'UUISpirit_Gauge::TextureList' has a wrong offset!");
static_assert(offsetof(UUISpirit_Gauge, DefaultFaceTexture) == 0x0005E8, "Member 'UUISpirit_Gauge::DefaultFaceTexture' has a wrong offset!");
static_assert(offsetof(UUISpirit_Gauge, GaugeMoveRate) == 0x0005F0, "Member 'UUISpirit_Gauge::GaugeMoveRate' has a wrong offset!");

// Class DarwinGame.UIStaff_Roll_00
// 0x0120 (0x05B0 - 0x0490)
class UUIStaff_Roll_00 final : public UDarwinUserWidget
{
public:
	float                                         ScrollSpeed;                                       // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MainStaffPanelSpace;                               // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           TitleList;                                         // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           NameList;                                          // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScrollDelayTime;                                   // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MemorialDelayTime;                                 // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EStaffRollTextColor, struct FLinearColor> TextColorList;                                     // 0x04C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             StaffRollDataTable;                                // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StaffRollMemoryDataTable;                          // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStartLoopAnimation*                  StaffRollRun;                                      // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIStaff_Roll_Name_1*>           OtherStaffRollList;                                // 0x0528(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIStaff_Roll_Name_2*>           MainStaffRollList;                                 // 0x0538(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       StarAnim;                                          // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 MemoryImage;                                       // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PicAnim;                                           // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0x50];                                     // 0x0560(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PicOutEnd();
	void PlayBackgroundMusic();
	void PlayPicOutAnim();
	void PlayPicWaitAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_00">();
	}
	static class UUIStaff_Roll_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_00>();
	}
};
static_assert(alignof(UUIStaff_Roll_00) == 0x000008, "Wrong alignment on UUIStaff_Roll_00");
static_assert(sizeof(UUIStaff_Roll_00) == 0x0005B0, "Wrong size on UUIStaff_Roll_00");
static_assert(offsetof(UUIStaff_Roll_00, ScrollSpeed) == 0x000490, "Member 'UUIStaff_Roll_00::ScrollSpeed' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, MainStaffPanelSpace) == 0x000494, "Member 'UUIStaff_Roll_00::MainStaffPanelSpace' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, TitleList) == 0x000498, "Member 'UUIStaff_Roll_00::TitleList' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, NameList) == 0x0004A8, "Member 'UUIStaff_Roll_00::NameList' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, ScrollDelayTime) == 0x0004B8, "Member 'UUIStaff_Roll_00::ScrollDelayTime' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, MemorialDelayTime) == 0x0004BC, "Member 'UUIStaff_Roll_00::MemorialDelayTime' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, TextColorList) == 0x0004C0, "Member 'UUIStaff_Roll_00::TextColorList' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, StaffRollDataTable) == 0x000510, "Member 'UUIStaff_Roll_00::StaffRollDataTable' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, StaffRollMemoryDataTable) == 0x000518, "Member 'UUIStaff_Roll_00::StaffRollMemoryDataTable' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, StaffRollRun) == 0x000520, "Member 'UUIStaff_Roll_00::StaffRollRun' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, OtherStaffRollList) == 0x000528, "Member 'UUIStaff_Roll_00::OtherStaffRollList' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, MainStaffRollList) == 0x000538, "Member 'UUIStaff_Roll_00::MainStaffRollList' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, StarAnim) == 0x000548, "Member 'UUIStaff_Roll_00::StarAnim' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, MemoryImage) == 0x000550, "Member 'UUIStaff_Roll_00::MemoryImage' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_00, PicAnim) == 0x000558, "Member 'UUIStaff_Roll_00::PicAnim' has a wrong offset!");

// Class DarwinGame.UIStaff_Roll_All
// 0x0020 (0x04B0 - 0x0490)
class UUIStaff_Roll_All final : public UDarwinUserWidget
{
public:
	float                                         OpenDelayTime;                                     // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStaff_Roll_00*                       StaffRoll;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStaff_Roll_Copy_00*                  Copyright;                                         // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_All">();
	}
	static class UUIStaff_Roll_All* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_All>();
	}
};
static_assert(alignof(UUIStaff_Roll_All) == 0x000008, "Wrong alignment on UUIStaff_Roll_All");
static_assert(sizeof(UUIStaff_Roll_All) == 0x0004B0, "Wrong size on UUIStaff_Roll_All");
static_assert(offsetof(UUIStaff_Roll_All, OpenDelayTime) == 0x000490, "Member 'UUIStaff_Roll_All::OpenDelayTime' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_All, StaffRoll) == 0x000498, "Member 'UUIStaff_Roll_All::StaffRoll' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_All, Copyright) == 0x0004A0, "Member 'UUIStaff_Roll_All::Copyright' has a wrong offset!");

// Class DarwinGame.UIStaff_Roll_FadeBase
// 0x0028 (0x04B8 - 0x0490)
class UUIStaff_Roll_FadeBase : public UDarwinUserWidget
{
public:
	float                                         WaitTime;                                          // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       InAnim;                                            // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OutAnim;                                           // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_FadeBase">();
	}
	static class UUIStaff_Roll_FadeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_FadeBase>();
	}
};
static_assert(alignof(UUIStaff_Roll_FadeBase) == 0x000008, "Wrong alignment on UUIStaff_Roll_FadeBase");
static_assert(sizeof(UUIStaff_Roll_FadeBase) == 0x0004B8, "Wrong size on UUIStaff_Roll_FadeBase");
static_assert(offsetof(UUIStaff_Roll_FadeBase, WaitTime) == 0x000490, "Member 'UUIStaff_Roll_FadeBase::WaitTime' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_FadeBase, InAnim) == 0x000498, "Member 'UUIStaff_Roll_FadeBase::InAnim' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_FadeBase, WaitAnim) == 0x0004A0, "Member 'UUIStaff_Roll_FadeBase::WaitAnim' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_FadeBase, OutAnim) == 0x0004A8, "Member 'UUIStaff_Roll_FadeBase::OutAnim' has a wrong offset!");

// Class DarwinGame.UIStaff_Roll_Copy_00
// 0x0018 (0x04D0 - 0x04B8)
class UUIStaff_Roll_Copy_00 final : public UUIStaff_Roll_FadeBase
{
public:
	TArray<class FText>                           CopyrightList;                                     // 0x04B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_Copy_00">();
	}
	static class UUIStaff_Roll_Copy_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_Copy_00>();
	}
};
static_assert(alignof(UUIStaff_Roll_Copy_00) == 0x000008, "Wrong alignment on UUIStaff_Roll_Copy_00");
static_assert(sizeof(UUIStaff_Roll_Copy_00) == 0x0004D0, "Wrong size on UUIStaff_Roll_Copy_00");
static_assert(offsetof(UUIStaff_Roll_Copy_00, CopyrightList) == 0x0004B8, "Member 'UUIStaff_Roll_Copy_00::CopyrightList' has a wrong offset!");

// Class DarwinGame.UIStaff_Roll_Name_00
// 0x0028 (0x04E0 - 0x04B8)
class UUIStaff_Roll_Name_00 final : public UUIStaff_Roll_FadeBase
{
public:
	TArray<class FString>                         TitleList;                                         // 0x04B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         NameList;                                          // 0x04C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_Name_00">();
	}
	static class UUIStaff_Roll_Name_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_Name_00>();
	}
};
static_assert(alignof(UUIStaff_Roll_Name_00) == 0x000008, "Wrong alignment on UUIStaff_Roll_Name_00");
static_assert(sizeof(UUIStaff_Roll_Name_00) == 0x0004E0, "Wrong size on UUIStaff_Roll_Name_00");
static_assert(offsetof(UUIStaff_Roll_Name_00, TitleList) == 0x0004B8, "Member 'UUIStaff_Roll_Name_00::TitleList' has a wrong offset!");
static_assert(offsetof(UUIStaff_Roll_Name_00, NameList) == 0x0004C8, "Member 'UUIStaff_Roll_Name_00::NameList' has a wrong offset!");

// Class DarwinGame.UIStaff_Roll_Root
// 0x0000 (0x04D0 - 0x04D0)
class UUIStaff_Roll_Root : public UUIInitWidget_Root
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaff_Roll_Root">();
	}
	static class UUIStaff_Roll_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaff_Roll_Root>();
	}
};
static_assert(alignof(UUIStaff_Roll_Root) == 0x000008, "Wrong alignment on UUIStaff_Roll_Root");
static_assert(sizeof(UUIStaff_Roll_Root) == 0x0004D0, "Wrong size on UUIStaff_Roll_Root");

// Class DarwinGame.UIStation_ArtifactIcon
// 0x0070 (0x0500 - 0x0490)
class UUIStation_ArtifactIcon final : public UDarwinUserWidget
{
public:
	TMap<EAreaType, class UTexture2D*>            IconTextureList;                                   // 0x0490(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ImageMaterial;                                     // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x10];                                     // 0x04E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 BaseIcon;                                          // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_ArtifactIcon">();
	}
	static class UUIStation_ArtifactIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_ArtifactIcon>();
	}
};
static_assert(alignof(UUIStation_ArtifactIcon) == 0x000008, "Wrong alignment on UUIStation_ArtifactIcon");
static_assert(sizeof(UUIStation_ArtifactIcon) == 0x000500, "Wrong size on UUIStation_ArtifactIcon");
static_assert(offsetof(UUIStation_ArtifactIcon, IconTextureList) == 0x000490, "Member 'UUIStation_ArtifactIcon::IconTextureList' has a wrong offset!");
static_assert(offsetof(UUIStation_ArtifactIcon, ImageMaterial) == 0x0004E0, "Member 'UUIStation_ArtifactIcon::ImageMaterial' has a wrong offset!");
static_assert(offsetof(UUIStation_ArtifactIcon, BaseIcon) == 0x0004F8, "Member 'UUIStation_ArtifactIcon::BaseIcon' has a wrong offset!");

// Class DarwinGame.UIStation_Map
// 0x00A8 (0x0538 - 0x0490)
class UUIStation_Map final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStation_PointBase*                   FocusPoint;                                        // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIStationLandIcon*>             LandIconList;                                      // 0x04E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIStation_MarkIcon*>            MarkIconList;                                      // 0x04F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x8];                                      // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       OnAnim;                                            // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnNameAnim;                                        // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       WaitNameAnim;                                      // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayWaitAnim();
	void PlayWaitNameAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_Map">();
	}
	static class UUIStation_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_Map>();
	}
};
static_assert(alignof(UUIStation_Map) == 0x000008, "Wrong alignment on UUIStation_Map");
static_assert(sizeof(UUIStation_Map) == 0x000538, "Wrong size on UUIStation_Map");
static_assert(offsetof(UUIStation_Map, FocusPoint) == 0x0004E0, "Member 'UUIStation_Map::FocusPoint' has a wrong offset!");
static_assert(offsetof(UUIStation_Map, LandIconList) == 0x0004E8, "Member 'UUIStation_Map::LandIconList' has a wrong offset!");
static_assert(offsetof(UUIStation_Map, MarkIconList) == 0x0004F8, "Member 'UUIStation_Map::MarkIconList' has a wrong offset!");
static_assert(offsetof(UUIStation_Map, OnAnim) == 0x000510, "Member 'UUIStation_Map::OnAnim' has a wrong offset!");
static_assert(offsetof(UUIStation_Map, WaitAnim) == 0x000518, "Member 'UUIStation_Map::WaitAnim' has a wrong offset!");
static_assert(offsetof(UUIStation_Map, OnNameAnim) == 0x000520, "Member 'UUIStation_Map::OnNameAnim' has a wrong offset!");
static_assert(offsetof(UUIStation_Map, WaitNameAnim) == 0x000528, "Member 'UUIStation_Map::WaitNameAnim' has a wrong offset!");

// Class DarwinGame.UIStation_MarkIcon
// 0x0020 (0x04B0 - 0x0490)
class UUIStation_MarkIcon final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_MarkIcon">();
	}
	static class UUIStation_MarkIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_MarkIcon>();
	}
};
static_assert(alignof(UUIStation_MarkIcon) == 0x000008, "Wrong alignment on UUIStation_MarkIcon");
static_assert(sizeof(UUIStation_MarkIcon) == 0x0004B0, "Wrong size on UUIStation_MarkIcon");

// Class DarwinGame.UIStation_Member
// 0x0030 (0x04C0 - 0x0490)
class UUIStation_Member final : public UDarwinUserWidget
{
public:
	TArray<class UUICategory_Panel_00*>           CategoryPanelList;                                 // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIItemmenu_ArtifactIcon*               MemberIcon;                                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_Member">();
	}
	static class UUIStation_Member* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_Member>();
	}
};
static_assert(alignof(UUIStation_Member) == 0x000008, "Wrong alignment on UUIStation_Member");
static_assert(sizeof(UUIStation_Member) == 0x0004C0, "Wrong size on UUIStation_Member");
static_assert(offsetof(UUIStation_Member, CategoryPanelList) == 0x000490, "Member 'UUIStation_Member::CategoryPanelList' has a wrong offset!");
static_assert(offsetof(UUIStation_Member, MemberIcon) == 0x0004A0, "Member 'UUIStation_Member::MemberIcon' has a wrong offset!");

// Class DarwinGame.UIStation_MonsterIcon
// 0x0070 (0x0500 - 0x0490)
class UUIStation_MonsterIcon final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x50];                                     // 0x0490(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIStation_CategoryIcon_S*>      Categories;                                        // 0x04E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIStation_MonsterIconEffect*           Effect;                                            // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIStation_MonsterIconFrame*            Frame;                                             // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_MonsterIcon">();
	}
	static class UUIStation_MonsterIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_MonsterIcon>();
	}
};
static_assert(alignof(UUIStation_MonsterIcon) == 0x000008, "Wrong alignment on UUIStation_MonsterIcon");
static_assert(sizeof(UUIStation_MonsterIcon) == 0x000500, "Wrong size on UUIStation_MonsterIcon");
static_assert(offsetof(UUIStation_MonsterIcon, Categories) == 0x0004E0, "Member 'UUIStation_MonsterIcon::Categories' has a wrong offset!");
static_assert(offsetof(UUIStation_MonsterIcon, Effect) == 0x0004F0, "Member 'UUIStation_MonsterIcon::Effect' has a wrong offset!");
static_assert(offsetof(UUIStation_MonsterIcon, Frame) == 0x0004F8, "Member 'UUIStation_MonsterIcon::Frame' has a wrong offset!");

// Class DarwinGame.UIStation_PointBase
// 0x0000 (0x04F8 - 0x04F8)
class UUIStation_PointBase final : public UUIStartLoopAnimation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStation_PointBase">();
	}
	static class UUIStation_PointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStation_PointBase>();
	}
};
static_assert(alignof(UUIStation_PointBase) == 0x000008, "Wrong alignment on UUIStation_PointBase");
static_assert(sizeof(UUIStation_PointBase) == 0x0004F8, "Wrong size on UUIStation_PointBase");

// Class DarwinGame.UIStationListDataTable
// 0x0000 (0x0030 - 0x0030)
class UUIStationListDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationListDataTable">();
	}
	static class UUIStationListDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationListDataTable>();
	}
};
static_assert(alignof(UUIStationListDataTable) == 0x000008, "Wrong alignment on UUIStationListDataTable");
static_assert(sizeof(UUIStationListDataTable) == 0x000030, "Wrong size on UUIStationListDataTable");

// Class DarwinGame.UIStationMenu
// 0x0090 (0x0520 - 0x0490)
class UUIStationMenu final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIStation_Map*                         StationMap;                                        // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStationMenuArea*                     StationMenuArea;                                   // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIStationPet*                          StationPet;                                        // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x50];                                     // 0x04D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeFocusFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationMenu">();
	}
	static class UUIStationMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationMenu>();
	}
};
static_assert(alignof(UUIStationMenu) == 0x000008, "Wrong alignment on UUIStationMenu");
static_assert(sizeof(UUIStationMenu) == 0x000520, "Wrong size on UUIStationMenu");
static_assert(offsetof(UUIStationMenu, StationMap) == 0x0004B0, "Member 'UUIStationMenu::StationMap' has a wrong offset!");
static_assert(offsetof(UUIStationMenu, StationMenuArea) == 0x0004B8, "Member 'UUIStationMenu::StationMenuArea' has a wrong offset!");
static_assert(offsetof(UUIStationMenu, UIUnderButton) == 0x0004C0, "Member 'UUIStationMenu::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUIStationMenu, StationPet) == 0x0004C8, "Member 'UUIStationMenu::StationPet' has a wrong offset!");

// Class DarwinGame.UIStationPet
// 0x0030 (0x04C0 - 0x0490)
class UUIStationPet final : public UDarwinUserWidget
{
public:
	class UDataTable*                             MessengerDataTable;                                // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIStation_Chara*                       Chara;                                             // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIStation_ArtifactIcon*                ArtifactIcon;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidgetData*                        textData;                                          // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidget*                            TextWidget;                                        // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStationPet">();
	}
	static class UUIStationPet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStationPet>();
	}
};
static_assert(alignof(UUIStationPet) == 0x000008, "Wrong alignment on UUIStationPet");
static_assert(sizeof(UUIStationPet) == 0x0004C0, "Wrong size on UUIStationPet");
static_assert(offsetof(UUIStationPet, MessengerDataTable) == 0x000490, "Member 'UUIStationPet::MessengerDataTable' has a wrong offset!");
static_assert(offsetof(UUIStationPet, Chara) == 0x000498, "Member 'UUIStationPet::Chara' has a wrong offset!");
static_assert(offsetof(UUIStationPet, ArtifactIcon) == 0x0004A0, "Member 'UUIStationPet::ArtifactIcon' has a wrong offset!");
static_assert(offsetof(UUIStationPet, textData) == 0x0004A8, "Member 'UUIStationPet::textData' has a wrong offset!");
static_assert(offsetof(UUIStationPet, TextWidget) == 0x0004B0, "Member 'UUIStationPet::TextWidget' has a wrong offset!");

// Class DarwinGame.UIStatusBlueprintFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UUIStatusBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStatusBlueprintFunctionLibrary">();
	}
	static class UUIStatusBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStatusBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UUIStatusBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UUIStatusBlueprintFunctionLibrary");
static_assert(sizeof(UUIStatusBlueprintFunctionLibrary) == 0x000030, "Wrong size on UUIStatusBlueprintFunctionLibrary");

// Class DarwinGame.UISteal
// 0x0050 (0x0600 - 0x05B0)
class UUISteal : public UUI3DBase
{
public:
	uint8                                         Pad_5A8[0x38];                                     // 0x05A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSeconds;                                      // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationSeconds;                                   // 0x05E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         AtomComp;                                          // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MissAnimEnd();
	void PlayRotate();
	void PressAnimEnd();
	void Push();
	void SetData(class AActor* Target, float HitRangePercent);
	void StopRotate();
	void SuccessAnimEnd();

	float GetRotationSeconds() const;
	bool IsSuccess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISteal">();
	}
	static class UUISteal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISteal>();
	}
};
static_assert(alignof(UUISteal) == 0x000010, "Wrong alignment on UUISteal");
static_assert(sizeof(UUISteal) == 0x000600, "Wrong size on UUISteal");
static_assert(offsetof(UUISteal, StartSeconds) == 0x0005E0, "Member 'UUISteal::StartSeconds' has a wrong offset!");
static_assert(offsetof(UUISteal, RotationSeconds) == 0x0005E4, "Member 'UUISteal::RotationSeconds' has a wrong offset!");
static_assert(offsetof(UUISteal, AtomComp) == 0x0005F0, "Member 'UUISteal::AtomComp' has a wrong offset!");

// Class DarwinGame.UISub_01
// 0x0008 (0x04B0 - 0x04A8)
class UUISub_01 : public UUIEvent_Mask
{
public:
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayContinuedWaitAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISub_01">();
	}
	static class UUISub_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISub_01>();
	}
};
static_assert(alignof(UUISub_01) == 0x000008, "Wrong alignment on UUISub_01");
static_assert(sizeof(UUISub_01) == 0x0004B0, "Wrong size on UUISub_01");

// Class DarwinGame.UISwapConfirm
// 0x0080 (0x0650 - 0x05D0)
class UUISwapConfirm final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x80];                                     // 0x05D0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISwapConfirm">();
	}
	static class UUISwapConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISwapConfirm>();
	}
};
static_assert(alignof(UUISwapConfirm) == 0x000008, "Wrong alignment on UUISwapConfirm");
static_assert(sizeof(UUISwapConfirm) == 0x000650, "Wrong size on UUISwapConfirm");

// Class DarwinGame.UISwapMenu
// 0x0098 (0x0568 - 0x04D0)
class UUISwapMenu final : public UUILeftMenuUseBase
{
public:
	uint8                                         Pad_4D0[0x18];                                     // 0x04D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUISwapMenu_List*                       SwapList;                                          // 0x04E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UnderButton;                                       // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x70];                                     // 0x04F8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISwapMenu">();
	}
	static class UUISwapMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISwapMenu>();
	}
};
static_assert(alignof(UUISwapMenu) == 0x000008, "Wrong alignment on UUISwapMenu");
static_assert(sizeof(UUISwapMenu) == 0x000568, "Wrong size on UUISwapMenu");
static_assert(offsetof(UUISwapMenu, SwapList) == 0x0004E8, "Member 'UUISwapMenu::SwapList' has a wrong offset!");
static_assert(offsetof(UUISwapMenu, UnderButton) == 0x0004F0, "Member 'UUISwapMenu::UnderButton' has a wrong offset!");

// Class DarwinGame.UISwapMenu_Root
// 0x0038 (0x0508 - 0x04D0)
class UUISwapMenu_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x38];                                     // 0x04D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISwapMenu_Root">();
	}
	static class UUISwapMenu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISwapMenu_Root>();
	}
};
static_assert(alignof(UUISwapMenu_Root) == 0x000008, "Wrong alignment on UUISwapMenu_Root");
static_assert(sizeof(UUISwapMenu_Root) == 0x000508, "Wrong size on UUISwapMenu_Root");

// Class DarwinGame.UITalk_Arrow
// 0x0008 (0x0498 - 0x0490)
class UUITalk_Arrow : public UDarwinUserWidget
{
public:
	class UWidgetAnimation*                       CurrentAnimation;                                  // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITalk_Arrow">();
	}
	static class UUITalk_Arrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITalk_Arrow>();
	}
};
static_assert(alignof(UUITalk_Arrow) == 0x000008, "Wrong alignment on UUITalk_Arrow");
static_assert(sizeof(UUITalk_Arrow) == 0x000498, "Wrong size on UUITalk_Arrow");
static_assert(offsetof(UUITalk_Arrow, CurrentAnimation) == 0x000490, "Member 'UUITalk_Arrow::CurrentAnimation' has a wrong offset!");

// Class DarwinGame.UITalk_BtnChoice
// 0x0060 (0x0550 - 0x04F0)
class UUITalk_BtnChoice : public UUIMenuItemBase
{
public:
	uint8                                         Pad_4F0[0x60];                                     // 0x04F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Decide();
	bool IsSlideIn();
	void OffNew();
	void OnNew();
	void SetData(const struct FChoiceItemData& Data);
	void SlideIn();
	void SlideOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITalk_BtnChoice">();
	}
	static class UUITalk_BtnChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITalk_BtnChoice>();
	}
};
static_assert(alignof(UUITalk_BtnChoice) == 0x000008, "Wrong alignment on UUITalk_BtnChoice");
static_assert(sizeof(UUITalk_BtnChoice) == 0x000550, "Wrong size on UUITalk_BtnChoice");

// Class DarwinGame.UITalk_WinChoice
// 0x0160 (0x0620 - 0x04C0)
class UUITalk_WinChoice : public UUIMenuBase
{
public:
	struct FChoiceWindowData                      ChoiceWindowData;                                  // 0x04C0(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x10];                                     // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChoiseWindowNum;                                   // 0x0538(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EHubReceptionType, struct FST_ReceptionUnlockData> HubReceptionFlagNames;                             // 0x0540(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TMap<EFacilityReceptionType, struct FST_ReceptionUnlockData> FacilityReceptionFlagNames;                        // 0x0590(0x0050)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	float                                         EnableDicideWait;                                  // 0x05E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x3C];                                     // 0x05E4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallChoiceResult(int32 Index_0);
	bool CanShortCut(EAxisMappingType ShortCutKey);
	void ChangeFocus(int32 Index_0);
	bool CheckSlideEnd(int32 InIndex);
	EEventType GetEventType();
	int32 GetShortCutItemIndex(EAxisMappingType ShortCutKey);
	void Performance();
	void SetData(const struct FChoiceWindowData& Data);
	void SetItemsData();
	void ShortCut(EAxisMappingType InputKey);
	void SlideIn();
	void WaitSlideIn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITalk_WinChoice">();
	}
	static class UUITalk_WinChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITalk_WinChoice>();
	}
};
static_assert(alignof(UUITalk_WinChoice) == 0x000008, "Wrong alignment on UUITalk_WinChoice");
static_assert(sizeof(UUITalk_WinChoice) == 0x000620, "Wrong size on UUITalk_WinChoice");
static_assert(offsetof(UUITalk_WinChoice, ChoiceWindowData) == 0x0004C0, "Member 'UUITalk_WinChoice::ChoiceWindowData' has a wrong offset!");
static_assert(offsetof(UUITalk_WinChoice, ChoiseWindowNum) == 0x000538, "Member 'UUITalk_WinChoice::ChoiseWindowNum' has a wrong offset!");
static_assert(offsetof(UUITalk_WinChoice, HubReceptionFlagNames) == 0x000540, "Member 'UUITalk_WinChoice::HubReceptionFlagNames' has a wrong offset!");
static_assert(offsetof(UUITalk_WinChoice, FacilityReceptionFlagNames) == 0x000590, "Member 'UUITalk_WinChoice::FacilityReceptionFlagNames' has a wrong offset!");
static_assert(offsetof(UUITalk_WinChoice, EnableDicideWait) == 0x0005E0, "Member 'UUITalk_WinChoice::EnableDicideWait' has a wrong offset!");

// Class DarwinGame.UITeam_Menu
// 0x01A0 (0x0670 - 0x04D0)
class alignas(0x10) UUITeam_Menu : public UUILeftMenuUseBase
{
public:
	TArray<struct FST_UITeamMenuItemStruct>       MenuItemList;                                      // 0x04D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RankUpSoftClass;                                   // 0x04E0(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BaseViewSoftClass;                                 // 0x0508(0x0028)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectingTimeMax;                                  // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectingTimeMin;                                  // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIFlagmenu_00*                         Flagmenu;                                          // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UIUnderButton;                                     // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHub_Status*                          UIHubStatus;                                       // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHub_RankUp*                          RankUpWindow;                                      // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIHub_PointUp*                         PointUpWindow;                                     // 0x0568(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_570[0xC8];                                     // 0x0570(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         CountSe;                                           // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         CoinFallSe;                                        // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x28];                                     // 0x0648(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlagChangeFocusCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITeam_Menu">();
	}
	static class UUITeam_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITeam_Menu>();
	}
};
static_assert(alignof(UUITeam_Menu) == 0x000010, "Wrong alignment on UUITeam_Menu");
static_assert(sizeof(UUITeam_Menu) == 0x000670, "Wrong size on UUITeam_Menu");
static_assert(offsetof(UUITeam_Menu, MenuItemList) == 0x0004D0, "Member 'UUITeam_Menu::MenuItemList' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, RankUpSoftClass) == 0x0004E0, "Member 'UUITeam_Menu::RankUpSoftClass' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, BaseViewSoftClass) == 0x000508, "Member 'UUITeam_Menu::BaseViewSoftClass' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, DirectingTimeMax) == 0x000530, "Member 'UUITeam_Menu::DirectingTimeMax' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, DirectingTimeMin) == 0x000534, "Member 'UUITeam_Menu::DirectingTimeMin' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, Flagmenu) == 0x000548, "Member 'UUITeam_Menu::Flagmenu' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, UIUnderButton) == 0x000550, "Member 'UUITeam_Menu::UIUnderButton' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, UIHubStatus) == 0x000558, "Member 'UUITeam_Menu::UIHubStatus' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, RankUpWindow) == 0x000560, "Member 'UUITeam_Menu::RankUpWindow' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, PointUpWindow) == 0x000568, "Member 'UUITeam_Menu::PointUpWindow' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, CountSe) == 0x000638, "Member 'UUITeam_Menu::CountSe' has a wrong offset!");
static_assert(offsetof(UUITeam_Menu, CoinFallSe) == 0x000640, "Member 'UUITeam_Menu::CoinFallSe' has a wrong offset!");

// Class DarwinGame.UITeam_Menu_Root
// 0x0008 (0x04D8 - 0x04D0)
class UUITeam_Menu_Root : public UUIInitWidget_Root
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITeam_Menu_Root">();
	}
	static class UUITeam_Menu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITeam_Menu_Root>();
	}
};
static_assert(alignof(UUITeam_Menu_Root) == 0x000008, "Wrong alignment on UUITeam_Menu_Root");
static_assert(sizeof(UUITeam_Menu_Root) == 0x0004D8, "Wrong size on UUITeam_Menu_Root");

// Class DarwinGame.UITeamIcon_Set
// 0x0010 (0x04A0 - 0x0490)
class UUITeamIcon_Set : public UDarwinUserWidget
{
public:
	class UImage*                                 FlagIconImage;                                     // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 PartyIconImage;                                    // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITeamIcon_Set">();
	}
	static class UUITeamIcon_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITeamIcon_Set>();
	}
};
static_assert(alignof(UUITeamIcon_Set) == 0x000008, "Wrong alignment on UUITeamIcon_Set");
static_assert(sizeof(UUITeamIcon_Set) == 0x0004A0, "Wrong size on UUITeamIcon_Set");
static_assert(offsetof(UUITeamIcon_Set, FlagIconImage) == 0x000490, "Member 'UUITeamIcon_Set::FlagIconImage' has a wrong offset!");
static_assert(offsetof(UUITeamIcon_Set, PartyIconImage) == 0x000498, "Member 'UUITeamIcon_Set::PartyIconImage' has a wrong offset!");

// Class DarwinGame.UITextColorDataTable
// 0x0000 (0x0030 - 0x0030)
class UUITextColorDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextColorDataTable">();
	}
	static class UUITextColorDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextColorDataTable>();
	}
};
static_assert(alignof(UUITextColorDataTable) == 0x000008, "Wrong alignment on UUITextColorDataTable");
static_assert(sizeof(UUITextColorDataTable) == 0x000030, "Wrong size on UUITextColorDataTable");

// Class DarwinGame.UITitle_Button_00
// 0x0008 (0x0498 - 0x0490)
class UUITitle_Button_00 : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_Button_00">();
	}
	static class UUITitle_Button_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_Button_00>();
	}
};
static_assert(alignof(UUITitle_Button_00) == 0x000008, "Wrong alignment on UUITitle_Button_00");
static_assert(sizeof(UUITitle_Button_00) == 0x000498, "Wrong size on UUITitle_Button_00");

// Class DarwinGame.UITitle_Load
// 0x0010 (0x0628 - 0x0618)
class UUITitle_Load final : public UUILoadContent
{
public:
	uint8                                         Pad_618[0x10];                                     // 0x0618(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_Load">();
	}
	static class UUITitle_Load* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_Load>();
	}
};
static_assert(alignof(UUITitle_Load) == 0x000008, "Wrong alignment on UUITitle_Load");
static_assert(sizeof(UUITitle_Load) == 0x000628, "Wrong size on UUITitle_Load");

// Class DarwinGame.UIContinued_Set
// 0x0000 (0x0548 - 0x0548)
class UUIContinued_Set final : public UUITitle_Select_Set_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContinued_Set">();
	}
	static class UUIContinued_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIContinued_Set>();
	}
};
static_assert(alignof(UUIContinued_Set) == 0x000008, "Wrong alignment on UUIContinued_Set");
static_assert(sizeof(UUIContinued_Set) == 0x000548, "Wrong size on UUIContinued_Set");

// Class DarwinGame.UIBeginning_Set
// 0x0000 (0x0548 - 0x0548)
class UUIBeginning_Set final : public UUITitle_Select_Set_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBeginning_Set">();
	}
	static class UUIBeginning_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBeginning_Set>();
	}
};
static_assert(alignof(UUIBeginning_Set) == 0x000008, "Wrong alignment on UUIBeginning_Set");
static_assert(sizeof(UUIBeginning_Set) == 0x000548, "Wrong size on UUIBeginning_Set");

// Class DarwinGame.UITrial_Set
// 0x0000 (0x0548 - 0x0548)
class UUITrial_Set final : public UUITitle_Select_Set_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITrial_Set">();
	}
	static class UUITrial_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITrial_Set>();
	}
};
static_assert(alignof(UUITrial_Set) == 0x000008, "Wrong alignment on UUITrial_Set");
static_assert(sizeof(UUITrial_Set) == 0x000548, "Wrong size on UUITrial_Set");

// Class DarwinGame.UIQuit_Set
// 0x0000 (0x0548 - 0x0548)
class UUIQuit_Set final : public UUITitle_Select_Set_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuit_Set">();
	}
	static class UUIQuit_Set* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuit_Set>();
	}
};
static_assert(alignof(UUIQuit_Set) == 0x000008, "Wrong alignment on UUIQuit_Set");
static_assert(sizeof(UUIQuit_Set) == 0x000548, "Wrong size on UUIQuit_Set");

// Class DarwinGame.UITitle_Subtitle
// 0x0000 (0x0490 - 0x0490)
class UUITitle_Subtitle final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitle_Subtitle">();
	}
	static class UUITitle_Subtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitle_Subtitle>();
	}
};
static_assert(alignof(UUITitle_Subtitle) == 0x000008, "Wrong alignment on UUITitle_Subtitle");
static_assert(sizeof(UUITitle_Subtitle) == 0x000490, "Wrong size on UUITitle_Subtitle");

// Class DarwinGame.UITopbar_00
// 0x0000 (0x04F8 - 0x04F8)
class UUITopbar_00 : public UUITopbar_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITopbar_00">();
	}
	static class UUITopbar_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITopbar_00>();
	}
};
static_assert(alignof(UUITopbar_00) == 0x000008, "Wrong alignment on UUITopbar_00");
static_assert(sizeof(UUITopbar_00) == 0x0004F8, "Wrong size on UUITopbar_00");

// Class DarwinGame.UITopbar_10
// 0x0000 (0x04F8 - 0x04F8)
class UUITopbar_10 : public UUITopbar_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITopbar_10">();
	}
	static class UUITopbar_10* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITopbar_10>();
	}
};
static_assert(alignof(UUITopbar_10) == 0x000008, "Wrong alignment on UUITopbar_10");
static_assert(sizeof(UUITopbar_10) == 0x0004F8, "Wrong size on UUITopbar_10");

// Class DarwinGame.UITreasureDetails_ContentMenu
// 0x03B0 (0x0840 - 0x0490)
class alignas(0x10) UUITreasureDetails_ContentMenu : public UDarwinUserWidget
{
public:
	struct FRotator                               ArtifactRotator;                                   // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GoodEventPlayTime;                                 // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TravelReturnCountUpTime;                           // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              ReplicaBG;                                         // 0x04A8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              NormalShadowTex;                                   // 0x04D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ReplicaShadowTex;                                  // 0x04F8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDarwinArtifactTwoCaptureImage*         CaptureImage;                                      // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIPartyMenu_BG*                        BG;                                                // 0x0528(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIUnder_Button*                        UnderButton;                                       // 0x0530(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 RepicaIconWidget;                                  // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 MyTreasureIconWidget;                              // 0x0540(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 OfficialIconWidget;                                // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 CategoryIconWidget;                                // 0x0550(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 LockIconWidget;                                    // 0x0558(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITopbar_00*                           Topbar;                                            // 0x0560(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDarwinUserWidget*>              PageList;                                          // 0x0568(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      CurrentPage;                                       // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureDetails_Page01*              DetailPage01;                                      // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureDetails_Page02*              DetailPage02;                                      // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureDetails_Page03*              DetailPage03;                                      // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITalk_WinStatusBase*                  TalkWin;                                           // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextWidgetData*                        TextWidgetData;                                    // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDarwinUserWidget*                      DarknessWidget;                                    // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGood_Directing*                      GoodDirecting;                                     // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x288];                                    // 0x05B8(0x0288)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureDetails_ContentMenu">();
	}
	static class UUITreasureDetails_ContentMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureDetails_ContentMenu>();
	}
};
static_assert(alignof(UUITreasureDetails_ContentMenu) == 0x000010, "Wrong alignment on UUITreasureDetails_ContentMenu");
static_assert(sizeof(UUITreasureDetails_ContentMenu) == 0x000840, "Wrong size on UUITreasureDetails_ContentMenu");
static_assert(offsetof(UUITreasureDetails_ContentMenu, ArtifactRotator) == 0x000490, "Member 'UUITreasureDetails_ContentMenu::ArtifactRotator' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, GoodEventPlayTime) == 0x00049C, "Member 'UUITreasureDetails_ContentMenu::GoodEventPlayTime' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, TravelReturnCountUpTime) == 0x0004A0, "Member 'UUITreasureDetails_ContentMenu::TravelReturnCountUpTime' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, ReplicaBG) == 0x0004A8, "Member 'UUITreasureDetails_ContentMenu::ReplicaBG' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, NormalShadowTex) == 0x0004D0, "Member 'UUITreasureDetails_ContentMenu::NormalShadowTex' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, ReplicaShadowTex) == 0x0004F8, "Member 'UUITreasureDetails_ContentMenu::ReplicaShadowTex' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, CaptureImage) == 0x000520, "Member 'UUITreasureDetails_ContentMenu::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, BG) == 0x000528, "Member 'UUITreasureDetails_ContentMenu::BG' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, UnderButton) == 0x000530, "Member 'UUITreasureDetails_ContentMenu::UnderButton' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, RepicaIconWidget) == 0x000538, "Member 'UUITreasureDetails_ContentMenu::RepicaIconWidget' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, MyTreasureIconWidget) == 0x000540, "Member 'UUITreasureDetails_ContentMenu::MyTreasureIconWidget' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, OfficialIconWidget) == 0x000548, "Member 'UUITreasureDetails_ContentMenu::OfficialIconWidget' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, CategoryIconWidget) == 0x000550, "Member 'UUITreasureDetails_ContentMenu::CategoryIconWidget' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, LockIconWidget) == 0x000558, "Member 'UUITreasureDetails_ContentMenu::LockIconWidget' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, Topbar) == 0x000560, "Member 'UUITreasureDetails_ContentMenu::Topbar' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, PageList) == 0x000568, "Member 'UUITreasureDetails_ContentMenu::PageList' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, CurrentPage) == 0x000578, "Member 'UUITreasureDetails_ContentMenu::CurrentPage' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, DetailPage01) == 0x000580, "Member 'UUITreasureDetails_ContentMenu::DetailPage01' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, DetailPage02) == 0x000588, "Member 'UUITreasureDetails_ContentMenu::DetailPage02' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, DetailPage03) == 0x000590, "Member 'UUITreasureDetails_ContentMenu::DetailPage03' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, TalkWin) == 0x000598, "Member 'UUITreasureDetails_ContentMenu::TalkWin' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, TextWidgetData) == 0x0005A0, "Member 'UUITreasureDetails_ContentMenu::TextWidgetData' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, DarknessWidget) == 0x0005A8, "Member 'UUITreasureDetails_ContentMenu::DarknessWidget' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_ContentMenu, GoodDirecting) == 0x0005B0, "Member 'UUITreasureDetails_ContentMenu::GoodDirecting' has a wrong offset!");

// Class DarwinGame.UITreasureDetails_Log
// 0x0008 (0x0498 - 0x0490)
class UUITreasureDetails_Log : public UDarwinUserWidget
{
public:
	class UComputeTextBlock*                      LogText;                                           // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureDetails_Log">();
	}
	static class UUITreasureDetails_Log* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureDetails_Log>();
	}
};
static_assert(alignof(UUITreasureDetails_Log) == 0x000008, "Wrong alignment on UUITreasureDetails_Log");
static_assert(sizeof(UUITreasureDetails_Log) == 0x000498, "Wrong size on UUITreasureDetails_Log");
static_assert(offsetof(UUITreasureDetails_Log, LogText) == 0x000490, "Member 'UUITreasureDetails_Log::LogText' has a wrong offset!");

// Class DarwinGame.UITreasureDetails_Page01
// 0x0028 (0x0518 - 0x04F0)
class UUITreasureDetails_Page01 : public UUIFreeScrollBase
{
public:
	class UUIMonsterDict_Content_02*              Content02_1;                                       // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMonsterDict_Content_15*              Content15;                                         // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMonsterDict_Content_16*              Content16;                                         // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureDetails_Content01*           Content01;                                         // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMonsterDict_Content_10*              Content10;                                         // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureDetails_Page01">();
	}
	static class UUITreasureDetails_Page01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureDetails_Page01>();
	}
};
static_assert(alignof(UUITreasureDetails_Page01) == 0x000008, "Wrong alignment on UUITreasureDetails_Page01");
static_assert(sizeof(UUITreasureDetails_Page01) == 0x000518, "Wrong size on UUITreasureDetails_Page01");
static_assert(offsetof(UUITreasureDetails_Page01, Content02_1) == 0x0004F0, "Member 'UUITreasureDetails_Page01::Content02_1' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page01, Content15) == 0x0004F8, "Member 'UUITreasureDetails_Page01::Content15' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page01, Content16) == 0x000500, "Member 'UUITreasureDetails_Page01::Content16' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page01, Content01) == 0x000508, "Member 'UUITreasureDetails_Page01::Content01' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page01, Content10) == 0x000510, "Member 'UUITreasureDetails_Page01::Content10' has a wrong offset!");

// Class DarwinGame.UITreasureDetails_Page02
// 0x0070 (0x0560 - 0x04F0)
class UUITreasureDetails_Page02 : public UUIFreeScrollBase
{
public:
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMonsterDict_Content_02*              Content02_2;                                       // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMonsterDict_Content_07*              Content07_1;                                       // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMonsterDict_Content_07*              Content07_2;                                       // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIMonsterDict_Content_04*              Content04;                                         // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           MaxTextColor;                                      // 0x0518(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           CountUpTextColor;                                  // 0x0528(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultTextColor;                                  // 0x0538(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x18];                                     // 0x0548(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureDetails_Page02">();
	}
	static class UUITreasureDetails_Page02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureDetails_Page02>();
	}
};
static_assert(alignof(UUITreasureDetails_Page02) == 0x000008, "Wrong alignment on UUITreasureDetails_Page02");
static_assert(sizeof(UUITreasureDetails_Page02) == 0x000560, "Wrong size on UUITreasureDetails_Page02");
static_assert(offsetof(UUITreasureDetails_Page02, Content02_2) == 0x0004F8, "Member 'UUITreasureDetails_Page02::Content02_2' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page02, Content07_1) == 0x000500, "Member 'UUITreasureDetails_Page02::Content07_1' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page02, Content07_2) == 0x000508, "Member 'UUITreasureDetails_Page02::Content07_2' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page02, Content04) == 0x000510, "Member 'UUITreasureDetails_Page02::Content04' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page02, MaxTextColor) == 0x000518, "Member 'UUITreasureDetails_Page02::MaxTextColor' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page02, CountUpTextColor) == 0x000528, "Member 'UUITreasureDetails_Page02::CountUpTextColor' has a wrong offset!");
static_assert(offsetof(UUITreasureDetails_Page02, DefaultTextColor) == 0x000538, "Member 'UUITreasureDetails_Page02::DefaultTextColor' has a wrong offset!");

// Class DarwinGame.UITreasureHideBase
// 0x0120 (0x0650 - 0x0530)
class UUITreasureHideBase final : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0xB4];                                     // 0x0530(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           MaxTextColor;                                      // 0x05E4(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_MonsterIconParts                   MonsterIconParts;                                  // 0x05F8(0x0050)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UTextBlock*                             NoSettingText;                                     // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureHideBase">();
	}
	static class UUITreasureHideBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureHideBase>();
	}
};
static_assert(alignof(UUITreasureHideBase) == 0x000008, "Wrong alignment on UUITreasureHideBase");
static_assert(sizeof(UUITreasureHideBase) == 0x000650, "Wrong size on UUITreasureHideBase");
static_assert(offsetof(UUITreasureHideBase, MaxTextColor) == 0x0005E4, "Member 'UUITreasureHideBase::MaxTextColor' has a wrong offset!");
static_assert(offsetof(UUITreasureHideBase, MonsterIconParts) == 0x0005F8, "Member 'UUITreasureHideBase::MonsterIconParts' has a wrong offset!");
static_assert(offsetof(UUITreasureHideBase, NoSettingText) == 0x000648, "Member 'UUITreasureHideBase::NoSettingText' has a wrong offset!");

// Class DarwinGame.UITreasureHideBaseFrame
// 0x0030 (0x04C0 - 0x0490)
class UUITreasureHideBaseFrame final : public UDarwinUserWidget
{
public:
	class UWidgetAnimation*                       FocusAnimation;                                    // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       LoopAnimation;                                     // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       OutFocusAnimation;                                 // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x18];                                     // 0x04A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayLoopAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureHideBaseFrame">();
	}
	static class UUITreasureHideBaseFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureHideBaseFrame>();
	}
};
static_assert(alignof(UUITreasureHideBaseFrame) == 0x000008, "Wrong alignment on UUITreasureHideBaseFrame");
static_assert(sizeof(UUITreasureHideBaseFrame) == 0x0004C0, "Wrong size on UUITreasureHideBaseFrame");
static_assert(offsetof(UUITreasureHideBaseFrame, FocusAnimation) == 0x000490, "Member 'UUITreasureHideBaseFrame::FocusAnimation' has a wrong offset!");
static_assert(offsetof(UUITreasureHideBaseFrame, LoopAnimation) == 0x000498, "Member 'UUITreasureHideBaseFrame::LoopAnimation' has a wrong offset!");
static_assert(offsetof(UUITreasureHideBaseFrame, OutFocusAnimation) == 0x0004A0, "Member 'UUITreasureHideBaseFrame::OutFocusAnimation' has a wrong offset!");

// Class DarwinGame.UITreasureHidePanel
// 0x0088 (0x0518 - 0x0490)
class UUITreasureHidePanel final : public UDarwinUserWidget
{
public:
	class UUITreasureHideBase*                    TreasureHideBase;                                  // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAutoTextBlock*                         TextBlock;                                         // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             IconTexture;                                       // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EMapSymbolType, class UTexture2D*>       IconImageList;                                     // 0x04A8(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	struct FLinearColor                           PasswordGrayColor;                                 // 0x04F8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DLBlueColor;                                       // 0x0508(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureHidePanel">();
	}
	static class UUITreasureHidePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureHidePanel>();
	}
};
static_assert(alignof(UUITreasureHidePanel) == 0x000008, "Wrong alignment on UUITreasureHidePanel");
static_assert(sizeof(UUITreasureHidePanel) == 0x000518, "Wrong size on UUITreasureHidePanel");
static_assert(offsetof(UUITreasureHidePanel, TreasureHideBase) == 0x000490, "Member 'UUITreasureHidePanel::TreasureHideBase' has a wrong offset!");
static_assert(offsetof(UUITreasureHidePanel, TextBlock) == 0x000498, "Member 'UUITreasureHidePanel::TextBlock' has a wrong offset!");
static_assert(offsetof(UUITreasureHidePanel, IconTexture) == 0x0004A0, "Member 'UUITreasureHidePanel::IconTexture' has a wrong offset!");
static_assert(offsetof(UUITreasureHidePanel, IconImageList) == 0x0004A8, "Member 'UUITreasureHidePanel::IconImageList' has a wrong offset!");
static_assert(offsetof(UUITreasureHidePanel, PasswordGrayColor) == 0x0004F8, "Member 'UUITreasureHidePanel::PasswordGrayColor' has a wrong offset!");
static_assert(offsetof(UUITreasureHidePanel, DLBlueColor) == 0x000508, "Member 'UUITreasureHidePanel::DLBlueColor' has a wrong offset!");

// Class DarwinGame.UITreasureHouse_Table
// 0x0250 (0x0720 - 0x04D0)
class alignas(0x10) UUITreasureHouse_Table : public UUILeftMenuUseBase
{
public:
	TArray<struct FST_ArtfifactCategoryInfo>      ArtifactCategoryInfoList;                          // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x10];                                     // 0x04E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIUnder_Button*                        UnderButton;                                       // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUICommonmenu_04*                       Commonmenu04;                                      // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUITreasureHouse_WinSort*               WinSort;                                           // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x1E0];                                    // 0x0508(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FST_ArtifactCompInfo>           CompInfoList;                                      // 0x06E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FST_ArtifactCompInfo>           CompDirectionExecInfoList;                         // 0x06F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_708[0x8];                                      // 0x0708(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UComputeTextBlock*                      EmptyTextBlock;                                    // 0x0710(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_718[0x8];                                      // 0x0718(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITreasureHouse_Table">();
	}
	static class UUITreasureHouse_Table* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITreasureHouse_Table>();
	}
};
static_assert(alignof(UUITreasureHouse_Table) == 0x000010, "Wrong alignment on UUITreasureHouse_Table");
static_assert(sizeof(UUITreasureHouse_Table) == 0x000720, "Wrong size on UUITreasureHouse_Table");
static_assert(offsetof(UUITreasureHouse_Table, ArtifactCategoryInfoList) == 0x0004D0, "Member 'UUITreasureHouse_Table::ArtifactCategoryInfoList' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_Table, UnderButton) == 0x0004F0, "Member 'UUITreasureHouse_Table::UnderButton' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_Table, Commonmenu04) == 0x0004F8, "Member 'UUITreasureHouse_Table::Commonmenu04' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_Table, WinSort) == 0x000500, "Member 'UUITreasureHouse_Table::WinSort' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_Table, CompInfoList) == 0x0006E8, "Member 'UUITreasureHouse_Table::CompInfoList' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_Table, CompDirectionExecInfoList) == 0x0006F8, "Member 'UUITreasureHouse_Table::CompDirectionExecInfoList' has a wrong offset!");
static_assert(offsetof(UUITreasureHouse_Table, EmptyTextBlock) == 0x000710, "Member 'UUITreasureHouse_Table::EmptyTextBlock' has a wrong offset!");

// Class DarwinGame.UITrial_BG_01
// 0x0000 (0x0490 - 0x0490)
class UUITrial_BG_01 final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITrial_BG_01">();
	}
	static class UUITrial_BG_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITrial_BG_01>();
	}
};
static_assert(alignof(UUITrial_BG_01) == 0x000008, "Wrong alignment on UUITrial_BG_01");
static_assert(sizeof(UUITrial_BG_01) == 0x000490, "Wrong size on UUITrial_BG_01");

// Class DarwinGame.UITrial_BG_02
// 0x0010 (0x04A0 - 0x0490)
class UUITrial_BG_02 final : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASofdecMoviePlayer*                     MoviePlayer;                                       // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITrial_BG_02">();
	}
	static class UUITrial_BG_02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITrial_BG_02>();
	}
};
static_assert(alignof(UUITrial_BG_02) == 0x000008, "Wrong alignment on UUITrial_BG_02");
static_assert(sizeof(UUITrial_BG_02) == 0x0004A0, "Wrong size on UUITrial_BG_02");
static_assert(offsetof(UUITrial_BG_02, MoviePlayer) == 0x000498, "Member 'UUITrial_BG_02::MoviePlayer' has a wrong offset!");

// Class DarwinGame.UITutorialGuide
// 0x0028 (0x04B8 - 0x0490)
class UUITutorialGuide : public UDarwinUserWidget
{
public:
	TArray<class UUITutorialGuide_Content*>       GuideContents;                                     // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGuide(const class FName& GuideId, float ShowTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialGuide">();
	}
	static class UUITutorialGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorialGuide>();
	}
};
static_assert(alignof(UUITutorialGuide) == 0x000008, "Wrong alignment on UUITutorialGuide");
static_assert(sizeof(UUITutorialGuide) == 0x0004B8, "Wrong size on UUITutorialGuide");
static_assert(offsetof(UUITutorialGuide, GuideContents) == 0x000490, "Member 'UUITutorialGuide::GuideContents' has a wrong offset!");

// Class DarwinGame.UITutorialGuide_Content
// 0x0038 (0x04C8 - 0x0490)
class UUITutorialGuide_Content : public UDarwinUserWidget
{
public:
	class UTextWidget*                            Command;                                           // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidgetData*                        CommandData;                                       // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               CommandBox;                                        // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                CommandSpacer;                                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidget*                            Action;                                            // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextWidgetData*                        ActionData;                                        // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               ActionBox;                                         // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetText(const class FString& CommandText, const class FString& ActionText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialGuide_Content">();
	}
	static class UUITutorialGuide_Content* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorialGuide_Content>();
	}
};
static_assert(alignof(UUITutorialGuide_Content) == 0x000008, "Wrong alignment on UUITutorialGuide_Content");
static_assert(sizeof(UUITutorialGuide_Content) == 0x0004C8, "Wrong size on UUITutorialGuide_Content");
static_assert(offsetof(UUITutorialGuide_Content, Command) == 0x000490, "Member 'UUITutorialGuide_Content::Command' has a wrong offset!");
static_assert(offsetof(UUITutorialGuide_Content, CommandData) == 0x000498, "Member 'UUITutorialGuide_Content::CommandData' has a wrong offset!");
static_assert(offsetof(UUITutorialGuide_Content, CommandBox) == 0x0004A0, "Member 'UUITutorialGuide_Content::CommandBox' has a wrong offset!");
static_assert(offsetof(UUITutorialGuide_Content, CommandSpacer) == 0x0004A8, "Member 'UUITutorialGuide_Content::CommandSpacer' has a wrong offset!");
static_assert(offsetof(UUITutorialGuide_Content, Action) == 0x0004B0, "Member 'UUITutorialGuide_Content::Action' has a wrong offset!");
static_assert(offsetof(UUITutorialGuide_Content, ActionData) == 0x0004B8, "Member 'UUITutorialGuide_Content::ActionData' has a wrong offset!");
static_assert(offsetof(UUITutorialGuide_Content, ActionBox) == 0x0004C0, "Member 'UUITutorialGuide_Content::ActionBox' has a wrong offset!");

// Class DarwinGame.UITutorialGuideDataTable
// 0x0000 (0x0030 - 0x0030)
class UUITutorialGuideDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialGuideDataTable">();
	}
	static class UUITutorialGuideDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorialGuideDataTable>();
	}
};
static_assert(alignof(UUITutorialGuideDataTable) == 0x000008, "Wrong alignment on UUITutorialGuideDataTable");
static_assert(sizeof(UUITutorialGuideDataTable) == 0x000030, "Wrong size on UUITutorialGuideDataTable");

// Class DarwinGame.UITutorialVisionDataTable
// 0x0000 (0x0030 - 0x0030)
class UUITutorialVisionDataTable final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutorialVisionDataTable">();
	}
	static class UUITutorialVisionDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutorialVisionDataTable>();
	}
};
static_assert(alignof(UUITutorialVisionDataTable) == 0x000008, "Wrong alignment on UUITutorialVisionDataTable");
static_assert(sizeof(UUITutorialVisionDataTable) == 0x000030, "Wrong size on UUITutorialVisionDataTable");

// Class DarwinGame.UIType_Legend_00
// 0x0050 (0x04E0 - 0x0490)
class UUIType_Legend_00 final : public UDarwinUserWidget
{
public:
	class UDataTable*                             WordDataTable;                                     // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExclamationMarkNum;                                // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LegendWordMax;                                     // 0x049C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         LegendWordList;                                    // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         FlashLegendWordList;                               // 0x04B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x20];                                     // 0x04C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIType_Legend_00">();
	}
	static class UUIType_Legend_00* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIType_Legend_00>();
	}
};
static_assert(alignof(UUIType_Legend_00) == 0x000008, "Wrong alignment on UUIType_Legend_00");
static_assert(sizeof(UUIType_Legend_00) == 0x0004E0, "Wrong size on UUIType_Legend_00");
static_assert(offsetof(UUIType_Legend_00, WordDataTable) == 0x000490, "Member 'UUIType_Legend_00::WordDataTable' has a wrong offset!");
static_assert(offsetof(UUIType_Legend_00, ExclamationMarkNum) == 0x000498, "Member 'UUIType_Legend_00::ExclamationMarkNum' has a wrong offset!");
static_assert(offsetof(UUIType_Legend_00, LegendWordMax) == 0x00049C, "Member 'UUIType_Legend_00::LegendWordMax' has a wrong offset!");
static_assert(offsetof(UUIType_Legend_00, LegendWordList) == 0x0004A0, "Member 'UUIType_Legend_00::LegendWordList' has a wrong offset!");
static_assert(offsetof(UUIType_Legend_00, FlashLegendWordList) == 0x0004B0, "Member 'UUIType_Legend_00::FlashLegendWordList' has a wrong offset!");

// Class DarwinGame.UIUnder_Button
// 0x0050 (0x04E0 - 0x0490)
class UUIUnder_Button : public UDarwinUserWidget
{
public:
	class FName                                   DefaultButtonType;                                 // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IconPadding;                                       // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextPadding;                                       // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             UnderButtonDataTable;                              // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             UnderButtonIconDataTable;                          // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x30];                                     // 0x04B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetButtonType(class FName ButtonType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUnder_Button">();
	}
	static class UUIUnder_Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUnder_Button>();
	}
};
static_assert(alignof(UUIUnder_Button) == 0x000008, "Wrong alignment on UUIUnder_Button");
static_assert(sizeof(UUIUnder_Button) == 0x0004E0, "Wrong size on UUIUnder_Button");
static_assert(offsetof(UUIUnder_Button, DefaultButtonType) == 0x000490, "Member 'UUIUnder_Button::DefaultButtonType' has a wrong offset!");
static_assert(offsetof(UUIUnder_Button, IconPadding) == 0x000498, "Member 'UUIUnder_Button::IconPadding' has a wrong offset!");
static_assert(offsetof(UUIUnder_Button, TextPadding) == 0x00049C, "Member 'UUIUnder_Button::TextPadding' has a wrong offset!");
static_assert(offsetof(UUIUnder_Button, UnderButtonDataTable) == 0x0004A0, "Member 'UUIUnder_Button::UnderButtonDataTable' has a wrong offset!");
static_assert(offsetof(UUIUnder_Button, UnderButtonIconDataTable) == 0x0004A8, "Member 'UUIUnder_Button::UnderButtonIconDataTable' has a wrong offset!");

// Class DarwinGame.UIUnknownArtifact_Eff01
// 0x0060 (0x04F0 - 0x0490)
class UUIUnknownArtifact_Eff01 : public UDarwinUserWidget
{
public:
	class UImage*                                 Eff01Image;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Eff02Image;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EUnknownArtifactEffectType, struct FUnknownArtifactEffectResources> EffectResourcesList;                               // 0x04A0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void PlayEffect(EArtifactType ArtifactType, bool IsReplica);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUnknownArtifact_Eff01">();
	}
	static class UUIUnknownArtifact_Eff01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUnknownArtifact_Eff01>();
	}
};
static_assert(alignof(UUIUnknownArtifact_Eff01) == 0x000008, "Wrong alignment on UUIUnknownArtifact_Eff01");
static_assert(sizeof(UUIUnknownArtifact_Eff01) == 0x0004F0, "Wrong size on UUIUnknownArtifact_Eff01");
static_assert(offsetof(UUIUnknownArtifact_Eff01, Eff01Image) == 0x000490, "Member 'UUIUnknownArtifact_Eff01::Eff01Image' has a wrong offset!");
static_assert(offsetof(UUIUnknownArtifact_Eff01, Eff02Image) == 0x000498, "Member 'UUIUnknownArtifact_Eff01::Eff02Image' has a wrong offset!");
static_assert(offsetof(UUIUnknownArtifact_Eff01, EffectResourcesList) == 0x0004A0, "Member 'UUIUnknownArtifact_Eff01::EffectResourcesList' has a wrong offset!");

// Class DarwinGame.UIUnknownArtifact_Pop
// 0x0020 (0x05D0 - 0x05B0)
class UUIUnknownArtifact_Pop : public UUI3DBase
{
public:
	class UImage*                                 UnknownArtifactImage;                              // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OneShotAnimTime;                                   // 0x05B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OneShotAnimTimeReplica;                            // 0x05B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayOneShotPopAnimation();
	void SetData(class AActor* Target, int32 ArtifactID, EArtifactType ArtifactType, bool InIsReplica);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUnknownArtifact_Pop">();
	}
	static class UUIUnknownArtifact_Pop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUnknownArtifact_Pop>();
	}
};
static_assert(alignof(UUIUnknownArtifact_Pop) == 0x000010, "Wrong alignment on UUIUnknownArtifact_Pop");
static_assert(sizeof(UUIUnknownArtifact_Pop) == 0x0005D0, "Wrong size on UUIUnknownArtifact_Pop");
static_assert(offsetof(UUIUnknownArtifact_Pop, UnknownArtifactImage) == 0x0005A8, "Member 'UUIUnknownArtifact_Pop::UnknownArtifactImage' has a wrong offset!");
static_assert(offsetof(UUIUnknownArtifact_Pop, OneShotAnimTime) == 0x0005B0, "Member 'UUIUnknownArtifact_Pop::OneShotAnimTime' has a wrong offset!");
static_assert(offsetof(UUIUnknownArtifact_Pop, OneShotAnimTimeReplica) == 0x0005B4, "Member 'UUIUnknownArtifact_Pop::OneShotAnimTimeReplica' has a wrong offset!");

// Class DarwinGame.UIUnknownHubPop
// 0x0010 (0x05C0 - 0x05B0)
class UUIUnknownHubPop : public UUI3DBase
{
public:
	float                                         OneShotAnimTime;                                   // 0x05A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AC[0x14];                                     // 0x05AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUnknownHubPop">();
	}
	static class UUIUnknownHubPop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUnknownHubPop>();
	}
};
static_assert(alignof(UUIUnknownHubPop) == 0x000010, "Wrong alignment on UUIUnknownHubPop");
static_assert(sizeof(UUIUnknownHubPop) == 0x0005C0, "Wrong size on UUIUnknownHubPop");
static_assert(offsetof(UUIUnknownHubPop, OneShotAnimTime) == 0x0005A8, "Member 'UUIUnknownHubPop::OneShotAnimTime' has a wrong offset!");

// Class DarwinGame.UIUpDownIcon
// 0x0018 (0x04A8 - 0x0490)
class UUIUpDownIcon final : public UDarwinUserWidget
{
public:
	class UImage*                                 IconImage;                                         // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             UpTexture;                                         // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             DownTexture;                                       // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitWidget(class UImage* iconImg, class UTexture2D* upTex, class UTexture2D* downTex);
	void SetData(int32 InParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUpDownIcon">();
	}
	static class UUIUpDownIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUpDownIcon>();
	}
};
static_assert(alignof(UUIUpDownIcon) == 0x000008, "Wrong alignment on UUIUpDownIcon");
static_assert(sizeof(UUIUpDownIcon) == 0x0004A8, "Wrong size on UUIUpDownIcon");
static_assert(offsetof(UUIUpDownIcon, IconImage) == 0x000490, "Member 'UUIUpDownIcon::IconImage' has a wrong offset!");
static_assert(offsetof(UUIUpDownIcon, UpTexture) == 0x000498, "Member 'UUIUpDownIcon::UpTexture' has a wrong offset!");
static_assert(offsetof(UUIUpDownIcon, DownTexture) == 0x0004A0, "Member 'UUIUpDownIcon::DownTexture' has a wrong offset!");

// Class DarwinGame.UIUseItemName
// 0x0008 (0x0498 - 0x0490)
class UUIUseItemName final : public UDarwinUserWidget
{
public:
	class UImage*                                 ImgItemIcon;                                       // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUseItemName">();
	}
	static class UUIUseItemName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUseItemName>();
	}
};
static_assert(alignof(UUIUseItemName) == 0x000008, "Wrong alignment on UUIUseItemName");
static_assert(sizeof(UUIUseItemName) == 0x000498, "Wrong size on UUIUseItemName");
static_assert(offsetof(UUIUseItemName, ImgItemIcon) == 0x000490, "Member 'UUIUseItemName::ImgItemIcon' has a wrong offset!");

// Class DarwinGame.UIVision
// 0x0060 (0x04F0 - 0x0490)
class UUIVision : public UDarwinUserWidget
{
public:
	class UUIVision_Name*                         VisionName;                                        // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CaptureImage;                                      // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVision_Select*                       VisionSelect;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         VisionSound;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIUnder_Button*                        UnderButton;                                       // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x38];                                     // 0x04B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCaptureImage();
	void Setup(const TArray<int32>& InMatchMonsterList, int32 FirstFocusIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision">();
	}
	static class UUIVision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision>();
	}
};
static_assert(alignof(UUIVision) == 0x000008, "Wrong alignment on UUIVision");
static_assert(sizeof(UUIVision) == 0x0004F0, "Wrong size on UUIVision");
static_assert(offsetof(UUIVision, VisionName) == 0x000490, "Member 'UUIVision::VisionName' has a wrong offset!");
static_assert(offsetof(UUIVision, CaptureImage) == 0x000498, "Member 'UUIVision::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIVision, VisionSelect) == 0x0004A0, "Member 'UUIVision::VisionSelect' has a wrong offset!");
static_assert(offsetof(UUIVision, VisionSound) == 0x0004A8, "Member 'UUIVision::VisionSound' has a wrong offset!");
static_assert(offsetof(UUIVision, UnderButton) == 0x0004B0, "Member 'UUIVision::UnderButton' has a wrong offset!");

// Class DarwinGame.UIVision_CutIn
// 0x0058 (0x04E8 - 0x0490)
class UUIVision_CutIn : public UDarwinUserWidget
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      CutInTextureList;                                  // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> CutInMaterialList;                                 // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Char_Base;                                         // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Char_Add;                                          // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       InAnim;                                            // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ImageMaterial;                                     // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x18];                                     // 0x04D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InAnimEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_CutIn">();
	}
	static class UUIVision_CutIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_CutIn>();
	}
};
static_assert(alignof(UUIVision_CutIn) == 0x000008, "Wrong alignment on UUIVision_CutIn");
static_assert(sizeof(UUIVision_CutIn) == 0x0004E8, "Wrong size on UUIVision_CutIn");
static_assert(offsetof(UUIVision_CutIn, CutInTextureList) == 0x000490, "Member 'UUIVision_CutIn::CutInTextureList' has a wrong offset!");
static_assert(offsetof(UUIVision_CutIn, CutInMaterialList) == 0x0004A0, "Member 'UUIVision_CutIn::CutInMaterialList' has a wrong offset!");
static_assert(offsetof(UUIVision_CutIn, Char_Base) == 0x0004B0, "Member 'UUIVision_CutIn::Char_Base' has a wrong offset!");
static_assert(offsetof(UUIVision_CutIn, Char_Add) == 0x0004B8, "Member 'UUIVision_CutIn::Char_Add' has a wrong offset!");
static_assert(offsetof(UUIVision_CutIn, InAnim) == 0x0004C0, "Member 'UUIVision_CutIn::InAnim' has a wrong offset!");
static_assert(offsetof(UUIVision_CutIn, ImageMaterial) == 0x0004C8, "Member 'UUIVision_CutIn::ImageMaterial' has a wrong offset!");

// Class DarwinGame.UIVision_Field
// 0x0070 (0x0500 - 0x0490)
class UUIVision_Field : public UDarwinUserWidget
{
public:
	TArray<class UUIVision_FieldIconChoice*>      VisionCaptures;                                    // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CaptureImage;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWhiteOut*                            WhiteOut;                                          // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      VisionCaptureBackGroundList;                       // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x40];                                     // 0x04C0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveSense();
	void FrameIn(EVisionFrameOutFlag Flag);
	void FrameOut(EVisionFrameOutFlag Flag);
	void InactiveSense();
	void Maximize();
	void MinimizeCaptureImage();
	void SetMute(bool bInIsMute);
	void SetTutorial(const EVisionPattern& Pattern);
	void SetupTutorial(const EVisionPattern& Pattern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Field">();
	}
	static class UUIVision_Field* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Field>();
	}
};
static_assert(alignof(UUIVision_Field) == 0x000008, "Wrong alignment on UUIVision_Field");
static_assert(sizeof(UUIVision_Field) == 0x000500, "Wrong size on UUIVision_Field");
static_assert(offsetof(UUIVision_Field, VisionCaptures) == 0x000490, "Member 'UUIVision_Field::VisionCaptures' has a wrong offset!");
static_assert(offsetof(UUIVision_Field, CaptureImage) == 0x0004A0, "Member 'UUIVision_Field::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIVision_Field, WhiteOut) == 0x0004A8, "Member 'UUIVision_Field::WhiteOut' has a wrong offset!");
static_assert(offsetof(UUIVision_Field, VisionCaptureBackGroundList) == 0x0004B0, "Member 'UUIVision_Field::VisionCaptureBackGroundList' has a wrong offset!");

// Class DarwinGame.UIVision_FieldIcon
// 0x0010 (0x04A0 - 0x0490)
class UUIVision_FieldIcon : public UDarwinUserWidget
{
public:
	class UImage*                                 CaptureImage;                                      // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundImage;                                   // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_FieldIcon">();
	}
	static class UUIVision_FieldIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_FieldIcon>();
	}
};
static_assert(alignof(UUIVision_FieldIcon) == 0x000008, "Wrong alignment on UUIVision_FieldIcon");
static_assert(sizeof(UUIVision_FieldIcon) == 0x0004A0, "Wrong size on UUIVision_FieldIcon");
static_assert(offsetof(UUIVision_FieldIcon, CaptureImage) == 0x000490, "Member 'UUIVision_FieldIcon::CaptureImage' has a wrong offset!");
static_assert(offsetof(UUIVision_FieldIcon, BackgroundImage) == 0x000498, "Member 'UUIVision_FieldIcon::BackgroundImage' has a wrong offset!");

// Class DarwinGame.UIVision_FieldIconChoice
// 0x0008 (0x0498 - 0x0490)
class UUIVision_FieldIconChoice : public UDarwinUserWidget
{
public:
	class UUIVision_FieldIcon*                    FieldIcon;                                         // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_FieldIconChoice">();
	}
	static class UUIVision_FieldIconChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_FieldIconChoice>();
	}
};
static_assert(alignof(UUIVision_FieldIconChoice) == 0x000008, "Wrong alignment on UUIVision_FieldIconChoice");
static_assert(sizeof(UUIVision_FieldIconChoice) == 0x000498, "Wrong size on UUIVision_FieldIconChoice");
static_assert(offsetof(UUIVision_FieldIconChoice, FieldIcon) == 0x000490, "Member 'UUIVision_FieldIconChoice::FieldIcon' has a wrong offset!");

// Class DarwinGame.UIVision_Menu
// 0x0050 (0x04E0 - 0x0490)
class UUIVision_Menu final : public UDarwinUserWidget
{
public:
	TArray<class UUIVision_Select_Panel*>         PanelList;                                         // 0x0490(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVision_Wave_Eff*                     WaveEff;                                           // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FST_VisionSelectPanelData>      PanelDatas;                                        // 0x04A8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PictureImage;                                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x20];                                     // 0x04C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChoiceInEnd();
	void ChoiceOutEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Menu">();
	}
	static class UUIVision_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Menu>();
	}
};
static_assert(alignof(UUIVision_Menu) == 0x000008, "Wrong alignment on UUIVision_Menu");
static_assert(sizeof(UUIVision_Menu) == 0x0004E0, "Wrong size on UUIVision_Menu");
static_assert(offsetof(UUIVision_Menu, PanelList) == 0x000490, "Member 'UUIVision_Menu::PanelList' has a wrong offset!");
static_assert(offsetof(UUIVision_Menu, WaveEff) == 0x0004A0, "Member 'UUIVision_Menu::WaveEff' has a wrong offset!");
static_assert(offsetof(UUIVision_Menu, PanelDatas) == 0x0004A8, "Member 'UUIVision_Menu::PanelDatas' has a wrong offset!");
static_assert(offsetof(UUIVision_Menu, PictureImage) == 0x0004B8, "Member 'UUIVision_Menu::PictureImage' has a wrong offset!");

// Class DarwinGame.UIVision_Menu_Root
// 0x0040 (0x0510 - 0x04D0)
class UUIVision_Menu_Root : public UUIInitWidget_Root
{
public:
	class UUIWhiteFade*                           FadePanel;                                         // 0x04D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 BackImage;                                         // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0x30];                                     // 0x04E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(const TArray<int32>& InMatchMonsterList, const EVisionPattern& InPattern);
	void SetFadeType(const EWhiteFadeState& InFadeState);
	void SetMute(bool InIsMute);
	void SetTutorial(const EVisionPattern& InPattern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Menu_Root">();
	}
	static class UUIVision_Menu_Root* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Menu_Root>();
	}
};
static_assert(alignof(UUIVision_Menu_Root) == 0x000008, "Wrong alignment on UUIVision_Menu_Root");
static_assert(sizeof(UUIVision_Menu_Root) == 0x000510, "Wrong size on UUIVision_Menu_Root");
static_assert(offsetof(UUIVision_Menu_Root, FadePanel) == 0x0004D0, "Member 'UUIVision_Menu_Root::FadePanel' has a wrong offset!");
static_assert(offsetof(UUIVision_Menu_Root, BackImage) == 0x0004D8, "Member 'UUIVision_Menu_Root::BackImage' has a wrong offset!");

// Class DarwinGame.UIVision_MonsterIcon
// 0x0058 (0x0588 - 0x0530)
class UUIVision_MonsterIcon : public UUIScrollMenuItemBase
{
public:
	uint8                                         Pad_530[0x58];                                     // 0x0530(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PanelWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_MonsterIcon">();
	}
	static class UUIVision_MonsterIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_MonsterIcon>();
	}
};
static_assert(alignof(UUIVision_MonsterIcon) == 0x000008, "Wrong alignment on UUIVision_MonsterIcon");
static_assert(sizeof(UUIVision_MonsterIcon) == 0x000588, "Wrong size on UUIVision_MonsterIcon");

// Class DarwinGame.UIVision_MonsterName
// 0x0028 (0x04B8 - 0x0490)
class UUIVision_MonsterName final : public UDarwinUserWidget
{
public:
	TArray<class UTexture2D*>                     NameBaseData;                                      // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     NameBaseTailData;                                  // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_MonsterName">();
	}
	static class UUIVision_MonsterName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_MonsterName>();
	}
};
static_assert(alignof(UUIVision_MonsterName) == 0x000008, "Wrong alignment on UUIVision_MonsterName");
static_assert(sizeof(UUIVision_MonsterName) == 0x0004B8, "Wrong size on UUIVision_MonsterName");
static_assert(offsetof(UUIVision_MonsterName, NameBaseData) == 0x000490, "Member 'UUIVision_MonsterName::NameBaseData' has a wrong offset!");
static_assert(offsetof(UUIVision_MonsterName, NameBaseTailData) == 0x0004A0, "Member 'UUIVision_MonsterName::NameBaseTailData' has a wrong offset!");

// Class DarwinGame.UIVision_Name
// 0x0000 (0x0490 - 0x0490)
class UUIVision_Name : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Name">();
	}
	static class UUIVision_Name* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Name>();
	}
};
static_assert(alignof(UUIVision_Name) == 0x000008, "Wrong alignment on UUIVision_Name");
static_assert(sizeof(UUIVision_Name) == 0x000490, "Wrong size on UUIVision_Name");

// Class DarwinGame.UIVision_Select
// 0x0020 (0x05F0 - 0x05D0)
class UUIVision_Select : public UUIScrollMenuBase
{
public:
	TArray<class UUIScrollMenuItemBase*>          Items;                                             // 0x05D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 MonsterList;                                       // 0x05E0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Select">();
	}
	static class UUIVision_Select* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Select>();
	}
};
static_assert(alignof(UUIVision_Select) == 0x000008, "Wrong alignment on UUIVision_Select");
static_assert(sizeof(UUIVision_Select) == 0x0005F0, "Wrong size on UUIVision_Select");
static_assert(offsetof(UUIVision_Select, Items) == 0x0005D0, "Member 'UUIVision_Select::Items' has a wrong offset!");
static_assert(offsetof(UUIVision_Select, MonsterList) == 0x0005E0, "Member 'UUIVision_Select::MonsterList' has a wrong offset!");

// Class DarwinGame.UIVision_Select_Panel
// 0x0030 (0x04C0 - 0x0490)
class UUIVision_Select_Panel final : public UDarwinUserWidget
{
public:
	TArray<struct FST_VisionPanelFrame>           EffectData;                                        // 0x0490(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 VisionCapture;                                     // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVision_MonsterIcon*                  MonsterIcon;                                       // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVision_MonsterName*                  MonsterName;                                       // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFocusEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Select_Panel">();
	}
	static class UUIVision_Select_Panel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Select_Panel>();
	}
};
static_assert(alignof(UUIVision_Select_Panel) == 0x000008, "Wrong alignment on UUIVision_Select_Panel");
static_assert(sizeof(UUIVision_Select_Panel) == 0x0004C0, "Wrong size on UUIVision_Select_Panel");
static_assert(offsetof(UUIVision_Select_Panel, EffectData) == 0x000490, "Member 'UUIVision_Select_Panel::EffectData' has a wrong offset!");
static_assert(offsetof(UUIVision_Select_Panel, VisionCapture) == 0x0004A0, "Member 'UUIVision_Select_Panel::VisionCapture' has a wrong offset!");
static_assert(offsetof(UUIVision_Select_Panel, MonsterIcon) == 0x0004A8, "Member 'UUIVision_Select_Panel::MonsterIcon' has a wrong offset!");
static_assert(offsetof(UUIVision_Select_Panel, MonsterName) == 0x0004B0, "Member 'UUIVision_Select_Panel::MonsterName' has a wrong offset!");

// Class DarwinGame.UIVision_Triangle
// 0x0000 (0x0490 - 0x0490)
class UUIVision_Triangle final : public UDarwinUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVision_Triangle">();
	}
	static class UUIVision_Triangle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVision_Triangle>();
	}
};
static_assert(alignof(UUIVision_Triangle) == 0x000008, "Wrong alignment on UUIVision_Triangle");
static_assert(sizeof(UUIVision_Triangle) == 0x000490, "Wrong size on UUIVision_Triangle");

// Class DarwinGame.UIVolume_01
// 0x00A0 (0x05D0 - 0x0530)
class UUIVolume_01 : public UUIScrollMenuItemBase
{
public:
	TArray<class UTexture2D*>                     SoundVolumeIcons;                                  // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     ScreenVolumeIcons;                                 // 0x0540(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     BrightnessVolumeIcons;                             // 0x0550(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     DensityVolumeIcons;                                // 0x0560(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     AntialiasingVolumeIcons;                           // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     LODVolumeIcons;                                    // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     AmbientVolumeIcons;                                // 0x0590(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VolumeSpeed;                                       // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIGaugeBase*                           VolumeGauge;                                       // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x20];                                     // 0x05B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVolume_01">();
	}
	static class UUIVolume_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVolume_01>();
	}
};
static_assert(alignof(UUIVolume_01) == 0x000008, "Wrong alignment on UUIVolume_01");
static_assert(sizeof(UUIVolume_01) == 0x0005D0, "Wrong size on UUIVolume_01");
static_assert(offsetof(UUIVolume_01, SoundVolumeIcons) == 0x000530, "Member 'UUIVolume_01::SoundVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, ScreenVolumeIcons) == 0x000540, "Member 'UUIVolume_01::ScreenVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, BrightnessVolumeIcons) == 0x000550, "Member 'UUIVolume_01::BrightnessVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, DensityVolumeIcons) == 0x000560, "Member 'UUIVolume_01::DensityVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, AntialiasingVolumeIcons) == 0x000570, "Member 'UUIVolume_01::AntialiasingVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, LODVolumeIcons) == 0x000580, "Member 'UUIVolume_01::LODVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, AmbientVolumeIcons) == 0x000590, "Member 'UUIVolume_01::AmbientVolumeIcons' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, VolumeSpeed) == 0x0005A0, "Member 'UUIVolume_01::VolumeSpeed' has a wrong offset!");
static_assert(offsetof(UUIVolume_01, VolumeGauge) == 0x0005A8, "Member 'UUIVolume_01::VolumeGauge' has a wrong offset!");

// Class DarwinGame.UIWhiteFade
// 0x0058 (0x04E8 - 0x0490)
class UUIWhiteFade : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       FadeInAnim;                                        // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FadeOutAnim;                                       // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FadeInHalfAnim;                                    // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       FadeOutHalfAnim;                                   // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       PlayingAnim;                                       // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x10];                                     // 0x04D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWhiteFade">();
	}
	static class UUIWhiteFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWhiteFade>();
	}
};
static_assert(alignof(UUIWhiteFade) == 0x000008, "Wrong alignment on UUIWhiteFade");
static_assert(sizeof(UUIWhiteFade) == 0x0004E8, "Wrong size on UUIWhiteFade");
static_assert(offsetof(UUIWhiteFade, FadeInAnim) == 0x0004B0, "Member 'UUIWhiteFade::FadeInAnim' has a wrong offset!");
static_assert(offsetof(UUIWhiteFade, FadeOutAnim) == 0x0004B8, "Member 'UUIWhiteFade::FadeOutAnim' has a wrong offset!");
static_assert(offsetof(UUIWhiteFade, FadeInHalfAnim) == 0x0004C0, "Member 'UUIWhiteFade::FadeInHalfAnim' has a wrong offset!");
static_assert(offsetof(UUIWhiteFade, FadeOutHalfAnim) == 0x0004C8, "Member 'UUIWhiteFade::FadeOutHalfAnim' has a wrong offset!");
static_assert(offsetof(UUIWhiteFade, PlayingAnim) == 0x0004D0, "Member 'UUIWhiteFade::PlayingAnim' has a wrong offset!");

// Class DarwinGame.UIWhiteOut
// 0x0020 (0x04B0 - 0x0490)
class UUIWhiteOut : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x20];                                     // 0x0490(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWhiteOut">();
	}
	static class UUIWhiteOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWhiteOut>();
	}
};
static_assert(alignof(UUIWhiteOut) == 0x000008, "Wrong alignment on UUIWhiteOut");
static_assert(sizeof(UUIWhiteOut) == 0x0004B0, "Wrong size on UUIWhiteOut");

// Class DarwinGame.UIWinBaseSetting
// 0x0028 (0x05F8 - 0x05D0)
class UUIWinBaseSetting : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x28];                                     // 0x05D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinBaseSetting">();
	}
	static class UUIWinBaseSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinBaseSetting>();
	}
};
static_assert(alignof(UUIWinBaseSetting) == 0x000008, "Wrong alignment on UUIWinBaseSetting");
static_assert(sizeof(UUIWinBaseSetting) == 0x0005F8, "Wrong size on UUIWinBaseSetting");

// Class DarwinGame.UIWinControlLayoutBase
// 0x0008 (0x05D8 - 0x05D0)
class UUIWinControlLayoutBase : public UUIScrollMenuBase
{
public:
	class UAutoTextBlock*                         HeaderTitleText;                                   // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinControlLayoutBase">();
	}
	static class UUIWinControlLayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinControlLayoutBase>();
	}
};
static_assert(alignof(UUIWinControlLayoutBase) == 0x000008, "Wrong alignment on UUIWinControlLayoutBase");
static_assert(sizeof(UUIWinControlLayoutBase) == 0x0005D8, "Wrong size on UUIWinControlLayoutBase");
static_assert(offsetof(UUIWinControlLayoutBase, HeaderTitleText) == 0x0005D0, "Member 'UUIWinControlLayoutBase::HeaderTitleText' has a wrong offset!");

// Class DarwinGame.UIWinControlLayoutController
// 0x0090 (0x0668 - 0x05D8)
class UUIWinControlLayoutController : public UUIWinControlLayoutBase
{
public:
	uint8                                         Pad_5D8[0x10];                                     // 0x05D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     ChoiceButtons;                                     // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIIconChoice*                          DecideButton;                                      // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EWinControllerTexture, class UTexture2D*> ControllerTextures;                                // 0x0600(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x18];                                     // 0x0650(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinControlLayoutController">();
	}
	static class UUIWinControlLayoutController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinControlLayoutController>();
	}
};
static_assert(alignof(UUIWinControlLayoutController) == 0x000008, "Wrong alignment on UUIWinControlLayoutController");
static_assert(sizeof(UUIWinControlLayoutController) == 0x000668, "Wrong size on UUIWinControlLayoutController");
static_assert(offsetof(UUIWinControlLayoutController, ChoiceButtons) == 0x0005E8, "Member 'UUIWinControlLayoutController::ChoiceButtons' has a wrong offset!");
static_assert(offsetof(UUIWinControlLayoutController, DecideButton) == 0x0005F8, "Member 'UUIWinControlLayoutController::DecideButton' has a wrong offset!");
static_assert(offsetof(UUIWinControlLayoutController, ControllerTextures) == 0x000600, "Member 'UUIWinControlLayoutController::ControllerTextures' has a wrong offset!");

// Class DarwinGame.UIWinControlLayoutKeyboard
// 0x0090 (0x0668 - 0x05D8)
class UUIWinControlLayoutKeyboard : public UUIWinControlLayoutBase
{
public:
	uint8                                         Pad_5D8[0x10];                                     // 0x05D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItemmenu_SortIconChoice*>     ChoiceButtons;                                     // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIIconChoice*                          DecideButton;                                      // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EWinKeyboardTexture, class UTexture2D*>  KeyboardTextures;                                  // 0x0600(0x0050)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x18];                                     // 0x0650(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinControlLayoutKeyboard">();
	}
	static class UUIWinControlLayoutKeyboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinControlLayoutKeyboard>();
	}
};
static_assert(alignof(UUIWinControlLayoutKeyboard) == 0x000008, "Wrong alignment on UUIWinControlLayoutKeyboard");
static_assert(sizeof(UUIWinControlLayoutKeyboard) == 0x000668, "Wrong size on UUIWinControlLayoutKeyboard");
static_assert(offsetof(UUIWinControlLayoutKeyboard, ChoiceButtons) == 0x0005E8, "Member 'UUIWinControlLayoutKeyboard::ChoiceButtons' has a wrong offset!");
static_assert(offsetof(UUIWinControlLayoutKeyboard, DecideButton) == 0x0005F8, "Member 'UUIWinControlLayoutKeyboard::DecideButton' has a wrong offset!");
static_assert(offsetof(UUIWinControlLayoutKeyboard, KeyboardTextures) == 0x000600, "Member 'UUIWinControlLayoutKeyboard::KeyboardTextures' has a wrong offset!");

// Class DarwinGame.UIWinControllerSetting
// 0x0198 (0x0790 - 0x05F8)
class UUIWinControllerSetting : public UUIWinBaseSetting
{
public:
	TArray<class FText>                           HeaderText;                                        // 0x05F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EGenericControllerMapping>             MappingList;                                       // 0x0608(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x178];                                    // 0x0618(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinControllerSetting">();
	}
	static class UUIWinControllerSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinControllerSetting>();
	}
};
static_assert(alignof(UUIWinControllerSetting) == 0x000008, "Wrong alignment on UUIWinControllerSetting");
static_assert(sizeof(UUIWinControllerSetting) == 0x000790, "Wrong size on UUIWinControllerSetting");
static_assert(offsetof(UUIWinControllerSetting, HeaderText) == 0x0005F8, "Member 'UUIWinControllerSetting::HeaderText' has a wrong offset!");
static_assert(offsetof(UUIWinControllerSetting, MappingList) == 0x000608, "Member 'UUIWinControllerSetting::MappingList' has a wrong offset!");

// Class DarwinGame.UIWinKeyboardSetting
// 0x0178 (0x0770 - 0x05F8)
class UUIWinKeyboardSetting : public UUIWinBaseSetting
{
public:
	TArray<class FName>                           DefaultConfigColumn1;                              // 0x05F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           DefaultConfigColumn2;                              // 0x0608(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x158];                                    // 0x0618(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinKeyboardSetting">();
	}
	static class UUIWinKeyboardSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinKeyboardSetting>();
	}
};
static_assert(alignof(UUIWinKeyboardSetting) == 0x000008, "Wrong alignment on UUIWinKeyboardSetting");
static_assert(sizeof(UUIWinKeyboardSetting) == 0x000770, "Wrong size on UUIWinKeyboardSetting");
static_assert(offsetof(UUIWinKeyboardSetting, DefaultConfigColumn1) == 0x0005F8, "Member 'UUIWinKeyboardSetting::DefaultConfigColumn1' has a wrong offset!");
static_assert(offsetof(UUIWinKeyboardSetting, DefaultConfigColumn2) == 0x000608, "Member 'UUIWinKeyboardSetting::DefaultConfigColumn2' has a wrong offset!");

// Class DarwinGame.UIWinMenu_CoinDiscard
// 0x0010 (0x0630 - 0x0620)
class UUIWinMenu_CoinDiscard : public UUIWinMenuSimple
{
public:
	class UTextBlock*                             TextWarningDescription;                            // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TextCount;                                         // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_CoinDiscard">();
	}
	static class UUIWinMenu_CoinDiscard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_CoinDiscard>();
	}
};
static_assert(alignof(UUIWinMenu_CoinDiscard) == 0x000008, "Wrong alignment on UUIWinMenu_CoinDiscard");
static_assert(sizeof(UUIWinMenu_CoinDiscard) == 0x000630, "Wrong size on UUIWinMenu_CoinDiscard");
static_assert(offsetof(UUIWinMenu_CoinDiscard, TextWarningDescription) == 0x000620, "Member 'UUIWinMenu_CoinDiscard::TextWarningDescription' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_CoinDiscard, TextCount) == 0x000628, "Member 'UUIWinMenu_CoinDiscard::TextCount' has a wrong offset!");

// Class DarwinGame.UIWinMenu_S_03
// 0x0008 (0x0498 - 0x0490)
class UUIWinMenu_S_03 : public UDarwinUserWidget
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_03">();
	}
	static class UUIWinMenu_S_03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_03>();
	}
};
static_assert(alignof(UUIWinMenu_S_03) == 0x000008, "Wrong alignment on UUIWinMenu_S_03");
static_assert(sizeof(UUIWinMenu_S_03) == 0x000498, "Wrong size on UUIWinMenu_S_03");

// Class DarwinGame.UIWinMenu_S_04
// 0x0028 (0x05F8 - 0x05D0)
class UUIWinMenu_S_04 : public UUIScrollMenuBase
{
public:
	class UAutoTextBlock*                         TextBlock;                                         // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIIconChoice*                          Button;                                            // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x18];                                     // 0x05E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_04">();
	}
	static class UUIWinMenu_S_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_04>();
	}
};
static_assert(alignof(UUIWinMenu_S_04) == 0x000008, "Wrong alignment on UUIWinMenu_S_04");
static_assert(sizeof(UUIWinMenu_S_04) == 0x0005F8, "Wrong size on UUIWinMenu_S_04");
static_assert(offsetof(UUIWinMenu_S_04, TextBlock) == 0x0005D0, "Member 'UUIWinMenu_S_04::TextBlock' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_S_04, Button) == 0x0005D8, "Member 'UUIWinMenu_S_04::Button' has a wrong offset!");

// Class DarwinGame.UIWinMenu_S_05
// 0x0030 (0x0600 - 0x05D0)
class UUIWinMenu_S_05 final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UComputeTextBlock*                      TextDescription;                                   // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIIconChoice*                          ButtonTwo[0x2];                                    // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_05">();
	}
	static class UUIWinMenu_S_05* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_05>();
	}
};
static_assert(alignof(UUIWinMenu_S_05) == 0x000008, "Wrong alignment on UUIWinMenu_S_05");
static_assert(sizeof(UUIWinMenu_S_05) == 0x000600, "Wrong size on UUIWinMenu_S_05");
static_assert(offsetof(UUIWinMenu_S_05, TextDescription) == 0x0005E0, "Member 'UUIWinMenu_S_05::TextDescription' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_S_05, ButtonTwo) == 0x0005E8, "Member 'UUIWinMenu_S_05::ButtonTwo' has a wrong offset!");

// Class DarwinGame.UIWinMenu_SH_02_Name
// 0x0058 (0x0628 - 0x05D0)
class UUIWinMenu_SH_02_Name : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINameBoxBase*                         UseBox;                                            // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUINameBoxBase*>                 NameBoxList;                                       // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIIconChoice*                          CloseButton;                                       // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIIconChoice*                          ButtonList[0x2];                                   // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x18];                                     // 0x0610(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_SH_02_Name">();
	}
	static class UUIWinMenu_SH_02_Name* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_SH_02_Name>();
	}
};
static_assert(alignof(UUIWinMenu_SH_02_Name) == 0x000008, "Wrong alignment on UUIWinMenu_SH_02_Name");
static_assert(sizeof(UUIWinMenu_SH_02_Name) == 0x000628, "Wrong size on UUIWinMenu_SH_02_Name");
static_assert(offsetof(UUIWinMenu_SH_02_Name, UseBox) == 0x0005E0, "Member 'UUIWinMenu_SH_02_Name::UseBox' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_SH_02_Name, NameBoxList) == 0x0005E8, "Member 'UUIWinMenu_SH_02_Name::NameBoxList' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_SH_02_Name, CloseButton) == 0x0005F8, "Member 'UUIWinMenu_SH_02_Name::CloseButton' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_SH_02_Name, ButtonList) == 0x000600, "Member 'UUIWinMenu_SH_02_Name::ButtonList' has a wrong offset!");

// Class DarwinGame.UIWinMenu_SH_03_Name
// 0x0070 (0x0640 - 0x05D0)
class UUIWinMenu_SH_03_Name final : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINameBoxBase*                         InputBox;                                          // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x38];                                     // 0x05F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TitleLabel;                                        // 0x0628(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UComputeTextBlock*                      InfoLabel;                                         // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_SH_03_Name">();
	}
	static class UUIWinMenu_SH_03_Name* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_SH_03_Name>();
	}
};
static_assert(alignof(UUIWinMenu_SH_03_Name) == 0x000008, "Wrong alignment on UUIWinMenu_SH_03_Name");
static_assert(sizeof(UUIWinMenu_SH_03_Name) == 0x000640, "Wrong size on UUIWinMenu_SH_03_Name");
static_assert(offsetof(UUIWinMenu_SH_03_Name, InputBox) == 0x0005E8, "Member 'UUIWinMenu_SH_03_Name::InputBox' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_SH_03_Name, TitleLabel) == 0x000628, "Member 'UUIWinMenu_SH_03_Name::TitleLabel' has a wrong offset!");
static_assert(offsetof(UUIWinMenu_SH_03_Name, InfoLabel) == 0x000630, "Member 'UUIWinMenu_SH_03_Name::InfoLabel' has a wrong offset!");

// Class DarwinGame.UIWinMenUMultipleChoices
// 0x0068 (0x0638 - 0x05D0)
class UUIWinMenUMultipleChoices : public UUIScrollMenuBase
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutoTextBlock*                         HeaderTitleText;                                   // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUIItemmenu_SortIconChoice*>     ChoiceButtons;                                     // 0x05E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUIIconChoice*                          DecideButton;                                      // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_600[0x38];                                     // 0x0600(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenUMultipleChoices">();
	}
	static class UUIWinMenUMultipleChoices* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenUMultipleChoices>();
	}
};
static_assert(alignof(UUIWinMenUMultipleChoices) == 0x000008, "Wrong alignment on UUIWinMenUMultipleChoices");
static_assert(sizeof(UUIWinMenUMultipleChoices) == 0x000638, "Wrong size on UUIWinMenUMultipleChoices");
static_assert(offsetof(UUIWinMenUMultipleChoices, HeaderTitleText) == 0x0005E0, "Member 'UUIWinMenUMultipleChoices::HeaderTitleText' has a wrong offset!");
static_assert(offsetof(UUIWinMenUMultipleChoices, ChoiceButtons) == 0x0005E8, "Member 'UUIWinMenUMultipleChoices::ChoiceButtons' has a wrong offset!");
static_assert(offsetof(UUIWinMenUMultipleChoices, DecideButton) == 0x0005F8, "Member 'UUIWinMenUMultipleChoices::DecideButton' has a wrong offset!");

// Class DarwinGame.UIWinMenu_S_01
// 0x0008 (0x0628 - 0x0620)
class UUIWinMenu_S_01 : public UUIWinMenuSimple
{
public:
	class UDataTable*                             ZOrderTable;                                       // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_01">();
	}
	static class UUIWinMenu_S_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_01>();
	}
};
static_assert(alignof(UUIWinMenu_S_01) == 0x000008, "Wrong alignment on UUIWinMenu_S_01");
static_assert(sizeof(UUIWinMenu_S_01) == 0x000628, "Wrong size on UUIWinMenu_S_01");
static_assert(offsetof(UUIWinMenu_S_01, ZOrderTable) == 0x000620, "Member 'UUIWinMenu_S_01::ZOrderTable' has a wrong offset!");

// Class DarwinGame.UIWinMenu_S_06
// 0x0000 (0x0620 - 0x0620)
class UUIWinMenu_S_06 final : public UUIWinMenuSimple
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_S_06">();
	}
	static class UUIWinMenu_S_06* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_S_06>();
	}
};
static_assert(alignof(UUIWinMenu_S_06) == 0x000008, "Wrong alignment on UUIWinMenu_S_06");
static_assert(sizeof(UUIWinMenu_S_06) == 0x000620, "Wrong size on UUIWinMenu_S_06");

// Class DarwinGame.UIWinMenu_SH_01
// 0x0008 (0x0628 - 0x0620)
class UUIWinMenu_SH_01 : public UUIWinMenuSimple
{
public:
	class UTextBlock*                             HeaderText;                                        // 0x0620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_SH_01">();
	}
	static class UUIWinMenu_SH_01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_SH_01>();
	}
};
static_assert(alignof(UUIWinMenu_SH_01) == 0x000008, "Wrong alignment on UUIWinMenu_SH_01");
static_assert(sizeof(UUIWinMenu_SH_01) == 0x000628, "Wrong size on UUIWinMenu_SH_01");
static_assert(offsetof(UUIWinMenu_SH_01, HeaderText) == 0x000620, "Member 'UUIWinMenu_SH_01::HeaderText' has a wrong offset!");

// Class DarwinGame.UIWinMenu_SH_04
// 0x0000 (0x0628 - 0x0628)
class UUIWinMenu_SH_04 : public UUIWinMenu_SH_01
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWinMenu_SH_04">();
	}
	static class UUIWinMenu_SH_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWinMenu_SH_04>();
	}
};
static_assert(alignof(UUIWinMenu_SH_04) == 0x000008, "Wrong alignment on UUIWinMenu_SH_04");
static_assert(sizeof(UUIWinMenu_SH_04) == 0x000628, "Wrong size on UUIWinMenu_SH_04");

// Class DarwinGame.UMGControlerInterface
// 0x0000 (0x0030 - 0x0030)
class IUMGControlerInterface final : public IInterface
{
public:
	void ResumeUMGAnimation();
	void StopUMGAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGControlerInterface">();
	}
	static class IUMGControlerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUMGControlerInterface>();
	}
};
static_assert(alignof(IUMGControlerInterface) == 0x000008, "Wrong alignment on IUMGControlerInterface");
static_assert(sizeof(IUMGControlerInterface) == 0x000030, "Wrong size on IUMGControlerInterface");

// Class DarwinGame.UpdatePerception
// 0x0000 (0x0038 - 0x0038)
class UUpdatePerception final : public UMonsterService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdatePerception">();
	}
	static class UUpdatePerception* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdatePerception>();
	}
};
static_assert(alignof(UUpdatePerception) == 0x000008, "Wrong alignment on UUpdatePerception");
static_assert(sizeof(UUpdatePerception) == 0x000038, "Wrong size on UUpdatePerception");

// Class DarwinGame.SizeFixImage
// 0x0010 (0x0228 - 0x0218)
class USizeFixImage final : public UImage
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SizeFixImage">();
	}
	static class USizeFixImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<USizeFixImage>();
	}
};
static_assert(alignof(USizeFixImage) == 0x000008, "Wrong alignment on USizeFixImage");
static_assert(sizeof(USizeFixImage) == 0x000228, "Wrong size on USizeFixImage");

// Class DarwinGame.SizeFixProgressBar
// 0x0210 (0x0320 - 0x0110)
class USizeFixProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x0110(0x01A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x02B0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImage;                                   // 0x02B8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImage;                                         // 0x02C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       MarqueeImage;                                      // 0x02C8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESizeFixProgressBarFillType                   BarFillType;                                       // 0x02D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarquee;                                        // 0x02D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PercentDelegate;                                   // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x0300(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetIsMarquee(bool InbIsMarquee);
	void SetPercent(float InPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SizeFixProgressBar">();
	}
	static class USizeFixProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<USizeFixProgressBar>();
	}
};
static_assert(alignof(USizeFixProgressBar) == 0x000008, "Wrong alignment on USizeFixProgressBar");
static_assert(sizeof(USizeFixProgressBar) == 0x000320, "Wrong size on USizeFixProgressBar");
static_assert(offsetof(USizeFixProgressBar, WidgetStyle) == 0x000110, "Member 'USizeFixProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, Style) == 0x0002B0, "Member 'USizeFixProgressBar::Style' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, BackgroundImage) == 0x0002B8, "Member 'USizeFixProgressBar::BackgroundImage' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, FillImage) == 0x0002C0, "Member 'USizeFixProgressBar::FillImage' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, MarqueeImage) == 0x0002C8, "Member 'USizeFixProgressBar::MarqueeImage' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, Percent) == 0x0002D0, "Member 'USizeFixProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, BarFillType) == 0x0002D4, "Member 'USizeFixProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, bIsMarquee) == 0x0002D5, "Member 'USizeFixProgressBar::bIsMarquee' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, BorderPadding) == 0x0002D8, "Member 'USizeFixProgressBar::BorderPadding' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, PercentDelegate) == 0x0002E0, "Member 'USizeFixProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, FillColorAndOpacity) == 0x0002F0, "Member 'USizeFixProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(USizeFixProgressBar, FillColorAndOpacityDelegate) == 0x000300, "Member 'USizeFixProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");

// Class DarwinGame.VisionCaptureCameraBase
// 0x0170 (0x03B0 - 0x0240)
class AVisionCaptureCameraBase : public ASceneCapture2D
{
public:
	TArray<class UTextureRenderTarget2D*>         VisionTextures;                                    // 0x0240(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FOVAngle;                                          // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BirdEyeAngle;                                      // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EVisionSightType, struct FMaterialVisionParam> mSightMaterialList;                                // 0x0258(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EVisionColorType, struct FMaterialVisionParam> mColorMaterialList;                                // 0x02A8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInstance>       mMaskTextureVisionMaterial;                        // 0x02F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FTextureMaskVisionParam> mMaskTextureParamList;                             // 0x0320(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              FailedTexture;                                     // 0x0370(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x18];                                     // 0x0398(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Capture(const int32 Index_0, const int32 Uid, const class FName KindId);
	void CaptureFailed(const int32 Index_0, const int32 Uid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisionCaptureCameraBase">();
	}
	static class AVisionCaptureCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVisionCaptureCameraBase>();
	}
};
static_assert(alignof(AVisionCaptureCameraBase) == 0x000008, "Wrong alignment on AVisionCaptureCameraBase");
static_assert(sizeof(AVisionCaptureCameraBase) == 0x0003B0, "Wrong size on AVisionCaptureCameraBase");
static_assert(offsetof(AVisionCaptureCameraBase, VisionTextures) == 0x000240, "Member 'AVisionCaptureCameraBase::VisionTextures' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, FOVAngle) == 0x000250, "Member 'AVisionCaptureCameraBase::FOVAngle' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, BirdEyeAngle) == 0x000254, "Member 'AVisionCaptureCameraBase::BirdEyeAngle' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, mSightMaterialList) == 0x000258, "Member 'AVisionCaptureCameraBase::mSightMaterialList' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, mColorMaterialList) == 0x0002A8, "Member 'AVisionCaptureCameraBase::mColorMaterialList' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, mMaskTextureVisionMaterial) == 0x0002F8, "Member 'AVisionCaptureCameraBase::mMaskTextureVisionMaterial' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, mMaskTextureParamList) == 0x000320, "Member 'AVisionCaptureCameraBase::mMaskTextureParamList' has a wrong offset!");
static_assert(offsetof(AVisionCaptureCameraBase, FailedTexture) == 0x000370, "Member 'AVisionCaptureCameraBase::FailedTexture' has a wrong offset!");

// Class DarwinGame.VoiceManager
// 0x00A0 (0x00D0 - 0x0030)
class UVoiceManager : public UObject
{
public:
	class UDataTable*                             KindVoiceList;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             NPCVoiceList;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             NPCVoiceListEn;                                    // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ExceptionVoiceList;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             KindVoiceListCueID;                                // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             KindVoiceListCueIDNPC;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             KindVoiceListCueIDUnique;                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             KindVoiceListCueIDException;                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TipsVoiceListCueID;                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TitleVoiceListCueID;                               // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELanguageVoiceType                            CurrentLanguageVoiceType;                          // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         GetArtifactVoice;                                  // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         ArrivalStationVoice;                               // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtomComponent*                         RivalTeamVoice;                                    // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0xC];                                       // 0x00A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EVoiceDataType                                BoardVoiceType;                                    // 0x00AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD[0x23];                                      // 0x00AD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceManager">();
	}
	static class UVoiceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceManager>();
	}
};
static_assert(alignof(UVoiceManager) == 0x000008, "Wrong alignment on UVoiceManager");
static_assert(sizeof(UVoiceManager) == 0x0000D0, "Wrong size on UVoiceManager");
static_assert(offsetof(UVoiceManager, KindVoiceList) == 0x000030, "Member 'UVoiceManager::KindVoiceList' has a wrong offset!");
static_assert(offsetof(UVoiceManager, NPCVoiceList) == 0x000038, "Member 'UVoiceManager::NPCVoiceList' has a wrong offset!");
static_assert(offsetof(UVoiceManager, NPCVoiceListEn) == 0x000040, "Member 'UVoiceManager::NPCVoiceListEn' has a wrong offset!");
static_assert(offsetof(UVoiceManager, ExceptionVoiceList) == 0x000048, "Member 'UVoiceManager::ExceptionVoiceList' has a wrong offset!");
static_assert(offsetof(UVoiceManager, KindVoiceListCueID) == 0x000050, "Member 'UVoiceManager::KindVoiceListCueID' has a wrong offset!");
static_assert(offsetof(UVoiceManager, KindVoiceListCueIDNPC) == 0x000058, "Member 'UVoiceManager::KindVoiceListCueIDNPC' has a wrong offset!");
static_assert(offsetof(UVoiceManager, KindVoiceListCueIDUnique) == 0x000060, "Member 'UVoiceManager::KindVoiceListCueIDUnique' has a wrong offset!");
static_assert(offsetof(UVoiceManager, KindVoiceListCueIDException) == 0x000068, "Member 'UVoiceManager::KindVoiceListCueIDException' has a wrong offset!");
static_assert(offsetof(UVoiceManager, TipsVoiceListCueID) == 0x000070, "Member 'UVoiceManager::TipsVoiceListCueID' has a wrong offset!");
static_assert(offsetof(UVoiceManager, TitleVoiceListCueID) == 0x000078, "Member 'UVoiceManager::TitleVoiceListCueID' has a wrong offset!");
static_assert(offsetof(UVoiceManager, CurrentLanguageVoiceType) == 0x000080, "Member 'UVoiceManager::CurrentLanguageVoiceType' has a wrong offset!");
static_assert(offsetof(UVoiceManager, GetArtifactVoice) == 0x000088, "Member 'UVoiceManager::GetArtifactVoice' has a wrong offset!");
static_assert(offsetof(UVoiceManager, ArrivalStationVoice) == 0x000090, "Member 'UVoiceManager::ArrivalStationVoice' has a wrong offset!");
static_assert(offsetof(UVoiceManager, RivalTeamVoice) == 0x000098, "Member 'UVoiceManager::RivalTeamVoice' has a wrong offset!");
static_assert(offsetof(UVoiceManager, BoardVoiceType) == 0x0000AC, "Member 'UVoiceManager::BoardVoiceType' has a wrong offset!");

// Class DarwinGame.WaterFallFlowBase
// 0x0028 (0x0250 - 0x0228)
class AWaterFallFlowBase final : public AActor
{
public:
	class UBoxComponent*                          BoxComp;                                           // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       SplineComp;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        ArrowComp;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FlowSpeed;                                         // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Target;                                            // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeginOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterFallFlowBase">();
	}
	static class AWaterFallFlowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterFallFlowBase>();
	}
};
static_assert(alignof(AWaterFallFlowBase) == 0x000008, "Wrong alignment on AWaterFallFlowBase");
static_assert(sizeof(AWaterFallFlowBase) == 0x000250, "Wrong size on AWaterFallFlowBase");
static_assert(offsetof(AWaterFallFlowBase, BoxComp) == 0x000228, "Member 'AWaterFallFlowBase::BoxComp' has a wrong offset!");
static_assert(offsetof(AWaterFallFlowBase, SplineComp) == 0x000230, "Member 'AWaterFallFlowBase::SplineComp' has a wrong offset!");
static_assert(offsetof(AWaterFallFlowBase, ArrowComp) == 0x000238, "Member 'AWaterFallFlowBase::ArrowComp' has a wrong offset!");
static_assert(offsetof(AWaterFallFlowBase, FlowSpeed) == 0x000240, "Member 'AWaterFallFlowBase::FlowSpeed' has a wrong offset!");
static_assert(offsetof(AWaterFallFlowBase, Target) == 0x000248, "Member 'AWaterFallFlowBase::Target' has a wrong offset!");

// Class DarwinGame.WaterStateBase
// 0x0010 (0x0180 - 0x0170)
class UWaterStateBase : public UMoveStateBase
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterStateBase">();
	}
	static class UWaterStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterStateBase>();
	}
};
static_assert(alignof(UWaterStateBase) == 0x000008, "Wrong alignment on UWaterStateBase");
static_assert(sizeof(UWaterStateBase) == 0x000180, "Wrong size on UWaterStateBase");

// Class DarwinGame.WaterStateSwim
// 0x0008 (0x0188 - 0x0180)
class UWaterStateSwim final : public UWaterStateBase
{
public:
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEffectVisiblity(bool Visibility);
	void SpawnSplash();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterStateSwim">();
	}
	static class UWaterStateSwim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterStateSwim>();
	}
};
static_assert(alignof(UWaterStateSwim) == 0x000008, "Wrong alignment on UWaterStateSwim");
static_assert(sizeof(UWaterStateSwim) == 0x000188, "Wrong size on UWaterStateSwim");

// Class DarwinGame.WaveBlockObjectBase
// 0x0020 (0x02D0 - 0x02B0)
class AWaveBlockObjectBase final : public AFieldObjectBase
{
public:
	class USceneComponent*                        mRoot;                                             // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Size;                                              // 0x02B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoxComponent;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaveBlockObjectBase">();
	}
	static class AWaveBlockObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaveBlockObjectBase>();
	}
};
static_assert(alignof(AWaveBlockObjectBase) == 0x000008, "Wrong alignment on AWaveBlockObjectBase");
static_assert(sizeof(AWaveBlockObjectBase) == 0x0002D0, "Wrong size on AWaveBlockObjectBase");
static_assert(offsetof(AWaveBlockObjectBase, mRoot) == 0x0002B0, "Member 'AWaveBlockObjectBase::mRoot' has a wrong offset!");
static_assert(offsetof(AWaveBlockObjectBase, Size) == 0x0002B8, "Member 'AWaveBlockObjectBase::Size' has a wrong offset!");
static_assert(offsetof(AWaveBlockObjectBase, BoxComponent) == 0x0002C8, "Member 'AWaveBlockObjectBase::BoxComponent' has a wrong offset!");

// Class DarwinGame.WideAreaMagicFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UWideAreaMagicFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WideAreaMagicFunctionLibrary">();
	}
	static class UWideAreaMagicFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWideAreaMagicFunctionLibrary>();
	}
};
static_assert(alignof(UWideAreaMagicFunctionLibrary) == 0x000008, "Wrong alignment on UWideAreaMagicFunctionLibrary");
static_assert(sizeof(UWideAreaMagicFunctionLibrary) == 0x000030, "Wrong size on UWideAreaMagicFunctionLibrary");

// Class DarwinGame.WindBase
// 0x0068 (0x0358 - 0x02F0)
class AWindBase final : public ASplineMeshObject
{
public:
	uint8                                         Pad_2F0[0x54];                                     // 0x02F0(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedToCenter;                                  // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisableRange;                                      // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitAngle;                                        // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapWind(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapWind(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindBase">();
	}
	static class AWindBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindBase>();
	}
};
static_assert(alignof(AWindBase) == 0x000008, "Wrong alignment on AWindBase");
static_assert(sizeof(AWindBase) == 0x000358, "Wrong size on AWindBase");
static_assert(offsetof(AWindBase, MaxSpeed) == 0x000344, "Member 'AWindBase::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AWindBase, MaxSpeedToCenter) == 0x000348, "Member 'AWindBase::MaxSpeedToCenter' has a wrong offset!");
static_assert(offsetof(AWindBase, DisableRange) == 0x00034C, "Member 'AWindBase::DisableRange' has a wrong offset!");
static_assert(offsetof(AWindBase, LimitAngle) == 0x000350, "Member 'AWindBase::LimitAngle' has a wrong offset!");

// Class DarwinGame.WordClassUtility
// 0x0000 (0x0030 - 0x0030)
class UWordClassUtility final : public UBlueprintFunctionLibrary
{
public:
	static class FText SglListOf(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WordClassUtility">();
	}
	static class UWordClassUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWordClassUtility>();
	}
};
static_assert(alignof(UWordClassUtility) == 0x000008, "Wrong alignment on UWordClassUtility");
static_assert(sizeof(UWordClassUtility) == 0x000030, "Wrong size on UWordClassUtility");

// Class DarwinGame.WorldTimeManager
// 0x0070 (0x00A0 - 0x0030)
class UWorldTimeManager : public UObject
{
public:
	float                                         m_TimeSpeedMagnification;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         m_RealTimeRequiredToOneDay;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              m_CurrentTimeSpan;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              m_LastUpdatedTime;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_ElapsedRateToday;                                // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0xC];                                       // 0x004C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             m_TimeZoneTable;                                   // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeTimeZoneWaitSecond;                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DayTimeStartHour;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DayTimeStartMinute;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NightStartHour;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NightStartMinute;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x9];                                       // 0x0088(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsNightTime;                                       // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92[0xE];                                       // 0x0092(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTime(int32 Hour, int32 Minute, bool SkipEvent);
	struct FTimespan ConvertTimespanToTime(const struct FTimespan& Timespan);
	ETimeZoneType GetTimeZoneType();
	ETimeZoneType GetTimeZoneTypeFromTime(int32 Hour, int32 Minute);
	void Initialize();
	void OnPause();
	void OnResume();
	void ResumeWeatherTime();
	void SetGameTime(int32 Hour, int32 Minute);
	void SetOneDayMinute(int32 Minute);
	void SetRealTimeRequiredToOneDay(int32 Time);
	void SetTime(int32 Hour, int32 Minute, bool SkipEvent);
	void SetTimeSpeedMagnification(float Magnification);
	void SetWeatherTimePause(int32 Hour, int32 Minute);
	void Update();
	void UpdateGameTime(const struct FTimespan& AddTime);

	struct FTimespan ConvertTimeToTimespan(int32 Hour, int32 Minute) const;
	struct FTimespan GetCurrentTimeSpan() const;
	float GetElapsedRateToday() const;
	int32 GetRealTimeRequiredToOneDay() const;
	struct FTimespan GetTime() const;
	float GetTimeSpeedMagnification() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTimeManager">();
	}
	static class UWorldTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTimeManager>();
	}
};
static_assert(alignof(UWorldTimeManager) == 0x000008, "Wrong alignment on UWorldTimeManager");
static_assert(sizeof(UWorldTimeManager) == 0x0000A0, "Wrong size on UWorldTimeManager");
static_assert(offsetof(UWorldTimeManager, m_TimeSpeedMagnification) == 0x000030, "Member 'UWorldTimeManager::m_TimeSpeedMagnification' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, m_RealTimeRequiredToOneDay) == 0x000034, "Member 'UWorldTimeManager::m_RealTimeRequiredToOneDay' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, m_CurrentTimeSpan) == 0x000038, "Member 'UWorldTimeManager::m_CurrentTimeSpan' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, m_LastUpdatedTime) == 0x000040, "Member 'UWorldTimeManager::m_LastUpdatedTime' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, m_ElapsedRateToday) == 0x000048, "Member 'UWorldTimeManager::m_ElapsedRateToday' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, m_TimeZoneTable) == 0x000058, "Member 'UWorldTimeManager::m_TimeZoneTable' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, ChangeTimeZoneWaitSecond) == 0x000060, "Member 'UWorldTimeManager::ChangeTimeZoneWaitSecond' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, DayTimeStartHour) == 0x000070, "Member 'UWorldTimeManager::DayTimeStartHour' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, DayTimeStartMinute) == 0x000074, "Member 'UWorldTimeManager::DayTimeStartMinute' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, NightStartHour) == 0x000080, "Member 'UWorldTimeManager::NightStartHour' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, NightStartMinute) == 0x000084, "Member 'UWorldTimeManager::NightStartMinute' has a wrong offset!");
static_assert(offsetof(UWorldTimeManager, IsNightTime) == 0x000091, "Member 'UWorldTimeManager::IsNightTime' has a wrong offset!");

}

