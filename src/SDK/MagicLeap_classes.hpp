#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MagicLeap

#include "Basic.hpp"

#include "MagicLeap_structs.hpp"
#include "Engine_classes.hpp"
#include "HeadMountedDisplay_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class MagicLeap.MagicLeapSettings
// 0x0008 (0x0038 - 0x0030)
class UMagicLeapSettings final : public UObject
{
public:
	bool                                          bEnableZI;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVulkanForZI;                                   // 0x0031(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMLAudioForZI;                                  // 0x0032(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapSettings">();
	}
	static class UMagicLeapSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapSettings>();
	}
};
static_assert(alignof(UMagicLeapSettings) == 0x000008, "Wrong alignment on UMagicLeapSettings");
static_assert(sizeof(UMagicLeapSettings) == 0x000038, "Wrong size on UMagicLeapSettings");
static_assert(offsetof(UMagicLeapSettings, bEnableZI) == 0x000030, "Member 'UMagicLeapSettings::bEnableZI' has a wrong offset!");
static_assert(offsetof(UMagicLeapSettings, bUseVulkanForZI) == 0x000031, "Member 'UMagicLeapSettings::bUseVulkanForZI' has a wrong offset!");
static_assert(offsetof(UMagicLeapSettings, bUseMLAudioForZI) == 0x000032, "Member 'UMagicLeapSettings::bUseMLAudioForZI' has a wrong offset!");

// Class MagicLeap.InAppPurchaseComponent
// 0x0078 (0x0130 - 0x00B8)
class UInAppPurchaseComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class FString& LogMessage)> InAppPurchaseLogMessage;                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FPurchaseItemDetails>& ItemsDetails)> GetItemsDetailsSuccess;                            // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              GetItemsDetailsFailure;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPurchaseConfirmation& PurchaseConfirmations)> PurchaseConfirmationSuccess;                       // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PurchaseConfirmationFailure;                       // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FPurchaseConfirmation>& PurchaseHistory)> GetPurchaseHistorySuccess;                         // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              GetPurchaseHistoryFailure;                         // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool TryGetItemsDetailsAsync(const TArray<class FString>& ItemIDs);
	bool TryGetPurchaseHistoryAsync(int32 InNumPages);
	bool TryPurchaseItemAsync(const struct FPurchaseItemDetails& ItemDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InAppPurchaseComponent">();
	}
	static class UInAppPurchaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInAppPurchaseComponent>();
	}
};
static_assert(alignof(UInAppPurchaseComponent) == 0x000008, "Wrong alignment on UInAppPurchaseComponent");
static_assert(sizeof(UInAppPurchaseComponent) == 0x000130, "Wrong size on UInAppPurchaseComponent");
static_assert(offsetof(UInAppPurchaseComponent, InAppPurchaseLogMessage) == 0x0000B8, "Member 'UInAppPurchaseComponent::InAppPurchaseLogMessage' has a wrong offset!");
static_assert(offsetof(UInAppPurchaseComponent, GetItemsDetailsSuccess) == 0x0000C8, "Member 'UInAppPurchaseComponent::GetItemsDetailsSuccess' has a wrong offset!");
static_assert(offsetof(UInAppPurchaseComponent, GetItemsDetailsFailure) == 0x0000D8, "Member 'UInAppPurchaseComponent::GetItemsDetailsFailure' has a wrong offset!");
static_assert(offsetof(UInAppPurchaseComponent, PurchaseConfirmationSuccess) == 0x0000E8, "Member 'UInAppPurchaseComponent::PurchaseConfirmationSuccess' has a wrong offset!");
static_assert(offsetof(UInAppPurchaseComponent, PurchaseConfirmationFailure) == 0x0000F8, "Member 'UInAppPurchaseComponent::PurchaseConfirmationFailure' has a wrong offset!");
static_assert(offsetof(UInAppPurchaseComponent, GetPurchaseHistorySuccess) == 0x000108, "Member 'UInAppPurchaseComponent::GetPurchaseHistorySuccess' has a wrong offset!");
static_assert(offsetof(UInAppPurchaseComponent, GetPurchaseHistoryFailure) == 0x000118, "Member 'UInAppPurchaseComponent::GetPurchaseHistoryFailure' has a wrong offset!");

// Class MagicLeap.MagicLeapRaycastComponent
// 0x0068 (0x0120 - 0x00B8)
class UMagicLeapRaycastComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RequestRaycast(const struct FMagicLeapRaycastQueryParams& RequestParams, const TDelegate<void(const struct FMagicLeapRaycastHitResult& HitResult)>& ResultDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapRaycastComponent">();
	}
	static class UMagicLeapRaycastComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapRaycastComponent>();
	}
};
static_assert(alignof(UMagicLeapRaycastComponent) == 0x000008, "Wrong alignment on UMagicLeapRaycastComponent");
static_assert(sizeof(UMagicLeapRaycastComponent) == 0x000120, "Wrong size on UMagicLeapRaycastComponent");

// Class MagicLeap.LuminApplicationLifecycleComponent
// 0x0050 (0x0198 - 0x0148)
class ULuminApplicationLifecycleComponent final : public UApplicationLifecycleComponent
{
public:
	TMulticastInlineDelegate<void()>              DeviceHasReactivatedDelegate;                      // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              DeviceWillEnterRealityModeDelegate;                // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              DeviceWillGoInStandbyDelegate;                     // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EFocusLostReason reason)> FocusLostDelegate;                                 // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FocusGainedDelegate;                               // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuminApplicationLifecycleComponent">();
	}
	static class ULuminApplicationLifecycleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuminApplicationLifecycleComponent>();
	}
};
static_assert(alignof(ULuminApplicationLifecycleComponent) == 0x000008, "Wrong alignment on ULuminApplicationLifecycleComponent");
static_assert(sizeof(ULuminApplicationLifecycleComponent) == 0x000198, "Wrong size on ULuminApplicationLifecycleComponent");
static_assert(offsetof(ULuminApplicationLifecycleComponent, DeviceHasReactivatedDelegate) == 0x000148, "Member 'ULuminApplicationLifecycleComponent::DeviceHasReactivatedDelegate' has a wrong offset!");
static_assert(offsetof(ULuminApplicationLifecycleComponent, DeviceWillEnterRealityModeDelegate) == 0x000158, "Member 'ULuminApplicationLifecycleComponent::DeviceWillEnterRealityModeDelegate' has a wrong offset!");
static_assert(offsetof(ULuminApplicationLifecycleComponent, DeviceWillGoInStandbyDelegate) == 0x000168, "Member 'ULuminApplicationLifecycleComponent::DeviceWillGoInStandbyDelegate' has a wrong offset!");
static_assert(offsetof(ULuminApplicationLifecycleComponent, FocusLostDelegate) == 0x000178, "Member 'ULuminApplicationLifecycleComponent::FocusLostDelegate' has a wrong offset!");
static_assert(offsetof(ULuminApplicationLifecycleComponent, FocusGainedDelegate) == 0x000188, "Member 'ULuminApplicationLifecycleComponent::FocusGainedDelegate' has a wrong offset!");

// Class MagicLeap.MagicLeapHeadTrackingNotificationsComponent
// 0x0090 (0x01D8 - 0x0148)
class UMagicLeapHeadTrackingNotificationsComponent final : public UVRNotificationsComponent
{
public:
	TMulticastInlineDelegate<void()>              OnHeadTrackingLost;                                // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnHeadTrackingRecovered;                           // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnHeadTrackingRecoveryFailed;                      // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnHeadTrackingNewSessionStarted;                   // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x50];                                     // 0x0188(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapHeadTrackingNotificationsComponent">();
	}
	static class UMagicLeapHeadTrackingNotificationsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapHeadTrackingNotificationsComponent>();
	}
};
static_assert(alignof(UMagicLeapHeadTrackingNotificationsComponent) == 0x000008, "Wrong alignment on UMagicLeapHeadTrackingNotificationsComponent");
static_assert(sizeof(UMagicLeapHeadTrackingNotificationsComponent) == 0x0001D8, "Wrong size on UMagicLeapHeadTrackingNotificationsComponent");
static_assert(offsetof(UMagicLeapHeadTrackingNotificationsComponent, OnHeadTrackingLost) == 0x000148, "Member 'UMagicLeapHeadTrackingNotificationsComponent::OnHeadTrackingLost' has a wrong offset!");
static_assert(offsetof(UMagicLeapHeadTrackingNotificationsComponent, OnHeadTrackingRecovered) == 0x000158, "Member 'UMagicLeapHeadTrackingNotificationsComponent::OnHeadTrackingRecovered' has a wrong offset!");
static_assert(offsetof(UMagicLeapHeadTrackingNotificationsComponent, OnHeadTrackingRecoveryFailed) == 0x000168, "Member 'UMagicLeapHeadTrackingNotificationsComponent::OnHeadTrackingRecoveryFailed' has a wrong offset!");
static_assert(offsetof(UMagicLeapHeadTrackingNotificationsComponent, OnHeadTrackingNewSessionStarted) == 0x000178, "Member 'UMagicLeapHeadTrackingNotificationsComponent::OnHeadTrackingNewSessionStarted' has a wrong offset!");

// Class MagicLeap.MagicLeapHMDFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMagicLeapHMDFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetGraphicsClientPerformanceInfo(struct FMagicLeapGraphicsClientPerformanceInfo* PerformanceInfo);
	static bool GetHeadTrackingMapEvents(TSet<EMagicLeapHeadTrackingMapEvent>* MapEvents);
	static bool GetHeadTrackingState(struct FMagicLeapHeadTrackingState* State);
	static int32 GetMinimumAPILevel();
	static class FString GetMLSDKVersion();
	static int32 GetMLSDKVersionMajor();
	static int32 GetMLSDKVersionMinor();
	static int32 GetMLSDKVersionRevision();
	static int32 GetPlatformAPILevel();
	static bool IsRunningOnMagicLeapHMD();
	static bool SetAppReady();
	static void SetBaseOrientation(const struct FQuat& InBaseOrientation);
	static void SetBasePosition(const struct FVector& InBasePosition);
	static void SetBaseRotation(const struct FRotator& InBaseRotation);
	static void SetFocusActor(const class AActor* InFocusActor, bool bSetStabilizationActor);
	static void SetStabilizationDepthActor(const class AActor* InStabilizationDepthActor, bool bSetFocusActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapHMDFunctionLibrary">();
	}
	static class UMagicLeapHMDFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapHMDFunctionLibrary>();
	}
};
static_assert(alignof(UMagicLeapHMDFunctionLibrary) == 0x000008, "Wrong alignment on UMagicLeapHMDFunctionLibrary");
static_assert(sizeof(UMagicLeapHMDFunctionLibrary) == 0x000030, "Wrong size on UMagicLeapHMDFunctionLibrary");

// Class MagicLeap.MagicLeapMeshTrackerComponent
// 0x0090 (0x0290 - 0x0200)
class UMagicLeapMeshTrackerComponent final : public USceneComponent
{
public:
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FGuid& ID, TArray<struct FVector>& Vertices, TArray<int32>& Triangles, TArray<struct FVector>& Normals, TArray<float>& Confidence)> OnMeshTrackerUpdated;                              // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          ScanWorld;                                         // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicLeapMeshType                            MeshType;                                          // 0x0219(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BoundingVolume;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicLeapMeshLOD                             LevelOfDetail;                                     // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PerimeterOfGapsToFill;                             // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Planarize;                                         // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisconnectedSectionArea;                           // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequestNormals;                                    // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequestVertexConfidence;                           // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicLeapMeshVertexColorMode                 VertexColorMode;                                   // 0x023A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B[0x5];                                      // 0x023B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         BlockVertexColors;                                 // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VertexColorFromConfidenceZero;                     // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VertexColorFromConfidenceOne;                      // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveOverlappingTriangles;                        // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMRMeshComponent*                       MRMesh;                                            // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BricksPerFrame;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0xC];                                      // 0x0284(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConnectBlockSelector(TScriptInterface<class IMagicLeapMeshBlockSelectorInterface> Selector);
	void ConnectMRMesh(class UMRMeshComponent* InMRMeshPtr);
	void DisconnectBlockSelector();
	void DisconnectMRMesh(class UMRMeshComponent* InMRMeshPtr);
	int32 GetNumQueuedBlockUpdates();
	void SelectMeshBlocks(const struct FMagicLeapTrackingMeshInfo& NewMeshInfo, TArray<struct FMagicLeapMeshBlockRequest>* RequestedMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapMeshTrackerComponent">();
	}
	static class UMagicLeapMeshTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapMeshTrackerComponent>();
	}
};
static_assert(alignof(UMagicLeapMeshTrackerComponent) == 0x000010, "Wrong alignment on UMagicLeapMeshTrackerComponent");
static_assert(sizeof(UMagicLeapMeshTrackerComponent) == 0x000290, "Wrong size on UMagicLeapMeshTrackerComponent");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, OnMeshTrackerUpdated) == 0x000208, "Member 'UMagicLeapMeshTrackerComponent::OnMeshTrackerUpdated' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, ScanWorld) == 0x000218, "Member 'UMagicLeapMeshTrackerComponent::ScanWorld' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, MeshType) == 0x000219, "Member 'UMagicLeapMeshTrackerComponent::MeshType' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, BoundingVolume) == 0x000220, "Member 'UMagicLeapMeshTrackerComponent::BoundingVolume' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, LevelOfDetail) == 0x000228, "Member 'UMagicLeapMeshTrackerComponent::LevelOfDetail' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, PerimeterOfGapsToFill) == 0x00022C, "Member 'UMagicLeapMeshTrackerComponent::PerimeterOfGapsToFill' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, Planarize) == 0x000230, "Member 'UMagicLeapMeshTrackerComponent::Planarize' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, DisconnectedSectionArea) == 0x000234, "Member 'UMagicLeapMeshTrackerComponent::DisconnectedSectionArea' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, RequestNormals) == 0x000238, "Member 'UMagicLeapMeshTrackerComponent::RequestNormals' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, RequestVertexConfidence) == 0x000239, "Member 'UMagicLeapMeshTrackerComponent::RequestVertexConfidence' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, VertexColorMode) == 0x00023A, "Member 'UMagicLeapMeshTrackerComponent::VertexColorMode' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, BlockVertexColors) == 0x000240, "Member 'UMagicLeapMeshTrackerComponent::BlockVertexColors' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, VertexColorFromConfidenceZero) == 0x000250, "Member 'UMagicLeapMeshTrackerComponent::VertexColorFromConfidenceZero' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, VertexColorFromConfidenceOne) == 0x000260, "Member 'UMagicLeapMeshTrackerComponent::VertexColorFromConfidenceOne' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, RemoveOverlappingTriangles) == 0x000270, "Member 'UMagicLeapMeshTrackerComponent::RemoveOverlappingTriangles' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, MRMesh) == 0x000278, "Member 'UMagicLeapMeshTrackerComponent::MRMesh' has a wrong offset!");
static_assert(offsetof(UMagicLeapMeshTrackerComponent, BricksPerFrame) == 0x000280, "Member 'UMagicLeapMeshTrackerComponent::BricksPerFrame' has a wrong offset!");

// Class MagicLeap.MagicLeapMeshBlockSelectorInterface
// 0x0000 (0x0030 - 0x0030)
class IMagicLeapMeshBlockSelectorInterface final : public IInterface
{
public:
	void SelectMeshBlocks(const struct FMagicLeapTrackingMeshInfo& NewMeshInfo, TArray<struct FMagicLeapMeshBlockRequest>* RequestedMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapMeshBlockSelectorInterface">();
	}
	static class IMagicLeapMeshBlockSelectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMagicLeapMeshBlockSelectorInterface>();
	}
};
static_assert(alignof(IMagicLeapMeshBlockSelectorInterface) == 0x000008, "Wrong alignment on IMagicLeapMeshBlockSelectorInterface");
static_assert(sizeof(IMagicLeapMeshBlockSelectorInterface) == 0x000030, "Wrong size on IMagicLeapMeshBlockSelectorInterface");

// Class MagicLeap.MagicLeapRaycastFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UMagicLeapRaycastFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FMagicLeapRaycastQueryParams MakeRaycastQueryParams(const struct FVector& Position, const struct FVector& Direction, const struct FVector& UpVector, int32 Width, int32 Height, float HorizontalFovDegrees, bool CollideWithUnobserved, int32 UserData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicLeapRaycastFunctionLibrary">();
	}
	static class UMagicLeapRaycastFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicLeapRaycastFunctionLibrary>();
	}
};
static_assert(alignof(UMagicLeapRaycastFunctionLibrary) == 0x000008, "Wrong alignment on UMagicLeapRaycastFunctionLibrary");
static_assert(sizeof(UMagicLeapRaycastFunctionLibrary) == 0x000030, "Wrong size on UMagicLeapRaycastFunctionLibrary");

}

