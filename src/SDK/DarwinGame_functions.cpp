#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DarwinGame

#include "Basic.hpp"

#include "DarwinGame_classes.hpp"
#include "DarwinGame_parameters.hpp"


namespace SDK
{

// Function DarwinGame.DarwinUserWidget.AddInputEventFunc
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           EventName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::AddInputEventFunc(const class FString& EventName, int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "AddInputEventFunc");

	Params::DarwinUserWidget_AddInputEventFunc Parms{};

	Parms.EventName = std::move(EventName);
	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.BeginUse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinUserWidget::BeginUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "BeginUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.Close
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinUserWidget::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.CloseAnimationEnd
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::CloseAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "CloseAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.CloseIfNotWillClose
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::CloseIfNotWillClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "CloseIfNotWillClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.CloseImmediate
// (Native, Public, BlueprintCallable)

void UDarwinUserWidget::CloseImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "CloseImmediate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.EndUse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinUserWidget::EndUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "EndUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.Input_Button_Down
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Button_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Button_Down");

	Params::DarwinUserWidget_Input_Button_Down Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Button_Left
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Button_Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Button_Left");

	Params::DarwinUserWidget_Input_Button_Left Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Button_Right
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Button_Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Button_Right");

	Params::DarwinUserWidget_Input_Button_Right Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Button_Up
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Button_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Button_Up");

	Params::DarwinUserWidget_Input_Button_Up Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Cancel
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Cancel");

	Params::DarwinUserWidget_Input_Cancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Decide
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Decide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Decide");

	Params::DarwinUserWidget_Input_Decide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Down
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Down");

	Params::DarwinUserWidget_Input_Down Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_L
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_L()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_L");

	Params::DarwinUserWidget_Input_L Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Left
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Left");

	Params::DarwinUserWidget_Input_Left Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Left_Analog_Down
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Left_Analog_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Left_Analog_Down");

	Params::DarwinUserWidget_Input_Left_Analog_Down Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Left_Analog_Left
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Left_Analog_Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Left_Analog_Left");

	Params::DarwinUserWidget_Input_Left_Analog_Left Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Left_Analog_Right
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Left_Analog_Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Left_Analog_Right");

	Params::DarwinUserWidget_Input_Left_Analog_Right Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Left_Analog_Up
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Left_Analog_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Left_Analog_Up");

	Params::DarwinUserWidget_Input_Left_Analog_Up Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Minus
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Minus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Minus");

	Params::DarwinUserWidget_Input_Minus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Mouse_Wheel_Down
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Mouse_Wheel_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Mouse_Wheel_Down");

	Params::DarwinUserWidget_Input_Mouse_Wheel_Down Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Mouse_Wheel_Up
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Mouse_Wheel_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Mouse_Wheel_Up");

	Params::DarwinUserWidget_Input_Mouse_Wheel_Up Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_PC_R
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_PC_R()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_PC_R");

	Params::DarwinUserWidget_Input_PC_R Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_PC_T
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_PC_T()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_PC_T");

	Params::DarwinUserWidget_Input_PC_T Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Plus
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Plus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Plus");

	Params::DarwinUserWidget_Input_Plus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_R
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_R()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_R");

	Params::DarwinUserWidget_Input_R Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Right
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Right");

	Params::DarwinUserWidget_Input_Right Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Right_Analog_Down
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Right_Analog_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Right_Analog_Down");

	Params::DarwinUserWidget_Input_Right_Analog_Down Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Right_Analog_Left
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Right_Analog_Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Right_Analog_Left");

	Params::DarwinUserWidget_Input_Right_Analog_Left Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Right_Analog_Right
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Right_Analog_Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Right_Analog_Right");

	Params::DarwinUserWidget_Input_Right_Analog_Right Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Right_Analog_Up
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Right_Analog_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Right_Analog_Up");

	Params::DarwinUserWidget_Input_Right_Analog_Up Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_RMB
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_RMB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_RMB");

	Params::DarwinUserWidget_Input_RMB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Tab
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Tab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Tab");

	Params::DarwinUserWidget_Input_Tab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Up
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Up");

	Params::DarwinUserWidget_Input_Up Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_X
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_X()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_X");

	Params::DarwinUserWidget_Input_X Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_Y
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_Y()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_Y");

	Params::DarwinUserWidget_Input_Y Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_ZL
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_ZL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_ZL");

	Params::DarwinUserWidget_Input_ZL Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.Input_ZR
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::Input_ZR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Input_ZR");

	Params::DarwinUserWidget_Input_ZR Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.InputEventFunc
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    GamePaused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKeyInput                        KeyInput                                               (Parm, NativeAccessSpecifierPublic)
// struct FKeyInput                        OutKeyInput                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FEventReply                      Reply                                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDarwinUserWidget::InputEventFunc(float DeltaTime, bool GamePaused, const struct FKeyInput& KeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Reply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "InputEventFunc");

	Params::DarwinUserWidget_InputEventFunc Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.GamePaused = GamePaused;
	Parms.KeyInput = std::move(KeyInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKeyInput != nullptr)
		*OutKeyInput = std::move(Parms.OutKeyInput);

	if (Reply != nullptr)
		*Reply = std::move(Parms.Reply);
}


// Function DarwinGame.DarwinUserWidget.InputName
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName EnteredName)>EnteredNameEvent                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDarwinUserWidget::InputName(class FName ID, class FName Name_0, const TDelegate<void(class FName EnteredName)>& EnteredNameEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "InputName");

	Params::DarwinUserWidget_InputName Parms{};

	Parms.ID = ID;
	Parms.Name_0 = Name_0;
	Parms.EnteredNameEvent = EnteredNameEvent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.DarwinUserWidget.IsRepeatPressedWIthSetting
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKeyInput                        KeyInput                                               (Parm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::IsRepeatPressedWIthSetting(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "IsRepeatPressedWIthSetting");

	Params::DarwinUserWidget_IsRepeatPressedWIthSetting Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.IsUse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::IsUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "IsUse");

	Params::DarwinUserWidget_IsUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.OnCloseAnimationEnd
// (Event, Protected, BlueprintEvent)

void UDarwinUserWidget::OnCloseAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "OnCloseAnimationEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.DarwinUserWidget.OnOpenAnimationEnd
// (Native, Event, Protected, BlueprintEvent)

void UDarwinUserWidget::OnOpenAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "OnOpenAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.open
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinUserWidget::open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.OpenAnimationEnd
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::OpenAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "OpenAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.OpenIfNotWillOpen
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::OpenIfNotWillOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "OpenIfNotWillOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.OpenImmediate
// (Native, Public, BlueprintCallable)

void UDarwinUserWidget::OpenImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "OpenImmediate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.PlayOneShot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   WaitTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::PlayOneShot(float WaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "PlayOneShot");

	Params::DarwinUserWidget_PlayOneShot Parms{};

	Parms.WaitTime = WaitTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.PlayOneShotAnimation
// (Final, Native, Public, BlueprintCallable)

void UDarwinUserWidget::PlayOneShotAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "PlayOneShotAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.RemoveRegisteredInputEvent
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::RemoveRegisteredInputEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "RemoveRegisteredInputEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.Resume
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinUserWidget::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.ResumeAnimationEnd
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::ResumeAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "ResumeAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.ResumeImmediate
// (Native, Public, BlueprintCallable)

void UDarwinUserWidget::ResumeImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "ResumeImmediate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.SetBrushFromButtonTexture
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UImage*                           TargetImage                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxisMappingType                        Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::SetBrushFromButtonTexture(class UImage* TargetImage, EAxisMappingType Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "SetBrushFromButtonTexture");

	Params::DarwinUserWidget_SetBrushFromButtonTexture Parms{};

	Parms.TargetImage = TargetImage;
	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.SetHandlingInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InIsHandlingInput                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::SetHandlingInput(bool InIsHandlingInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "SetHandlingInput");

	Params::DarwinUserWidget_SetHandlingInput Parms{};

	Parms.InIsHandlingInput = InIsHandlingInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.SetHideCount
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::SetHideCount(float Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "SetHideCount");

	Params::DarwinUserWidget_SetHideCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.SetProgressBar
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UProgressBar*                     Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Numerator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Denominator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::SetProgressBar(class UProgressBar* Target, int32 Numerator, int32 Denominator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "SetProgressBar");

	Params::DarwinUserWidget_SetProgressBar Parms{};

	Parms.Target = Target;
	Parms.Numerator = Numerator;
	Parms.Denominator = Denominator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.Suspend
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinUserWidget::Suspend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Suspend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.SuspendAnimationEnd
// (Final, Native, Protected, BlueprintCallable)

void UDarwinUserWidget::SuspendAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "SuspendAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.SuspendImmediate
// (Native, Public, BlueprintCallable)

void UDarwinUserWidget::SuspendImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "SuspendImmediate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.Update
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "Update");

	Params::DarwinUserWidget_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.UpdateAtPostUpdateWork
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinUserWidget::UpdateAtPostUpdateWork(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "UpdateAtPostUpdateWork");

	Params::DarwinUserWidget_UpdateAtPostUpdateWork Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinUserWidget.CanAction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EWidgetAction                           Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::CanAction(EWidgetAction Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "CanAction");

	Params::DarwinUserWidget_CanAction Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.GetDarwinUserWidgetFromName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinUserWidget* UDarwinUserWidget::GetDarwinUserWidgetFromName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "GetDarwinUserWidgetFromName");

	Params::DarwinUserWidget_GetDarwinUserWidgetFromName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.GetImageFromName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UDarwinUserWidget::GetImageFromName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "GetImageFromName");

	Params::DarwinUserWidget_GetImageFromName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.GetOpenState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOpenState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOpenState UDarwinUserWidget::GetOpenState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "GetOpenState");

	Params::DarwinUserWidget_GetOpenState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.GetTextBlockFromName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextBlock* UDarwinUserWidget::GetTextBlockFromName(class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "GetTextBlockFromName");

	Params::DarwinUserWidget_GetTextBlockFromName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinUserWidget.IsJustPressedWithLeftAnalog
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinUserWidget::IsJustPressedWithLeftAnalog(EAxisMappingType Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinUserWidget", "IsJustPressedWithLeftAnalog");

	Params::DarwinUserWidget_IsJustPressedWithLeftAnalog Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UI3DBase.SetAttachSocketName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUI3DBase::SetAttachSocketName(class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UI3DBase", "SetAttachSocketName");

	Params::UI3DBase_SetAttachSocketName Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UI3DBase.SetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InLocaion                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUI3DBase::SetLocation(const struct FVector& InLocaion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UI3DBase", "SetLocation");

	Params::UI3DBase_SetLocation Parms{};

	Parms.InLocaion = std::move(InLocaion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UI3DBase.SetTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUI3DBase::SetTargetActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UI3DBase", "SetTargetActor");

	Params::UI3DBase_SetTargetActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UI3DBase.Update3DTransform
// (Final, Native, Public, BlueprintCallable)

void UUI3DBase::Update3DTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UI3DBase", "Update3DTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_SkillChain_Word.SetChainData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   DamageNum                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_SkillChain_Word::SetChainData(const int32& DamageNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_SkillChain_Word", "SetChainData");

	Params::UIField_SkillChain_Word_SetChainData Parms{};

	Parms.DamageNum = DamageNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.AddItemList
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUIMenuItemBase*                  Item                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::AddItemList(class UUIMenuItemBase* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "AddItemList");

	Params::UIMenuBase_AddItemList Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.ChangeFocusWithNavigation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckSelfKeyInput                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuBase::ChangeFocusWithNavigation(EAxisMappingType Key, bool CheckSelfKeyInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "ChangeFocusWithNavigation");

	Params::UIMenuBase_ChangeFocusWithNavigation Parms{};

	Parms.Key = Key;
	Parms.CheckSelfKeyInput = CheckSelfKeyInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.CheckSelectableFromKeyInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIMenuBase*                      Menu                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuBase::CheckSelectableFromKeyInput(EAxisMappingType Key, class UUIMenuBase* Menu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "CheckSelectableFromKeyInput");

	Params::UIMenuBase_CheckSelectableFromKeyInput Parms{};

	Parms.Key = Key;
	Parms.Menu = Menu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.ClearItemList
// (Final, Native, Public, BlueprintCallable)

void UUIMenuBase::ClearItemList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "ClearItemList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.CloseItemList
// (Final, Native, Public, BlueprintCallable)

void UUIMenuBase::CloseItemList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "CloseItemList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.GetItemList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UUIMenuItemBase*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UUIMenuItemBase*> UUIMenuBase::GetItemList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "GetItemList");

	Params::UIMenuBase_GetItemList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.OnTriedToMoveBeyondTheEdgeFunc
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::OnTriedToMoveBeyondTheEdgeFunc(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "OnTriedToMoveBeyondTheEdgeFunc");

	Params::UIMenuBase_OnTriedToMoveBeyondTheEdgeFunc Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.OutFocusCurrentFocusItem
// (Final, Native, Public, BlueprintCallable)

void UUIMenuBase::OutFocusCurrentFocusItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "OutFocusCurrentFocusItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.RemoveIndexItemList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::RemoveIndexItemList(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "RemoveIndexItemList");

	Params::UIMenuBase_RemoveIndexItemList Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.SetFocusItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUIMenuItemBase*                  Item                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::SetFocusItem(class UUIMenuItemBase* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "SetFocusItem");

	Params::UIMenuBase_SetFocusItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.SetFocusItemFromIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::SetFocusItemFromIndex(int32 ItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "SetFocusItemFromIndex");

	Params::UIMenuBase_SetFocusItemFromIndex Parms{};

	Parms.ItemIndex = ItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.SetItemList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UUIMenuItemBase*>          NewParam                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::SetItemList(const TArray<class UUIMenuItemBase*>& NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "SetItemList");

	Params::UIMenuBase_SetItemList Parms{};

	Parms.NewParam = std::move(NewParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.SetNavigationLinear
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UUIMenuItemBase*>          NewParam                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Loop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxisMappingType                        PrevKey                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxisMappingType                        NextKey                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::SetNavigationLinear(const TArray<class UUIMenuItemBase*>& NewParam, bool Loop, EAxisMappingType PrevKey, EAxisMappingType NextKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "SetNavigationLinear");

	Params::UIMenuBase_SetNavigationLinear Parms{};

	Parms.NewParam = std::move(NewParam);
	Parms.Loop = Loop;
	Parms.PrevKey = PrevKey;
	Parms.NextKey = NextKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.SetNavigationLinearLR
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UUIMenuItemBase*>          NewParam                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Loop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::SetNavigationLinearLR(const TArray<class UUIMenuItemBase*>& NewParam, bool Loop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "SetNavigationLinearLR");

	Params::UIMenuBase_SetNavigationLinearLR Parms{};

	Parms.NewParam = std::move(NewParam);
	Parms.Loop = Loop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.SetNavigationLinearUpDown
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UUIMenuItemBase*>          NewParam                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Loop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuBase::SetNavigationLinearUpDown(const TArray<class UUIMenuItemBase*>& NewParam, bool Loop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "SetNavigationLinearUpDown");

	Params::UIMenuBase_SetNavigationLinearUpDown Parms{};

	Parms.NewParam = std::move(NewParam);
	Parms.Loop = Loop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuBase.GetFocusItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIMenuItemBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIMenuItemBase* UUIMenuBase::GetFocusItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "GetFocusItem");

	Params::UIMenuBase_GetFocusItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.GetIndexAtFocusItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIMenuBase::GetIndexAtFocusItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "GetIndexAtFocusItem");

	Params::UIMenuBase_GetIndexAtFocusItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.HasFocusItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuBase::HasFocusItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "HasFocusItem");

	Params::UIMenuBase_HasFocusItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.ItemListLastIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIMenuBase::ItemListLastIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "ItemListLastIndex");

	Params::UIMenuBase_ItemListLastIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuBase.ItemListLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIMenuBase::ItemListLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuBase", "ItemListLength");

	Params::UIMenuBase_ItemListLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.CanPlaySelectSound
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIScrollMenuBase::CanPlaySelectSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "CanPlaySelectSound");

	Params::UIScrollMenuBase_CanPlaySelectSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.CanSelect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIScrollMenuBase::CanSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "CanSelect");

	Params::UIScrollMenuBase_CanSelect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.ChangePage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckSelfKeyInput                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIScrollMenuBase::ChangePage(EAxisMappingType Key, bool CheckSelfKeyInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "ChangePage");

	Params::UIScrollMenuBase_ChangePage Parms{};

	Parms.Key = Key;
	Parms.CheckSelfKeyInput = CheckSelfKeyInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.InitList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InListNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::InitList(int32 InListNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "InitList");

	Params::UIScrollMenuBase_InitList Parms{};

	Parms.InListNum = InListNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.InitScrollMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UUIScrollMenuItemBase*>    InItemList                                             (Parm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::InitScrollMenu(const TArray<class UUIScrollMenuItemBase*>& InItemList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "InitScrollMenu");

	Params::UIScrollMenuBase_InitScrollMenu Parms{};

	Parms.InItemList = std::move(InItemList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.IsScrolling
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIScrollMenuBase::IsScrolling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "IsScrolling");

	Params::UIScrollMenuBase_IsScrolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.IsValidItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUIScrollMenuItemBase*            InItem                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIScrollMenuBase::IsValidItem(class UUIScrollMenuItemBase* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "IsValidItem");

	Params::UIScrollMenuBase_IsValidItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.ResetDispList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InFocusIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSetFocus                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::ResetDispList(int32 InFocusIndex, bool IsSetFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "ResetDispList");

	Params::UIScrollMenuBase_ResetDispList Parms{};

	Parms.InFocusIndex = InFocusIndex;
	Parms.IsSetFocus = IsSetFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.ResetDispListKeepFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSetFocus                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::ResetDispListKeepFocus(bool IsSetFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "ResetDispListKeepFocus");

	Params::UIScrollMenuBase_ResetDispListKeepFocus Parms{};

	Parms.IsSetFocus = IsSetFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.ResetDispListStartIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InFocusIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InListStartIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSetFocus                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::ResetDispListStartIndex(int32 InFocusIndex, int32 InListStartIndex, bool IsSetFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "ResetDispListStartIndex");

	Params::UIScrollMenuBase_ResetDispListStartIndex Parms{};

	Parms.InFocusIndex = InFocusIndex;
	Parms.InListStartIndex = InListStartIndex;
	Parms.IsSetFocus = IsSetFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.ScrollPage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckSelfKeyInput                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIScrollMenuBase::ScrollPage(EAxisMappingType Key, bool CheckSelfKeyInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "ScrollPage");

	Params::UIScrollMenuBase_ScrollPage Parms{};

	Parms.Key = Key;
	Parms.CheckSelfKeyInput = CheckSelfKeyInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuBase.SetFocusItemFromListIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::SetFocusItemFromListIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "SetFocusItemFromListIndex");

	Params::UIScrollMenuBase_SetFocusItemFromListIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.SetItemData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUIScrollMenuItemBase*            InItem                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::SetItemData(class UUIScrollMenuItemBase* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "SetItemData");

	Params::UIScrollMenuBase_SetItemData Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuBase.SetVisibleCursorArrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsVisible_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EArrowWidgetVisibleType                 VisibleType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuBase::SetVisibleCursorArrow(bool IsVisible_0, EArrowWidgetVisibleType VisibleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuBase", "SetVisibleCursorArrow");

	Params::UIScrollMenuBase_SetVisibleCursorArrow Parms{};

	Parms.IsVisible_0 = IsVisible_0;
	Parms.VisibleType = VisibleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AbilityTask_PlayMontageAndWaitEvent.PlayMontageAndWaitEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags_0                                            (Parm, NativeAccessSpecifierPublic)
// float                                   Rate_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRootMotionTranslationScale_0                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlayMontageAndWaitEvent*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlayMontageAndWaitEvent* UAbilityTask_PlayMontageAndWaitEvent::PlayMontageAndWaitEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlayMontageAndWaitEvent", "PlayMontageAndWaitEvent");

	Params::AbilityTask_PlayMontageAndWaitEvent_PlayMontageAndWaitEvent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.MontageToPlay_0 = MontageToPlay_0;
	Parms.EventTags_0 = std::move(EventTags_0);
	Parms.Rate_0 = Rate_0;
	Parms.StartSection_0 = StartSection_0;
	Parms.bStopWhenAbilityEnds_0 = bStopWhenAbilityEnds_0;
	Parms.AnimRootMotionTranslationScale_0 = AnimRootMotionTranslationScale_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateBase.Button_A
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_A(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_A");

	Params::StateBase_Button_A Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_B
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_B(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_B");

	Params::StateBase_Button_B Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_Down
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_Down(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_Down");

	Params::StateBase_Button_Down Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_L
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_L(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_L");

	Params::StateBase_Button_L Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_Left
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_Left(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_Left");

	Params::StateBase_Button_Left Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_LT
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_LT(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_LT");

	Params::StateBase_Button_LT Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_PC_R
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_PC_R(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_PC_R");

	Params::StateBase_Button_PC_R Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_PC_T
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_PC_T(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_PC_T");

	Params::StateBase_Button_PC_T Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_R
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_R(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_R");

	Params::StateBase_Button_R Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_Right
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_Right(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_Right");

	Params::StateBase_Button_Right Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_RMB
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_RMB(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_RMB");

	Params::StateBase_Button_RMB Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_RT
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_RT(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_RT");

	Params::StateBase_Button_RT Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_Up
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_Up(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_Up");

	Params::StateBase_Button_Up Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_X
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_X(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_X");

	Params::StateBase_Button_X Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Button_Y
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Button_Y(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Button_Y");

	Params::StateBase_Button_Y Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Cancel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UStateBase::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Cancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Enter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UStateBase::Enter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Enter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Exit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UStateBase::Exit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Exit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Move
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InputVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Move(const struct FVector& InputVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Move");

	Params::StateBase_Move Parms{};

	Parms.InputVector = std::move(InputVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.SpecialLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::SpecialLeft(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "SpecialLeft");

	Params::StateBase_SpecialLeft Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.SpecialRight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::SpecialRight(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "SpecialRight");

	Params::StateBase_SpecialRight Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.TakeAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ActionTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::TakeAction(const struct FGameplayTag& ActionTag, bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "TakeAction");

	Params::StateBase_TakeAction Parms{};

	Parms.ActionTag = std::move(ActionTag);
	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Thumb_Left
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Thumb_Left(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Thumb_Left");

	Params::StateBase_Thumb_Left Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.Update
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "Update");

	Params::StateBase_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateBase.CalcAxisValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStateBase::CalcAxisValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "CalcAxisValue");

	Params::StateBase_CalcAxisValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateBase.GetInputRotation
// (Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UStateBase::GetInputRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "GetInputRotation");

	Params::StateBase_GetInputRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateBase.GetLastMovementInput
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UStateBase::GetLastMovementInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "GetLastMovementInput");

	Params::StateBase_GetLastMovementInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateBase.GetMoveRotation
// (Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UStateBase::GetMoveRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "GetMoveRotation");

	Params::StateBase_GetMoveRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateBase.GetMoveValue
// (Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Axis                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateBase::GetMoveValue(float* Axis, float* Direction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateBase", "GetMoveValue");

	Params::StateBase_GetMoveValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Axis != nullptr)
		*Axis = Parms.Axis;

	if (Direction != nullptr)
		*Direction = Parms.Direction;
}


// Function DarwinGame.UIDungeon_Floor.SetRoomNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewRoomNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIDungeon_Floor::SetRoomNumber(int32 NewRoomNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIDungeon_Floor", "SetRoomNumber");

	Params::UIDungeon_Floor_SetRoomNumber Parms{};

	Parms.NewRoomNumber = NewRoomNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MoveStateBase.CheckFrontWall
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   RayLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IncidentAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Top                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Bottom                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoveStateBase::CheckFrontWall(float RayLength, float Angle, float IncidentAngle, float Top, float Bottom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "CheckFrontWall");

	Params::MoveStateBase_CheckFrontWall Parms{};

	Parms.RayLength = RayLength;
	Parms.Angle = Angle;
	Parms.IncidentAngle = IncidentAngle;
	Parms.Top = Top;
	Parms.Bottom = Bottom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MoveStateBase.CheckWallHeight
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Top                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Bottom                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoveStateBase::CheckWallHeight(float Top, float Bottom, float* Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "CheckWallHeight");

	Params::MoveStateBase_CheckWallHeight Parms{};

	Parms.Top = Top;
	Parms.Bottom = Bottom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Height != nullptr)
		*Height = Parms.Height;

	return Parms.ReturnValue;
}


// Function DarwinGame.MoveStateBase.GetGradientVector
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoveStateBase::GetGradientVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "GetGradientVector");

	Params::MoveStateBase_GetGradientVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MoveStateBase.SetNextMoveStateTag
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoveStateBase::SetNextMoveStateTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "SetNextMoveStateTag");

	Params::MoveStateBase_SetNextMoveStateTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MoveStateBase.GetNextMoveStateTag
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UMoveStateBase::GetNextMoveStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "GetNextMoveStateTag");

	Params::MoveStateBase_GetNextMoveStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MoveStateBase.GetWallSurface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UMoveStateBase::GetWallSurface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "GetWallSurface");

	Params::MoveStateBase_GetWallSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MoveStateBase.IsWallSurfaceFound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoveStateBase::IsWallSurfaceFound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveStateBase", "IsWallSurfaceFound");

	Params::MoveStateBase_IsWallSurfaceFound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.AddExp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Exp                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::AddExp(const int32 Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "AddExp");

	Params::GameDataPlayer_AddExp Parms{};

	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.AddGold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Gold                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::AddGold(int32 Gold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "AddGold");

	Params::GameDataPlayer_AddGold Parms{};

	Parms.Gold = Gold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataPlayer*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataPlayer* UGameDataPlayer::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "Clone");

	Params::GameDataPlayer_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataPlayer*                  game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::Overwrite(class UGameDataPlayer* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "Overwrite");

	Params::GameDataPlayer_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetAttributeList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class FName, int32>                list                                                   (Parm, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetAttributeList(const TMap<class FName, int32>& list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetAttributeList");

	Params::GameDataPlayer_SetAttributeList Parms{};

	Parms.list = std::move(list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetBP(int32 BP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetBP");

	Params::GameDataPlayer_SetBP Parms{};

	Parms.BP = BP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetEquipmentCoins
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FST_CoinData>             EquipmentCoins                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetEquipmentCoins(const TArray<struct FST_CoinData>& EquipmentCoins)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetEquipmentCoins");

	Params::GameDataPlayer_SetEquipmentCoins Parms{};

	Parms.EquipmentCoins = std::move(EquipmentCoins);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetFeatureBuffList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class FName, struct FFeatureMapData>list                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetFeatureBuffList(const TMap<class FName, struct FFeatureMapData>& list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetFeatureBuffList");

	Params::GameDataPlayer_SetFeatureBuffList Parms{};

	Parms.list = std::move(list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetGold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Gold                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetGold(int32 Gold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetGold");

	Params::GameDataPlayer_SetGold Parms{};

	Parms.Gold = Gold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   HP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetHP(int32 HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetHP");

	Params::GameDataPlayer_SetHP Parms{};

	Parms.HP = HP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.SetMP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataPlayer::SetMP(int32 MP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "SetMP");

	Params::GameDataPlayer_SetMP Parms{};

	Parms.MP = MP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataPlayer.GetAdvanceStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UGameDataPlayer::GetAdvanceStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetAdvanceStatus");

	Params::GameDataPlayer_GetAdvanceStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetAttributeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, int32>          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<class FName, int32> UGameDataPlayer::GetAttributeList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetAttributeList");

	Params::GameDataPlayer_GetAttributeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetBaseStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UGameDataPlayer::GetBaseStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetBaseStatus");

	Params::GameDataPlayer_GetBaseStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetBP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetBP");

	Params::GameDataPlayer_GetBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetEquipmentCoins
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FST_CoinData>       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TArray<struct FST_CoinData> UGameDataPlayer::GetEquipmentCoins() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetEquipmentCoins");

	Params::GameDataPlayer_GetEquipmentCoins Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetFeatureBuffList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, struct FFeatureMapData>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<class FName, struct FFeatureMapData> UGameDataPlayer::GetFeatureBuffList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetFeatureBuffList");

	Params::GameDataPlayer_GetFeatureBuffList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetGold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetGold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetGold");

	Params::GameDataPlayer_GetGold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetHP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetHP");

	Params::GameDataPlayer_GetHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetLevel");

	Params::GameDataPlayer_GetLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetMP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetMP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetMP");

	Params::GameDataPlayer_GetMP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetRequiredExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetRequiredExp(int32 Level) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetRequiredExp");

	Params::GameDataPlayer_GetRequiredExp Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetRequiredExpToNextLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetRequiredExpToNextLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetRequiredExpToNextLevel");

	Params::GameDataPlayer_GetRequiredExpToNextLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetRequiredExpToNextLevelPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameDataPlayer::GetRequiredExpToNextLevelPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetRequiredExpToNextLevelPercent");

	Params::GameDataPlayer_GetRequiredExpToNextLevelPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UGameDataPlayer::GetStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetStatus");

	Params::GameDataPlayer_GetStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.GetTotalExp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataPlayer::GetTotalExp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "GetTotalExp");

	Params::GameDataPlayer_GetTotalExp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.IsKindKamyu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataPlayer::IsKindKamyu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "IsKindKamyu");

	Params::GameDataPlayer_IsKindKamyu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataPlayer.IsKindMaya
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataPlayer::IsKindMaya() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataPlayer", "IsKindMaya");

	Params::GameDataPlayer_IsKindMaya Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BaseAreaLevelUpDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UBaseAreaLevelUpDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAreaLevelUpDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AbyssRectTrigger.OnBeginOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAbyssRectTrigger::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbyssRectTrigger", "OnBeginOverlap");

	Params::AbyssRectTrigger_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActingArtifact.OnLand
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActingArtifact::OnLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActingArtifact", "OnLand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActingArtifact.StartFall
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActingArtifact::StartFall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActingArtifact", "StartFall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActingArtifact.StartSevenStoneAdjustLocation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActingArtifact::StartSevenStoneAdjustLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActingArtifact", "StartSevenStoneAdjustLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActingArtifact.StartSevenStoneAdjustRotation
// (Final, Native, Public, BlueprintCallable)

void AActingArtifact::StartSevenStoneAdjustRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActingArtifact", "StartSevenStoneAdjustRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActingArtifact.StartSevenStoneEffectDirection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActingArtifact::StartSevenStoneEffectDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActingArtifact", "StartSevenStoneEffectDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActingArtifact.StartSevenStoneLineDirection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AActingArtifact::StartSevenStoneLineDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActingArtifact", "StartSevenStoneLineDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionAbilitySystemComponent.AddOnlyGameplayTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionAbilitySystemComponent::AddOnlyGameplayTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAbilitySystemComponent", "AddOnlyGameplayTag");

	Params::ActionAbilitySystemComponent_AddOnlyGameplayTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionAbilitySystemComponent.HasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionAbilitySystemComponent::HasTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAbilitySystemComponent", "HasTag");

	Params::ActionAbilitySystemComponent_HasTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionAbilitySystemComponent.SetPauseAllActiveGameplayEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Pause                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionAbilitySystemComponent::SetPauseAllActiveGameplayEffects(bool Pause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAbilitySystemComponent", "SetPauseAllActiveGameplayEffects");

	Params::ActionAbilitySystemComponent_SetPauseAllActiveGameplayEffects Parms{};

	Parms.Pause = Pause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionAbilitySystemComponent.GetOwnedTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UActionAbilitySystemComponent::GetOwnedTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAbilitySystemComponent", "GetOwnedTags");

	Params::ActionAbilitySystemComponent_GetOwnedTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionAssistFindWater.OnBeginOverlapCollision
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActionAssistFindWater::OnBeginOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAssistFindWater", "OnBeginOverlapCollision");

	Params::ActionAssistFindWater_OnBeginOverlapCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionAssistFindWater.OnEndOverlapCollision
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionAssistFindWater::OnEndOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionAssistFindWater", "OnEndOverlapCollision");

	Params::ActionAssistFindWater_OnEndOverlapCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.Deselect
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUIMenuItemBase::Deselect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "Deselect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.UIMenuItemBase.Focus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUIMenuItemBase::Focus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "Focus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.FocusImidiate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUIMenuItemBase::FocusImidiate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "FocusImidiate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.GetCursorPosition
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HasCursor                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Position                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuItemBase::GetCursorPosition(bool* HasCursor, struct FVector2D* Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "GetCursorPosition");

	Params::UIMenuItemBase_GetCursorPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HasCursor != nullptr)
		*HasCursor = Parms.HasCursor;

	if (Position != nullptr)
		*Position = std::move(Parms.Position);
}


// Function DarwinGame.UIMenuItemBase.GetNavigationItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIMenuItemBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIMenuItemBase* UUIMenuItemBase::GetNavigationItem(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "GetNavigationItem");

	Params::UIMenuItemBase_GetNavigationItem Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.GetNavigationItemWithSelectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIMenuItemBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIMenuItemBase* UUIMenuItemBase::GetNavigationItemWithSelectable(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "GetNavigationItemWithSelectable");

	Params::UIMenuItemBase_GetNavigationItemWithSelectable Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.GetNavigationItemWithSelectableKeyRepead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIMenuItemBase*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIMenuItemBase* UUIMenuItemBase::GetNavigationItemWithSelectableKeyRepead(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "GetNavigationItemWithSelectableKeyRepead");

	Params::UIMenuItemBase_GetNavigationItemWithSelectableKeyRepead Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.HasNavigationItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuItemBase::HasNavigationItem(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "HasNavigationItem");

	Params::UIMenuItemBase_HasNavigationItem Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.IsKeyEdge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuItemBase::IsKeyEdge(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "IsKeyEdge");

	Params::UIMenuItemBase_IsKeyEdge Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.IsKeyRepeatSelectable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuItemBase::IsKeyRepeatSelectable(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "IsKeyRepeatSelectable");

	Params::UIMenuItemBase_IsKeyRepeatSelectable Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.IsSelectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuItemBase::IsSelectable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "IsSelectable");

	Params::UIMenuItemBase_IsSelectable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.IsSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuItemBase::IsSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "IsSelected");

	Params::UIMenuItemBase_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuItemBase.OutFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUIMenuItemBase::OutFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "OutFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.OutFocusImidiate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UUIMenuItemBase::OutFocusImidiate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "OutFocusImidiate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.RemoveNavigationItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuItemBase::RemoveNavigationItem(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "RemoveNavigationItem");

	Params::UIMenuItemBase_RemoveNavigationItem Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.Select
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUIMenuItemBase::Select()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "Select");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.UIMenuItemBase.SetNavigationItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIMenuItemBase*                  ToItem                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    KeyRepeatSelectable                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    KeyEdge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuItemBase::SetNavigationItem(EAxisMappingType Key, class UUIMenuItemBase* ToItem, bool KeyRepeatSelectable, bool KeyEdge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "SetNavigationItem");

	Params::UIMenuItemBase_SetNavigationItem Parms{};

	Parms.Key = Key;
	Parms.ToItem = ToItem;
	Parms.KeyRepeatSelectable = KeyRepeatSelectable;
	Parms.KeyEdge = KeyEdge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.SetNavigationItemLR
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_UIMenuNavigationItem         Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FST_UIMenuNavigationItem         Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UUIMenuItemBase::SetNavigationItemLR(const struct FST_UIMenuNavigationItem& Left, const struct FST_UIMenuNavigationItem& Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "SetNavigationItemLR");

	Params::UIMenuItemBase_SetNavigationItemLR Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = std::move(Right);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuItemBase.SetSelectable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewParam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuItemBase::SetSelectable(bool NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuItemBase", "SetSelectable");

	Params::UIMenuItemBase_SetSelectable Parms{};

	Parms.NewParam = NewParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.GetArrow
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UCanvasPanel*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCanvasPanel* UUIScrollMenuItemBase::GetArrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "GetArrow");

	Params::UIScrollMenuItemBase_GetArrow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuItemBase.GetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UUIScrollMenuItemBase::GetPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "GetPosition");

	Params::UIScrollMenuItemBase_GetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuItemBase.GetScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UUIScrollMenuItemBase::GetScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "GetScale");

	Params::UIScrollMenuItemBase_GetScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIScrollMenuItemBase.Move
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InTargetPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InTargetScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPosIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::Move(const struct FVector2D& InTargetPosition, const struct FVector2D& InTargetScale, int32 InPosIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "Move");

	Params::UIScrollMenuItemBase_Move Parms{};

	Parms.InTargetPosition = std::move(InTargetPosition);
	Parms.InTargetScale = std::move(InTargetScale);
	Parms.InPosIndex = InPosIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.PlayLoopAnimation
// (Final, Native, Protected, BlueprintCallable)

void UUIScrollMenuItemBase::PlayLoopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "PlayLoopAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.SetFocusAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Focus_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 OutFocus_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 Loop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::SetFocusAnimation(class UWidgetAnimation* Focus_0, class UWidgetAnimation* OutFocus_0, class UWidgetAnimation* Loop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "SetFocusAnimation");

	Params::UIScrollMenuItemBase_SetFocusAnimation Parms{};

	Parms.Focus_0 = Focus_0;
	Parms.OutFocus_0 = OutFocus_0;
	Parms.Loop = Loop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.SetFocusAnimationByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             FocusName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutFocusName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LoopName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::SetFocusAnimationByName(class FName FocusName, class FName OutFocusName, class FName LoopName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "SetFocusAnimationByName");

	Params::UIScrollMenuItemBase_SetFocusAnimationByName Parms{};

	Parms.FocusName = FocusName;
	Parms.OutFocusName = OutFocusName;
	Parms.LoopName = LoopName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.SetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::SetPosition(const struct FVector2D& InPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "SetPosition");

	Params::UIScrollMenuItemBase_SetPosition Parms{};

	Parms.InPosition = std::move(InPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.SetScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::SetScale(const struct FVector2D& InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "SetScale");

	Params::UIScrollMenuItemBase_SetScale Parms{};

	Parms.InScale = std::move(InScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.SetScrollItem
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPosIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::SetScrollItem(int32 Index_0, const struct FVector2D& InPosition, const struct FVector2D& InScale, int32 InPosIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "SetScrollItem");

	Params::UIScrollMenuItemBase_SetScrollItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.InPosition = std::move(InPosition);
	Parms.InScale = std::move(InScale);
	Parms.InPosIndex = InPosIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.StartLoopAnimation
// (Final, Native, Protected, BlueprintCallable)

void UUIScrollMenuItemBase::StartLoopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "StartLoopAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.StopLoopAnimation
// (Final, Native, Protected, BlueprintCallable)

void UUIScrollMenuItemBase::StopLoopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "StopLoopAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.UpdatePosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InScrollSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::UpdatePosition(float InDeltaTime, float InScrollSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "UpdatePosition");

	Params::UIScrollMenuItemBase_UpdatePosition Parms{};

	Parms.InDeltaTime = InDeltaTime;
	Parms.InScrollSpeed = InScrollSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIScrollMenuItemBase.UpdateScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InScalingSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIScrollMenuItemBase::UpdateScale(float InDeltaTime, float InScalingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIScrollMenuItemBase", "UpdateScale");

	Params::UIScrollMenuItemBase_UpdateScale Parms{};

	Parms.InDeltaTime = InDeltaTime;
	Parms.InScalingSpeed = InScalingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionComponent.CanParkour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETraceTypeQuery                         TraceType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionComponent::CanParkour(const ETraceTypeQuery TraceType, EDrawDebugTrace DrawDebugType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionComponent", "CanParkour");

	Params::ActionComponent_CanParkour Parms{};

	Parms.TraceType = TraceType;
	Parms.DrawDebugType = DrawDebugType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.BlowToAttackerDirection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionDataTable::BlowToAttackerDirection(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "BlowToAttackerDirection");

	Params::ActionDataTable_BlowToAttackerDirection Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.ConvertActionOverviewID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActionOverviewID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActionLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharacterLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             outOverviewID                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionDataTable::ConvertActionOverviewID(class FName ActionOverviewID, int32 ActionLevel, int32 CharacterLevel, class FName* outOverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "ConvertActionOverviewID");

	Params::ActionDataTable_ConvertActionOverviewID Parms{};

	Parms.ActionOverviewID = ActionOverviewID;
	Parms.ActionLevel = ActionLevel;
	Parms.CharacterLevel = CharacterLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outOverviewID != nullptr)
		*outOverviewID = Parms.outOverviewID;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.DecideDeriVateID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActionDataTable::DecideDeriVateID(class FName ActionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "DecideDeriVateID");

	Params::ActionDataTable_DecideDeriVateID Parms{};

	Parms.ActionID = ActionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetActionEffections
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectEffectionEnum>            Effections                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionDataTable::GetActionEffections(class FName DetailID, TArray<EObjectEffectionEnum>* Effections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetActionEffections");

	Params::ActionDataTable_GetActionEffections Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Effections != nullptr)
		*Effections = std::move(Parms.Effections);
}


// Function DarwinGame.ActionDataTable.GetActionTargetType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActionTargetType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActionTargetType UActionDataTable::GetActionTargetType(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetActionTargetType");

	Params::ActionDataTable_GetActionTargetType Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetActPerformance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_ActionPerformance            Performance                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionDataTable::GetActPerformance(class FName OverviewID, struct FST_ActionPerformance* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetActPerformance");

	Params::ActionDataTable_GetActPerformance Parms{};

	Parms.OverviewID = OverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.GetAttributes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_Attribute>            Attributes                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionDataTable::GetAttributes(class FName DetailID, TArray<struct FST_Attribute>* Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetAttributes");

	Params::ActionDataTable_GetAttributes Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Attributes != nullptr)
		*Attributes = std::move(Parms.Attributes);
}


// Function DarwinGame.ActionDataTable.GetBallisticPerformance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_BallisticPerformance         Performance                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionDataTable::GetBallisticPerformance(class FName DetailID, struct FST_BallisticPerformance* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetBallisticPerformance");

	Params::ActionDataTable_GetBallisticPerformance Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.GetCastTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionDataTable::GetCastTime(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetCastTime");

	Params::ActionDataTable_GetCastTime Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetChildActionPerformance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_ChildActionPerformance       Performance                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionDataTable::GetChildActionPerformance(class FName DetailID, struct FST_ChildActionPerformance* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetChildActionPerformance");

	Params::ActionDataTable_GetChildActionPerformance Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.GetClassType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActionClassType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActionClassType UActionDataTable::GetClassType(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetClassType");

	Params::ActionDataTable_GetClassType Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetClassTypeFromOverViewID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActionClassType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActionClassType UActionDataTable::GetClassTypeFromOverViewID(class FName OverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetClassTypeFromOverViewID");

	Params::ActionDataTable_GetClassTypeFromOverViewID Parms{};

	Parms.OverviewID = OverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetCorrectValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActionDataTable::GetCorrectValue(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetCorrectValue");

	Params::ActionDataTable_GetCorrectValue Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetDamageData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEnemy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_AttackData                   AttackData                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UActionDataTable::GetDamageData(class FName DetailID, bool IsEnemy, struct FST_AttackData* AttackData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetDamageData");

	Params::ActionDataTable_GetDamageData Parms{};

	Parms.DetailID = DetailID;
	Parms.IsEnemy = IsEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AttackData != nullptr)
		*AttackData = std::move(Parms.AttackData);
}


// Function DarwinGame.ActionDataTable.GetEffectType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EActionEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActionEffectType UActionDataTable::GetEffectType(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetEffectType");

	Params::ActionDataTable_GetEffectType Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetHitStopTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionDataTable::GetHitStopTime(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetHitStopTime");

	Params::ActionDataTable_GetHitStopTime Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetLaserPerformance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_LaserPerformance             Performance                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionDataTable::GetLaserPerformance(class FName DetailID, struct FST_LaserPerformance* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetLaserPerformance");

	Params::ActionDataTable_GetLaserPerformance Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.GetOverHeadFallPerformance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_OverHeadFallPerformanceDefinePerformance                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionDataTable::GetOverHeadFallPerformance(class FName OverviewID, struct FST_OverHeadFallPerformanceDefine* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetOverHeadFallPerformance");

	Params::ActionDataTable_GetOverHeadFallPerformance Parms{};

	Parms.OverviewID = OverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.GetOverviewID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActionDataTable::GetOverviewID(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetOverviewID");

	Params::ActionDataTable_GetOverviewID Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetReactionType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageReactionType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDamageReactionType UActionDataTable::GetReactionType(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetReactionType");

	Params::ActionDataTable_GetReactionType Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetRequiredMP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionOverviewID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActionDataTable::GetRequiredMP(class FName ActionOverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetRequiredMP");

	Params::ActionDataTable_GetRequiredMP Parms{};

	Parms.ActionOverviewID = ActionOverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetResistanceID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EResistJudgeType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsEnemy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActionDataTable::GetResistanceID(class FName DetailID, EResistJudgeType Type, bool bIsEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetResistanceID");

	Params::ActionDataTable_GetResistanceID Parms{};

	Parms.DetailID = DetailID;
	Parms.Type = Type;
	Parms.bIsEnemy = bIsEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.GetResistanceTypes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EResistanceType>                 Types                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionDataTable::GetResistanceTypes(class FName DetailID, TArray<EResistanceType>* Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetResistanceTypes");

	Params::ActionDataTable_GetResistanceTypes Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Types != nullptr)
		*Types = std::move(Parms.Types);
}


// Function DarwinGame.ActionDataTable.GetShotgunActionPerformance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_ShotgunActionPerformance>Performance                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionDataTable::GetShotgunActionPerformance(class FName DetailID, TArray<struct FST_ShotgunActionPerformance>* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetShotgunActionPerformance");

	Params::ActionDataTable_GetShotgunActionPerformance Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.GetTargetArea
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TargetArea                   Performance                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UActionDataTable::GetTargetArea(class FName OverviewID, struct FST_TargetArea* Performance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "GetTargetArea");

	Params::ActionDataTable_GetTargetArea Parms{};

	Parms.OverviewID = OverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Performance != nullptr)
		*Performance = std::move(Parms.Performance);
}


// Function DarwinGame.ActionDataTable.IsDerivateOverviewID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionDataTable::IsDerivateOverviewID(class FName OverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "IsDerivateOverviewID");

	Params::ActionDataTable_IsDerivateOverviewID Parms{};

	Parms.OverviewID = OverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.IsEnableHitStop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DetailID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionDataTable::IsEnableHitStop(class FName DetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "IsEnableHitStop");

	Params::ActionDataTable_IsEnableHitStop Parms{};

	Parms.DetailID = DetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionDataTable.UseCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActionDataTable::UseCurve(class FName OverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActionDataTable", "UseCurve");

	Params::ActionDataTable_UseCurve Parms{};

	Parms.OverviewID = OverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataShop.AddBoughtItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataShop::AddBoughtItem(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "AddBoughtItem");

	Params::GameDataShop_AddBoughtItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataShop.AddId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNew                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataShop::AddId(const class FName& ID, bool IsNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "AddId");

	Params::GameDataShop_AddId Parms{};

	Parms.ID = ID;
	Parms.IsNew = IsNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataShop.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataShop*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataShop* UGameDataShop::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "Clone");

	Params::GameDataShop_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataShop.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataShop*                    game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataShop::Overwrite(class UGameDataShop* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "Overwrite");

	Params::GameDataShop_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataShop.SetIsNewItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNew                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataShop::SetIsNewItem(const class FName& ID, bool IsNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "SetIsNewItem");

	Params::GameDataShop_SetIsNewItem Parms{};

	Parms.ID = ID;
	Parms.IsNew = IsNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataShop.IsBoughtItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataShop::IsBoughtItem(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "IsBoughtItem");

	Params::GameDataShop_IsBoughtItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataShop.IsContainId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataShop::IsContainId(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "IsContainId");

	Params::GameDataShop_IsContainId Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataShop.IsNewItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataShop::IsNewItem(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "IsNewItem");

	Params::GameDataShop_IsNewItem Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataShop.IsNewShopData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ShopID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataShop::IsNewShopData(int32 ShopID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataShop", "IsNewShopData");

	Params::GameDataShop_IsNewShopData Parms{};

	Parms.ShopID = ShopID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.AddPlayerActionCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQuestClearPlayerActionType             Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestFunctionLibrary::AddPlayerActionCount(const EQuestClearPlayerActionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "AddPlayerActionCount");

	Params::QuestFunctionLibrary_AddPlayerActionCount Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestFunctionLibrary.AddPlayerActionNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQuestClearPlayerActionType             Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestFunctionLibrary::AddPlayerActionNum(const EQuestClearPlayerActionType Type, const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "AddPlayerActionNum");

	Params::QuestFunctionLibrary_AddPlayerActionNum Parms{};

	Parms.Type = Type;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestFunctionLibrary.ArrivalDestination
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestFunctionLibrary::ArrivalDestination(const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "ArrivalDestination");

	Params::QuestFunctionLibrary_ArrivalDestination Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestFunctionLibrary.CalcQuestCountRandom
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Param                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UQuestFunctionLibrary::CalcQuestCountRandom(const int32 Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CalcQuestCountRandom");

	Params::QuestFunctionLibrary_CalcQuestCountRandom Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckArtifactDetectNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_QuestListClear               ClearDat                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameDataQuest*                   GameDataQuest                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckArtifactDetectNum(const struct FST_QuestListClear& ClearDat, const class FName QuestID, const class UGameDataQuest* GameDataQuest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckArtifactDetectNum");

	Params::QuestFunctionLibrary_CheckArtifactDetectNum Parms{};

	Parms.ClearDat = std::move(ClearDat);
	Parms.QuestID = QuestID;
	Parms.GameDataQuest = GameDataQuest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckArtifactDisplayNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_QuestListClear               ClearDat                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOrderQuestData                  OrderData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckArtifactDisplayNum(const struct FST_QuestListClear& ClearDat, const struct FOrderQuestData& OrderData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckArtifactDisplayNum");

	Params::QuestFunctionLibrary_CheckArtifactDisplayNum Parms{};

	Parms.ClearDat = std::move(ClearDat);
	Parms.OrderData = std::move(OrderData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckArtifactGetNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_QuestListClear               ClearDat                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameDataQuest*                   GameDataQuest                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckArtifactGetNum(const struct FST_QuestListClear& ClearDat, const class FName QuestID, const class UGameDataQuest* GameDataQuest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckArtifactGetNum");

	Params::QuestFunctionLibrary_CheckArtifactGetNum Parms{};

	Parms.ClearDat = std::move(ClearDat);
	Parms.QuestID = QuestID;
	Parms.GameDataQuest = GameDataQuest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckArtifactSum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_QuestListClear               ClearDat                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckArtifactSum(const struct FST_QuestListClear& ClearDat, const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckArtifactSum");

	Params::QuestFunctionLibrary_CheckArtifactSum Parms{};

	Parms.ClearDat = std::move(ClearDat);
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckClearTargetObjectDestroy
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   ClearNum                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckClearTargetObjectDestroy(const int32& ClearNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckClearTargetObjectDestroy");

	Params::QuestFunctionLibrary_CheckClearTargetObjectDestroy Parms{};

	Parms.ClearNum = ClearNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckFriendMonsterNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   friend_num                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckFriendMonsterNum(int32 friend_num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckFriendMonsterNum");

	Params::QuestFunctionLibrary_CheckFriendMonsterNum Parms{};

	Parms.friend_num = friend_num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckMonsterVisionNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_QuestListClear               ClearDat                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckMonsterVisionNum(const struct FST_QuestListClear& ClearDat, const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckMonsterVisionNum");

	Params::QuestFunctionLibrary_CheckMonsterVisionNum Parms{};

	Parms.ClearDat = std::move(ClearDat);
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.CheckTeamRank
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   team_rank                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestFunctionLibrary::CheckTeamRank(int32 team_rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "CheckTeamRank");

	Params::QuestFunctionLibrary_CheckTeamRank Parms{};

	Parms.team_rank = team_rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestFunctionLibrary.PlayQuestEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             quest_id                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestFunctionLibrary::PlayQuestEvent(const class FName& quest_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "PlayQuestEvent");

	Params::QuestFunctionLibrary_PlayQuestEvent Parms{};

	Parms.quest_id = quest_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestFunctionLibrary.ResetArrivalDestination
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RectID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestFunctionLibrary::ResetArrivalDestination(const class FName RectID, const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestFunctionLibrary", "ResetArrivalDestination");

	Params::QuestFunctionLibrary_ResetArrivalDestination Parms{};

	Parms.RectID = RectID;
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.AdjustLocation
// (Native, Protected, BlueprintCallable)

void UActionGameplayAbility::AdjustLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "AdjustLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.AdjustState
// (Final, Native, Protected, BlueprintCallable)

void UActionGameplayAbility::AdjustState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "AdjustState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.CalculateBaseLocation
// (Final, Native, Protected, BlueprintCallable)

void UActionGameplayAbility::CalculateBaseLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "CalculateBaseLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.Cancel
// (Final, Native, Public, BlueprintCallable)

void UActionGameplayAbility::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "Cancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.CreateEffectContainerSpec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FActionGameplayEffectContainerSpec UActionGameplayAbility::CreateEffectContainerSpec(class FName actionDetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "CreateEffectContainerSpec");

	Params::ActionGameplayAbility_CreateEffectContainerSpec Parms{};

	Parms.actionDetailID = actionDetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionGameplayAbility.CreateEffectContainerSpecFromActionOverViewID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionOverviewID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FActionGameplayEffectContainerSpec UActionGameplayAbility::CreateEffectContainerSpecFromActionOverViewID(class FName ActionOverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "CreateEffectContainerSpecFromActionOverViewID");

	Params::ActionGameplayAbility_CreateEffectContainerSpecFromActionOverViewID Parms{};

	Parms.ActionOverviewID = ActionOverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionGameplayAbility.CreateEffectContainerSpecWithAttackResult
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttackHitResultStruct           AttackResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FActionGameplayEffectContainerSpec UActionGameplayAbility::CreateEffectContainerSpecWithAttackResult(class FName actionDetailID, const struct FAttackHitResultStruct& AttackResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "CreateEffectContainerSpecWithAttackResult");

	Params::ActionGameplayAbility_CreateEffectContainerSpecWithAttackResult Parms{};

	Parms.actionDetailID = actionDetailID;
	Parms.AttackResult = std::move(AttackResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionGameplayAbility.Debug_CheckPrintTask
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    OnBlend                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnIntercept                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnCancel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionGameplayAbility::Debug_CheckPrintTask(bool OnBlend, bool OnIntercept, bool OnCancel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "Debug_CheckPrintTask");

	Params::ActionGameplayAbility_Debug_CheckPrintTask Parms{};

	Parms.OnBlend = OnBlend;
	Parms.OnIntercept = OnIntercept;
	Parms.OnCancel = OnCancel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.Debug_SetNeedCallOnTaskFinish
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionGameplayAbility::Debug_SetNeedCallOnTaskFinish(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "Debug_SetNeedCallOnTaskFinish");

	Params::ActionGameplayAbility_Debug_SetNeedCallOnTaskFinish Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.End
// (Final, Native, Public, BlueprintCallable)

void UActionGameplayAbility::End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.EndMoveOnCurve
// (Final, Native, Protected, BlueprintCallable)

void UActionGameplayAbility::EndMoveOnCurve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "EndMoveOnCurve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.JumpToSection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionGameplayAbility::JumpToSection(class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "JumpToSection");

	Params::ActionGameplayAbility_JumpToSection Parms{};

	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.OnCollisionHit
// (Final, Native, Protected, BlueprintCallable)

void UActionGameplayAbility::OnCollisionHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "OnCollisionHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.SetNextSection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionGameplayAbility::SetNextSection(class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "SetNextSection");

	Params::ActionGameplayAbility_SetNextSection Parms{};

	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionGameplayAbility.StopEquipMotion
// (Final, Native, Protected, BlueprintCallable)

void UActionGameplayAbility::StopEquipMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionGameplayAbility", "StopEquipMotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpawnedCallbackHolder.countKillNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterSpawnedCallbackHolder::countKillNumber(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpawnedCallbackHolder", "countKillNumber");

	Params::MonsterSpawnedCallbackHolder_countKillNumber Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpawnedCallbackHolder.GetKillCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterSpawnedCallbackHolder::GetKillCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpawnedCallbackHolder", "GetKillCount");

	Params::MonsterSpawnedCallbackHolder_GetKillCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterSpawnedCallbackHolder.ResetKillCount
// (Final, Native, Public, BlueprintCallable)

void AMonsterSpawnedCallbackHolder::ResetKillCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpawnedCallbackHolder", "ResetKillCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpawnedCallbackHolder.SetKillCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterSpawnedCallbackHolder::SetKillCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpawnedCallbackHolder", "SetKillCount");

	Params::MonsterSpawnedCallbackHolder_SetKillCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpawnedCallbackHolder.SetTargetBattleID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BattleID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterSpawnedCallbackHolder::SetTargetBattleID(class FName BattleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpawnedCallbackHolder", "SetTargetBattleID");

	Params::MonsterSpawnedCallbackHolder_SetTargetBattleID Parms{};

	Parms.BattleID = BattleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionPoint.GetGameFlag
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AActionPoint::GetGameFlag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionPoint", "GetGameFlag");

	Params::ActionPoint_GetGameFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionPoint.GetType
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActionPointType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActionPointType AActionPoint::GetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionPoint", "GetType");

	Params::ActionPoint_GetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsNotifyState_MonsterTimeWait.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterTimeWait::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterTimeWait", "NotifyBegin");

	Params::MonsNotifyState_MonsterTimeWait_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterTimeWait.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterTimeWait::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterTimeWait", "NotifyEnd");

	Params::MonsNotifyState_MonsterTimeWait_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterTimeWait.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterTimeWait::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterTimeWait", "NotifyTick");

	Params::MonsNotifyState_MonsterTimeWait_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectBase.DoEventEndSubBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldObjectBase::DoEventEndSubBP(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "DoEventEndSubBP");

	Params::FieldObjectBase_DoEventEndSubBP Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.FieldObjectBase.DoEventStartSubBP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldObjectBase::DoEventStartSubBP(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "DoEventStartSubBP");

	Params::FieldObjectBase_DoEventStartSubBP Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.FieldObjectBase.OnInitializeSub
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AFieldObjectBase::OnInitializeSub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "OnInitializeSub");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.FieldObjectBase.OnPauseSub
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AFieldObjectBase::OnPauseSub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "OnPauseSub");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.FieldObjectBase.OnReceiveEventSubBP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEventStruct                     Info                                                   (Parm, NativeAccessSpecifierPublic)

void AFieldObjectBase::OnReceiveEventSubBP(const struct FEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "OnReceiveEventSubBP");

	Params::FieldObjectBase_OnReceiveEventSubBP Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.FieldObjectBase.OnReceiveHitSubBP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EObjectEffectionEnum                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Inst                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldObjectBase::OnReceiveHitSubBP(EObjectEffectionEnum Type, class AActor* Inst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "OnReceiveHitSubBP");

	Params::FieldObjectBase_OnReceiveHitSubBP Parms{};

	Parms.Type = Type;
	Parms.Inst = Inst;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.FieldObjectBase.OnResumeSub
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AFieldObjectBase::OnResumeSub()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "OnResumeSub");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.FieldObjectBase.OnShowObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldObjectBase::OnShowObject(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "OnShowObject");

	Params::FieldObjectBase_OnShowObject Parms{};

	Parms.IsShow = IsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectBase.Pause
// (Final, Native, Public, BlueprintCallable)

void AFieldObjectBase::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectBase.Resume
// (Final, Native, Public, BlueprintCallable)

void AFieldObjectBase::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectBase.SetActorHiddenInGameToAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldObjectBase::SetActorHiddenInGameToAll(bool bNewHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectBase", "SetActorHiddenInGameToAll");

	Params::FieldObjectBase_SetActorHiddenInGameToAll Parms{};

	Parms.bNewHidden = bNewHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.AttachToRail
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InboundVector                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrainBase::AttachToRail(const struct FVector& Location, const struct FVector& InboundVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "AttachToRail");

	Params::TrainBase_AttachToRail Parms{};

	Parms.Location = std::move(Location);
	Parms.InboundVector = std::move(InboundVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.
// (Final, Native, Public)

void ATrainBase::m________________________2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.
// (Final, Native, Public)

void ATrainBase::m________________________1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.
// (Final, Native, Public)

void ATrainBase::m________________________0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.
// (Final, Native, Public)

void ATrainBase::m_______________________()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.SetRelease
// (Final, Native, Private, BlueprintCallable)

void ATrainBase::SetRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "SetRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.SetVisibleTrainRail
// (Final, Native, Public, BlueprintCallable)

void ATrainBase::SetVisibleTrainRail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "SetVisibleTrainRail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.TurnOnHeadLamp
// (Final, Native, Public, BlueprintCallable)

void ATrainBase::TurnOnHeadLamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "TurnOnHeadLamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrainBase.GetDoorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ATrainBase::GetDoorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "GetDoorLocation");

	Params::TrainBase_GetDoorLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TrainBase.GetStandPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ATrainBase::GetStandPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainBase", "GetStandPoint");

	Params::TrainBase_GetStandPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionPointExamine.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EActionPointType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             gameFlag                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActionPointExamine::SetData(EActionPointType Type, const class FName& gameFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionPointExamine", "SetData");

	Params::ActionPointExamine_SetData Parms{};

	Parms.Type = Type;
	Parms.gameFlag = gameFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.Enter_Abnormal
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UActionStateBase::Enter_Abnormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Enter_Abnormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.Enter_Air
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UActionStateBase::Enter_Air()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Enter_Air");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.Enter_Dive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UActionStateBase::Enter_Dive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Enter_Dive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.Enter_Ground
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UActionStateBase::Enter_Ground()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Enter_Ground");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.Enter_Ride
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UActionStateBase::Enter_Ride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Enter_Ride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.Enter_Water
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UActionStateBase::Enter_Water()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Enter_Water");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.EnterWithResult
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FActionResult                    InActionResult                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UActionStateBase::EnterWithResult(const struct FActionResult& InActionResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "EnterWithResult");

	Params::ActionStateBase_EnterWithResult Parms{};

	Parms.InActionResult = std::move(InActionResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.GetActionResult
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FActionResult              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FActionResult UActionStateBase::GetActionResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "GetActionResult");

	Params::ActionStateBase_GetActionResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ActionStateBase.Land
// (Final, Native, Public, BlueprintCallable)

void UActionStateBase::Land()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "Land");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ActionStateBase.OnLand
// (Event, Protected, BlueprintEvent)

void UActionStateBase::OnLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionStateBase", "OnLand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.ActionTargetType.GetTargets
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AGPACharacter*                    TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionTargetType::GetTargets(class AGPACharacter* TargetCharacter, class AActor* TargetActor, const struct FGameplayEventData& EventData, TArray<struct FHitResult>* OutHitResults, TArray<class AActor*>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionTargetType", "GetTargets");

	Params::ActionTargetType_GetTargets Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.TargetActor = TargetActor;
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function DarwinGame.GameDataAchievement.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataAchievement*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataAchievement* UGameDataAchievement::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataAchievement", "Clone");

	Params::GameDataAchievement_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataAchievement.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataAchievement*             game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataAchievement::Overwrite(class UGameDataAchievement* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataAchievement", "Overwrite");

	Params::GameDataAchievement_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UAreaDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.ChangeNextText
// (Final, Native, Public, BlueprintCallable)

void UTalkEventSystem::ChangeNextText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "ChangeNextText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.ClosePicture
// (Final, Native, Private, BlueprintCallable)

void UTalkEventSystem::ClosePicture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "ClosePicture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.CloseTalkWindow
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UTalkEventSystem::CloseTalkWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "CloseTalkWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.TalkEventSystem.EndTalkEvent
// (Final, Native, Public, BlueprintCallable)

void UTalkEventSystem::EndTalkEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "EndTalkEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.GetTalkerActor
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Actor                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPlayer                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCBase*                         NPCActor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::GetTalkerActor(class AGPACharacter** Actor, bool* IsPlayer, class ANPCBase** NPCActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "GetTalkerActor");

	Params::TalkEventSystem_GetTalkerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Actor != nullptr)
		*Actor = Parms.Actor;

	if (IsPlayer != nullptr)
		*IsPlayer = Parms.IsPlayer;

	if (NPCActor != nullptr)
		*NPCActor = Parms.NPCActor;
}


// Function DarwinGame.TalkEventSystem.IsCloseTalkWindow
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkEventSystem::IsCloseTalkWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "IsCloseTalkWindow");

	Params::TalkEventSystem_IsCloseTalkWindow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.TalkEventSystem.IsOpenTalkWindow
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkEventSystem::IsOpenTalkWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "IsOpenTalkWindow");

	Params::TalkEventSystem_IsOpenTalkWindow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.TalkEventSystem.OnUtilityDelegateEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CommandStr                                             (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::OnUtilityDelegateEvent(const class FString& CommandStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "OnUtilityDelegateEvent");

	Params::TalkEventSystem_OnUtilityDelegateEvent Parms{};

	Parms.CommandStr = std::move(CommandStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.OpenTalkWindow
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::OpenTalkWindow(const class FString& TextID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "OpenTalkWindow");

	Params::TalkEventSystem_OpenTalkWindow Parms{};

	Parms.TextID = std::move(TextID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.TalkEventSystem.OpenTalkWindowForceText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::OpenTalkWindowForceText(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "OpenTalkWindowForceText");

	Params::TalkEventSystem_OpenTalkWindowForceText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.PutEmotionEffectOnTalker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmotionEffectID                        EmotionEffectID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::PutEmotionEffectOnTalker(EEmotionEffectID EmotionEffectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "PutEmotionEffectOnTalker");

	Params::TalkEventSystem_PutEmotionEffectOnTalker Parms{};

	Parms.EmotionEffectID = EmotionEffectID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.PutMotionOnTalker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextTalkEmotion                        EmotionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::PutMotionOnTalker(ETextTalkEmotion EmotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "PutMotionOnTalker");

	Params::TalkEventSystem_PutMotionOnTalker Parms{};

	Parms.EmotionID = EmotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.PutStampOnTalker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStampIconType                          StampID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Option                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopNum                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::PutStampOnTalker(const EStampIconType StampID, const class FString& Option, const int32 LoopNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "PutStampOnTalker");

	Params::TalkEventSystem_PutStampOnTalker Parms{};

	Parms.StampID = StampID;
	Parms.Option = std::move(Option);
	Parms.LoopNum = LoopNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.ResetActorEmote
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    IsBodySkip                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::ResetActorEmote(const bool IsBodySkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "ResetActorEmote");

	Params::TalkEventSystem_ResetActorEmote Parms{};

	Parms.IsBodySkip = IsBodySkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.ResetActorStamp
// (Final, Native, Private, BlueprintCallable)

void UTalkEventSystem::ResetActorStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "ResetActorStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.SendSelectResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SendSelectIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::SendSelectResult(int32 SendSelectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "SendSelectResult");

	Params::TalkEventSystem_SendSelectResult Parms{};

	Parms.SendSelectIndex = SendSelectIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.SetEventOwnerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkEventSystem::SetEventOwnerActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "SetEventOwnerActor");

	Params::TalkEventSystem_SetEventOwnerActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.SetTextWidgetData
// (Final, Native, Protected, BlueprintCallable)

void UTalkEventSystem::SetTextWidgetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "SetTextWidgetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.StartTalkEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_EventData                    EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTalkEventSystem::StartTalkEvent(const struct FST_EventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "StartTalkEvent");

	Params::TalkEventSystem_StartTalkEvent Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TalkEventSystem.IsSelectCancel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkEventSystem::IsSelectCancel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkEventSystem", "IsSelectCancel");

	Params::TalkEventSystem_IsSelectCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MagicBase.CheckTerrainWithLineTrace
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       out_hit                                                (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          StartPos                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMagicBase::CheckTerrainWithLineTrace(struct FHitResult* out_hit, const struct FVector& StartPos, const struct FVector& EndPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MagicBase", "CheckTerrainWithLineTrace");

	Params::MagicBase_CheckTerrainWithLineTrace Parms{};

	Parms.StartPos = std::move(StartPos);
	Parms.EndPos = std::move(EndPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (out_hit != nullptr)
		*out_hit = std::move(Parms.out_hit);

	return Parms.ReturnValue;
}


// Function DarwinGame.AnimNotifyState_ZoomUp.GetDestAngle
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimNotifyState_ZoomUp::GetDestAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_ZoomUp", "GetDestAngle");

	Params::AnimNotifyState_ZoomUp_GetDestAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.AnimNotifyState_ZoomUp.GetDestLength
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimNotifyState_ZoomUp::GetDestLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_ZoomUp", "GetDestLength");

	Params::AnimNotifyState_ZoomUp_GetDestLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.AnimNotifyState_ZoomUp.GetDestYaw
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimNotifyState_ZoomUp::GetDestYaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_ZoomUp", "GetDestYaw");

	Params::AnimNotifyState_ZoomUp_GetDestYaw Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.AreaFunctionLibrary.GetErosionCorrection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAreaFunctionLibrary::GetErosionCorrection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AreaFunctionLibrary", "GetErosionCorrection");

	Params::AreaFunctionLibrary_GetErosionCorrection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationTank.SetReflectionRelease
// (Final, Native, Public, BlueprintCallable)

void AStationTank::SetReflectionRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationTank", "SetReflectionRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationTank.SetReflectionSeal
// (Final, Native, Public, BlueprintCallable)

void AStationTank::SetReflectionSeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationTank", "SetReflectionSeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AimTargetComponent.SetAimEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimTargetComponent::SetAimEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimTargetComponent", "SetAimEnabled");

	Params::AimTargetComponent_SetAimEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddAttackCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddAttackCount(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddAttackCount");

	Params::GameDataHistory_AddAttackCount Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddDefeatedMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddDefeatedMonsterCount(const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddDefeatedMonsterCount");

	Params::GameDataHistory_AddDefeatedMonsterCount Parms{};

	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddFriendMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddFriendMonsterCount(const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddFriendMonsterCount");

	Params::GameDataHistory_AddFriendMonsterCount Parms{};

	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemBuyCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemBuyCount(const class FName& ItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemBuyCount");

	Params::GameDataHistory_AddItemBuyCount Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemCollectionCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAreaType                               AreaType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemCollectionCount(const class FName& ItemId, EAreaType AreaType, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemCollectionCount");

	Params::GameDataHistory_AddItemCollectionCount Parms{};

	Parms.ItemId = ItemId;
	Parms.AreaType = AreaType;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemGetCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemGetCount(const class FName& ItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemGetCount");

	Params::GameDataHistory_AddItemGetCount Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemMakeCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemMakeCount(const class FName& ItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemMakeCount");

	Params::GameDataHistory_AddItemMakeCount Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemSellCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemSellCount(const class FName& ItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemSellCount");

	Params::GameDataHistory_AddItemSellCount Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemUseToEnemyCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemUseToEnemyCount(const class FName& ItemId, const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemUseToEnemyCount");

	Params::GameDataHistory_AddItemUseToEnemyCount Parms{};

	Parms.ItemId = ItemId;
	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemUseToFriendCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemUseToFriendCount(const class FName& ItemId, const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemUseToFriendCount");

	Params::GameDataHistory_AddItemUseToFriendCount Parms{};

	Parms.ItemId = ItemId;
	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddItemUseToMeCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddItemUseToMeCount(const class FName& ItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddItemUseToMeCount");

	Params::GameDataHistory_AddItemUseToMeCount Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddKillMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddKillMonsterCount(const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddKillMonsterCount");

	Params::GameDataHistory_AddKillMonsterCount Parms{};

	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddKillNightmareMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddKillNightmareMonsterCount(const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddKillNightmareMonsterCount");

	Params::GameDataHistory_AddKillNightmareMonsterCount Parms{};

	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddPlayerActionCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddPlayerActionCount(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddPlayerActionCount");

	Params::GameDataHistory_AddPlayerActionCount Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddPlayerActionNum
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddPlayerActionNum(const class FName& ID, const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddPlayerActionNum");

	Params::GameDataHistory_AddPlayerActionNum Parms{};

	Parms.ID = ID;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddRivalTeamKillCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddRivalTeamKillCount(ERivalTeamForce RivalTeam, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddRivalTeamKillCount");

	Params::GameDataHistory_AddRivalTeamKillCount Parms{};

	Parms.RivalTeam = RivalTeam;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddScoutMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddScoutMonsterCount(const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddScoutMonsterCount");

	Params::GameDataHistory_AddScoutMonsterCount Parms{};

	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.AddStealMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::AddStealMonsterCount(const class FName& KindId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "AddStealMonsterCount");

	Params::GameDataHistory_AddStealMonsterCount Parms{};

	Parms.KindId = KindId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.ArrivalDestinationRect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::ArrivalDestinationRect(const class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "ArrivalDestinationRect");

	Params::GameDataHistory_ArrivalDestinationRect Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataHistory*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataHistory* UGameDataHistory::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "Clone");

	Params::GameDataHistory_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataHistory*                 game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::Overwrite(class UGameDataHistory* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "Overwrite");

	Params::GameDataHistory_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.ResetDestinationRect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHistory::ResetDestinationRect(const class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "ResetDestinationRect");

	Params::GameDataHistory_ResetDestinationRect Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataHistory.GetAttackCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UGameDataHistory::GetAttackCount(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetAttackCount");

	Params::GameDataHistory_GetAttackCount Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetDefeatedMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetDefeatedMonsterCount(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetDefeatedMonsterCount");

	Params::GameDataHistory_GetDefeatedMonsterCount Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetDictMonsters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UGameDataHistory::GetDictMonsters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetDictMonsters");

	Params::GameDataHistory_GetDictMonsters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetFriendMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetFriendMonsterCount(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetFriendMonsterCount");

	Params::GameDataHistory_GetFriendMonsterCount Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetFriendMonsterCountAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetFriendMonsterCountAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetFriendMonsterCountAll");

	Params::GameDataHistory_GetFriendMonsterCountAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetFriendMonsterCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetFriendMonsterCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetFriendMonsterCountMap");

	Params::GameDataHistory_GetFriendMonsterCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemBuyCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemBuyCount(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemBuyCount");

	Params::GameDataHistory_GetItemBuyCount Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemBuyCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetItemBuyCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemBuyCountMap");

	Params::GameDataHistory_GetItemBuyCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemCollectionCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, struct FItemCollection>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, struct FItemCollection> UGameDataHistory::GetItemCollectionCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemCollectionCountMap");

	Params::GameDataHistory_GetItemCollectionCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemGetCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemGetCount(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemGetCount");

	Params::GameDataHistory_GetItemGetCount Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemGetCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetItemGetCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemGetCountMap");

	Params::GameDataHistory_GetItemGetCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemMakeCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemMakeCount(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemMakeCount");

	Params::GameDataHistory_GetItemMakeCount Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemMakeCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetItemMakeCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemMakeCountMap");

	Params::GameDataHistory_GetItemMakeCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemSellCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemSellCount(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemSellCount");

	Params::GameDataHistory_GetItemSellCount Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemSellCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetItemSellCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemSellCountMap");

	Params::GameDataHistory_GetItemSellCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemsGet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UGameDataHistory::GetItemsGet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemsGet");

	Params::GameDataHistory_GetItemsGet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToEnemyCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemUseToEnemyCount(const class FName& ItemId, const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToEnemyCount");

	Params::GameDataHistory_GetItemUseToEnemyCount Parms{};

	Parms.ItemId = ItemId;
	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToEnemyCountAllItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemUseToEnemyCountAllItem(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToEnemyCountAllItem");

	Params::GameDataHistory_GetItemUseToEnemyCountAllItem Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToEnemyCountAllItemOfType
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemDataType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemUseToEnemyCountAllItemOfType(const class FName& KindId, EItemDataType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToEnemyCountAllItemOfType");

	Params::GameDataHistory_GetItemUseToEnemyCountAllItemOfType Parms{};

	Parms.KindId = KindId;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToEnemyCountAllMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemUseToEnemyCountAllMonster(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToEnemyCountAllMonster");

	Params::GameDataHistory_GetItemUseToEnemyCountAllMonster Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToEnemyCountDetail
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetItemUseToEnemyCountDetail(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToEnemyCountDetail");

	Params::GameDataHistory_GetItemUseToEnemyCountDetail Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToEnemyCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, struct FItemUseToMonster>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, struct FItemUseToMonster> UGameDataHistory::GetItemUseToEnemyCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToEnemyCountMap");

	Params::GameDataHistory_GetItemUseToEnemyCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToFriendCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, struct FItemUseToMonster>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, struct FItemUseToMonster> UGameDataHistory::GetItemUseToFriendCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToFriendCountMap");

	Params::GameDataHistory_GetItemUseToFriendCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToMeCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetItemUseToMeCount(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToMeCount");

	Params::GameDataHistory_GetItemUseToMeCount Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetItemUseToMeCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetItemUseToMeCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetItemUseToMeCountMap");

	Params::GameDataHistory_GetItemUseToMeCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetKilledMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetKilledMonsterCount(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetKilledMonsterCount");

	Params::GameDataHistory_GetKilledMonsterCount Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetKilledMonsterCountAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetKilledMonsterCountAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetKilledMonsterCountAll");

	Params::GameDataHistory_GetKilledMonsterCountAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetKilledMonsterCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetKilledMonsterCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetKilledMonsterCountMap");

	Params::GameDataHistory_GetKilledMonsterCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetKilledNightmareMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetKilledNightmareMonsterCount(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetKilledNightmareMonsterCount");

	Params::GameDataHistory_GetKilledNightmareMonsterCount Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetKilledNightmareMonsterCountAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetKilledNightmareMonsterCountAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetKilledNightmareMonsterCountAll");

	Params::GameDataHistory_GetKilledNightmareMonsterCountAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetKilledNightmareMonsterCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetKilledNightmareMonsterCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetKilledNightmareMonsterCountMap");

	Params::GameDataHistory_GetKilledNightmareMonsterCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetPlayerActionCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UGameDataHistory::GetPlayerActionCount(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetPlayerActionCount");

	Params::GameDataHistory_GetPlayerActionCount Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetRegisteredKindIDList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UGameDataHistory::GetRegisteredKindIDList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetRegisteredKindIDList");

	Params::GameDataHistory_GetRegisteredKindIDList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetRivalTeamKillCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetRivalTeamKillCount(ERivalTeamForce RivalTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetRivalTeamKillCount");

	Params::GameDataHistory_GetRivalTeamKillCount Parms{};

	Parms.RivalTeam = RivalTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetRivalTeamKillCountTMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<ERivalTeamForce, int32>            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<ERivalTeamForce, int32> UGameDataHistory::GetRivalTeamKillCountTMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetRivalTeamKillCountTMap");

	Params::GameDataHistory_GetRivalTeamKillCountTMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetScoutedMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetScoutedMonsterCount(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetScoutedMonsterCount");

	Params::GameDataHistory_GetScoutedMonsterCount Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetScoutedMonsterCountAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetScoutedMonsterCountAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetScoutedMonsterCountAll");

	Params::GameDataHistory_GetScoutedMonsterCountAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetScoutedMonsterCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetScoutedMonsterCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetScoutedMonsterCountMap");

	Params::GameDataHistory_GetScoutedMonsterCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetStealedMonsterCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetStealedMonsterCount(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetStealedMonsterCount");

	Params::GameDataHistory_GetStealedMonsterCount Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetStealedMonsterCountAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataHistory::GetStealedMonsterCountAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetStealedMonsterCountAll");

	Params::GameDataHistory_GetStealedMonsterCountAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.GetStealedMonsterCountMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> UGameDataHistory::GetStealedMonsterCountMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "GetStealedMonsterCountMap");

	Params::GameDataHistory_GetStealedMonsterCountMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsBuyItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsBuyItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsBuyItem");

	Params::GameDataHistory_IsBuyItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsDefeatedMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsDefeatedMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsDefeatedMonster");

	Params::GameDataHistory_IsDefeatedMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsDestinationRect
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsDestinationRect(const class FName& QuestID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsDestinationRect");

	Params::GameDataHistory_IsDestinationRect Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsDictMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsDictMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsDictMonster");

	Params::GameDataHistory_IsDictMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsFriendMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsFriendMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsFriendMonster");

	Params::GameDataHistory_IsFriendMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsGetItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsGetItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsGetItem");

	Params::GameDataHistory_IsGetItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsKilledMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsKilledMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsKilledMonster");

	Params::GameDataHistory_IsKilledMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsKilledNightmareMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsKilledNightmareMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsKilledNightmareMonster");

	Params::GameDataHistory_IsKilledNightmareMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsMakeItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsMakeItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsMakeItem");

	Params::GameDataHistory_IsMakeItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsRegisterItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsRegisterItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsRegisterItem");

	Params::GameDataHistory_IsRegisterItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsRegisterMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsRegisterMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsRegisterMonster");

	Params::GameDataHistory_IsRegisterMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsRegisterRivalTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsRegisterRivalTeam(ERivalTeamForce RivalTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsRegisterRivalTeam");

	Params::GameDataHistory_IsRegisterRivalTeam Parms{};

	Parms.RivalTeam = RivalTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsScoutedMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsScoutedMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsScoutedMonster");

	Params::GameDataHistory_IsScoutedMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsSellItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsSellItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsSellItem");

	Params::GameDataHistory_IsSellItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsStealedMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsStealedMonster(const class FName& KindId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsStealedMonster");

	Params::GameDataHistory_IsStealedMonster Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsUseItemToEnemy
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsUseItemToEnemy(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsUseItemToEnemy");

	Params::GameDataHistory_IsUseItemToEnemy Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsUseItemToFriend
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsUseItemToFriend(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsUseItemToFriend");

	Params::GameDataHistory_IsUseItemToFriend Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHistory.IsUseItemToMe
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataHistory::IsUseItemToMe(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHistory", "IsUseItemToMe");

	Params::GameDataHistory_IsUseItemToMe Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AirShipBase.SetCollisionEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAirShipBase::SetCollisionEnable(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirShipBase", "SetCollisionEnable");

	Params::AirShipBase_SetCollisionEnable Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SkillChainSystemComponent.PauseChain
// (Final, Native, Public, BlueprintCallable)

void USkillChainSystemComponent::PauseChain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillChainSystemComponent", "PauseChain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SkillChainSystemComponent.ResumeChain
// (Final, Native, Public, BlueprintCallable)

void USkillChainSystemComponent::ResumeChain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillChainSystemComponent", "ResumeChain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AirStateBase.SetVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAirStateBase::SetVelocity(const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirStateBase", "SetVelocity");

	Params::AirStateBase_SetVelocity Parms{};

	Parms.Velocity = std::move(Velocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BelongingInterface.GetBelonging
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag IBelongingInterface::GetBelonging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BelongingInterface", "GetBelonging");

	Params::BelongingInterface_GetBelonging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AirStateJump.Jump
// (Native, Public, BlueprintCallable)

void UAirStateJump::Jump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirStateJump", "Jump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AirStateJump.CalculateJumpVelocity
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAirStateJump::CalculateJumpVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirStateJump", "CalculateJumpVelocity");

	Params::AirStateJump_CalculateJumpVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SceneCaptureBase.GetCharacterActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* ASceneCaptureBase::GetCharacterActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneCaptureBase", "GetCharacterActor");

	Params::SceneCaptureBase_GetCharacterActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIArtifact_Warehouse.SetPedestalIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIArtifact_Warehouse::SetPedestalIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIArtifact_Warehouse", "SetPedestalIndex");

	Params::UIArtifact_Warehouse_SetPedestalIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.IndoorTriggerBase.OnBeginOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndoorTriggerBase::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndoorTriggerBase", "OnBeginOverlap");

	Params::IndoorTriggerBase_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.IndoorTriggerBase.OnEndOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIndoorTriggerBase::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndoorTriggerBase", "OnEndOverlap");

	Params::IndoorTriggerBase_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AirStateStartLink.IsFalling
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAirStateStartLink::IsFalling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirStateStartLink", "IsFalling");

	Params::AirStateStartLink_IsFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AirStateStartLink.IsLinkSuccessed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAirStateStartLink::IsLinkSuccessed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirStateStartLink", "IsLinkSuccessed");

	Params::AirStateStartLink_IsLinkSuccessed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAbilitySystemBlueprintLibrary.GetActionResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FActionResult                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FActionResult UDarwinAbilitySystemBlueprintLibrary::GetActionResult(const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinAbilitySystemBlueprintLibrary", "GetActionResult");

	Params::DarwinAbilitySystemBlueprintLibrary_GetActionResult Parms{};

	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAbilitySystemBlueprintLibrary.GetAttackResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayCueParameters           Parameters                                             (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FAttackHitResultStruct           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAttackHitResultStruct UDarwinAbilitySystemBlueprintLibrary::GetAttackResult(const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinAbilitySystemBlueprintLibrary", "GetAttackResult");

	Params::DarwinAbilitySystemBlueprintLibrary_GetAttackResult Parms{};

	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.ActorIsCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::ActorIsCharacter(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ActorIsCharacter");

	Params::DarwinBlueprintLibrary_ActorIsCharacter Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.ActorIsPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::ActorIsPlayer(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ActorIsPlayer");

	Params::DarwinBlueprintLibrary_ActorIsPlayer Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.AddTargetsToEffectContainerSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActionGameplayEffectContainerSpecContainerSpec                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               HitResults                                             (ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   TargetActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FActionGameplayEffectContainerSpec UDarwinBlueprintLibrary::AddTargetsToEffectContainerSpec(const struct FActionGameplayEffectContainerSpec& ContainerSpec, const TArray<struct FHitResult>& HitResults, const TArray<class AActor*>& TargetActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "AddTargetsToEffectContainerSpec");

	Params::DarwinBlueprintLibrary_AddTargetsToEffectContainerSpec Parms{};

	Parms.ContainerSpec = std::move(ContainerSpec);
	Parms.HitResults = std::move(HitResults);
	Parms.TargetActors = std::move(TargetActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.AddUIBrightness
// (Final, Native, Static, Public, BlueprintCallable)

void UDarwinBlueprintLibrary::AddUIBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "AddUIBrightness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.ApplyExternalEffectContainerSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActionGameplayEffectContainerSpecContainerSpec                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDarwinBlueprintLibrary::ApplyExternalEffectContainerSpec(const struct FActionGameplayEffectContainerSpec& ContainerSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ApplyExternalEffectContainerSpec");

	Params::DarwinBlueprintLibrary_ApplyExternalEffectContainerSpec Parms{};

	Parms.ContainerSpec = std::move(ContainerSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.ASyncLoadAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FSoftObjectPath                  targetsToStream                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FASyncLoadInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FASyncLoadInfo UDarwinBlueprintLibrary::ASyncLoadAsset(const struct FSoftObjectPath& targetsToStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ASyncLoadAsset");

	Params::DarwinBlueprintLibrary_ASyncLoadAsset Parms{};

	Parms.targetsToStream = std::move(targetsToStream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.ASyncLoadAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSoftObjectPath>          targetsToStream                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FASyncLoadInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FASyncLoadInfo UDarwinBlueprintLibrary::ASyncLoadAssets(const TArray<struct FSoftObjectPath>& targetsToStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ASyncLoadAssets");

	Params::DarwinBlueprintLibrary_ASyncLoadAssets Parms{};

	Parms.targetsToStream = std::move(targetsToStream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.BoxOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         BoxRotation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::BoxOverlapActors(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "BoxOverlapActors");

	Params::DarwinBlueprintLibrary_BoxOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.BoxRotation = std::move(BoxRotation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.BoxOverlapActorsByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         BoxRotation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::BoxOverlapActorsByProfile(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const class FName& ProfileName, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "BoxOverlapActorsByProfile");

	Params::DarwinBlueprintLibrary_BoxOverlapActorsByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.BoxRotation = std::move(BoxRotation);
	Parms.ProfileName = ProfileName;
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.BoxOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         BoxRotation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::BoxOverlapComponents(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "BoxOverlapComponents");

	Params::DarwinBlueprintLibrary_BoxOverlapComponents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.BoxRotation = std::move(BoxRotation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.BoxOverlapComponentsByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         BoxRotation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::BoxOverlapComponentsByProfile(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const struct FRotator& BoxRotation, const class FName& ProfileName, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "BoxOverlapComponentsByProfile");

	Params::DarwinBlueprintLibrary_BoxOverlapComponentsByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.BoxRotation = std::move(BoxRotation);
	Parms.ProfileName = ProfileName;
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.CapsuleOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsulePos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CapsuleRotation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::CapsuleOverlapActors(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "CapsuleOverlapActors");

	Params::DarwinBlueprintLibrary_CapsuleOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = std::move(CapsulePos);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.CapsuleRotation = std::move(CapsuleRotation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.CapsuleOverlapActorsByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsulePos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CapsuleRotation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::CapsuleOverlapActorsByProfile(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const class FName& ProfileName, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "CapsuleOverlapActorsByProfile");

	Params::DarwinBlueprintLibrary_CapsuleOverlapActorsByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = std::move(CapsulePos);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.CapsuleRotation = std::move(CapsuleRotation);
	Parms.ProfileName = ProfileName;
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.CapsuleOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsulePos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CapsuleRotation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::CapsuleOverlapComponents(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "CapsuleOverlapComponents");

	Params::DarwinBlueprintLibrary_CapsuleOverlapComponents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = std::move(CapsulePos);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.CapsuleRotation = std::move(CapsuleRotation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.CapsuleOverlapComponentsByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsulePos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CapsuleRotation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::CapsuleOverlapComponentsByProfile(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const struct FRotator& CapsuleRotation, const class FName& ProfileName, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "CapsuleOverlapComponentsByProfile");

	Params::DarwinBlueprintLibrary_CapsuleOverlapComponentsByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = std::move(CapsulePos);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.CapsuleRotation = std::move(CapsuleRotation);
	Parms.ProfileName = ProfileName;
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.CheckCurrentFloor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           observe                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExtendScaleToUpward                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FHitResult> UDarwinBlueprintLibrary::CheckCurrentFloor(class AActor* observe, float Height, float Radius, float ExtendScaleToUpward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "CheckCurrentFloor");

	Params::DarwinBlueprintLibrary_CheckCurrentFloor Parms{};

	Parms.observe = observe;
	Parms.Height = Height;
	Parms.Radius = Radius;
	Parms.ExtendScaleToUpward = ExtendScaleToUpward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.DataTableRemoveAssetInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::DataTableRemoveAssetInfo(class UDataTable* DataTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DataTableRemoveAssetInfo");

	Params::DarwinBlueprintLibrary_DataTableRemoveAssetInfo Parms{};

	Parms.DataTable = DataTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.DisableFixedFrameRate
// (Final, Native, Static, Public, BlueprintCallable)

void UDarwinBlueprintLibrary::DisableFixedFrameRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DisableFixedFrameRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.DoesEffectContainerSpecHaveEffects
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FActionGameplayEffectContainerSpecContainerSpec                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::DoesEffectContainerSpecHaveEffects(const struct FActionGameplayEffectContainerSpec& ContainerSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DoesEffectContainerSpecHaveEffects");

	Params::DarwinBlueprintLibrary_DoesEffectContainerSpecHaveEffects Parms{};

	Parms.ContainerSpec = std::move(ContainerSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.DoesEffectContainerSpecHaveTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FActionGameplayEffectContainerSpecContainerSpec                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::DoesEffectContainerSpecHaveTargets(const struct FActionGameplayEffectContainerSpec& ContainerSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DoesEffectContainerSpecHaveTargets");

	Params::DarwinBlueprintLibrary_DoesEffectContainerSpecHaveTargets Parms{};

	Parms.ContainerSpec = std::move(ContainerSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.DoesTagBelongToEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Belong                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::DoesTagBelongToEnemy(const struct FGameplayTag& Belong)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DoesTagBelongToEnemy");

	Params::DarwinBlueprintLibrary_DoesTagBelongToEnemy Parms{};

	Parms.Belong = std::move(Belong);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.DoesTargetBlongToAlly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::DoesTargetBlongToAlly(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DoesTargetBlongToAlly");

	Params::DarwinBlueprintLibrary_DoesTargetBlongToAlly Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.DoesTargetBlongToEnemy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::DoesTargetBlongToEnemy(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DoesTargetBlongToEnemy");

	Params::DarwinBlueprintLibrary_DoesTargetBlongToEnemy Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.DoesTargetBlongToSameDepartment
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::DoesTargetBlongToSameDepartment(class AActor* Source, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "DoesTargetBlongToSameDepartment");

	Params::DarwinBlueprintLibrary_DoesTargetBlongToSameDepartment Parms{};

	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.EnableFixedFrameRate
// (Final, Native, Static, Public, BlueprintCallable)

void UDarwinBlueprintLibrary::EnableFixedFrameRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "EnableFixedFrameRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.ExportCSVFromDataTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FilePath                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::ExportCSVFromDataTable(const class UDataTable* DataTable, const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ExportCSVFromDataTable");

	Params::DarwinBlueprintLibrary_ExportCSVFromDataTable Parms{};

	Parms.DataTable = DataTable;
	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.FindNPC
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   FindDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FindAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::FindNPC(float FindDistance, float FindAngle, const TArray<EObjectTypeQuery>& ObjectTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "FindNPC");

	Params::DarwinBlueprintLibrary_FindNPC Parms{};

	Parms.FindDistance = FindDistance;
	Parms.FindAngle = FindAngle;
	Parms.ObjectTypes = std::move(ObjectTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.ForceGarbageCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bFullPurge                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::ForceGarbageCollection(bool bFullPurge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ForceGarbageCollection");

	Params::DarwinBlueprintLibrary_ForceGarbageCollection Parms{};

	Parms.bFullPurge = bFullPurge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetAnimationAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FSoftObjectPath                  SoftObjectPath                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* UDarwinBlueprintLibrary::GetAnimationAsset(const struct FSoftObjectPath& SoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetAnimationAsset");

	Params::DarwinBlueprintLibrary_GetAnimationAsset Parms{};

	Parms.SoftObjectPath = std::move(SoftObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetAverageFPS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDarwinBlueprintLibrary::GetAverageFPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetAverageFPS");

	Params::DarwinBlueprintLibrary_GetAverageFPS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetAverageMS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDarwinBlueprintLibrary::GetAverageMS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetAverageMS");

	Params::DarwinBlueprintLibrary_GetAverageMS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetIntegerByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VarName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutInteger                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::GetIntegerByName(class UObject* Target, class FName VarName, int32* OutInteger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetIntegerByName");

	Params::DarwinBlueprintLibrary_GetIntegerByName Parms{};

	Parms.Target = Target;
	Parms.VarName = VarName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteger != nullptr)
		*OutInteger = Parms.OutInteger;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetLoadAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FASyncLoadInfo                   ASyncLoadInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          LoadAsset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::GetLoadAsset(const struct FASyncLoadInfo& ASyncLoadInfo, class UObject** LoadAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetLoadAsset");

	Params::DarwinBlueprintLibrary_GetLoadAsset Parms{};

	Parms.ASyncLoadInfo = std::move(ASyncLoadInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LoadAsset != nullptr)
		*LoadAsset = Parms.LoadAsset;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetLoadAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FASyncLoadInfo                   ASyncLoadInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  loadAssets                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::GetLoadAssets(const struct FASyncLoadInfo& ASyncLoadInfo, TArray<class UObject*>* loadAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetLoadAssets");

	Params::DarwinBlueprintLibrary_GetLoadAssets Parms{};

	Parms.ASyncLoadInfo = std::move(ASyncLoadInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (loadAssets != nullptr)
		*loadAssets = std::move(Parms.loadAssets);
}


// Function DarwinGame.DarwinBlueprintLibrary.GetTargetFPS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDarwinBlueprintLibrary::GetTargetFPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetTargetFPS");

	Params::DarwinBlueprintLibrary_GetTargetFPS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.GetTargetMS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDarwinBlueprintLibrary::GetTargetMS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "GetTargetMS");

	Params::DarwinBlueprintLibrary_GetTargetMS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.InitializeResolution
// (Final, Native, Static, Public, BlueprintCallable)

void UDarwinBlueprintLibrary::InitializeResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "InitializeResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.IsConfigFixedFrameRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::IsConfigFixedFrameRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "IsConfigFixedFrameRate");

	Params::DarwinBlueprintLibrary_IsConfigFixedFrameRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.IsExistAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::IsExistAsset(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "IsExistAsset");

	Params::DarwinBlueprintLibrary_IsExistAsset Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.IsFinishedASyncLoad
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FASyncLoadInfo                   ASyncLoadInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::IsFinishedASyncLoad(const struct FASyncLoadInfo& ASyncLoadInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "IsFinishedASyncLoad");

	Params::DarwinBlueprintLibrary_IsFinishedASyncLoad Parms{};

	Parms.ASyncLoadInfo = std::move(ASyncLoadInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.IsHitLocationAtFeet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           observe                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::IsHitLocationAtFeet(class AActor* observe, float Height, float Radius, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "IsHitLocationAtFeet");

	Params::DarwinBlueprintLibrary_IsHitLocationAtFeet Parms{};

	Parms.observe = observe;
	Parms.Height = Height;
	Parms.Radius = Radius;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.IsObjectFaceToFace
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::IsObjectFaceToFace(const struct FRotator& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "IsObjectFaceToFace");

	Params::DarwinBlueprintLibrary_IsObjectFaceToFace Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.IsOnFloor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           observe                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExtendScaleToUpward                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::IsOnFloor(class AActor* observe, float Height, float Radius, float ExtendScaleToUpward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "IsOnFloor");

	Params::DarwinBlueprintLibrary_IsOnFloor Parms{};

	Parms.observe = observe;
	Parms.Height = Height;
	Parms.Radius = Radius;
	Parms.ExtendScaleToUpward = ExtendScaleToUpward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.ReleaseASyncLoad
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FASyncLoadInfo                   inAsyncLoadInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FASyncLoadInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FASyncLoadInfo UDarwinBlueprintLibrary::ReleaseASyncLoad(const struct FASyncLoadInfo& inAsyncLoadInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "ReleaseASyncLoad");

	Params::DarwinBlueprintLibrary_ReleaseASyncLoad Parms{};

	Parms.inAsyncLoadInfo = std::move(inAsyncLoadInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.SetFixedFrameRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FPS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::SetFixedFrameRate(bool bUse, float FPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "SetFixedFrameRate");

	Params::DarwinBlueprintLibrary_SetFixedFrameRate Parms{};

	Parms.bUse = bUse;
	Parms.FPS = FPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.SetIntegerByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VarName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutInteger                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::SetIntegerByName(class UObject* Target, class FName VarName, int32 NewValue, int32* OutInteger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "SetIntegerByName");

	Params::DarwinBlueprintLibrary_SetIntegerByName Parms{};

	Parms.Target = Target;
	Parms.VarName = VarName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteger != nullptr)
		*OutInteger = Parms.OutInteger;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.SetMaxFPS
// (Final, Native, Static, Public, BlueprintCallable)

void UDarwinBlueprintLibrary::SetMaxFPS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "SetMaxFPS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.SpawnActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDarwinBlueprintLibrary::SpawnActor(const class UObject* Object, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "SpawnActor");

	Params::DarwinBlueprintLibrary_SpawnActor Parms{};

	Parms.Object = Object;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinBlueprintLibrary.UnlockPCAchievement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDarwinAchievementsID                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinBlueprintLibrary::UnlockPCAchievement(EDarwinAchievementsID ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "UnlockPCAchievement");

	Params::DarwinBlueprintLibrary_UnlockPCAchievement Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinBlueprintLibrary.WhetherHitOnGround
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           observe                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinBlueprintLibrary::WhetherHitOnGround(class AActor* observe, float Height, float Radius, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinBlueprintLibrary", "WhetherHitOnGround");

	Params::DarwinBlueprintLibrary_WhetherHitOnGround Parms{};

	Parms.observe = observe;
	Parms.Height = Height;
	Parms.Radius = Radius;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIBoardmenu_MonsterIconChoice.IconIn
// (Final, Native, Public, BlueprintCallable)

void UUIBoardmenu_MonsterIconChoice::IconIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBoardmenu_MonsterIconChoice", "IconIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBoardmenu_MonsterIconChoice.ShutterOpen
// (Final, Native, Public, BlueprintCallable)

void UUIBoardmenu_MonsterIconChoice::ShutterOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBoardmenu_MonsterIconChoice", "ShutterOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBoardmenu_MonsterIconChoice.WingsOut
// (Final, Native, Public, BlueprintCallable)

void UUIBoardmenu_MonsterIconChoice::WingsOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBoardmenu_MonsterIconChoice", "WingsOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ArtifactPoint.GetSoundComponent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UPointEnvSound*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPointEnvSound* AArtifactPoint::GetSoundComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactPoint", "GetSoundComponent");

	Params::ArtifactPoint_GetSoundComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.ArtifactPoint.OnBeginOverlapEffectCollision
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AArtifactPoint::OnBeginOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactPoint", "OnBeginOverlapEffectCollision");

	Params::ArtifactPoint_OnBeginOverlapEffectCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ArtifactPoint.OnEndOverlapEffectCollision
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArtifactPoint::OnEndOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactPoint", "OnEndOverlapEffectCollision");

	Params::ArtifactPoint_OnEndOverlapEffectCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIArtifactList_Field.FrameIn
// (Final, Native, Public, BlueprintCallable)

void UUIArtifactList_Field::FrameIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIArtifactList_Field", "FrameIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIArtifactList_Field.FrameOut
// (Final, Native, Public, BlueprintCallable)

void UUIArtifactList_Field::FrameOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIArtifactList_Field", "FrameOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAssetManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDarwinAssetManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinAssetManager* UDarwinAssetManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinAssetManager", "GetInstance");

	Params::DarwinAssetManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ItemObjectBase.GetStaticMeshComponentRelativeLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AItemObjectBase::GetStaticMeshComponentRelativeLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemObjectBase", "GetStaticMeshComponentRelativeLocation");

	Params::ItemObjectBase_GetStaticMeshComponentRelativeLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ItemObjectBase.GetItemGetInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FFieldItemGetInfo>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FFieldItemGetInfo> AItemObjectBase::GetItemGetInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemObjectBase", "GetItemGetInfo");

	Params::ItemObjectBase_GetItemGetInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ItemObjectBase.GetObjectRootComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* AItemObjectBase::GetObjectRootComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemObjectBase", "GetObjectRootComponent");

	Params::ItemObjectBase_GetObjectRootComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ItemObjectBase.GetStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* AItemObjectBase::GetStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemObjectBase", "GetStaticMesh");

	Params::ItemObjectBase_GetStaticMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DropItemObject.OnDrop
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LaunchVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADropItemObject::OnDrop(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropItemObject", "OnDrop");

	Params::DropItemObject_OnDrop Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DropItemObject.OnDropCheck
// (Final, Native, Protected)

void ADropItemObject::OnDropCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropItemObject", "OnDropCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DropItemObject.OverlapWaterObject
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              collision                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADropItemObject::OverlapWaterObject(class UPrimitiveComponent* collision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropItemObject", "OverlapWaterObject");

	Params::DropItemObject_OverlapWaterObject Parms{};

	Parms.collision = collision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DropItemObject.GetWaterOverlapCollision
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ADropItemObject::GetWaterOverlapCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropItemObject", "GetWaterOverlapCollision");

	Params::DropItemObject_GetWaterOverlapCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_IconStamp.EndStampAnimation
// (Final, Native, Private)

void UUIField_IconStamp::EndStampAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconStamp", "EndStampAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconStamp.PlayStamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LoopStart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIField_IconStamp::PlayStamp(float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool LoopStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconStamp", "PlayStamp");

	Params::UIField_IconStamp_PlayStamp Parms{};

	Parms.StartAtTime = StartAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.LoopStart = LoopStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_IconStamp.PlayStampByTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AnimTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIField_IconStamp::PlayStampByTime(float AnimTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconStamp", "PlayStampByTime");

	Params::UIField_IconStamp_PlayStampByTime Parms{};

	Parms.AnimTime = AnimTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_IconStamp.SetDataFromType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStampIconType                          StampType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStampFrameType                         Frame                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LoopStart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconStamp::SetDataFromType(const EStampIconType StampType, class AActor* Target, const EStampFrameType Frame, bool LoopStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconStamp", "SetDataFromType");

	Params::UIField_IconStamp_SetDataFromType Parms{};

	Parms.StampType = StampType;
	Parms.Target = Target;
	Parms.Frame = Frame;
	Parms.LoopStart = LoopStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconStamp.StopStamp
// (Final, Native, Public, BlueprintCallable)

void UUIField_IconStamp::StopStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconStamp", "StopStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.AddEmotionEffect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EEmotionEffectID                        ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::AddEmotionEffect(const EEmotionEffectID ID, const EEffectSizeID Size, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "AddEmotionEffect");

	Params::GameCharacter_AddEmotionEffect Parms{};

	Parms.ID = ID;
	Parms.Size = Size;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.AddStamp
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EStampIconType                          Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::AddStamp(const EStampIconType Type, int32 LoopNum, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "AddStamp");

	Params::GameCharacter_AddStamp Parms{};

	Parms.Type = Type;
	Parms.LoopNum = LoopNum;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.AdjustActorUpVector
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::AdjustActorUpVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "AdjustActorUpVector");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.AttachToSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AttachActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESocket                                 socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::AttachToSocket(class AActor* AttachActor, ESocket socket, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "AttachToSocket");

	Params::GameCharacter_AttachToSocket Parms{};

	Parms.AttachActor = AttachActor;
	Parms.socket = socket;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.CancelEmote
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::CancelEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "CancelEmote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.CancelEmoteBody
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::CancelEmoteBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "CancelEmoteBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.CancelEmoteFacial
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::CancelEmoteFacial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "CancelEmoteFacial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.ChangeDefaultMaterialInstance
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::ChangeDefaultMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "ChangeDefaultMaterialInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.CloseFukidashi
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGameCharacter::CloseFukidashi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "CloseFukidashi");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.GameCharacter.CreateAndSetMaterialInstanceDynamicFromMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCopyPamameterFromOld                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* AGameCharacter::CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent, bool bCopyPamameterFromOld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "CreateAndSetMaterialInstanceDynamicFromMaterial");

	Params::GameCharacter_CreateAndSetMaterialInstanceDynamicFromMaterial Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.Parent = Parent;
	Parms.bCopyPamameterFromOld = bCopyPamameterFromOld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.DetachFromSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DetachActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::DetachFromSocket(class AActor* DetachActor, EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "DetachFromSocket");

	Params::GameCharacter_DetachFromSocket Parms{};

	Parms.DetachActor = DetachActor;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.DisableLookAt
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::DisableLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "DisableLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.DisableLookAtDirect
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::DisableLookAtDirect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "DisableLookAtDirect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.EnableLookAtCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::EnableLookAtCharacter(class AGameCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "EnableLookAtCharacter");

	Params::GameCharacter_EnableLookAtCharacter Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.EnableLookAtCharacterDirect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::EnableLookAtCharacterDirect(class AGameCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "EnableLookAtCharacterDirect");

	Params::GameCharacter_EnableLookAtCharacterDirect Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.EnableLookAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::EnableLookAtLocation(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "EnableLookAtLocation");

	Params::GameCharacter_EnableLookAtLocation Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.EnableLookAtLocationDirect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::EnableLookAtLocationDirect(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "EnableLookAtLocationDirect");

	Params::GameCharacter_EnableLookAtLocationDirect Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.EnableUIMode
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::EnableUIMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "EnableUIMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.EndUpdateCollision
// (Final, Native, Private, BlueprintCallable)

void AGameCharacter::EndUpdateCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "EndUpdateCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.GetAControllerTickable
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::GetAControllerTickable(bool* enable, class FString* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "GetAControllerTickable");

	Params::GameCharacter_GetAControllerTickable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (enable != nullptr)
		*enable = Parms.enable;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function DarwinGame.GameCharacter.IsOverAbyssBorder
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCharacter::IsOverAbyssBorder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "IsOverAbyssBorder");

	Params::GameCharacter_IsOverAbyssBorder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.NotifyHitAbyssTriggerObject
// (Native, Public, BlueprintCallable)

void AGameCharacter::NotifyHitAbyssTriggerObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "NotifyHitAbyssTriggerObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.OnAnimInstanceInitialized
// (Native, Event, Protected, BlueprintEvent)

void AGameCharacter::OnAnimInstanceInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "OnAnimInstanceInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.OnFinishBodyEmote
// (Final, Native, Protected, BlueprintCallable)

void AGameCharacter::OnFinishBodyEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "OnFinishBodyEmote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.OpenFukidashi
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFukidashiEnum                          FukidashiType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CharacterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FukidashiText                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    VisibleIcon                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AutoClose                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TalkeID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::OpenFukidashi(EFukidashiEnum FukidashiType, const class FString& CharacterName, const class FString& FukidashiText, const bool VisibleIcon, const bool AutoClose, const class FName TalkeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "OpenFukidashi");

	Params::GameCharacter_OpenFukidashi Parms{};

	Parms.FukidashiType = FukidashiType;
	Parms.CharacterName = std::move(CharacterName);
	Parms.FukidashiText = std::move(FukidashiText);
	Parms.VisibleIcon = VisibleIcon;
	Parms.AutoClose = AutoClose;
	Parms.TalkeID = TalkeID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.GameCharacter.Pause
// (Native, Public, BlueprintCallable)

void AGameCharacter::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmote
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EEmoteMethod>                    ignoreMethods                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteRuntimeOption*              runtimeOpt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteStampOverwriteOption*       overwriteOpt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteBodyMotionOverwriteOption*  overwriteBodyOpt                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteFaceOverwriteOption*        overwriteFaceOpt                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteBlinkOverwriteOption*       overwriteBlinkOpt                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteVocalizeOverwriteOption*    overwriteVocalizeOpt                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmote(EEmoteType Type, const TArray<EEmoteMethod>& ignoreMethods, class UEmoteRuntimeOption* runtimeOpt, class UEmoteStampOverwriteOption* overwriteOpt, class UEmoteBodyMotionOverwriteOption* overwriteBodyOpt, class UEmoteFaceOverwriteOption* overwriteFaceOpt, class UEmoteBlinkOverwriteOption* overwriteBlinkOpt, class UEmoteVocalizeOverwriteOption* overwriteVocalizeOpt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmote");

	Params::GameCharacter_PlayEmote Parms{};

	Parms.Type = Type;
	Parms.ignoreMethods = std::move(ignoreMethods);
	Parms.runtimeOpt = runtimeOpt;
	Parms.overwriteOpt = overwriteOpt;
	Parms.overwriteBodyOpt = overwriteBodyOpt;
	Parms.overwriteFaceOpt = overwriteFaceOpt;
	Parms.overwriteBlinkOpt = overwriteBlinkOpt;
	Parms.overwriteVocalizeOpt = overwriteVocalizeOpt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteBlink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEmoteRuntimeOption*              runtimeOpt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteBlinkOverwriteOption*       overwriteOpt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTotalEmote                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmoteBlink(class UEmoteRuntimeOption* runtimeOpt, class UEmoteBlinkOverwriteOption* overwriteOpt, bool bUseTotalEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteBlink");

	Params::GameCharacter_PlayEmoteBlink Parms{};

	Parms.runtimeOpt = runtimeOpt;
	Parms.overwriteOpt = overwriteOpt;
	Parms.bUseTotalEmote = bUseTotalEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteBody
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteRuntimeOption*              runtimeOpt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteBodyMotionOverwriteOption*  overwriteOpt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTotalEmote                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmoteBody(EEmoteType Type, class UEmoteRuntimeOption* runtimeOpt, class UEmoteBodyMotionOverwriteOption* overwriteOpt, bool bUseTotalEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteBody");

	Params::GameCharacter_PlayEmoteBody Parms{};

	Parms.Type = Type;
	Parms.runtimeOpt = runtimeOpt;
	Parms.overwriteOpt = overwriteOpt;
	Parms.bUseTotalEmote = bUseTotalEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteBodyNextToLoopSection
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::PlayEmoteBodyNextToLoopSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteBodyNextToLoopSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteFacial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteRuntimeOption*              runtimeOpt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteFaceOverwriteOption*        overwriteOpt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTotalEmote                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmoteFacial(EEmoteType Type, class UEmoteRuntimeOption* runtimeOpt, class UEmoteFaceOverwriteOption* overwriteOpt, bool bUseTotalEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteFacial");

	Params::GameCharacter_PlayEmoteFacial Parms{};

	Parms.Type = Type;
	Parms.runtimeOpt = runtimeOpt;
	Parms.overwriteOpt = overwriteOpt;
	Parms.bUseTotalEmote = bUseTotalEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteSE
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmoteSE(EEmoteType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteSE");

	Params::GameCharacter_PlayEmoteSE Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteStamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteRuntimeOption*              runtimeOpt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteStampOverwriteOption*       overwriteOpt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTotalEmote                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmoteStamp(EEmoteType Type, class UEmoteRuntimeOption* runtimeOpt, class UEmoteStampOverwriteOption* overwriteOpt, bool bUseTotalEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteStamp");

	Params::GameCharacter_PlayEmoteStamp Parms{};

	Parms.Type = Type;
	Parms.runtimeOpt = runtimeOpt;
	Parms.overwriteOpt = overwriteOpt;
	Parms.bUseTotalEmote = bUseTotalEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.PlayEmoteVocalize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEmoteRuntimeOption*              runtimeOpt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteVocalizeOverwriteOption*    overwriteVocalizeOpt                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTotalEmote                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::PlayEmoteVocalize(class UEmoteRuntimeOption* runtimeOpt, class UEmoteVocalizeOverwriteOption* overwriteVocalizeOpt, bool bUseTotalEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "PlayEmoteVocalize");

	Params::GameCharacter_PlayEmoteVocalize Parms{};

	Parms.runtimeOpt = runtimeOpt;
	Parms.overwriteVocalizeOpt = overwriteVocalizeOpt;
	Parms.bUseTotalEmote = bUseTotalEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.RemoveDefaultMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::RemoveDefaultMaterial(int32 ElementIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "RemoveDefaultMaterial");

	Params::GameCharacter_RemoveDefaultMaterial Parms{};

	Parms.ElementIndex = ElementIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.RemoveDefaultMaterialByName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::RemoveDefaultMaterialByName(const class FName& MaterialSlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "RemoveDefaultMaterialByName");

	Params::GameCharacter_RemoveDefaultMaterialByName Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.RemoveEmotionEffect
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::RemoveEmotionEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "RemoveEmotionEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.RemoveStamp
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::RemoveStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "RemoveStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.Resume
// (Native, Public, BlueprintCallable)

void AGameCharacter::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.SetDefaultMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetDefaultMaterial(int32 ElementIndex, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetDefaultMaterial");

	Params::GameCharacter_SetDefaultMaterial Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.SetDefaultMaterialByName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetDefaultMaterialByName(const class FName& MaterialSlotName, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetDefaultMaterialByName");

	Params::GameCharacter_SetDefaultMaterialByName Parms{};

	Parms.MaterialSlotName = MaterialSlotName;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.SetEmoteFacialAnim
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    FacialAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetEmoteFacialAnim(class UAnimSequence* FacialAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetEmoteFacialAnim");

	Params::GameCharacter_SetEmoteFacialAnim Parms{};

	Parms.FacialAnim = FacialAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.SetEnableAController
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetEnableAController(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetEnableAController");

	Params::GameCharacter_SetEnableAController Parms{};

	Parms.enable = enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.GameCharacter.SetEnableApplyEmoteFace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetEnableApplyEmoteFace(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetEnableApplyEmoteFace");

	Params::GameCharacter_SetEnableApplyEmoteFace Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.SetLookAtParamHead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AnglearVelocity                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVertical                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampHorizontal                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetLookAtParamHead(const float AnglearVelocity, const float ClampVertical, const float ClampHorizontal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetLookAtParamHead");

	Params::GameCharacter_SetLookAtParamHead Parms{};

	Parms.AnglearVelocity = AnglearVelocity;
	Parms.ClampVertical = ClampVertical;
	Parms.ClampHorizontal = ClampHorizontal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.SetLookAtParamSpine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AnglearVelocity                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVertical                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampHorizontal                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameCharacter::SetLookAtParamSpine(const float AnglearVelocity, const float ClampVertical, const float ClampHorizontal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "SetLookAtParamSpine");

	Params::GameCharacter_SetLookAtParamSpine Parms{};

	Parms.AnglearVelocity = AnglearVelocity;
	Parms.ClampVertical = ClampVertical;
	Parms.ClampHorizontal = ClampHorizontal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmote
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmoteBlink
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmoteBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmoteBlink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmoteBody
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmoteBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmoteBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmoteFacial
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmoteFacial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmoteFacial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmoteSE
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmoteSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmoteSE");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmoteStamp
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmoteStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmoteStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.StopEmoteVocalize
// (Final, Native, Public, BlueprintCallable)

void AGameCharacter::StopEmoteVocalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "StopEmoteVocalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameCharacter.GetIsPause
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCharacter::GetIsPause() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "GetIsPause");

	Params::GameCharacter_GetIsPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.GetSocketName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESocket                                 socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AGameCharacter::GetSocketName(ESocket socket) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "GetSocketName");

	Params::GameCharacter_GetSocketName Parms{};

	Parms.socket = socket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.GetSocketTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESocket                                 socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERelativeTransformSpace                 TransformSpace                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AGameCharacter::GetSocketTransform(ESocket socket, ERelativeTransformSpace TransformSpace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "GetSocketTransform");

	Params::GameCharacter_GetSocketTransform Parms{};

	Parms.socket = socket;
	Parms.TransformSpace = TransformSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.HasEmoteEndMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteType                              Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCharacter::HasEmoteEndMotion(const EEmoteType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "HasEmoteEndMotion");

	Params::GameCharacter_HasEmoteEndMotion Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.IsOpenFukidashi
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCharacter::IsOpenFukidashi() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "IsOpenFukidashi");

	Params::GameCharacter_IsOpenFukidashi Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.IsPlayEmote
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCharacter::IsPlayEmote() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "IsPlayEmote");

	Params::GameCharacter_IsPlayEmote Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameCharacter.IsUpdateCollision
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameCharacter::IsUpdateCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCharacter", "IsUpdateCollision");

	Params::GameCharacter_IsUpdateCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.ActivateAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            AbilityTags                                            (Parm, NativeAccessSpecifierPublic)
// bool                                    bAllowRemoteActivation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::ActivateAbilities(const struct FGameplayTagContainer& AbilityTags, bool bAllowRemoteActivation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ActivateAbilities");

	Params::GPACharacter_ActivateAbilities Parms{};

	Parms.AbilityTags = std::move(AbilityTags);
	Parms.bAllowRemoteActivation = bAllowRemoteActivation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.ApplyForce
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EForceType                              Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Force                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::ApplyForce(const EForceType Type, const struct FVector& Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ApplyForce");

	Params::GPACharacter_ApplyForce Parms{};

	Parms.Type = Type;
	Parms.Force = std::move(Force);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ApplySubFoodEffectGameplayEffectData
// (Final, Native, Protected)
// Parameters:
// int32                                   FoodHandle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UnitId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::ApplySubFoodEffectGameplayEffectData(int32 FoodHandle, int32 UnitId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ApplySubFoodEffectGameplayEffectData");

	Params::GPACharacter_ApplySubFoodEffectGameplayEffectData Parms{};

	Parms.FoodHandle = FoodHandle;
	Parms.UnitId = UnitId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.CalcFallingAltitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::CalcFallingAltitude()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "CalcFallingAltitude");

	Params::GPACharacter_CalcFallingAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.CalculateAttributeStatus
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::CalculateAttributeStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "CalculateAttributeStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.CalculateConditionalFeatureStatus
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::CalculateConditionalFeatureStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "CalculateConditionalFeatureStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.CancelAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            AbilityTags                                            (Parm, NativeAccessSpecifierPublic)

void AGPACharacter::CancelAbilities(const struct FGameplayTagContainer& AbilityTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "CancelAbilities");

	Params::GPACharacter_CancelAbilities Parms{};

	Parms.AbilityTags = std::move(AbilityTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.CanUseMP
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::CanUseMP(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "CanUseMP");

	Params::GPACharacter_CanUseMP Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.ChangeBelong
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::ChangeBelong(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ChangeBelong");

	Params::GPACharacter_ChangeBelong Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ChangeToCurrentStateMoveMode
// (Native, Public, BlueprintCallable)

void AGPACharacter::ChangeToCurrentStateMoveMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ChangeToCurrentStateMoveMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ClearRunninngActionOverViewID
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::ClearRunninngActionOverViewID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ClearRunninngActionOverViewID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ClearTemporarilyHoldActionDetailID
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::ClearTemporarilyHoldActionDetailID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ClearTemporarilyHoldActionDetailID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.Dodge
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    StickTilted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::Dodge(bool StickTilted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "Dodge");

	Params::GPACharacter_Dodge Parms{};

	Parms.StickTilted = StickTilted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.EndAbilities
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            AbilityTags                                            (Parm, NativeAccessSpecifierPublic)

void AGPACharacter::EndAbilities(const struct FGameplayTagContainer& AbilityTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "EndAbilities");

	Params::GPACharacter_EndAbilities Parms{};

	Parms.AbilityTags = std::move(AbilityTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.EndRigidTime
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGPACharacter::EndRigidTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "EndRigidTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.GPACharacter.EqualBelong
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::EqualBelong(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "EqualBelong");

	Params::GPACharacter_EqualBelong Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.EventSetEnableAController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::EventSetEnableAController(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "EventSetEnableAController");

	Params::GPACharacter_EventSetEnableAController Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ExpendMP
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::ExpendMP(const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ExpendMP");

	Params::GPACharacter_ExpendMP Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.FindBattleMotionData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MotionID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::FindBattleMotionData(class FName MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "FindBattleMotionData");

	Params::GPACharacter_FindBattleMotionData Parms{};

	Parms.MotionID = MotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetActiveAbilitiesWithTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            GameplayTagContainer                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UActionGameplayAbility*>   ActiveAbilities                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::GetActiveAbilitiesWithTags(const struct FGameplayTagContainer& GameplayTagContainer, TArray<class UActionGameplayAbility*>* ActiveAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetActiveAbilitiesWithTags");

	Params::GPACharacter_GetActiveAbilitiesWithTags Parms{};

	Parms.GameplayTagContainer = std::move(GameplayTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActiveAbilities != nullptr)
		*ActiveAbilities = std::move(Parms.ActiveAbilities);
}


// Function DarwinGame.GPACharacter.GetBodyEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* AGPACharacter::GetBodyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetBodyEffect");

	Params::GPACharacter_GetBodyEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FST_TempCharaDataForDamageCalcReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FST_TempCharaDataForDamageCalc AGPACharacter::GetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetData");

	Params::GPACharacter_GetData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetHeadEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* AGPACharacter::GetHeadEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetHeadEffect");

	Params::GPACharacter_GetHeadEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetStun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetStun");

	Params::GPACharacter_GetStun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.Initialize
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::Initialize(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "Initialize");

	Params::GPACharacter_Initialize Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.InitStatus
// (Native, Event, Public, BlueprintEvent)

void AGPACharacter::InitStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "InitStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.IsUsingAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            GameplayTagContainer                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::IsUsingAbility(const struct FGameplayTagContainer& GameplayTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "IsUsingAbility");

	Params::GPACharacter_IsUsingAbility Parms{};

	Parms.GameplayTagContainer = std::move(GameplayTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.JudgeMagicRampage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::JudgeMagicRampage(class FName actionDetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "JudgeMagicRampage");

	Params::GPACharacter_JudgeMagicRampage Parms{};

	Parms.actionDetailID = actionDetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.KnockBack
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direct                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::KnockBack(const struct FVector& Direct, float Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "KnockBack");

	Params::GPACharacter_KnockBack Parms{};

	Parms.Direct = std::move(Direct);
	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.KnockBackAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActionResult                    ActionResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AGPACharacter::KnockBackAction(const struct FActionResult& ActionResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "KnockBackAction");

	Params::GPACharacter_KnockBackAction Parms{};

	Parms.ActionResult = std::move(ActionResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnDamaged
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEffectContextHandle     Handle                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnDamaged(const struct FGameplayEffectContextHandle& Handle, float DamageAmount, class AGPACharacter* InstigatorCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnDamaged");

	Params::GPACharacter_OnDamaged Parms{};

	Parms.Handle = std::move(Handle);
	Parms.DamageAmount = DamageAmount;
	Parms.InstigatorCharacter = InstigatorCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnDead
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AGPACharacter*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnDead(class AGPACharacter* InstigatorCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnDead");

	Params::GPACharacter_OnDead Parms{};

	Parms.InstigatorCharacter = InstigatorCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnGuard
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEffectContextHandle     Handle                                                 (Parm, NativeAccessSpecifierPublic)
// EGuardType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnGuard(const struct FGameplayEffectContextHandle& Handle, EGuardType Type, class AGPACharacter* InstigatorCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnGuard");

	Params::GPACharacter_OnGuard Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Type = Type;
	Parms.InstigatorCharacter = InstigatorCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnGuts
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnGuts(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnGuts");

	Params::GPACharacter_OnGuts Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnHealed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEffectContextHandle     Handle                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnHealed(const struct FGameplayEffectContextHandle& Handle, float HealAmount, class AGPACharacter* InstigatorCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnHealed");

	Params::GPACharacter_OnHealed Parms{};

	Parms.Handle = std::move(Handle);
	Parms.HealAmount = HealAmount;
	Parms.InstigatorCharacter = InstigatorCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnLand
// (Native, Public, BlueprintCallable)

void AGPACharacter::OnLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnLand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnMPHealed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEffectContextHandle     Handle                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnMPHealed(const struct FGameplayEffectContextHandle& Handle, float HealAmount, class AGPACharacter* InstigatorCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnMPHealed");

	Params::GPACharacter_OnMPHealed Parms{};

	Parms.Handle = std::move(Handle);
	Parms.HealAmount = HealAmount;
	Parms.InstigatorCharacter = InstigatorCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.OnSetHiddenByDithering
// (Native, Protected)
// Parameters:
// bool                                    Hidden                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::OnSetHiddenByDithering(bool Hidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "OnSetHiddenByDithering");

	Params::GPACharacter_OnSetHiddenByDithering Parms{};

	Parms.Hidden = Hidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ReleaseForce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EForceType                              Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::ReleaseForce(const EForceType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ReleaseForce");

	Params::GPACharacter_ReleaseForce Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ResetMaxFlySpeed
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::ResetMaxFlySpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ResetMaxFlySpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ResetMaxMoveSpeed
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::ResetMaxMoveSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ResetMaxMoveSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.ResetMaxWalkSpeed
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::ResetMaxWalkSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "ResetMaxWalkSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.RotateToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RotateRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::RotateToTarget(int32 RotateRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "RotateToTarget");

	Params::GPACharacter_RotateToTarget Parms{};

	Parms.RotateRate = RotateRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.RotateToTargetWithAllParams
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RotateRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::RotateToTargetWithAllParams(class USceneComponent* Target, const struct FVector& Offset, int32 RotateRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "RotateToTargetWithAllParams");

	Params::GPACharacter_RotateToTargetWithAllParams Parms{};

	Parms.Target = Target;
	Parms.Offset = std::move(Offset);
	Parms.RotateRate = RotateRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.RotateToTargetWithOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RotateRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::RotateToTargetWithOffset(const struct FVector& Offset, int32 RotateRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "RotateToTargetWithOffset");

	Params::GPACharacter_RotateToTargetWithOffset Parms{};

	Parms.Offset = std::move(Offset);
	Parms.RotateRate = RotateRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetCurrentDamageReactionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageReactionType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetCurrentDamageReactionType(EDamageReactionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetCurrentDamageReactionType");

	Params::GPACharacter_SetCurrentDamageReactionType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetHP
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetHP(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetHP");

	Params::GPACharacter_SetHP Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetInDodge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InDodge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetInDodge(bool InDodge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetInDodge");

	Params::GPACharacter_SetInDodge Parms{};

	Parms.InDodge = InDodge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetLinkTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetLinkTarget(class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetLinkTarget");

	Params::GPACharacter_SetLinkTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetMP
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetMP(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetMP");

	Params::GPACharacter_SetMP Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetPauseAllAttributeEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Pause_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetPauseAllAttributeEffect(bool Pause_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetPauseAllAttributeEffect");

	Params::GPACharacter_SetPauseAllAttributeEffect Parms{};

	Parms.Pause_0 = Pause_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetRootMotionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetRootMotionScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetRootMotionScale");

	Params::GPACharacter_SetRootMotionScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetRunningLinkID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             LinkID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetRunningLinkID(const class FName LinkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetRunningLinkID");

	Params::GPACharacter_SetRunningLinkID Parms{};

	Parms.LinkID = LinkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetRunninngActionOverViewID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetRunninngActionOverViewID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetRunninngActionOverViewID");

	Params::GPACharacter_SetRunninngActionOverViewID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetTemporarilyActionDetailID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetTemporarilyActionDetailID(const class FName& actionDetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetTemporarilyActionDetailID");

	Params::GPACharacter_SetTemporarilyActionDetailID Parms{};

	Parms.actionDetailID = actionDetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetVisible
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetVisible(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetVisible");

	Params::GPACharacter_SetVisible Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.SetVisibleOnlyBodyAndEquipments
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::SetVisibleOnlyBodyAndEquipments(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SetVisibleOnlyBodyAndEquipments");

	Params::GPACharacter_SetVisibleOnlyBodyAndEquipments Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.StartRigidTime
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGPACharacter::StartRigidTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "StartRigidTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.GPACharacter.SyncWithLoadedData
// (Final, Native, Public, BlueprintCallable)

void AGPACharacter::SyncWithLoadedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "SyncWithLoadedData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GPACharacter.UseMP
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::UseMP(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "UseMP");

	Params::GPACharacter_UseMP Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetAttributeList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                AttributeList                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void AGPACharacter::GetAttributeList(TMap<class FName, int32>* AttributeList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetAttributeList");

	Params::GPACharacter_GetAttributeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AttributeList != nullptr)
		*AttributeList = std::move(Parms.AttributeList);
}


// Function DarwinGame.GPACharacter.GetCharacterLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGPACharacter::GetCharacterLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetCharacterLevel");

	Params::GPACharacter_GetCharacterLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetDarwinCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USwitchCollisionMovementComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USwitchCollisionMovementComponent* AGPACharacter::GetDarwinCharacterMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetDarwinCharacterMovement");

	Params::GPACharacter_GetDarwinCharacterMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetDitheringComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDitheringComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDitheringComponent* AGPACharacter::GetDitheringComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetDitheringComponent");

	Params::GPACharacter_GetDitheringComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetEffectSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEffectSizeID                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEffectSizeID AGPACharacter::GetEffectSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetEffectSize");

	Params::GPACharacter_GetEffectSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetFallingAltitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetFallingAltitude() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetFallingAltitude");

	Params::GPACharacter_GetFallingAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetFeatures
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FFeaturePossessionInfo>   Features                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGPACharacter::GetFeatures(TArray<struct FFeaturePossessionInfo>* Features) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetFeatures");

	Params::GPACharacter_GetFeatures Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Features != nullptr)
		*Features = std::move(Parms.Features);
}


// Function DarwinGame.GPACharacter.GetHP
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetHP");

	Params::GPACharacter_GetHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetLinkTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* AGPACharacter::GetLinkTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetLinkTarget");

	Params::GPACharacter_GetLinkTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetMaxHP
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetMaxHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetMaxHP");

	Params::GPACharacter_GetMaxHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetMaxMP
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetMaxMP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetMaxMP");

	Params::GPACharacter_GetMaxMP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetMP
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetMP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetMP");

	Params::GPACharacter_GetMP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetOriginKindID
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AGPACharacter::GetOriginKindID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetOriginKindID");

	Params::GPACharacter_GetOriginKindID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetResistLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EResistanceType                         ResistType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGPACharacter::GetResistLevel(EResistanceType ResistType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetResistLevel");

	Params::GPACharacter_GetResistLevel Parms{};

	Parms.ResistType = ResistType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetRootMotionScale
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGPACharacter::GetRootMotionScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetRootMotionScale");

	Params::GPACharacter_GetRootMotionScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetRunningLinkID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AGPACharacter::GetRunningLinkID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetRunningLinkID");

	Params::GPACharacter_GetRunningLinkID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetRunninngActionOverViewID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AGPACharacter::GetRunninngActionOverViewID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetRunninngActionOverViewID");

	Params::GPACharacter_GetRunninngActionOverViewID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status AGPACharacter::GetStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetStatus");

	Params::GPACharacter_GetStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetTargetComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AGPACharacter::GetTargetComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetTargetComponent");

	Params::GPACharacter_GetTargetComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.GetTemporarilyActionDetailID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AGPACharacter::GetTemporarilyActionDetailID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "GetTemporarilyActionDetailID");

	Params::GPACharacter_GetTemporarilyActionDetailID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.IsMPEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::IsMPEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "IsMPEmpty");

	Params::GPACharacter_IsMPEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GPACharacter.IsRunninngAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGPACharacter::IsRunninngAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GPACharacter", "IsRunninngAction");

	Params::GPACharacter_IsRunninngAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.AvoidMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::AvoidMonster(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "AvoidMonster");

	Params::MonsterBase_AvoidMonster Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.CancelBehaviorAndWait
// (Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::CancelBehaviorAndWait(class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "CancelBehaviorAndWait");

	Params::MonsterBase_CancelBehaviorAndWait Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.CanExetuteMonsterTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::CanExetuteMonsterTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "CanExetuteMonsterTask");

	Params::MonsterBase_CanExetuteMonsterTask Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.ChangeBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    change                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::ChangeBehavior(bool change)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ChangeBehavior");

	Params::MonsterBase_ChangeBehavior Parms{};

	Parms.change = change;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.CheckRemakeAttackLocationData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::CheckRemakeAttackLocationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "CheckRemakeAttackLocationData");

	Params::MonsterBase_CheckRemakeAttackLocationData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.CloseSubjugetionMessage
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::CloseSubjugetionMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "CloseSubjugetionMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.CountEcologicalMotionWithConsecutiveNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterEcologicalMotion                ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterBase::CountEcologicalMotionWithConsecutiveNumber(EMonsterEcologicalMotion ID, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "CountEcologicalMotionWithConsecutiveNumber");

	Params::MonsterBase_CountEcologicalMotionWithConsecutiveNumber Parms{};

	Parms.ID = ID;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.CountUpRandomWalkFailedCount
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::CountUpRandomWalkFailedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "CountUpRandomWalkFailedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.GetAbnormalEffectHandel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle AMonsterBase::GetAbnormalEffectHandel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetAbnormalEffectHandel");

	Params::MonsterBase_GetAbnormalEffectHandel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetAcceptableRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBase::GetAcceptableRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetAcceptableRadius");

	Params::MonsterBase_GetAcceptableRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetAnimSection
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMonsterBase::GetAnimSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetAnimSection");

	Params::MonsterBase_GetAnimSection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetAreaOfEffectComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAreaOfEffectControlComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAreaOfEffectControlComponent* AMonsterBase::GetAreaOfEffectComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetAreaOfEffectComponent");

	Params::MonsterBase_GetAreaOfEffectComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetBattleAIBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterBattleAIBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterBattleAIBase* AMonsterBase::GetBattleAIBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetBattleAIBase");

	Params::MonsterBase_GetBattleAIBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetBattleOnDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetBattleOnDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetBattleOnDead");

	Params::MonsterBase_GetBattleOnDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetBattleStartWaiting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetBattleStartWaiting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetBattleStartWaiting");

	Params::MonsterBase_GetBattleStartWaiting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetCausedDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetCausedDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetCausedDamage");

	Params::MonsterBase_GetCausedDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetCombatState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterCombatState                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterCombatState AMonsterBase::GetCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetCombatState");

	Params::MonsterBase_GetCombatState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetEcologicalMotionData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_EcologicalMotionData         Out                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// EMonsterEcologicalMotion                ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetEcologicalMotionData(struct FST_EcologicalMotionData* Out, EMonsterEcologicalMotion ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetEcologicalMotionData");

	Params::MonsterBase_GetEcologicalMotionData Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetEcologicalMotionDataWithNumber
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_EcologicalMotionData         Out                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// EMonsterEcologicalMotion                ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   No                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetEcologicalMotionDataWithNumber(struct FST_EcologicalMotionData* Out, EMonsterEcologicalMotion ID, int32 No)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetEcologicalMotionDataWithNumber");

	Params::MonsterBase_GetEcologicalMotionDataWithNumber Parms{};

	Parms.ID = ID;
	Parms.No = No;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetLandSection
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMonsterBase::GetLandSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetLandSection");

	Params::MonsterBase_GetLandSection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetMonsterRingComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterRingComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterRingComponent* AMonsterBase::GetMonsterRingComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetMonsterRingComponent");

	Params::MonsterBase_GetMonsterRingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetMoveAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetMoveAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetMoveAnimation");

	Params::MonsterBase_GetMoveAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetOuterRequestLeave
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetOuterRequestLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetOuterRequestLeave");

	Params::MonsterBase_GetOuterRequestLeave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetParentGeneratorType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnemySpawnGeneratorType                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnemySpawnGeneratorType AMonsterBase::GetParentGeneratorType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetParentGeneratorType");

	Params::MonsterBase_GetParentGeneratorType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetReversalTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBase::GetReversalTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetReversalTime");

	Params::MonsterBase_GetReversalTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetSpecialAbilityLevelSequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULevelSequence*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequence* AMonsterBase::GetSpecialAbilityLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetSpecialAbilityLevelSequence");

	Params::MonsterBase_GetSpecialAbilityLevelSequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetSuperArmor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetSuperArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetSuperArmor");

	Params::MonsterBase_GetSuperArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.HasChangedBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::HasChangedBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "HasChangedBehavior");

	Params::MonsterBase_HasChangedBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.HasRequestChangeBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::HasRequestChangeBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "HasRequestChangeBehavior");

	Params::MonsterBase_HasRequestChangeBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsChargeBreaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsChargeBreaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsChargeBreaking");

	Params::MonsterBase_IsChargeBreaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsHiding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsHiding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsHiding");

	Params::MonsterBase_IsHiding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsStun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsStun");

	Params::MonsterBase_IsStun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.NeedFixedJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::NeedFixedJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "NeedFixedJump");

	Params::MonsterBase_NeedFixedJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.NextBehaviorWithContext
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBehaviorContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMonsterBase::NextBehaviorWithContext(class AGPACharacter* Target, const struct FBehaviorContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "NextBehaviorWithContext");

	Params::MonsterBase_NextBehaviorWithContext Parms{};

	Parms.Target = Target;
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.PushBackAvoidanceBodys
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::PushBackAvoidanceBodys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "PushBackAvoidanceBodys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.RemoveAttackLocationSelf
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::RemoveAttackLocationSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "RemoveAttackLocationSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.RequestChangeBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    change                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::RequestChangeBehavior(bool change)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "RequestChangeBehavior");

	Params::MonsterBase_RequestChangeBehavior Parms{};

	Parms.change = change;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.RequestLeave
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::RequestLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "RequestLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.ResetBehavior
// (Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::ResetBehavior(class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ResetBehavior");

	Params::MonsterBase_ResetBehavior Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.ResetBehaviorWithContext
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBehaviorContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMonsterBase::ResetBehaviorWithContext(class AGPACharacter* Target, const struct FBehaviorContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ResetBehaviorWithContext");

	Params::MonsterBase_ResetBehaviorWithContext Parms{};

	Parms.Target = Target;
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.ResetRandomWalkFailedCount
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::ResetRandomWalkFailedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ResetRandomWalkFailedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.RotateToSelectTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RotateRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::RotateToSelectTarget(int32 RotateRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "RotateToSelectTarget");

	Params::MonsterBase_RotateToSelectTarget Parms{};

	Parms.RotateRate = RotateRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetAbnormalEffectHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      meffect                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetAbnormalEffectHandle(const struct FActiveGameplayEffectHandle& meffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetAbnormalEffectHandle");

	Params::MonsterBase_SetAbnormalEffectHandle Parms{};

	Parms.meffect = std::move(meffect);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetAcceptableRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetAcceptableRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetAcceptableRadius");

	Params::MonsterBase_SetAcceptableRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetAnimSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetAnimSection(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetAnimSection");

	Params::MonsterBase_SetAnimSection Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetBattleOnDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetBattleOnDead(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetBattleOnDead");

	Params::MonsterBase_SetBattleOnDead Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetBattleStartWaiting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetBattleStartWaiting(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetBattleStartWaiting");

	Params::MonsterBase_SetBattleStartWaiting Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBehavior                        Behavior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetBehavior(EMonsterBehavior Behavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetBehavior");

	Params::MonsterBase_SetBehavior Parms{};

	Parms.Behavior = Behavior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetBoolOnBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetBoolOnBlackboard(class FName Key, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetBoolOnBlackboard");

	Params::MonsterBase_SetBoolOnBlackboard Parms{};

	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetCausedDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetCausedDamage(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetCausedDamage");

	Params::MonsterBase_SetCausedDamage Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetChargeBreaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetChargeBreaking(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetChargeBreaking");

	Params::MonsterBase_SetChargeBreaking Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetCombatState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterCombatState                     State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetCombatState(EMonsterCombatState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetCombatState");

	Params::MonsterBase_SetCombatState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetDamageCollisionEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetDamageCollisionEnable(bool isEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetDamageCollisionEnable");

	Params::MonsterBase_SetDamageCollisionEnable Parms{};

	Parms.isEnable = isEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetEcologicalState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEcologicalState                        ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetEcologicalState(EEcologicalState ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetEcologicalState");

	Params::MonsterBase_SetEcologicalState Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetFloatOnBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetFloatOnBlackboard(class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetFloatOnBlackboard");

	Params::MonsterBase_SetFloatOnBlackboard Parms{};

	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetHidingDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetHidingDamage(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetHidingDamage");

	Params::MonsterBase_SetHidingDamage Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetIntOnBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetIntOnBlackboard(class FName Key, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetIntOnBlackboard");

	Params::MonsterBase_SetIntOnBlackboard Parms{};

	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetLandSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetLandSection(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetLandSection");

	Params::MonsterBase_SetLandSection Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetMagicChantingTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEffectBase*                      chantingEffect                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   chantingTimer                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetMagicChantingTimer(class AEffectBase* chantingEffect, const float chantingTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetMagicChantingTimer");

	Params::MonsterBase_SetMagicChantingTimer Parms{};

	Parms.chantingEffect = chantingEffect;
	Parms.chantingTimer = chantingTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetMonsterStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterStatus                          Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetFlag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetMonsterStatus(EMonsterStatus Status, bool SetFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetMonsterStatus");

	Params::MonsterBase_SetMonsterStatus Parms{};

	Parms.Status = Status;
	Parms.SetFlag = SetFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetMoveAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetMoveAnimation(bool Animation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetMoveAnimation");

	Params::MonsterBase_SetMoveAnimation Parms{};

	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetOuterRequestLeave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetOuterRequestLeave(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetOuterRequestLeave");

	Params::MonsterBase_SetOuterRequestLeave Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetPlayingDeadEd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetPlayingDeadEd(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetPlayingDeadEd");

	Params::MonsterBase_SetPlayingDeadEd Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetPlayingHideEd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetPlayingHideEd(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetPlayingHideEd");

	Params::MonsterBase_SetPlayingHideEd Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetStateComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetStateComplete(bool Complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetStateComplete");

	Params::MonsterBase_SetStateComplete Parms{};

	Parms.Complete = Complete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetSuperArmor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    change                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetSuperArmor(bool change)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetSuperArmor");

	Params::MonsterBase_SetSuperArmor Parms{};

	Parms.change = change;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetTargetDropItemOnBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADropItemObject*                  Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetTargetDropItemOnBlackboard(class FName Key, class ADropItemObject* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetTargetDropItemOnBlackboard");

	Params::MonsterBase_SetTargetDropItemOnBlackboard Parms{};

	Parms.Key = Key;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetTerritoryMaxRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetTerritoryMaxRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetTerritoryMaxRadius");

	Params::MonsterBase_SetTerritoryMaxRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetTerritoryMinRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetTerritoryMinRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetTerritoryMinRadius");

	Params::MonsterBase_SetTerritoryMinRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetThoughtType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterThoughtType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetThoughtType(EMonsterThoughtType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetThoughtType");

	Params::MonsterBase_SetThoughtType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isLeft                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetTurn(float Angle, bool isLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetTurn");

	Params::MonsterBase_SetTurn Parms{};

	Parms.Angle = Angle;
	Parms.isLeft = isLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.SetVectorOnBlackboard
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::SetVectorOnBlackboard(class FName Key, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "SetVectorOnBlackboard");

	Params::MonsterBase_SetVectorOnBlackboard Parms{};

	Parms.Key = Key;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.ShowSubjugationMessage
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::ShowSubjugationMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ShowSubjugationMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.StackBossFinishSequence
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::StackBossFinishSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "StackBossFinishSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.StartActionCoolTime
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::StartActionCoolTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "StartActionCoolTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.StartDamageGetUp
// (Native, Public, BlueprintCallable)

void AMonsterBase::StartDamageGetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "StartDamageGetUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.StartEcoActCoolTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::StartEcoActCoolTime(class FName ID, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "StartEcoActCoolTime");

	Params::MonsterBase_StartEcoActCoolTime Parms{};

	Parms.ID = ID;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.TaskFinishBroadcast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsCallBroadcast                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::TaskFinishBroadcast(bool IsCallBroadcast)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "TaskFinishBroadcast");

	Params::MonsterBase_TaskFinishBroadcast Parms{};

	Parms.IsCallBroadcast = IsCallBroadcast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.TaskFinishClear
// (Final, Native, Public, BlueprintCallable)

void AMonsterBase::TaskFinishClear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "TaskFinishClear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.UpdateActionCoolTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::UpdateActionCoolTime(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "UpdateActionCoolTime");

	Params::MonsterBase_UpdateActionCoolTime Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.UpdateEachs
// (Native, Event, Public, BlueprintEvent)

void AMonsterBase::UpdateEachs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "UpdateEachs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.UpdateEcoActCoolTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBase::UpdateEcoActCoolTime(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "UpdateEcoActCoolTime");

	Params::MonsterBase_UpdateEcoActCoolTime Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBase.ValidEcologicalMotion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterEcologicalMotion                ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::ValidEcologicalMotion(EMonsterEcologicalMotion ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ValidEcologicalMotion");

	Params::MonsterBase_ValidEcologicalMotion Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.ValidEcologicalMotions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<EMonsterEcologicalMotion>        IDs                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::ValidEcologicalMotions(const TArray<EMonsterEcologicalMotion>& IDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ValidEcologicalMotions");

	Params::MonsterBase_ValidEcologicalMotions Parms{};

	Parms.IDs = std::move(IDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.ValidEcologicalMotionWithNumber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterEcologicalMotion                ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   No                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::ValidEcologicalMotionWithNumber(EMonsterEcologicalMotion ID, int32 No)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ValidEcologicalMotionWithNumber");

	Params::MonsterBase_ValidEcologicalMotionWithNumber Parms{};

	Parms.ID = ID;
	Parms.No = No;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.ValidTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::ValidTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "ValidTurn");

	Params::MonsterBase_ValidTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetActionCycle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBase::GetActionCycle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetActionCycle");

	Params::MonsterBase_GetActionCycle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetBehavior
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBehavior                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBehavior AMonsterBase::GetBehavior() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetBehavior");

	Params::MonsterBase_GetBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetBoolOnBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetBoolOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetBoolOnBlackboard");

	Params::MonsterBase_GetBoolOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetEcologicalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEcologicalState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEcologicalState AMonsterBase::GetEcologicalState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetEcologicalState");

	Params::MonsterBase_GetEcologicalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetFieldLinkType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFieldLinkType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFieldLinkType AMonsterBase::GetFieldLinkType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetFieldLinkType");

	Params::MonsterBase_GetFieldLinkType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetFloatOnBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBase::GetFloatOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetFloatOnBlackboard");

	Params::MonsterBase_GetFloatOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetIntOnBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterBase::GetIntOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetIntOnBlackboard");

	Params::MonsterBase_GetIntOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetIsBoss
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetIsBoss() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetIsBoss");

	Params::MonsterBase_GetIsBoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetIsKeepInvisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetIsKeepInvisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetIsKeepInvisible");

	Params::MonsterBase_GetIsKeepInvisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetIsNormalBoss
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetIsNormalBoss() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetIsNormalBoss");

	Params::MonsterBase_GetIsNormalBoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetKindIDName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AMonsterBase::GetKindIDName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetKindIDName");

	Params::MonsterBase_GetKindIDName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetMonsterAIController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMonsterAIController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterAIController* AMonsterBase::GetMonsterAIController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetMonsterAIController");

	Params::MonsterBase_GetMonsterAIController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetMonsterStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterStatus                          Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetMonsterStatus(EMonsterStatus Status) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetMonsterStatus");

	Params::MonsterBase_GetMonsterStatus Parms{};

	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetParamMonsterType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterType AMonsterBase::GetParamMonsterType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetParamMonsterType");

	Params::MonsterBase_GetParamMonsterType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetPartyIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterBase::GetPartyIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetPartyIndex");

	Params::MonsterBase_GetPartyIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetRotatorOnBlackboard
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AMonsterBase::GetRotatorOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetRotatorOnBlackboard");

	Params::MonsterBase_GetRotatorOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetStateComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::GetStateComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetStateComplete");

	Params::MonsterBase_GetStateComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetTargetDropItemOnBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADropItemObject*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADropItemObject* AMonsterBase::GetTargetDropItemOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetTargetDropItemOnBlackboard");

	Params::MonsterBase_GetTargetDropItemOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetTargetOnBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* AMonsterBase::GetTargetOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetTargetOnBlackboard");

	Params::MonsterBase_GetTargetOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetTerritoryMaxRadius
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBase::GetTerritoryMaxRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetTerritoryMaxRadius");

	Params::MonsterBase_GetTerritoryMaxRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetTerritoryMinRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBase::GetTerritoryMinRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetTerritoryMinRadius");

	Params::MonsterBase_GetTerritoryMinRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetThoughtType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterThoughtType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterThoughtType AMonsterBase::GetThoughtType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetThoughtType");

	Params::MonsterBase_GetThoughtType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.GetVectorOnBlackboard
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMonsterBase::GetVectorOnBlackboard(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "GetVectorOnBlackboard");

	Params::MonsterBase_GetVectorOnBlackboard Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsEnemyMonster
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsEnemyMonster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsEnemyMonster");

	Params::MonsterBase_IsEnemyMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsFlyType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsFlyType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsFlyType");

	Params::MonsterBase_IsFlyType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsFriendMonster
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsFriendMonster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsFriendMonster");

	Params::MonsterBase_IsFriendMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsHidingDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsHidingDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsHidingDamage");

	Params::MonsterBase_IsHidingDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsHighAltitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsHighAltitude() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsHighAltitude");

	Params::MonsterBase_IsHighAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsPlayingDeadEd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsPlayingDeadEd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsPlayingDeadEd");

	Params::MonsterBase_IsPlayingDeadEd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsPlayingHideEd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsPlayingHideEd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsPlayingHideEd");

	Params::MonsterBase_IsPlayingHideEd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsTargeted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsTargeted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsTargeted");

	Params::MonsterBase_IsTargeted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBase.IsTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBase::IsTurn(float Angle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBase", "IsTurn");

	Params::MonsterBase_IsTurn Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.AttachHaveArtifactOnHead
// (Final, Native, Public, BlueprintCallable)

void AMonster::AttachHaveArtifactOnHead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "AttachHaveArtifactOnHead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.BattleAIActionDecision
// (Final, Native, Public, BlueprintCallable)

void AMonster::BattleAIActionDecision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "BattleAIActionDecision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.BehaviorDecision
// (Final, Native, Public, BlueprintCallable)

void AMonster::BehaviorDecision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "BehaviorDecision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.BindOnTargetPerceptionUpdated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AMonster::BindOnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "BindOnTargetPerceptionUpdated");

	Params::Monster_BindOnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.CancelLink
// (Final, Native, Public, BlueprintCallable)

void AMonster::CancelLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "CancelLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.ClearHaveArtifact
// (Final, Native, Public, BlueprintCallable)

void AMonster::ClearHaveArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "ClearHaveArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.DetachHaveArtifactOnHead
// (Final, Native, Public, BlueprintCallable)

void AMonster::DetachHaveArtifactOnHead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "DetachHaveArtifactOnHead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.DispatchMonsterGetUp
// (Final, Native, Public, BlueprintCallable)

void AMonster::DispatchMonsterGetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "DispatchMonsterGetUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.DropHaveArtifact
// (Final, Native, Public, BlueprintCallable)

void AMonster::DropHaveArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "DropHaveArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.EndCounterAttackFromFootpad
// (Final, Native, Public, BlueprintCallable)

void AMonster::EndCounterAttackFromFootpad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "EndCounterAttackFromFootpad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.EndGetUp
// (Final, Native, Public, BlueprintCallable)

void AMonster::EndGetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "EndGetUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.GetBattleAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterBattleAI*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterBattleAI* AMonster::GetBattleAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetBattleAI");

	Params::Monster_GetBattleAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetCamEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::GetCamEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetCamEnd");

	Params::Monster_GetCamEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetCameraControll
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMonsterCameraControllType              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterCameraControllType AMonster::GetCameraControll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetCameraControll");

	Params::Monster_GetCameraControll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetCameraType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMonsterCameraType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterCameraType AMonster::GetCameraType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetCameraType");

	Params::Monster_GetCameraType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetEcologicalAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterEcologicalAI*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterEcologicalAI* AMonster::GetEcologicalAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetEcologicalAI");

	Params::Monster_GetEcologicalAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetIsCounterAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::GetIsCounterAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetIsCounterAttack");

	Params::Monster_GetIsCounterAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetIsGetUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::GetIsGetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetIsGetUp");

	Params::Monster_GetIsGetUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetMonsterPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterPhase                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterPhase AMonster::GetMonsterPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetMonsterPhase");

	Params::Monster_GetMonsterPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetRivalTeamNonBattleAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterRivalteamNonBattleAI*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterRivalteamNonBattleAI* AMonster::GetRivalTeamNonBattleAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetRivalTeamNonBattleAI");

	Params::Monster_GetRivalTeamNonBattleAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetRivalTeamStealArtifactAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterRivalteamStealArtifactAI* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterRivalteamStealArtifactAI* AMonster::GetRivalTeamStealArtifactAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetRivalTeamStealArtifactAI");

	Params::Monster_GetRivalTeamStealArtifactAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.HiddenDeadIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::HiddenDeadIcon(bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "HiddenDeadIcon");

	Params::Monster_HiddenDeadIcon Parms{};

	Parms.IsHidden = IsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.OnFinishAllEmote
// (Final, Native, Private)

void AMonster::OnFinishAllEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "OnFinishAllEmote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.OnFinishPlayOneShotArtifactNotifyStamp
// (Final, Native, Private)

void AMonster::OnFinishPlayOneShotArtifactNotifyStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "OnFinishPlayOneShotArtifactNotifyStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.PickUpArtifact
// (Final, Native, Public, BlueprintCallable)

void AMonster::PickUpArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "PickUpArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.RemoveAttackLocationUser
// (Final, Native, Public, BlueprintCallable)

void AMonster::RemoveAttackLocationUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "RemoveAttackLocationUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.RequestLeaveDispatchMonster
// (Final, Native, Public, BlueprintCallable)

void AMonster::RequestLeaveDispatchMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "RequestLeaveDispatchMonster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetCamEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetCamEnd(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetCamEnd");

	Params::Monster_SetCamEnd Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetCameraControll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterCameraControllType              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetCameraControll(EMonsterCameraControllType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetCameraControll");

	Params::Monster_SetCameraControll Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetCameraType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterCameraType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetCameraType(EMonsterCameraType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetCameraType");

	Params::Monster_SetCameraType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetEyesSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetEyesSocket(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetEyesSocket");

	Params::Monster_SetEyesSocket Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetIsCounterAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsCounterAttack                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetIsCounterAttack(bool IsCounterAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetIsCounterAttack");

	Params::Monster_SetIsCounterAttack Parms{};

	Parms.IsCounterAttack = IsCounterAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetMonsterPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterPhase                           phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetMonsterPhase(EMonsterPhase phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetMonsterPhase");

	Params::Monster_SetMonsterPhase Parms{};

	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.SetRivalTeamDialogID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonster::SetRivalTeamDialogID(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "SetRivalTeamDialogID");

	Params::Monster_SetRivalTeamDialogID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.StartLink
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::StartLink(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "StartLink");

	Params::Monster_StartLink Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.StartLinkDefault
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::StartLinkDefault(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "StartLinkDefault");

	Params::Monster_StartLinkDefault Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.StartLinkDive
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::StartLinkDive(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "StartLinkDive");

	Params::Monster_StartLinkDive Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.StopMove
// (Final, Native, Public, BlueprintCallable)

void AMonster::StopMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "StopMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.WaitLink
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AMonster::WaitLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "WaitLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.WithdrawalFootpad
// (Final, Native, Public, BlueprintCallable)

void AMonster::WithdrawalFootpad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "WithdrawalFootpad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.Monster.GetMonsterTableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMonsterTableComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterTableComponent* AMonster::GetMonsterTableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetMonsterTableComponent");

	Params::Monster_GetMonsterTableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetRivalTeamDialogID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonster::GetRivalTeamDialogID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetRivalTeamDialogID");

	Params::Monster_GetRivalTeamDialogID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.GetStealArtifactID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonster::GetStealArtifactID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "GetStealArtifactID");

	Params::Monster_GetStealArtifactID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.Monster.HasStealArtifact
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonster::HasStealArtifact() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Monster", "HasStealArtifact");

	Params::Monster_HasStealArtifact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttackCollisionInterface.IsMagicRampage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAttackCollisionInterface::IsMagicRampage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionInterface", "IsMagicRampage");

	Params::AttackCollisionInterface_IsMagicRampage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttackCollisionInterface.IsOffsetable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAttackCollisionInterface::IsOffsetable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionInterface", "IsOffsetable");

	Params::AttackCollisionInterface_IsOffsetable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttackCollisionInterface.Pause
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAttackCollisionInterface::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionInterface", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttackCollisionInterface.PostDamage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAttackCollisionInterface::PostDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionInterface", "PostDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttackCollisionInterface.PostHit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAttackCollisionInterface::PostHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionInterface", "PostHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttackCollisionInterface.Resume
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAttackCollisionInterface::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionInterface", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AnimNotify_PickUpArtifact.PickUpArtifact
// (Final, Native, Public, Const)

void UAnimNotify_PickUpArtifact::PickUpArtifact() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotify_PickUpArtifact", "PickUpArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LiftObjectBase.CloseLeftDoorSkip
// (Final, Native, Public)

void ALiftObjectBase::CloseLeftDoorSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftObjectBase", "CloseLeftDoorSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LiftObjectBase.CloseRightDoorSkip
// (Final, Native, Public)

void ALiftObjectBase::CloseRightDoorSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftObjectBase", "CloseRightDoorSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LiftObjectBase.OpenLeftDoorSkip
// (Final, Native, Public)

void ALiftObjectBase::OpenLeftDoorSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftObjectBase", "OpenLeftDoorSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LiftObjectBase.OpenRightDoorSkip
// (Final, Native, Public)

void ALiftObjectBase::OpenRightDoorSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftObjectBase", "OpenRightDoorSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLockon.LockOff
// (Final, Native, Public, BlueprintCallable)

void UUIField_IconLockon::LockOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLockon", "LockOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLockon.LockOn
// (Final, Native, Public, BlueprintCallable)

void UUIField_IconLockon::LockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLockon", "LockOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLockon.SetLockOnState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLockOn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLockon::SetLockOnState(bool IsLockOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLockon", "SetLockOnState");

	Params::UIField_IconLockon_SetLockOnState Parms{};

	Parms.IsLockOn = IsLockOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLockon.SetMarkerVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Condition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLockon::SetMarkerVisibility(bool Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLockon", "SetMarkerVisibility");

	Params::UIField_IconLockon_SetMarkerVisibility Parms{};

	Parms.Condition = Condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLockon.SetTarget
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLockon::SetTarget(class USceneComponent* SceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLockon", "SetTarget");

	Params::UIField_IconLockon_SetTarget Parms{};

	Parms.SceneComponent = SceneComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.AttackCollisionBase.OnComponentBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// struct FOverlapEventInfo                Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             ElementID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAttackCollisionBase::OnComponentBeginOverlap(const struct FOverlapEventInfo& Info, class FName ElementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionBase", "OnComponentBeginOverlap");

	Params::AttackCollisionBase_OnComponentBeginOverlap Parms{};

	Parms.Info = std::move(Info);
	Parms.ElementID = ElementID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttackCollisionBase.OnComponentExecuteOverlapEvent
// (Native, Public, HasOutParams)
// Parameters:
// struct FAttackCollisionEventInfo        Info                                                   (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             damageCollisionId                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    doDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAttackCollisionBase::OnComponentExecuteOverlapEvent(struct FAttackCollisionEventInfo* Info, class FName damageCollisionId, bool doDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionBase", "OnComponentExecuteOverlapEvent");

	Params::AttackCollisionBase_OnComponentExecuteOverlapEvent Parms{};

	Parms.damageCollisionId = damageCollisionId;
	Parms.doDamage = doDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function DarwinGame.AttackCollisionBase.Release
// (Native, Protected)

void AAttackCollisionBase::Release()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionBase", "Release");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttackCollisionBase.Reset
// (Native, Event, Protected, BlueprintEvent)

void AAttackCollisionBase::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackCollisionBase", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ProjectileMagicBase.ReturnBulletEffect
// (Final, Native, Protected, BlueprintCallable)

void AProjectileMagicBase::ReturnBulletEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileMagicBase", "ReturnBulletEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ProjectileMagicBase.SpawnBulletEffect
// (Final, Native, Protected, BlueprintCallable)

void AProjectileMagicBase::SpawnBulletEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileMagicBase", "SpawnBulletEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MissileMagicBase.OnHit
// (Final, Native, Public, BlueprintCallable)

void AMissileMagicBase::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileMagicBase", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MissileMagicBase.OnLaunch
// (Final, Native, Public, BlueprintCallable)

void AMissileMagicBase::OnLaunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileMagicBase", "OnLaunch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TreasureFigureBase.EnableUIMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFigureType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    pedestal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Crystal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureFigureBase::EnableUIMode(EFigureType Type, bool pedestal, bool Crystal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureFigureBase", "EnableUIMode");

	Params::TreasureFigureBase_EnableUIMode Parms{};

	Parms.Type = Type;
	Parms.pedestal = pedestal;
	Parms.Crystal = Crystal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BaseAreaBattleFunctionLibrary.IsBaseAreaBattleEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAreaBattleFunctionLibrary::IsBaseAreaBattleEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseAreaBattleFunctionLibrary", "IsBaseAreaBattleEvent");

	Params::BaseAreaBattleFunctionLibrary_IsBaseAreaBattleEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BaseAreaBattleFunctionLibrary.IsOccurringBaseAreaBattle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    isCheckEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAreaBattleFunctionLibrary::IsOccurringBaseAreaBattle(bool isCheckEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseAreaBattleFunctionLibrary", "IsOccurringBaseAreaBattle");

	Params::BaseAreaBattleFunctionLibrary_IsOccurringBaseAreaBattle Parms{};

	Parms.isCheckEvent = isCheckEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DoorObjectBase.AutoCloseDoor
// (Native, Protected)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoorObjectBase::AutoCloseDoor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorObjectBase", "AutoCloseDoor");

	Params::DoorObjectBase_AutoCloseDoor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DoorObjectBase.PlayClose
// (Native, Protected, BlueprintCallable)

void ADoorObjectBase::PlayClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorObjectBase", "PlayClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DoorObjectBase.PlayOpen
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoorObjectBase::PlayOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorObjectBase", "PlayOpen");

	Params::DoorObjectBase_PlayOpen Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DoorObjectBase.SetClose
// (Native, Protected, BlueprintCallable)

void ADoorObjectBase::SetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorObjectBase", "SetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DoorObjectBase.SetOpen
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoorObjectBase::SetOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorObjectBase", "SetOpen");

	Params::DoorObjectBase_SetOpen Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DoorObjectBase.GetObjectDoorComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADoorObjectBase::GetObjectDoorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorObjectBase", "GetObjectDoorComponent");

	Params::DoorObjectBase_GetObjectDoorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BasicDoor.ReceivePlayClose
// (Event, Protected, BlueprintEvent)

void ABasicDoor::ReceivePlayClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicDoor", "ReceivePlayClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.BasicDoor.ReceivePlayOpen
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasicDoor::ReceivePlayOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicDoor", "ReceivePlayOpen");

	Params::BasicDoor_ReceivePlayOpen Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.BasicDoor.ReceiveSetClose
// (Event, Protected, BlueprintEvent)

void ABasicDoor::ReceiveSetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicDoor", "ReceiveSetClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.BasicDoor.ReceiveSetOpen
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABasicDoor::ReceiveSetOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasicDoor", "ReceiveSetOpen");

	Params::BasicDoor_ReceiveSetOpen Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.SoundManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundManager* USoundManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundManager", "GetInstance");

	Params::SoundManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIEstimate_Effect.EndFlash
// (Final, Native, Private)

void UUIEstimate_Effect::EndFlash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_Effect", "EndFlash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICorrection_01.SlideInEnd
// (Final, Native, Protected)

void UUICorrection_01::SlideInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICorrection_01", "SlideInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataTips.AddOpenTips
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataTips::AddOpenTips(const class FName& TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "AddOpenTips");

	Params::GameDataTips_AddOpenTips Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataTips.AddPopupTips
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataTips::AddPopupTips(const class FName& TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "AddPopupTips");

	Params::GameDataTips_AddPopupTips Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataTips.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataTips*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataTips* UGameDataTips::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "Clone");

	Params::GameDataTips_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataTips.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataTips*                    game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataTips::Overwrite(class UGameDataTips* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "Overwrite");

	Params::GameDataTips_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataTips.ShowTips
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataTips::ShowTips(const class FName& TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "ShowTips");

	Params::GameDataTips_ShowTips Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataTips.IsOpenTips
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataTips::IsOpenTips(const class FName& TipsID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "IsOpenTips");

	Params::GameDataTips_IsOpenTips Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataTips.IsOpenTipsNew
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataTips::IsOpenTipsNew(const class FName& TipsID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "IsOpenTipsNew");

	Params::GameDataTips_IsOpenTipsNew Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataTips.IsPopupedTips
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataTips::IsPopupedTips(const class FName& TipsID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTips", "IsPopupedTips");

	Params::GameDataTips_IsPopupedTips Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleInformation.AddAttackTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleInformation::AddAttackTarget(class AGPACharacter* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleInformation", "AddAttackTarget");

	Params::BattleInformation_AddAttackTarget Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BattleInformation.GetAttackTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* UBattleInformation::GetAttackTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleInformation", "GetAttackTarget");

	Params::BattleInformation_GetAttackTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleInformation.SetOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    registerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleInformation::SetOwner(class AGPACharacter* Owner, EMonsterRegisterType registerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleInformation", "SetOwner");

	Params::BattleInformation_SetOwner Parms{};

	Parms.Owner = Owner;
	Parms.registerType = registerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateActionCastTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateActionCastTime(class FName actionDetailID, const struct FST_TempCharaDataForDamageCalc& Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateActionCastTime");

	Params::BattleBlueprintFunctionLibrary_CalculateActionCastTime Parms{};

	Parms.actionDetailID = actionDetailID;
	Parms.Source = std::move(Source);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateBreathDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateBreathDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateBreathDamage");

	Params::BattleBlueprintFunctionLibrary_CalculateBreathDamage Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateDamageCorrectValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateDamageCorrectValue(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateDamageCorrectValue");

	Params::BattleBlueprintFunctionLibrary_CalculateDamageCorrectValue Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateDamageCorrectValueWithountActionCorrect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateDamageCorrectValueWithountActionCorrect(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateDamageCorrectValueWithountActionCorrect");

	Params::BattleBlueprintFunctionLibrary_CalculateDamageCorrectValueWithountActionCorrect Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateDamageRevision
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FST_AttackData                   AttackData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateDamageRevision(const struct FST_AttackData& AttackData, const struct FST_TempCharaDataForDamageCalc& Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateDamageRevision");

	Params::BattleBlueprintFunctionLibrary_CalculateDamageRevision Parms{};

	Parms.AttackData = std::move(AttackData);
	Parms.Source = std::move(Source);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateDropMoney
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MonsterParamID                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattleBlueprintFunctionLibrary::CalculateDropMoney(const class FName& MonsterParamID, const int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateDropMoney");

	Params::BattleBlueprintFunctionLibrary_CalculateDropMoney Parms{};

	Parms.MonsterParamID = MonsterParamID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateDropRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MonsterParamID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBattleBlueprintFunctionLibrary::CalculateDropRate(class FName MonsterParamID, class AGPACharacter* InstigatorCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateDropRate");

	Params::BattleBlueprintFunctionLibrary_CalculateDropRate Parms{};

	Parms.MonsterParamID = MonsterParamID;
	Parms.InstigatorCharacter = InstigatorCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateEffectTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateEffectTime(class FName ID, int32 Level, const struct FST_TempCharaDataForDamageCalc& Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateEffectTime");

	Params::BattleBlueprintFunctionLibrary_CalculateEffectTime Parms{};

	Parms.ID = ID;
	Parms.Level = Level;
	Parms.Source = std::move(Source);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateMagicalBulletDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateMagicalBulletDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateMagicalBulletDamage");

	Params::BattleBlueprintFunctionLibrary_CalculateMagicalBulletDamage Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateMagicalDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Rampage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateMagicalDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target, bool Rampage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateMagicalDamage");

	Params::BattleBlueprintFunctionLibrary_CalculateMagicalDamage Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);
	Parms.Rampage = Rampage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateMPCost
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AGPACharacter*                    Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionOverviewID                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateMPCost(class AGPACharacter* Instigator, const class FName& ActionOverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateMPCost");

	Params::BattleBlueprintFunctionLibrary_CalculateMPCost Parms{};

	Parms.Instigator = Instigator;
	Parms.ActionOverviewID = ActionOverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculatePhysicalBulletDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculatePhysicalBulletDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculatePhysicalBulletDamage");

	Params::BattleBlueprintFunctionLibrary_CalculatePhysicalBulletDamage Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculatePhysicalDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAttackHitResultStruct           AttackResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsCritical                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculatePhysicalDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target, const struct FAttackHitResultStruct& AttackResult, bool IsCritical)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculatePhysicalDamage");

	Params::BattleBlueprintFunctionLibrary_CalculatePhysicalDamage Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);
	Parms.AttackResult = std::move(AttackResult);
	Parms.IsCritical = IsCritical;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateSkillChainTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateSkillChainTime(const struct FST_TempCharaDataForDamageCalc& Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateSkillChainTime");

	Params::BattleBlueprintFunctionLibrary_CalculateSkillChainTime Parms{};

	Parms.Source = std::move(Source);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateSkillDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateSkillDamage(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateSkillDamage");

	Params::BattleBlueprintFunctionLibrary_CalculateSkillDamage Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.CalculateTakenDamageRevision
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FST_AttackData                   AttackData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBattleBlueprintFunctionLibrary::CalculateTakenDamageRevision(const struct FST_AttackData& AttackData, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "CalculateTakenDamageRevision");

	Params::BattleBlueprintFunctionLibrary_CalculateTakenDamageRevision Parms{};

	Parms.AttackData = std::move(AttackData);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.GainExp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Exp                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleBlueprintFunctionLibrary::GainExp(const int32 Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "GainExp");

	Params::BattleBlueprintFunctionLibrary_GainExp Parms{};

	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.GetBlownVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FActionResult                    ActionResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bToBack                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBattleBlueprintFunctionLibrary::GetBlownVelocity(const struct FActionResult& ActionResult, class AGPACharacter* Target, bool bToBack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "GetBlownVelocity");

	Params::BattleBlueprintFunctionLibrary_GetBlownVelocity Parms{};

	Parms.ActionResult = std::move(ActionResult);
	Parms.Target = Target;
	Parms.bToBack = bToBack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.IsTargetOfAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleBlueprintFunctionLibrary::IsTargetOfAction(class FName actionDetailID, class AActor* Source, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "IsTargetOfAction");

	Params::BattleBlueprintFunctionLibrary_IsTargetOfAction Parms{};

	Parms.actionDetailID = actionDetailID;
	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.IsTargetOfActionAlly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleBlueprintFunctionLibrary::IsTargetOfActionAlly(class FName actionDetailID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "IsTargetOfActionAlly");

	Params::BattleBlueprintFunctionLibrary_IsTargetOfActionAlly Parms{};

	Parms.actionDetailID = actionDetailID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.JudgeWhetherAttackIsBlow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ActionID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleBlueprintFunctionLibrary::JudgeWhetherAttackIsBlow(const class FName ActionID, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "JudgeWhetherAttackIsBlow");

	Params::BattleBlueprintFunctionLibrary_JudgeWhetherAttackIsBlow Parms{};

	Parms.ActionID = ActionID;
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.JudgeWhetherAttackIsRampage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FST_AttackData                   AttackData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_TempCharaDataForDamageCalc   Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleBlueprintFunctionLibrary::JudgeWhetherAttackIsRampage(const struct FST_AttackData& AttackData, const struct FST_TempCharaDataForDamageCalc& Source, const struct FST_TempCharaDataForDamageCalc& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "JudgeWhetherAttackIsRampage");

	Params::BattleBlueprintFunctionLibrary_JudgeWhetherAttackIsRampage Parms{};

	Parms.AttackData = std::move(AttackData);
	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.JudgeWhetherEvasion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGuardType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGuardType UBattleBlueprintFunctionLibrary::JudgeWhetherEvasion(class FName actionDetailID, class AGPACharacter* Source, class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "JudgeWhetherEvasion");

	Params::BattleBlueprintFunctionLibrary_JudgeWhetherEvasion Parms{};

	Parms.actionDetailID = actionDetailID;
	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleBlueprintFunctionLibrary.LotteryGetUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleBlueprintFunctionLibrary::LotteryGetUp(class AGPACharacter* Instigator, class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattleBlueprintFunctionLibrary", "LotteryGetUp");

	Params::BattleBlueprintFunctionLibrary_LotteryGetUp Parms{};

	Parms.Instigator = Instigator;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TreasureMapObjectBase.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Param                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureMapObjectBase::Initialize(const class FName Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureMapObjectBase", "Initialize");

	Params::TreasureMapObjectBase_Initialize Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptBase.Init
// (Final, Native, Protected, BlueprintCallable)

void AGameScriptBase::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptBase", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkMenuBase.ExecuteLinkAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULinkMenuBase::ExecuteLinkAction(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkMenuBase", "ExecuteLinkAction");

	Params::LinkMenuBase_ExecuteLinkAction Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.LinkMenuBase.IsExecutable
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULinkMenuBase::IsExecutable(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkMenuBase", "IsExecutable");

	Params::LinkMenuBase_IsExecutable Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.LinkMenuBase.StartReacstTimer
// (Final, Native, Protected, BlueprintCallable)

void ULinkMenuBase::StartReacstTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkMenuBase", "StartReacstTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkMenuBase.GetLinkWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIField_IconLink*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_IconLink* ULinkMenuBase::GetLinkWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkMenuBase", "GetLinkWidget");

	Params::LinkMenuBase_GetLinkWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.HomingMagiceBase.OnHit
// (Final, Native, Public, BlueprintCallable)

void AHomingMagiceBase::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomingMagiceBase", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DamageExecutionBase.CalculateDamage
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FGameplayEffectContextHandle     ContextHandle                                          (Parm, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Stun                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageExecutionBase::CalculateDamage(const struct FGameplayEffectContextHandle& ContextHandle, class AGPACharacter* Source, class AGPACharacter* Target, float* Damage, float* Stun) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageExecutionBase", "CalculateDamage");

	Params::DamageExecutionBase_CalculateDamage Parms{};

	Parms.ContextHandle = std::move(ContextHandle);
	Parms.Source = Source;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Damage != nullptr)
		*Damage = Parms.Damage;

	if (Stun != nullptr)
		*Stun = Parms.Stun;
}


// Function DarwinGame.UICoinMenu.Refresh
// (Final, Native, Protected, BlueprintCallable)

void UUICoinMenu::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoinMenu", "Refresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventDataBase.CanForcedBattleEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventDataBase::CanForcedBattleEvent(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventDataBase", "CanForcedBattleEvent");

	Params::EventDataBase_CanForcedBattleEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventDataBase.ConvertItemIdToTreasureAreaId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventDataBase::ConvertItemIdToTreasureAreaId(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventDataBase", "ConvertItemIdToTreasureAreaId");

	Params::EventDataBase_ConvertItemIdToTreasureAreaId Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventDataBase.ConvertItemIdToTresureId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventDataBase::ConvertItemIdToTresureId(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventDataBase", "ConvertItemIdToTresureId");

	Params::EventDataBase_ConvertItemIdToTresureId Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AnimNotifyState_ComboInputTime.OnComboInputBegin
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimNotifyState_ComboInputTime::OnComboInputBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_ComboInputTime", "OnComboInputBegin");

	Params::AnimNotifyState_ComboInputTime_OnComboInputBegin Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.TotalDuration = TotalDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.TipsOpener.AddOpenScheduleManualTipsList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTipsOpener::AddOpenScheduleManualTipsList(const class FName& TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "AddOpenScheduleManualTipsList");

	Params::TipsOpener_AddOpenScheduleManualTipsList Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TipsOpener.AddOpenScheduleNewItemGetTipsList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTipsOpener::AddOpenScheduleNewItemGetTipsList(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "AddOpenScheduleNewItemGetTipsList");

	Params::TipsOpener_AddOpenScheduleNewItemGetTipsList Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TipsOpener.ClearDelayedTipsSchedule
// (Final, Native, Public, BlueprintCallable)

void UTipsOpener::ClearDelayedTipsSchedule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "ClearDelayedTipsSchedule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TipsOpener.OpenDelayedTips
// (Final, Native, Private)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTipsOpener::OpenDelayedTips(const class FName TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "OpenDelayedTips");

	Params::TipsOpener_OpenDelayedTips Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TipsOpener.OpenTips
// (Final, Native, Public, BlueprintCallable)

void UTipsOpener::OpenTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "OpenTips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TipsOpener.OpenTipsSpecifyOnly
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTipsOpener::OpenTipsSpecifyOnly(const class FName& TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "OpenTipsSpecifyOnly");

	Params::TipsOpener_OpenTipsSpecifyOnly Parms{};

	Parms.TipsID = TipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TipsOpener.RequestOpenDelayedTips
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTipsOpener::RequestOpenDelayedTips(const class FName& TipsID, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsOpener", "RequestOpenDelayedTips");

	Params::TipsOpener_RequestOpenDelayedTips Parms{};

	Parms.TipsID = TipsID;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICoinStatusArrow.InitWidget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UImage*                           iconImg                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                       upValue                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 statusUp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICoinStatusArrow::InitWidget(class UImage* iconImg, class UTextBlock* upValue, class UWidgetAnimation* statusUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoinStatusArrow", "InitWidget");

	Params::UICoinStatusArrow_InitWidget Parms{};

	Parms.iconImg = iconImg;
	Parms.upValue = upValue;
	Parms.statusUp = statusUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidgetData.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSystemMessage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   defaultCursol                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   cancelPos                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Price                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forceRuby                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidgetData::SetText(const class FString& inString, bool isSystemMessage, int32 defaultCursol, int32 cancelPos, int32 Price, bool forceRuby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidgetData", "SetText");

	Params::TextWidgetData_SetText Parms{};

	Parms.inString = std::move(inString);
	Parms.isSystemMessage = isSystemMessage;
	Parms.defaultCursol = defaultCursol;
	Parms.cancelPos = cancelPos;
	Parms.Price = Price;
	Parms.forceRuby = forceRuby;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.GetBigStarEmissive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEnvironmentObject::GetBigStarEmissive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "GetBigStarEmissive");

	Params::EnvironmentObject_GetBigStarEmissive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentObject.GetEnvironmentType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnvironmentType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnvironmentType AEnvironmentObject::GetEnvironmentType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "GetEnvironmentType");

	Params::EnvironmentObject_GetEnvironmentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentObject.GetFogDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEnvironmentObject::GetFogDensity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "GetFogDensity");

	Params::EnvironmentObject_GetFogDensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentObject.GetSmallStarEmissive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEnvironmentObject::GetSmallStarEmissive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "GetSmallStarEmissive");

	Params::EnvironmentObject_GetSmallStarEmissive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentObject.GetSmallStarReduce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEnvironmentObject::GetSmallStarReduce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "GetSmallStarReduce");

	Params::EnvironmentObject_GetSmallStarReduce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentObject.GetStarOverallEmissive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEnvironmentObject::GetStarOverallEmissive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "GetStarOverallEmissive");

	Params::EnvironmentObject_GetStarOverallEmissive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentObject.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EnvID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::Initialize(const class FName& EnvID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "Initialize");

	Params::EnvironmentObject_Initialize Parms{};

	Parms.EnvID = EnvID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.PreInitialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPostProcessComponent*            PostProcessComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             SkySphere                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             SkyCloud                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               SkyLight                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionalLightComponent*       DirectionalLight                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UExponentialHeightFogComponent*   ExponentialHeightFog                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     SkyMPC                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      SunColorCurve                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     SunRotationCurve                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     DirectionalLightRotationCurve                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::PreInitialize(class UPostProcessComponent* PostProcessComponent, class UStaticMeshComponent* SkySphere, class UStaticMeshComponent* SkyCloud, class USkyLightComponent* SkyLight, class UDirectionalLightComponent* DirectionalLight, class UExponentialHeightFogComponent* ExponentialHeightFog, class UMaterialParameterCollection* SkyMPC, class UCurveFloat* SunColorCurve, class UCurveVector* SunRotationCurve, class UCurveVector* DirectionalLightRotationCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "PreInitialize");

	Params::EnvironmentObject_PreInitialize Parms{};

	Parms.PostProcessComponent = PostProcessComponent;
	Parms.SkySphere = SkySphere;
	Parms.SkyCloud = SkyCloud;
	Parms.SkyLight = SkyLight;
	Parms.DirectionalLight = DirectionalLight;
	Parms.ExponentialHeightFog = ExponentialHeightFog;
	Parms.SkyMPC = SkyMPC;
	Parms.SunColorCurve = SunColorCurve;
	Parms.SunRotationCurve = SunRotationCurve;
	Parms.DirectionalLightRotationCurve = DirectionalLightRotationCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.RefreshSettings
// (Final, Native, Public, BlueprintCallable)

void AEnvironmentObject::RefreshSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "RefreshSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.SetBigStarEmissive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::SetBigStarEmissive(float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "SetBigStarEmissive");

	Params::EnvironmentObject_SetBigStarEmissive Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.SetFogDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Density                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::SetFogDensity(float Density)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "SetFogDensity");

	Params::EnvironmentObject_SetFogDensity Parms{};

	Parms.Density = Density;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.SetPostProcessWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnvironmentPostProcessType             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::SetPostProcessWeight(EEnvironmentPostProcessType Type, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "SetPostProcessWeight");

	Params::EnvironmentObject_SetPostProcessWeight Parms{};

	Parms.Type = Type;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.SetSmallStarEmissive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::SetSmallStarEmissive(float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "SetSmallStarEmissive");

	Params::EnvironmentObject_SetSmallStarEmissive Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.SetSmallStarReduce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::SetSmallStarReduce(float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "SetSmallStarReduce");

	Params::EnvironmentObject_SetSmallStarReduce Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.SetStarOverallEmissive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnvironmentObject::SetStarOverallEmissive(float Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "SetStarOverallEmissive");

	Params::EnvironmentObject_SetStarOverallEmissive Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentObject.Update
// (Final, Native, Public, BlueprintCallable)

void AEnvironmentObject::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentObject", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.SetBoxVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorBase::SetBoxVisible(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "SetBoxVisible");

	Params::EnemySpawnGeneratorBase_SetBoxVisible Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.SetEnableSpawnCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorBase::SetEnableSpawnCheck(const bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "SetEnableSpawnCheck");

	Params::EnemySpawnGeneratorBase_SetEnableSpawnCheck Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.SetGeneratorID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorBase::SetGeneratorID(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "SetGeneratorID");

	Params::EnemySpawnGeneratorBase_SetGeneratorID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.SetIgnoreAreaCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorBase::SetIgnoreAreaCheck(const bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "SetIgnoreAreaCheck");

	Params::EnemySpawnGeneratorBase_SetIgnoreAreaCheck Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.SetOverlapCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorBase::SetOverlapCheck(const bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "SetOverlapCheck");

	Params::EnemySpawnGeneratorBase_SetOverlapCheck Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.SetStopSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorBase::SetStopSpawn(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "SetStopSpawn");

	Params::EnemySpawnGeneratorBase_SetStopSpawn Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorBase.GetChildGeneratorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnemySpawnGeneratorBase::GetChildGeneratorRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "GetChildGeneratorRadius");

	Params::EnemySpawnGeneratorBase_GetChildGeneratorRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.GetGeneratorID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UEnemySpawnGeneratorBase::GetGeneratorID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "GetGeneratorID");

	Params::EnemySpawnGeneratorBase_GetGeneratorID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.HasActiveGenerator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnGeneratorBase::HasActiveGenerator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "HasActiveGenerator");

	Params::EnemySpawnGeneratorBase_HasActiveGenerator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.IsBoxVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnGeneratorBase::IsBoxVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "IsBoxVisible");

	Params::EnemySpawnGeneratorBase_IsBoxVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.IsEnableSpawnCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnGeneratorBase::IsEnableSpawnCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "IsEnableSpawnCheck");

	Params::EnemySpawnGeneratorBase_IsEnableSpawnCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.IsIgnoreAreaCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnGeneratorBase::IsIgnoreAreaCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "IsIgnoreAreaCheck");

	Params::EnemySpawnGeneratorBase_IsIgnoreAreaCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.IsOverlapCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnGeneratorBase::IsOverlapCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "IsOverlapCheck");

	Params::EnemySpawnGeneratorBase_IsOverlapCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorBase.IsStopSpawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnGeneratorBase::IsStopSpawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorBase", "IsStopSpawn");

	Params::EnemySpawnGeneratorBase_IsStopSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorDirect.SetForwardArrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UArrowComponent*                  arrow                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorDirect::SetForwardArrow(class UArrowComponent* arrow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorDirect", "SetForwardArrow");

	Params::EnemySpawnGeneratorDirect_SetForwardArrow Parms{};

	Parms.arrow = arrow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorDirect.SetIgnoreSphere
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USphereComponent*                 Sphere                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorDirect::SetIgnoreSphere(class USphereComponent* Sphere)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorDirect", "SetIgnoreSphere");

	Params::EnemySpawnGeneratorDirect_SetIgnoreSphere Parms{};

	Parms.Sphere = Sphere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorDirect.SetSpawnBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    Box                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorDirect::SetSpawnBox(class UBoxComponent* Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorDirect", "SetSpawnBox");

	Params::EnemySpawnGeneratorDirect_SetSpawnBox Parms{};

	Parms.Box = Box;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorDirect.SetSpawnCylinder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                Cylinder                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorDirect::SetSpawnCylinder(class UCapsuleComponent* Cylinder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorDirect", "SetSpawnCylinder");

	Params::EnemySpawnGeneratorDirect_SetSpawnCylinder Parms{};

	Parms.Cylinder = Cylinder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ArtifactFigureDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UArtifactFigureDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactFigureDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoor.FrontCheck
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFlexibleDoor::FrontCheck(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoor", "FrontCheck");

	Params::FlexibleDoor_FrontCheck Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SimpleOpenAnimInstance.PlayClose
// (Final, Native, Public, BlueprintCallable)

void USimpleOpenAnimInstance::PlayClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "PlayClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleOpenAnimInstance.PlayOpen
// (Final, Native, Public, BlueprintCallable)

void USimpleOpenAnimInstance::PlayOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "PlayOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleOpenAnimInstance.SetClose
// (Final, Native, Public, BlueprintCallable)

void USimpleOpenAnimInstance::SetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "SetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleOpenAnimInstance.SetOpen
// (Final, Native, Public, BlueprintCallable)

void USimpleOpenAnimInstance::SetOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "SetOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleOpenAnimInstance.IsCloseAndPlayAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleOpenAnimInstance::IsCloseAndPlayAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "IsCloseAndPlayAnimation");

	Params::SimpleOpenAnimInstance_IsCloseAndPlayAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SimpleOpenAnimInstance.IsCloseAndSkipAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleOpenAnimInstance::IsCloseAndSkipAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "IsCloseAndSkipAnimation");

	Params::SimpleOpenAnimInstance_IsCloseAndSkipAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SimpleOpenAnimInstance.IsOpenAndPlayAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleOpenAnimInstance::IsOpenAndPlayAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "IsOpenAndPlayAnimation");

	Params::SimpleOpenAnimInstance_IsOpenAndPlayAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SimpleOpenAnimInstance.IsOpenAndSkipAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleOpenAnimInstance::IsOpenAndSkipAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleOpenAnimInstance", "IsOpenAndSkipAnimation");

	Params::SimpleOpenAnimInstance_IsOpenAndSkipAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIComplete.EndCompAnimCallback
// (Final, Native, Private)

void UUIComplete::EndCompAnimCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComplete", "EndCompAnimCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIComplete.EndCompOutAnimCallback
// (Final, Native, Private)

void UUIComplete::EndCompOutAnimCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComplete", "EndCompOutAnimCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIComplete.PlayCompMe
// (Final, Native, Private)

void UUIComplete::PlayCompMe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComplete", "PlayCompMe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIComplete.StartCompAnim
// (Final, Native, Private)

void UUIComplete::StartCompAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIComplete", "StartCompAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EstimateBackPanel.SetPanelMaterial
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEstimateBackPanel::SetPanelMaterial(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateBackPanel", "SetPanelMaterial");

	Params::EstimateBackPanel_SetPanelMaterial Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.FootEffectSystemComponent.PlayFootEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFootEffectRequest               Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFootEffectSystemComponent::PlayFootEffect(const struct FFootEffectRequest& Request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootEffectSystemComponent", "PlayFootEffect");

	Params::FootEffectSystemComponent_PlayFootEffect Parms{};

	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonPointMaze.GetEffectLocation
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADungeonPointMaze::GetEffectLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonPointMaze", "GetEffectLocation");

	Params::DungeonPointMaze_GetEffectLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBattleAIBase.GetCurrentAIPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBattleAIPart                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBattleAIPart UMonsterBattleAIBase::GetCurrentAIPart(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBattleAIBase", "GetCurrentAIPart");

	Params::MonsterBattleAIBase_GetCurrentAIPart Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBattleAIBase.ActionCycleMoveSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::ActionCycleMoveSelect(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "ActionCycleMoveSelect");

	Params::MonsterBattleAIBase_ActionCycleMoveSelect Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAIBase.CheckDistancingToBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::CheckDistancingToBehavior(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "CheckDistancingToBehavior");

	Params::MonsterBattleAIBase_CheckDistancingToBehavior Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAIBase.MoveSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::MoveSelect(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "MoveSelect");

	Params::MonsterBattleAIBase_MoveSelect Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAIBase.PreAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::PreAction(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "PreAction");

	Params::MonsterBattleAIBase_PreAction Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAIBase.SetupActionCycle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::SetupActionCycle(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "SetupActionCycle");

	Params::MonsterBattleAIBase_SetupActionCycle Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAIBase.SetupActionLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::SetupActionLocation(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "SetupActionLocation");

	Params::MonsterBattleAIBase_SetupActionLocation Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAIBase.StartActionCycle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAIBase::StartActionCycle(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAIBase", "StartActionCycle");

	Params::MonsterBattleAIBase_StartActionCycle Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventFlagBlueprintLibrary.IsCrearSelectRangeEventFlag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FlagNameBase                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFlagBlueprintLibrary::IsCrearSelectRangeEventFlag(const class FString& FlagNameBase, int32 StartNum, int32 EndNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFlagBlueprintLibrary", "IsCrearSelectRangeEventFlag");

	Params::EventFlagBlueprintLibrary_IsCrearSelectRangeEventFlag Parms{};

	Parms.FlagNameBase = std::move(FlagNameBase);
	Parms.StartNum = StartNum;
	Parms.EndNum = EndNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFlagBlueprintLibrary.SetSelectRangeEventFlag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FlagNameBase                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFlagBlueprintLibrary::SetSelectRangeEventFlag(const class FString& FlagNameBase, int32 StartNum, int32 EndNum, bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFlagBlueprintLibrary", "SetSelectRangeEventFlag");

	Params::EventFlagBlueprintLibrary_SetSelectRangeEventFlag Parms{};

	Parms.FlagNameBase = std::move(FlagNameBase);
	Parms.StartNum = StartNum;
	Parms.EndNum = EndNum;
	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppDebugMenu.DebugDrawText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   sec                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppDebugMenu::DebugDrawText(const class FString& Text, const float sec, const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppDebugMenu", "DebugDrawText");

	Params::AppDebugMenu_DebugDrawText Parms{};

	Parms.Text = std::move(Text);
	Parms.sec = sec;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppDebugMenu.ResetNextLevel
// (Final, Native, Public, BlueprintCallable)

void UAppDebugMenu::ResetNextLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDebugMenu", "ResetNextLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppDebugMenu.UpdateInput
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamePaused                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKeyInput                        KeyInput                                               (Parm, NativeAccessSpecifierPublic)
// struct FKeyInput                        OutKeyInput                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FEventReply                      Output                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UAppDebugMenu::UpdateInput(const float DeltaTime, const bool bGamePaused, const struct FKeyInput& KeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDebugMenu", "UpdateInput");

	Params::AppDebugMenu_UpdateInput Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.bGamePaused = bGamePaused;
	Parms.KeyInput = std::move(KeyInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKeyInput != nullptr)
		*OutKeyInput = std::move(Parms.OutKeyInput);

	if (Output != nullptr)
		*Output = std::move(Parms.Output);
}


// Function DarwinGame.AppDebugMenu.GetRevision
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppDebugMenu::GetRevision(class FString* Text) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDebugMenu", "GetRevision");

	Params::AppDebugMenu_GetRevision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);
}


// Function DarwinGame.AppDebugMenu.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppDebugMenu::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDebugMenu", "IsActive");

	Params::AppDebugMenu_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppDebugMenu.IsIdle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppDebugMenu::IsIdle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppDebugMenu", "IsIdle");

	Params::AppDebugMenu_IsIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppGameInstance.GetAppGameInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAppGameInstance*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppGameInstance* UAppGameInstance::GetAppGameInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AppGameInstance", "GetAppGameInstance");

	Params::AppGameInstance_GetAppGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppGameInstance.AsyncLoadMainField
// (Event, Protected, BlueprintEvent)

void UAppGameInstance::AsyncLoadMainField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "AsyncLoadMainField");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.AppGameInstance.AsyncLoadMainFieldFinish
// (Final, Native, Protected, BlueprintCallable)

void UAppGameInstance::AsyncLoadMainFieldFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "AsyncLoadMainFieldFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppGameInstance.GetGameSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameSetting*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameSetting* UAppGameInstance::GetGameSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "GetGameSettings");

	Params::AppGameInstance_GetGameSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppGameInstance.GotoDebugLunture
// (Final, Native, Public, BlueprintCallable)

void UAppGameInstance::GotoDebugLunture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "GotoDebugLunture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppGameInstance.GotoGameMain
// (Final, Native, Public, BlueprintCallable)

void UAppGameInstance::GotoGameMain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "GotoGameMain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppGameInstance.HideDebugMenu
// (Event, Public, BlueprintEvent)

void UAppGameInstance::HideDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "HideDebugMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.AppGameInstance.OnCreateDebugMenu
// (Event, Protected, BlueprintEvent)

void UAppGameInstance::OnCreateDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "OnCreateDebugMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.AppGameInstance.ShowDebugMenu
// (Event, Public, BlueprintEvent)

void UAppGameInstance::ShowDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "ShowDebugMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.AppGameInstance.StartGame
// (Final, Native, Public, BlueprintCallable)

void UAppGameInstance::StartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "StartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppGameInstance.UnLoadMainField
// (Event, Protected, BlueprintEvent)

void UAppGameInstance::UnLoadMainField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "UnLoadMainField");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.AppGameInstance.GetDebugMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAppDebugMenu*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppDebugMenu* UAppGameInstance::GetDebugMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "GetDebugMenu");

	Params::AppGameInstance_GetDebugMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppGameInstance.GetGameWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UAppGameInstance::GetGameWorld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "GetGameWorld");

	Params::AppGameInstance_GetGameWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppGameInstance.IsStatedGameInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAppGameInstance::IsStatedGameInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppGameInstance", "IsStatedGameInstance");

	Params::AppGameInstance_IsStatedGameInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.AddInputEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float DeltaTime, bool bGamePaused, const struct FKeyInput& InKeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)>InEvent                                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FirstInterval                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AfterSecondInterval                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppInputComponent::AddInputEvent(const class FString& UniqueId, TDelegate<void(float DeltaTime, bool bGamePaused, const struct FKeyInput& InKeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)> InEvent, int32 InPriority, int32 FirstInterval, int32 AfterSecondInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "AddInputEvent");

	Params::AppInputComponent_AddInputEvent Parms{};

	Parms.UniqueId = std::move(UniqueId);
	Parms.InEvent = InEvent;
	Parms.InPriority = InPriority;
	Parms.FirstInterval = FirstInterval;
	Parms.AfterSecondInterval = AfterSecondInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppInputComponent.AddInputEventWithInterruptedEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float DeltaTime, bool bGamePaused, const struct FKeyInput& InKeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)>InEvent                                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InInterruptedEvent                                     (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FirstInterval                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AfterSecondInterval                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppInputComponent::AddInputEventWithInterruptedEvent(const class FString& UniqueId, TDelegate<void(float DeltaTime, bool bGamePaused, const struct FKeyInput& InKeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)> InEvent, TDelegate<void()> InInterruptedEvent, int32 InPriority, int32 FirstInterval, int32 AfterSecondInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "AddInputEventWithInterruptedEvent");

	Params::AppInputComponent_AddInputEventWithInterruptedEvent Parms{};

	Parms.UniqueId = std::move(UniqueId);
	Parms.InEvent = InEvent;
	Parms.InInterruptedEvent = InInterruptedEvent;
	Parms.InPriority = InPriority;
	Parms.FirstInterval = FirstInterval;
	Parms.AfterSecondInterval = AfterSecondInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppInputComponent.RemoveSingleInputEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAppInputComponent::RemoveSingleInputEvent(const class FString& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "RemoveSingleInputEvent");

	Params::AppInputComponent_RemoveSingleInputEvent Parms{};

	Parms.UniqueId = std::move(UniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppInputComponent.GetInputPriority_DebugMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppInputComponent::GetInputPriority_DebugMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "GetInputPriority_DebugMenu");

	Params::AppInputComponent_GetInputPriority_DebugMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.GetInputPriority_EVENT
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppInputComponent::GetInputPriority_EVENT() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "GetInputPriority_EVENT");

	Params::AppInputComponent_GetInputPriority_EVENT Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.GetInputPriority_Max
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppInputComponent::GetInputPriority_Max() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "GetInputPriority_Max");

	Params::AppInputComponent_GetInputPriority_Max Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.GetInputPriority_Min
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppInputComponent::GetInputPriority_Min() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "GetInputPriority_Min");

	Params::AppInputComponent_GetInputPriority_Min Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.GetInputPriority_PLAYER
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppInputComponent::GetInputPriority_PLAYER() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "GetInputPriority_PLAYER");

	Params::AppInputComponent_GetInputPriority_PLAYER Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.GetInputPriority_UI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAppInputComponent::GetInputPriority_UI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "GetInputPriority_UI");

	Params::AppInputComponent_GetInputPriority_UI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppInputComponent.OutputLogInputEvent
// (Final, Native, Public, BlueprintCallable, Const)

void UAppInputComponent::OutputLogInputEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppInputComponent", "OutputLogInputEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIButtonArrow.off
// (Final, Native, Public, BlueprintCallable)

void UUIButtonArrow::off()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIButtonArrow", "off");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIButtonArrow.on
// (Final, Native, Public, BlueprintCallable)

void UUIButtonArrow::on()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIButtonArrow", "on");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIButtonArrow.Push
// (Final, Native, Public, BlueprintCallable)

void UUIButtonArrow::Push()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIButtonArrow", "Push");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManagerActor.StartDebugEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventSystemManagerActor::StartDebugEvent(const class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManagerActor", "StartDebugEvent");

	Params::EventSystemManagerActor_StartDebugEvent Parms{};

	Parms.EventID = EventID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventSystemManagerActor.GetEventExecuter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEventExecuter*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventExecuter* AEventSystemManagerActor::GetEventExecuter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManagerActor", "GetEventExecuter");

	Params::EventSystemManagerActor_GetEventExecuter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManagerActor.GetEventManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEventManager*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventManager* AEventSystemManagerActor::GetEventManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManagerActor", "GetEventManager");

	Params::EventSystemManagerActor_GetEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManagerActor.GetSequencerContorller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USequencerController*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USequencerController* AEventSystemManagerActor::GetSequencerContorller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManagerActor", "GetSequencerContorller");

	Params::EventSystemManagerActor_GetSequencerContorller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppPlayerController.AdjustInputValueWithFPS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAppPlayerController::AdjustInputValueWithFPS(float Value, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "AdjustInputValueWithFPS");

	Params::AppPlayerController_AdjustInputValueWithFPS Parms{};

	Parms.Value = Value;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppPlayerController.CanOperateCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppPlayerController::CanOperateCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "CanOperateCamera");

	Params::AppPlayerController_CanOperateCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppPlayerController.ClearLeftStickInput
// (Final, Native, Public, BlueprintCallable)

void AAppPlayerController::ClearLeftStickInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "ClearLeftStickInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppPlayerController.ClearRightStickInput
// (Final, Native, Public, BlueprintCallable)

void AAppPlayerController::ClearRightStickInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "ClearRightStickInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppPlayerController.GetAppInputComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAppInputComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAppInputComponent* AAppPlayerController::GetAppInputComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "GetAppInputComponent");

	Params::AppPlayerController_GetAppInputComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppPlayerController.SetInputEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::SetInputEnable(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "SetInputEnable");

	Params::AppPlayerController_SetInputEnable Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppPlayerController.SetKeyRepeatInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FirstInterval                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::SetKeyRepeatInterval(int32 FirstInterval, int32 Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "SetKeyRepeatInterval");

	Params::AppPlayerController_SetKeyRepeatInterval Parms{};

	Parms.FirstInterval = FirstInterval;
	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppPlayerController.UpdateKeyState
// (Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAppPlayerController::UpdateKeyState(EAxisMappingType Type, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "UpdateKeyState");

	Params::AppPlayerController_UpdateKeyState Parms{};

	Parms.Type = Type;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AppPlayerController.GetMouseWheelAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAppPlayerController::GetMouseWheelAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "GetMouseWheelAxis");

	Params::AppPlayerController_GetMouseWheelAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppPlayerController.HasAppWindowFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAppPlayerController::HasAppWindowFocus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "HasAppWindowFocus");

	Params::AppPlayerController_HasAppWindowFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AppPlayerController.OutputLogStackInputComponent
// (Final, Native, Public, BlueprintCallable, Const)

void AAppPlayerController::OutputLogStackInputComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppPlayerController", "OutputLogStackInputComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DataTableManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTableManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTableManager* UDataTableManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableManager", "GetInstance");

	Params::DataTableManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AreaOfEffectBase.FadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAreaOfEffectBase::FadeIn(float StartDelay, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectBase", "FadeIn");

	Params::AreaOfEffectBase_FadeIn Parms{};

	Parms.StartDelay = StartDelay;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaOfEffectBase.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAreaOfEffectBase::FadeOut(float StartDelay, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectBase", "FadeOut");

	Params::AreaOfEffectBase_FadeOut Parms{};

	Parms.StartDelay = StartDelay;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaOfEffectBase.SetHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAreaOfEffectBase::SetHeight(float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectBase", "SetHeight");

	Params::AreaOfEffectBase_SetHeight Parms{};

	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundPatternControlComponent.SetPattern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnvironmentSoundPatternID              ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundPatternControlComponent::SetPattern(EEnvironmentSoundPatternID ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundPatternControlComponent", "SetPattern");

	Params::SoundPatternControlComponent_SetPattern Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaOfEffectControlComponent.LoadTargetAreaInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAreaOfEffectControlComponent::LoadTargetAreaInfo(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectControlComponent", "LoadTargetAreaInfo");

	Params::AreaOfEffectControlComponent_LoadTargetAreaInfo Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaOfEffectControlComponent.TargetAreaPlayEnd
// (Final, Native, Public, BlueprintCallable)

void UAreaOfEffectControlComponent::TargetAreaPlayEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectControlComponent", "TargetAreaPlayEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaOfEffectControlComponent.TargetAreaPlayStart
// (Final, Native, Public, BlueprintCallable)

void UAreaOfEffectControlComponent::TargetAreaPlayStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectControlComponent", "TargetAreaPlayStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AreaOfEffectDecalComponet.OnFadeComplete
// (Final, Native, Public)
// Parameters:
// EAoEDecalState                          FadeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAreaOfEffectDecalComponet::OnFadeComplete(EAoEDecalState FadeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectDecalComponet", "OnFadeComplete");

	Params::AreaOfEffectDecalComponet_OnFadeComplete Parms{};

	Parms.FadeType = FadeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.ChangeAbnormalState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NextAbnormalStateTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::ChangeAbnormalState(const struct FGameplayTag& NextAbnormalStateTag, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "ChangeAbnormalState");

	Params::StateComponent_ChangeAbnormalState Parms{};

	Parms.NextAbnormalStateTag = std::move(NextAbnormalStateTag);
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.ChangeActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NextActionStateTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::ChangeActionState(const struct FGameplayTag& NextActionStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "ChangeActionState");

	Params::StateComponent_ChangeActionState Parms{};

	Parms.NextActionStateTag = std::move(NextActionStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.ChangeActionStateWithResult
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NextActionStateTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionResult                    ActionResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UStateComponent::ChangeActionStateWithResult(const struct FGameplayTag& NextActionStateTag, const struct FActionResult& ActionResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "ChangeActionStateWithResult");

	Params::StateComponent_ChangeActionStateWithResult Parms{};

	Parms.NextActionStateTag = std::move(NextActionStateTag);
	Parms.ActionResult = std::move(ActionResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.ChangeEventState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NextEventStateTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::ChangeEventState(const struct FGameplayTag& NextEventStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "ChangeEventState");

	Params::StateComponent_ChangeEventState Parms{};

	Parms.NextEventStateTag = std::move(NextEventStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.ChangeMoveState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NextMoveStateTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::ChangeMoveState(const struct FGameplayTag& NextMoveStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "ChangeMoveState");

	Params::StateComponent_ChangeMoveState Parms{};

	Parms.NextMoveStateTag = std::move(NextMoveStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginKindID                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::Initialize(const class FName OriginKindID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "Initialize");

	Params::StateComponent_Initialize Parms{};

	Parms.OriginKindID = OriginKindID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.Move
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::Move(const struct FVector& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "Move");

	Params::StateComponent_Move Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.ResetState
// (Final, Native, Public, BlueprintCallable)

void UStateComponent::ResetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "ResetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.SetEnableInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::SetEnableInput(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "SetEnableInput");

	Params::StateComponent_SetEnableInput Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.TakeAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ActionTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateComponent::TakeAction(const struct FGameplayTag& ActionTag, bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "TakeAction");

	Params::StateComponent_TakeAction Parms{};

	Parms.ActionTag = std::move(ActionTag);
	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StateComponent.GetActionStateList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<struct FGameplayTag, class UActionStateBase*>ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, class UActionStateBase*> UStateComponent::GetActionStateList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "GetActionStateList");

	Params::StateComponent_GetActionStateList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateComponent.GetCurrentActionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UActionStateBase*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionStateBase* UStateComponent::GetCurrentActionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "GetCurrentActionState");

	Params::StateComponent_GetCurrentActionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateComponent.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStateBase*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStateBase* UStateComponent::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "GetCurrentState");

	Params::StateComponent_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StateComponent.GetMoveStateList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<struct FGameplayTag, class UStateBase*>ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, class UStateBase*> UStateComponent::GetMoveStateList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateComponent", "GetMoveStateList");

	Params::StateComponent_GetMoveStateList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AreaOfEffectManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAreaOfEffectManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAreaOfEffectManager* UAreaOfEffectManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AreaOfEffectManager", "GetInstance");

	Params::AreaOfEffectManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AreaOfEffectManager.LoadSectorAoEMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESectorAoEAngle                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UAreaOfEffectManager::LoadSectorAoEMaterial(ESectorAoEAngle Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectManager", "LoadSectorAoEMaterial");

	Params::AreaOfEffectManager_LoadSectorAoEMaterial Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AreaOfEffectManager.SpawnRectangleAreaOfEffect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DecalHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLoc                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ARectangleAreaOfEffect*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARectangleAreaOfEffect* UAreaOfEffectManager::SpawnRectangleAreaOfEffect(const struct FVector2D& Size, float DecalHeight, const struct FVector& WorldLoc, const struct FRotator& WorldRot, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectManager", "SpawnRectangleAreaOfEffect");

	Params::AreaOfEffectManager_SpawnRectangleAreaOfEffect Parms{};

	Parms.Size = std::move(Size);
	Parms.DecalHeight = DecalHeight;
	Parms.WorldLoc = std::move(WorldLoc);
	Parms.WorldRot = std::move(WorldRot);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AreaOfEffectManager.SpawnSectorAreaOfEffect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DecalHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESectorAoEAngle                         AngleType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLoc                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASectorAreaOfEffect*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASectorAreaOfEffect* UAreaOfEffectManager::SpawnSectorAreaOfEffect(float Radius, float DecalHeight, ESectorAoEAngle AngleType, const struct FVector& WorldLoc, const struct FRotator& WorldRot, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaOfEffectManager", "SpawnSectorAreaOfEffect");

	Params::AreaOfEffectManager_SpawnSectorAreaOfEffect Parms{};

	Parms.Radius = Radius;
	Parms.DecalHeight = DecalHeight;
	Parms.AngleType = AngleType;
	Parms.WorldLoc = std::move(WorldLoc);
	Parms.WorldRot = std::move(WorldRot);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.ETextDataType_Fukidasi
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::ETextDataType_Fukidasi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextManager", "ETextDataType_Fukidasi");

	Params::TextManager_ETextDataType_Fukidasi Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.ETextDataType_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::ETextDataType_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextManager", "ETextDataType_None");

	Params::TextManager_ETextDataType_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.ETextDataType_Reference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::ETextDataType_Reference()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextManager", "ETextDataType_Reference");

	Params::TextManager_ETextDataType_Reference Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.ETextDataType_Serifu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::ETextDataType_Serifu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextManager", "ETextDataType_Serifu");

	Params::TextManager_ETextDataType_Serifu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.ETextDataType_SystemMessage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::ETextDataType_SystemMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextManager", "ETextDataType_SystemMessage");

	Params::TextManager_ETextDataType_SystemMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTextManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextManager* UTextManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextManager", "GetInstance");

	Params::TextManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.getNPCList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UTextManager::getNPCList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "getNPCList");

	Params::TextManager_getNPCList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.SetLanguageSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextLanguage                           newSetting                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextManager::SetLanguageSetting(const ETextLanguage newSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "SetLanguageSetting");

	Params::TextManager_SetLanguageSetting Parms{};

	Parms.newSetting = newSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextManager.GetColorTagTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UTextManager::GetColorTagTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetColorTagTable");

	Params::TextManager_GetColorTagTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetEventPairReplaceText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UTextManager::GetEventPairReplaceText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetEventPairReplaceText");

	Params::TextManager_GetEventPairReplaceText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetEventReplaceText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UTextManager::GetEventReplaceText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetEventReplaceText");

	Params::TextManager_GetEventReplaceText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetFriendAppearanceID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::GetFriendAppearanceID(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetFriendAppearanceID");

	Params::TextManager_GetFriendAppearanceID Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetLanguageSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ETextLanguage                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ETextLanguage UTextManager::GetLanguageSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetLanguageSetting");

	Params::TextManager_GetLanguageSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetNpcAppearanceID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextManager::GetNpcAppearanceID(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcAppearanceID");

	Params::TextManager_GetNpcAppearanceID Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetNpcDisplayName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextManager::GetNpcDisplayName(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcDisplayName");

	Params::TextManager_GetNpcDisplayName Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetNpcDisplayNameAndCheck
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DisplayName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UTextManager::GetNpcDisplayNameAndCheck(const class FName& NpcID, class FString* DisplayName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcDisplayNameAndCheck");

	Params::TextManager_GetNpcDisplayNameAndCheck Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DisplayName != nullptr)
		*DisplayName = std::move(Parms.DisplayName);

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetNpcInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNPCInfoData                     NpcInfo                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UTextManager::GetNpcInfo(const class FName& NpcID, struct FNPCInfoData* NpcInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcInfo");

	Params::TextManager_GetNpcInfo Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NpcInfo != nullptr)
		*NpcInfo = std::move(Parms.NpcInfo);

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetNpcNickName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NickName1                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NickName2                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextManager::GetNpcNickName(const class FName& NpcID, class FString* NickName1, class FString* NickName2) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcNickName");

	Params::TextManager_GetNpcNickName Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NickName1 != nullptr)
		*NickName1 = std::move(Parms.NickName1);

	if (NickName2 != nullptr)
		*NickName2 = std::move(Parms.NickName2);
}


// Function DarwinGame.TextManager.GetNpcPartTalkerType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UTextManager::GetNpcPartTalkerType(const class FName NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcPartTalkerType");

	Params::TextManager_GetNpcPartTalkerType Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetNpcSeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ENpcSeType                        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const ENpcSeType UTextManager::GetNpcSeType(const class FName NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetNpcSeType");

	Params::TextManager_GetNpcSeType Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetStampTagTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UTextManager::GetStampTagTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetStampTagTable");

	Params::TextManager_GetStampTagTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetTextByTableName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           TableName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextManager::GetTextByTableName(const class FString& TableName, const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetTextByTableName");

	Params::TextManager_GetTextByTableName Parms{};

	Parms.TableName = std::move(TableName);
	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetTextCS
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextManager::GetTextCS(const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetTextCS");

	Params::TextManager_GetTextCS Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetTextFukidasi
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextManager::GetTextFukidasi(const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetTextFukidasi");

	Params::TextManager_GetTextFukidasi Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetTextIE
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextManager::GetTextIE(const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetTextIE");

	Params::TextManager_GetTextIE Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetTextInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTextInfoWorkData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTextInfoWorkData UTextManager::GetTextInfo(const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetTextInfo");

	Params::TextManager_GetTextInfo Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.GetTextSIE
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextManager::GetTextSIE(const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "GetTextSIE");

	Params::TextManager_GetTextSIE Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextManager.IsTextInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextManager::IsTextInfo(const class FName& TextID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextManager", "IsTextInfo");

	Params::TextManager_IsTextInfo Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterEcologicalAI.CalcWaitActionSecond
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMonsterEcologicalAI::CalcWaitActionSecond(class AMonster* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "CalcWaitActionSecond");

	Params::MonsterEcologicalAI_CalcWaitActionSecond Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterEcologicalAI.ClearRunningEcologyMontageID
// (Final, Native, Public, BlueprintCallable)

void UMonsterEcologicalAI::ClearRunningEcologyMontageID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "ClearRunningEcologyMontageID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterEcologicalAI.PopRunningEcologyMontageID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMonsterEcologicalAI::PopRunningEcologyMontageID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "PopRunningEcologyMontageID");

	Params::MonsterEcologicalAI_PopRunningEcologyMontageID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterEcologicalAI.PushRunningEcologyMontageID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterEcologicalAI::PushRunningEcologyMontageID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "PushRunningEcologyMontageID");

	Params::MonsterEcologicalAI_PushRunningEcologyMontageID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterEcologicalAI.SetRunningEcologyMontageID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterEcologicalAI::SetRunningEcologyMontageID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "SetRunningEcologyMontageID");

	Params::MonsterEcologicalAI_SetRunningEcologyMontageID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterEcologicalAI.GetRunningEcologyMontageID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UMonsterEcologicalAI::GetRunningEcologyMontageID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "GetRunningEcologyMontageID");

	Params::MonsterEcologicalAI_GetRunningEcologyMontageID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterEcologicalAI.IsRunningEcologyMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterEcologicalAI::IsRunningEcologyMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterEcologicalAI", "IsRunningEcologyMontage");

	Params::MonsterEcologicalAI_IsRunningEcologyMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorFix.SetSpawnBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    Box                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorFix::SetSpawnBox(class UBoxComponent* Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorFix", "SetSpawnBox");

	Params::EnemySpawnGeneratorFix_SetSpawnBox Parms{};

	Parms.Box = Box;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ArtifactFunctionLibrary.GetCarryingArtifactsNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UArtifactFunctionLibrary::GetCarryingArtifactsNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ArtifactFunctionLibrary", "GetCarryingArtifactsNum");

	Params::ArtifactFunctionLibrary_GetCarryingArtifactsNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorRandom.SetSpawnBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    Box                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorRandom::SetSpawnBox(class UBoxComponent* Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorRandom", "SetSpawnBox");

	Params::EnemySpawnGeneratorRandom_SetSpawnBox Parms{};

	Parms.Box = Box;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectSpline.GetSplineComponent
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* AFieldObjectSpline::GetSplineComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectSpline", "GetSplineComponent");

	Params::FieldObjectSpline_GetSplineComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.ArtifactManager.DisableArtifactPointEffect
// (Final, Native, Public, BlueprintCallable)

void UArtifactManager::DisableArtifactPointEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactManager", "DisableArtifactPointEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ArtifactManager.EnableArtifactPointEffect
// (Final, Native, Public, BlueprintCallable)

void UArtifactManager::EnableArtifactPointEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactManager", "EnableArtifactPointEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ArtifactPointDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UArtifactPointDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArtifactPointDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBaseBattle_Logo_00.EndCloseAnimation
// (Final, Native, Protected)

void UUIBaseBattle_Logo_00::EndCloseAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBaseBattle_Logo_00", "EndCloseAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBaseBattle_Logo_00.EndOpenAnimation
// (Final, Native, Protected)

void UUIBaseBattle_Logo_00::EndOpenAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBaseBattle_Logo_00", "EndOpenAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBaseBattle_Logo_00.EndWaitAnimation
// (Final, Native, Protected)

void UUIBaseBattle_Logo_00::EndWaitAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBaseBattle_Logo_00", "EndWaitAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBaseBattle_Logo_00.SetBaseBattleType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBaseBattleType                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isEnableCloseAnimation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIBaseBattle_Logo_00::SetBaseBattleType(EBaseBattleType Type, bool isEnableCloseAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBaseBattle_Logo_00", "SetBaseBattleType");

	Params::UIBaseBattle_Logo_00_SetBaseBattleType Parms{};

	Parms.Type = Type;
	Parms.isEnableCloseAnimation = isEnableCloseAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttachObjectBase.GetDitheringComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDitheringComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDitheringComponent* AAttachObjectBase::GetDitheringComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachObjectBase", "GetDitheringComponent");

	Params::AttachObjectBase_GetDitheringComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttachObjectBase.GetSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AAttachObjectBase::GetSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachObjectBase", "GetSkeletalMesh");

	Params::AttachObjectBase_GetSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttachObjectBase.GetStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* AAttachObjectBase::GetStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachObjectBase", "GetStaticMesh");

	Params::AttachObjectBase_GetStaticMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OutbreakQuestGimmickBase.BeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOutbreakQuestGimmickBase::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutbreakQuestGimmickBase", "BeginOverlap");

	Params::OutbreakQuestGimmickBase_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.OutbreakQuestGimmickBase.EndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOutbreakQuestGimmickBase::EndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutbreakQuestGimmickBase", "EndOverlap");

	Params::OutbreakQuestGimmickBase_EndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttackElementBaseComponent.OnComponentBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAttackElementBaseComponent::OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackElementBaseComponent", "OnComponentBeginOverlap");

	Params::AttackElementBaseComponent_OnComponentBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttributeDataTable.ClampLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAttributeDataTable::ClampLevel(class FName ID, int32 CurrentLevel, int32 AddLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "ClampLevel");

	Params::AttributeDataTable_ClampLevel Parms{};

	Parms.ID = ID;
	Parms.CurrentLevel = CurrentLevel;
	Parms.AddLevel = AddLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetAttributeTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UAttributeDataTable::GetAttributeTag(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetAttributeTag");

	Params::AttributeDataTable_GetAttributeTag Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetBlockOccursionList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutList                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAttributeDataTable::GetBlockOccursionList(class FName AttributeID, TArray<class FName>* OutList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetBlockOccursionList");

	Params::AttributeDataTable_GetBlockOccursionList Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetDurationType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttributeDurationType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAttributeDurationType UAttributeDataTable::GetDurationType(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetDurationType");

	Params::AttributeDataTable_GetDurationType Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetEffectOtherType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttributeOtherType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAttributeOtherType UAttributeDataTable::GetEffectOtherType(const class FName& AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetEffectOtherType");

	Params::AttributeDataTable_GetEffectOtherType Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetEffectParamType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusParamType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusParamType UAttributeDataTable::GetEffectParamType(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetEffectParamType");

	Params::AttributeDataTable_GetEffectParamType Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetEffectType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFeatureSystemType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFeatureSystemType UAttributeDataTable::GetEffectType(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetEffectType");

	Params::AttributeDataTable_GetEffectType Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetEffectValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeDataTable::GetEffectValue(class FName AttributeID, int32 Level, bool IsTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetEffectValue");

	Params::AttributeDataTable_GetEffectValue Parms{};

	Parms.AttributeID = AttributeID;
	Parms.Level = Level;
	Parms.IsTarget = IsTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetExecutionRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAttributeDataTable::GetExecutionRate(class FName AttributeID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetExecutionRate");

	Params::AttributeDataTable_GetExecutionRate Parms{};

	Parms.AttributeID = AttributeID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetInfluenceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInfluenceAttribute                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInfluenceAttribute UAttributeDataTable::GetInfluenceType(class FName AttributeID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetInfluenceType");

	Params::AttributeDataTable_GetInfluenceType Parms{};

	Parms.AttributeID = AttributeID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetOriginalInfluenceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInfluenceAttribute                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInfluenceAttribute UAttributeDataTable::GetOriginalInfluenceType(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetOriginalInfluenceType");

	Params::AttributeDataTable_GetOriginalInfluenceType Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetProcessPolicy
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttributeProcessPolicy                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAttributeProcessPolicy UAttributeDataTable::GetProcessPolicy(const class FName& AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetProcessPolicy");

	Params::AttributeDataTable_GetProcessPolicy Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AttributeDataTable.GetReleasedTagsByDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bTargetIsEnemy                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReleaseTags                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UAttributeDataTable::GetReleasedTagsByDamage(bool bTargetIsEnemy, struct FGameplayTagContainer* ReleaseTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetReleasedTagsByDamage");

	Params::AttributeDataTable_GetReleasedTagsByDamage Parms{};

	Parms.bTargetIsEnemy = bTargetIsEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReleaseTags != nullptr)
		*ReleaseTags = std::move(Parms.ReleaseTags);
}


// Function DarwinGame.AttributeDataTable.GetReleaseTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReleaseTags                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UAttributeDataTable::GetReleaseTags(class FName AttributeID, struct FGameplayTagContainer* ReleaseTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetReleaseTags");

	Params::AttributeDataTable_GetReleaseTags Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReleaseTags != nullptr)
		*ReleaseTags = std::move(Parms.ReleaseTags);
}


// Function DarwinGame.AttributeDataTable.GetRequirementTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            RequirementTags                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UAttributeDataTable::GetRequirementTags(class FName AttributeID, struct FGameplayTagContainer* RequirementTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetRequirementTags");

	Params::AttributeDataTable_GetRequirementTags Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RequirementTags != nullptr)
		*RequirementTags = std::move(Parms.RequirementTags);
}


// Function DarwinGame.AttributeDataTable.GetStatusIconID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAttributeDataTable::GetStatusIconID(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeDataTable", "GetStatusIconID");

	Params::AttributeDataTable_GetStatusIconID Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OriginParameterDataTable.GetAbilityClassList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftClassPtr<class UClass>>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<TSoftClassPtr<class UClass>> UOriginParameterDataTable::GetAbilityClassList(class FName OriginID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OriginParameterDataTable", "GetAbilityClassList");

	Params::OriginParameterDataTable_GetAbilityClassList Parms{};

	Parms.OriginID = OriginID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OriginParameterDataTable.GetActionStateClassMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, TSubclassOf<class UActionStateBase>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, TSubclassOf<class UActionStateBase>> UOriginParameterDataTable::GetActionStateClassMap(class FName OriginID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OriginParameterDataTable", "GetActionStateClassMap");

	Params::OriginParameterDataTable_GetActionStateClassMap Parms{};

	Parms.OriginID = OriginID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OriginParameterDataTable.GetDefaultMoveState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UOriginParameterDataTable::GetDefaultMoveState(class FName OriginID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OriginParameterDataTable", "GetDefaultMoveState");

	Params::OriginParameterDataTable_GetDefaultMoveState Parms{};

	Parms.OriginID = OriginID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OriginParameterDataTable.GetEnableMoveStateTagList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UOriginParameterDataTable::GetEnableMoveStateTagList(class FName OriginID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OriginParameterDataTable", "GetEnableMoveStateTagList");

	Params::OriginParameterDataTable_GetEnableMoveStateTagList Parms{};

	Parms.OriginID = OriginID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OriginParameterDataTable.GetEventStateClassMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, TSubclassOf<class UEventStateBase>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, TSubclassOf<class UEventStateBase>> UOriginParameterDataTable::GetEventStateClassMap(class FName OriginID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OriginParameterDataTable", "GetEventStateClassMap");

	Params::OriginParameterDataTable_GetEventStateClassMap Parms{};

	Parms.OriginID = OriginID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OriginParameterDataTable.GetMoveStateClassMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             OriginID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, TSubclassOf<class UStateBase>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, TSubclassOf<class UStateBase>> UOriginParameterDataTable::GetMoveStateClassMap(class FName OriginID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OriginParameterDataTable", "GetMoveStateClassMap");

	Params::OriginParameterDataTable_GetMoveStateClassMap Parms{};

	Parms.OriginID = OriginID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_WinEnemy.AddStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatusRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "AddStatusIcon");

	Params::UIField_WinEnemy_AddStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;
	Parms.StatusRank = StatusRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.ChangeStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FStateChangeIconData>     OrderList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "ChangeStatusIcon");

	Params::UIField_WinEnemy_ChangeStatusIcon Parms{};

	Parms.OrderList = std::move(OrderList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.DebugSetIsHideFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::DebugSetIsHideFlag(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "DebugSetIsHideFlag");

	Params::UIField_WinEnemy_DebugSetIsHideFlag Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.DeleteAllStatusIcon
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinEnemy::DeleteAllStatusIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "DeleteAllStatusIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.DeleteStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::DeleteStatusIcon(const class FName& StatusParameterID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "DeleteStatusIcon");

	Params::UIField_WinEnemy_DeleteStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.GetSpiritGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUISpirit_Gauge*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUISpirit_Gauge* UUIField_WinEnemy::GetSpiritGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "GetSpiritGauge");

	Params::UIField_WinEnemy_GetSpiritGauge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_WinEnemy.InitData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::InitData(int32 InHP, int32 InMaxHP, int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "InitData");

	Params::UIField_WinEnemy_InitData Parms{};

	Parms.InHP = InHP;
	Parms.InMaxHP = InMaxHP;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.SetHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::SetHP(int32 InHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "SetHP");

	Params::UIField_WinEnemy_SetHP Parms{};

	Parms.InHP = InHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::SetLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "SetLevel");

	Params::UIField_WinEnemy_SetLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.SetMaxHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::SetMaxHP(int32 InMaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "SetMaxHP");

	Params::UIField_WinEnemy_SetMaxHP Parms{};

	Parms.InMaxHP = InMaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinEnemy.SetName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InName                                                 (Parm, NativeAccessSpecifierPublic)

void UUIField_WinEnemy::SetName(const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinEnemy", "SetName");

	Params::UIField_WinEnemy_SetName Parms{};

	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.AttributeFunctionLibrary.K2_IsSeal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttributeProcessPolicy                 Policy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAttributeFunctionLibrary::K2_IsSeal(const class AGPACharacter* Target, EAttributeProcessPolicy Policy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AttributeFunctionLibrary", "K2_IsSeal");

	Params::AttributeFunctionLibrary_K2_IsSeal Parms{};

	Parms.Target = Target;
	Parms.Policy = Policy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BaseAreaBattle.MonserDefeatCallback
// (Final, Native, Private)

void ABaseAreaBattle::MonserDefeatCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAreaBattle", "MonserDefeatCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.OutbreakQuestPointDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UOutbreakQuestPointDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutbreakQuestPointDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BaseAreaBattleMonsterBeginCallbackHolder.MonserCreatedCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     MonsterBase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAreaBattleMonsterBeginCallbackHolder::MonserCreatedCallback(class AMonsterBase* MonsterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAreaBattleMonsterBeginCallbackHolder", "MonserCreatedCallback");

	Params::BaseAreaBattleMonsterBeginCallbackHolder_MonserCreatedCallback Parms{};

	Parms.MonsterBase = MonsterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.GetDebugEventId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FString UEventManager::GetDebugEventId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventManager", "GetDebugEventId");

	Params::EventManager_GetDebugEventId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.SetDebugEventId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SetDebugEventId(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventManager", "SetDebugEventId");

	Params::EventManager_SetDebugEventId Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.AutoSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::AutoSave(const class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "AutoSave");

	Params::EventManager_AutoSave Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.DeleteEventArtifact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::DeleteEventArtifact(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "DeleteEventArtifact");

	Params::EventManager_DeleteEventArtifact Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.EventFinishMove
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::EventFinishMove(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "EventFinishMove");

	Params::EventManager_EventFinishMove Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.ForcedEndEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::ForcedEndEvent(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "ForcedEndEvent");

	Params::EventManager_ForcedEndEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.GetCurrentEventID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventManager::GetCurrentEventID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "GetCurrentEventID");

	Params::EventManager_GetCurrentEventID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.GetEventClearData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_EventClearTableInfo          EventClearData                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventManager::GetEventClearData(class FName EventID, struct FST_EventClearTableInfo* EventClearData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "GetEventClearData");

	Params::EventManager_GetEventClearData Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EventClearData != nullptr)
		*EventClearData = std::move(Parms.EventClearData);

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.GetEventData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_EventData                    EventData                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EQuestState                             QuestState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventManager::GetEventData(class FName EventID, struct FST_EventData* EventData, EQuestState QuestState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "GetEventData");

	Params::EventManager_GetEventData Parms{};

	Parms.EventID = EventID;
	Parms.QuestState = QuestState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EventData != nullptr)
		*EventData = std::move(Parms.EventData);

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.GetReleaseStigmataNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventManager::GetReleaseStigmataNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "GetReleaseStigmataNum");

	Params::EventManager_GetReleaseStigmataNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.IsReleaseStigmataEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventManager::IsReleaseStigmataEvent(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "IsReleaseStigmataEvent");

	Params::EventManager_IsReleaseStigmataEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.OnEventFinished
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::OnEventFinished(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "OnEventFinished");

	Params::EventManager_OnEventFinished Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.PlayEvent
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestState                             QuestState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::PlayEvent(const class FName& EventID, EQuestState QuestState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "PlayEvent");

	Params::EventManager_PlayEvent Parms{};

	Parms.EventID = EventID;
	Parms.QuestState = QuestState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventManager.PlayEventMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::PlayEventMonster(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "PlayEventMonster");

	Params::EventManager_PlayEventMonster Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.PlayEventOfItemFirstAdd
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ItemFirstAdd                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::PlayEventOfItemFirstAdd(const class FName& ItemFirstAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "PlayEventOfItemFirstAdd");

	Params::EventManager_PlayEventOfItemFirstAdd Parms{};

	Parms.ItemFirstAdd = ItemFirstAdd;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventManager.RemoveFriendMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::RemoveFriendMonster(const class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "RemoveFriendMonster");

	Params::EventManager_RemoveFriendMonster Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.RemoveResetEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::RemoveResetEvent(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "RemoveResetEvent");

	Params::EventManager_RemoveResetEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.SetCurrentEventID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SetCurrentEventID(const class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "SetCurrentEventID");

	Params::EventManager_SetCurrentEventID Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.SetEventSender
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEventSender*                     Sender                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SetEventSender(class UEventSender* Sender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "SetEventSender");

	Params::EventManager_SetEventSender Parms{};

	Parms.Sender = Sender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.SetEventSkip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SetEventSkip(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "SetEventSkip");

	Params::EventManager_SetEventSkip Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.SetSendEventActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SetSendEventActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "SetSendEventActor");

	Params::EventManager_SetSendEventActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.SpawnEventArtifact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SpawnEventArtifact(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "SpawnEventArtifact");

	Params::EventManager_SpawnEventArtifact Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.SpawnRequestEventMonster
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::SpawnRequestEventMonster(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "SpawnRequestEventMonster");

	Params::EventManager_SpawnRequestEventMonster Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.UpdateEpisode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEpisodeType                            EpisodeType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::UpdateEpisode(EEpisodeType EpisodeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "UpdateEpisode");

	Params::EventManager_UpdateEpisode Parms{};

	Parms.EpisodeType = EpisodeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.UpdateQuestTargetEnemyUI
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::UpdateQuestTargetEnemyUI(int32 KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "UpdateQuestTargetEnemyUI");

	Params::EventManager_UpdateQuestTargetEnemyUI Parms{};

	Parms.KindId = KindId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventManager.UseEventClearItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::UseEventClearItems(const class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "UseEventClearItems");

	Params::EventManager_UseEventClearItems Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventManager.EventMonsterIsReady
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventManager::EventMonsterIsReady(const class FName& EventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "EventMonsterIsReady");

	Params::EventManager_EventMonsterIsReady Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.EventMonsterIsRequested
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventManager::EventMonsterIsRequested(const class FName& EventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "EventMonsterIsRequested");

	Params::EventManager_EventMonsterIsRequested Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.GetEventSendActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AActor* UEventManager::GetEventSendActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "GetEventSendActor");

	Params::EventManager_GetEventSendActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventManager.GetResistedEventIDLast
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventManager::GetResistedEventIDLast() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "GetResistedEventIDLast");

	Params::EventManager_GetResistedEventIDLast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.AddCoin
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameBelongingsCoin::AddCoin(const struct FST_CoinParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "AddCoin");

	Params::GameBelongingsCoin_AddCoin Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameBelongingsCoin*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameBelongingsCoin* UGameBelongingsCoin::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "Clone");

	Params::GameBelongingsCoin_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.InitCoinMenuSetting
// (Final, Native, Public, BlueprintCallable)

void UGameBelongingsCoin::InitCoinMenuSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "InitCoinMenuSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameBelongingsCoin*              game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsCoin::Overwrite(class UGameBelongingsCoin* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "Overwrite");

	Params::GameBelongingsCoin_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.RemoveCoin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Uid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsCoin::RemoveCoin(int32 Uid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "RemoveCoin");

	Params::GameBelongingsCoin_RemoveCoin Parms{};

	Parms.Uid = Uid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.SetCoinMenuAutoEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECoinAutoEquip                          CoinAutoEquip                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsCoin::SetCoinMenuAutoEquip(ECoinAutoEquip CoinAutoEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "SetCoinMenuAutoEquip");

	Params::GameBelongingsCoin_SetCoinMenuAutoEquip Parms{};

	Parms.CoinAutoEquip = CoinAutoEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.SetCoinMenuFilter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<ECoinFilter>                     CoinFilter                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsCoin::SetCoinMenuFilter(const TArray<ECoinFilter>& CoinFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "SetCoinMenuFilter");

	Params::GameBelongingsCoin_SetCoinMenuFilter Parms{};

	Parms.CoinFilter = std::move(CoinFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.SetCoinMenuSort
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECoinSort                               CoinSort                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsCoin::SetCoinMenuSort(ECoinSort CoinSort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "SetCoinMenuSort");

	Params::GameBelongingsCoin_SetCoinMenuSort Parms{};

	Parms.CoinSort = CoinSort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.SetNew
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Uid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNew                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsCoin::SetNew(int32 Uid, bool IsNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "SetNew");

	Params::GameBelongingsCoin_SetNew Parms{};

	Parms.Uid = Uid;
	Parms.IsNew = IsNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsCoin.GetCapacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameBelongingsCoin::GetCapacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "GetCapacity");

	Params::GameBelongingsCoin_GetCapacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.GetCoin
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Uid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_CoinData                     CoinData                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameBelongingsCoin::GetCoin(int32 Uid, struct FST_CoinData* CoinData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "GetCoin");

	Params::GameBelongingsCoin_GetCoin Parms{};

	Parms.Uid = Uid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CoinData != nullptr)
		*CoinData = std::move(Parms.CoinData);

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.GetCoinAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<int32, struct FST_CoinData>  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<int32, struct FST_CoinData> UGameBelongingsCoin::GetCoinAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "GetCoinAll");

	Params::GameBelongingsCoin_GetCoinAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.GetCoinMenuAutoEquip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECoinAutoEquip                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECoinAutoEquip UGameBelongingsCoin::GetCoinMenuAutoEquip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "GetCoinMenuAutoEquip");

	Params::GameBelongingsCoin_GetCoinMenuAutoEquip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.GetCoinMenuFilter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<ECoinFilter>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TArray<ECoinFilter> UGameBelongingsCoin::GetCoinMenuFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "GetCoinMenuFilter");

	Params::GameBelongingsCoin_GetCoinMenuFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsCoin.GetCoinMenuSort
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECoinSort                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECoinSort UGameBelongingsCoin::GetCoinMenuSort() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsCoin", "GetCoinMenuSort");

	Params::GameBelongingsCoin_GetCoinMenuSort Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnergyMaterialControlComponent.AddEnergyValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnergyMaterialControlComponent::AddEnergyValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyMaterialControlComponent", "AddEnergyValue");

	Params::EnergyMaterialControlComponent_AddEnergyValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnergyMaterialControlComponent.SetEnergyValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnergyMaterialControlComponent::SetEnergyValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyMaterialControlComponent", "SetEnergyValue");

	Params::EnergyMaterialControlComponent_SetEnergyValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnergyMaterialControlComponent.SetRelease
// (Final, Native, Public, BlueprintCallable)

void UEnergyMaterialControlComponent::SetRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyMaterialControlComponent", "SetRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnergyMaterialControlComponent.SetSeal
// (Final, Native, Public, BlueprintCallable)

void UEnergyMaterialControlComponent::SetSeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyMaterialControlComponent", "SetSeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnergyMaterialControlComponent.ToRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnergyMaterialControlComponent::ToRelease(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyMaterialControlComponent", "ToRelease");

	Params::EnergyMaterialControlComponent_ToRelease Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnergyMaterialControlComponent.ToSeal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnergyMaterialControlComponent::ToSeal(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnergyMaterialControlComponent", "ToSeal");

	Params::EnergyMaterialControlComponent_ToSeal Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.ChangePhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEffectProgress                         NextPhase_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::ChangePhase(EEffectProgress NextPhase_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "ChangePhase");

	Params::EffectBase_ChangePhase Parms{};

	Parms.NextPhase_0 = NextPhase_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.ChangePhaseTrail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEffectProgress                         NextPhase_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             soket_A                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             soket_B                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::ChangePhaseTrail(EEffectProgress NextPhase_0, class USceneComponent* Parent, class FName soket_A, class FName soket_B, ETrailWidthMode Mode, float Width)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "ChangePhaseTrail");

	Params::EffectBase_ChangePhaseTrail Parms{};

	Parms.NextPhase_0 = NextPhase_0;
	Parms.Parent = Parent;
	Parms.soket_A = soket_A;
	Parms.soket_B = soket_B;
	Parms.Mode = Mode;
	Parms.Width = Width;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinAttachToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDarwinCoordRule                        scale_rule                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinAttachToActor(class AActor* Parent, class FName socket, EDarwinCoordRule scale_rule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinAttachToActor");

	Params::EffectBase_DarwinAttachToActor Parms{};

	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.scale_rule = scale_rule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinAttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDarwinCoordRule                        scale_rule                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinAttachToComponent(class USceneComponent* Parent, class FName socket, EDarwinCoordRule scale_rule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinAttachToComponent");

	Params::EffectBase_DarwinAttachToComponent Parms{};

	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.scale_rule = scale_rule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetLocation(EDarwinCoordRule Rule, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetLocation");

	Params::EffectBase_DarwinSetLocation Parms{};

	Parms.Rule = Rule;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetLocationAndRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetLocationAndRotator(EDarwinCoordRule Rule, const struct FVector& Location, const struct FRotator& Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetLocationAndRotator");

	Params::EffectBase_DarwinSetLocationAndRotator Parms{};

	Parms.Rule = Rule;
	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetLocationAndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetLocationAndScale(EDarwinCoordRule Rule, const struct FVector& Location, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetLocationAndScale");

	Params::EffectBase_DarwinSetLocationAndScale Parms{};

	Parms.Rule = Rule;
	Parms.Location = std::move(Location);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetRotator(EDarwinCoordRule Rule, const struct FRotator& Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetRotator");

	Params::EffectBase_DarwinSetRotator Parms{};

	Parms.Rule = Rule;
	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetRotatorAndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetRotatorAndScale(EDarwinCoordRule Rule, const struct FRotator& Rotator, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetRotatorAndScale");

	Params::EffectBase_DarwinSetRotatorAndScale Parms{};

	Parms.Rule = Rule;
	Parms.Rotator = std::move(Rotator);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetScale(EDarwinCoordRule Rule, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetScale");

	Params::EffectBase_DarwinSetScale Parms{};

	Parms.Rule = Rule;
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetScaleFromSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           SizeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetScaleFromSize(EDarwinCoordRule Rule, EEffectSizeID SizeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetScaleFromSize");

	Params::EffectBase_DarwinSetScaleFromSize Parms{};

	Parms.Rule = Rule;
	Parms.SizeID = SizeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EDarwinCoordRule                        Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetTransform(EDarwinCoordRule Rule, const struct FVector& Location, const struct FRotator& Rotator, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetTransform");

	Params::EffectBase_DarwinSetTransform Parms{};

	Parms.Rule = Rule;
	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.DarwinSetUsingAbsoluteRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsAbsoluteRotation                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::DarwinSetUsingAbsoluteRotation(const bool IsAbsoluteRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "DarwinSetUsingAbsoluteRotation");

	Params::EffectBase_DarwinSetUsingAbsoluteRotation Parms{};

	Parms.IsAbsoluteRotation = IsAbsoluteRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.NextPhase
// (Final, Native, Public, BlueprintCallable)

void AEffectBase::NextPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "NextPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.NextPhaseTrail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             soket_A                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             soket_B                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::NextPhaseTrail(class USceneComponent* Parent, class FName soket_A, class FName soket_B, ETrailWidthMode Mode, float Width)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "NextPhaseTrail");

	Params::EffectBase_NextPhaseTrail Parms{};

	Parms.Parent = Parent;
	Parms.soket_A = soket_A;
	Parms.soket_B = soket_B;
	Parms.Mode = Mode;
	Parms.Width = Width;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.ParticleDelayPlay
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FTimerHandle                     Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UExtendParticleComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::ParticleDelayPlay(const struct FTimerHandle& Handle, class UExtendParticleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "ParticleDelayPlay");

	Params::EffectBase_ParticleDelayPlay Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.Pause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::Pause(bool isPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "Pause");

	Params::EffectBase_Pause Parms{};

	Parms.isPause = isPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.PauseEmit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::PauseEmit(bool isPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "PauseEmit");

	Params::EffectBase_PauseEmit Parms{};

	Parms.isPause = isPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.Play
// (Final, Native, Public, BlueprintCallable)

void AEffectBase::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.PlaySound
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EffectId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::PlaySound(class FName EffectId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "PlaySound");

	Params::EffectBase_PlaySound Parms{};

	Parms.EffectId = EffectId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.PlayTrail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             soket_A                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             soket_B                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::PlayTrail(class USceneComponent* Parent, class FName soket_A, class FName soket_B, ETrailWidthMode Mode, float Width)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "PlayTrail");

	Params::EffectBase_PlayTrail Parms{};

	Parms.Parent = Parent;
	Parms.soket_A = soket_A;
	Parms.soket_B = soket_B;
	Parms.Mode = Mode;
	Parms.Width = Width;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamSourcePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewSourcePoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamSourcePoint(int32 EmitterIndex, const struct FVector& NewSourcePoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamSourcePoint");

	Params::EffectBase_SetBeamSourcePoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewSourcePoint = std::move(NewSourcePoint);
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamSourcePointAllEmitters
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewSourcePoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamSourcePointAllEmitters(const struct FVector& NewSourcePoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamSourcePointAllEmitters");

	Params::EffectBase_SetBeamSourcePointAllEmitters Parms{};

	Parms.NewSourcePoint = std::move(NewSourcePoint);
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamSourceStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewSourceStrength                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamSourceStrength");

	Params::EffectBase_SetBeamSourceStrength Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewSourceStrength = NewSourceStrength;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamSourceTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTangentPoint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamSourceTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamSourceTangent");

	Params::EffectBase_SetBeamSourceTangent Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTangentPoint = std::move(NewTangentPoint);
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamTargetPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTargetPoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamTargetPoint(int32 EmitterIndex, const struct FVector& NewTargetPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamTargetPoint");

	Params::EffectBase_SetBeamTargetPoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTargetPoint = std::move(NewTargetPoint);
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamTargetPointAllEmitters
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewTargetPoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamTargetPointAllEmitters(const struct FVector& NewTargetPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamTargetPointAllEmitters");

	Params::EffectBase_SetBeamTargetPointAllEmitters Parms{};

	Parms.NewTargetPoint = std::move(NewTargetPoint);
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamTargetStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewTargetStrength                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamTargetStrength");

	Params::EffectBase_SetBeamTargetStrength Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTargetStrength = NewTargetStrength;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.SetBeamTargetTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTangentPoint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectBase::SetBeamTargetTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "SetBeamTargetTangent");

	Params::EffectBase_SetBeamTargetTangent Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTangentPoint = std::move(NewTangentPoint);
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.Stop
// (Final, Native, Public, BlueprintCallable)

void AEffectBase::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.StopEmit
// (Final, Native, Public, BlueprintCallable)

void AEffectBase::StopEmit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "StopEmit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectBase.GetCurrentPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEffectProgress                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEffectProgress AEffectBase::GetCurrentPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "GetCurrentPhase");

	Params::EffectBase_GetCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectBase.GetEffectID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AEffectBase::GetEffectID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "GetEffectID");

	Params::EffectBase_GetEffectID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectBase.GetPhasePlayComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectBase::GetPhasePlayComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "GetPhasePlayComplete");

	Params::EffectBase_GetPhasePlayComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectBase.IsComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEffectBase::IsComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectBase", "IsComplete");

	Params::EffectBase_IsComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UICharAdd_Base.IsPressedDecide
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUICharAdd_Base::IsPressedDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICharAdd_Base", "IsPressedDecide");

	Params::UICharAdd_Base_IsPressedDecide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UICharAdd_Base.SetNpc
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERivalTeamForce                         Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICharAdd_Base::SetNpc(class FName NpcID, ERivalTeamForce Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICharAdd_Base", "SetNpc");

	Params::UICharAdd_Base_SetNpc Parms{};

	Parms.NpcID = NpcID;
	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceDataTable.GetFaceParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EEmoteFaceType                          FaceType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmoteFace                       outFace                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEmoteFaceSetting                outSetting                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmoteFaceDataTable::GetFaceParameter(EEmoteFaceType FaceType, struct FEmoteFace* outFace, struct FEmoteFaceSetting* outSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmoteFaceDataTable", "GetFaceParameter");

	Params::EmoteFaceDataTable_GetFaceParameter Parms{};

	Parms.FaceType = FaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outFace != nullptr)
		*outFace = std::move(Parms.outFace);

	if (outSetting != nullptr)
		*outSetting = std::move(Parms.outSetting);

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldActionAbility.Access
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::Access()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "Access");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.AdjustDigRate
// (Final, Native, Protected)

void UFieldActionAbility::AdjustDigRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "AdjustDigRate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.AdjustRotation
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::AdjustRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "AdjustRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.CancelAccess
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::CancelAccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "CancelAccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.CancelDig
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::CancelDig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "CancelDig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.DestroyAtcingArtifact
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::DestroyAtcingArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "DestroyAtcingArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.DigUp
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::DigUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "DigUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.DirectRotation
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::DirectRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "DirectRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.EndAccess
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::EndAccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "EndAccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.EndDig
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::EndDig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "EndDig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.Give
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::Give()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "Give");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.LookAt
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::LookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "LookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.MoveToTarget
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::MoveToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "MoveToTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.OnPointFilled
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::OnPointFilled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "OnPointFilled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.Pickup
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::Pickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "Pickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.PrepareTurn
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::PrepareTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "PrepareTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.ResetFlagRotation
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::ResetFlagRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "ResetFlagRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.SetTurnAngle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldActionAbility::SetTurnAngle(float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "SetTurnAngle");

	Params::FieldActionAbility_SetTurnAngle Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.StartPull
// (Final, Native, Protected, BlueprintCallable)

void UFieldActionAbility::StartPull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "StartPull");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.StartSevenStoneDirection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ESevenStoneDirectionType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldActionAbility::StartSevenStoneDirection(ESevenStoneDirectionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "StartSevenStoneDirection");

	Params::FieldActionAbility_StartSevenStoneDirection Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldActionAbility.GetParkourData
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FParkour                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FParkour UFieldActionAbility::GetParkourData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "GetParkourData");

	Params::FieldActionAbility_GetParkourData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldActionAbility.GetTurnRotation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UFieldActionAbility::GetTurnRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "GetTurnRotation");

	Params::FieldActionAbility_GetTurnRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldActionAbility.IsDirectRotationAction
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldActionAbility::IsDirectRotationAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "IsDirectRotationAction");

	Params::FieldActionAbility_IsDirectRotationAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldActionAbility.IsRequiredRotationAction
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldActionAbility::IsRequiredRotationAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionAbility", "IsRequiredRotationAction");

	Params::FieldActionAbility_IsRequiredRotationAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleSystemComponent.DeleteAttackCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           OrderId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleSystemComponent::DeleteAttackCollision(const class FString& OrderId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSystemComponent", "DeleteAttackCollision");

	Params::BattleSystemComponent_DeleteAttackCollision Parms{};

	Parms.OrderId = std::move(OrderId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BattleSystemComponent.GenerateShootAttackCollision
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AttackCollisionID                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecSpec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AAttackCollisionBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAttackCollisionBase* UBattleSystemComponent::GenerateShootAttackCollision(class AActor* Target, class FName actionDetailID, const class FString& AttackCollisionID, const struct FActionGameplayEffectContainerSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSystemComponent", "GenerateShootAttackCollision");

	Params::BattleSystemComponent_GenerateShootAttackCollision Parms{};

	Parms.Target = Target;
	Parms.actionDetailID = actionDetailID;
	Parms.AttackCollisionID = std::move(AttackCollisionID);
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BattleSystemComponent.GenerateTouchAttackCollision
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AttackCollisionID                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecSpec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleSystemComponent::GenerateTouchAttackCollision(class AGPACharacter* Target, class FName actionDetailID, const class FString& AttackCollisionID, const struct FActionGameplayEffectContainerSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSystemComponent", "GenerateTouchAttackCollision");

	Params::BattleSystemComponent_GenerateTouchAttackCollision Parms{};

	Parms.Target = Target;
	Parms.actionDetailID = actionDetailID;
	Parms.AttackCollisionID = std::move(AttackCollisionID);
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BattleSystemComponent.GetAttackCollisionId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           OrderId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   outUniqueCollisionID                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattleSystemComponent::GetAttackCollisionId(const class FString& OrderId, int32* outUniqueCollisionID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleSystemComponent", "GetAttackCollisionId");

	Params::BattleSystemComponent_GetAttackCollisionId Parms{};

	Parms.OrderId = std::move(OrderId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outUniqueCollisionID != nullptr)
		*outUniqueCollisionID = Parms.outUniqueCollisionID;

	return Parms.ReturnValue;
}


// Function DarwinGame.BGMSoundMapDataAsset.Reset
// (Final, Native, Public, BlueprintCallable)

void UBGMSoundMapDataAsset::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BGMSoundMapDataAsset", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFieldManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFieldManager* UFieldManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldManager", "GetInstance");

	Params::FieldManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.DestroyRivalTeamFlag
// (Final, Native, Public, BlueprintCallable)

void UFieldManager::DestroyRivalTeamFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "DestroyRivalTeamFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldManager.SpawnRivalTeamFlag
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ERivalTeamForce                         Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UFieldManager::SpawnRivalTeamFlag(ERivalTeamForce Force, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "SpawnRivalTeamFlag");

	Params::FieldManager_SpawnRivalTeamFlag Parms{};

	Parms.Force = Force;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldManager.GetAllyBattleInformation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBattleInformation*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBattleInformation* UFieldManager::GetAllyBattleInformation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetAllyBattleInformation");

	Params::FieldManager_GetAllyBattleInformation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetArtifactManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UArtifactManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtifactManager* UFieldManager::GetArtifactManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetArtifactManager");

	Params::FieldManager_GetArtifactManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetBattleDirector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBattleDirector*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBattleDirector* UFieldManager::GetBattleDirector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetBattleDirector");

	Params::FieldManager_GetBattleDirector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetCollectionPointManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCollectionPointManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCollectionPointManager* UFieldManager::GetCollectionPointManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetCollectionPointManager");

	Params::FieldManager_GetCollectionPointManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetDungeonManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDungeonManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDungeonManager* UFieldManager::GetDungeonManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetDungeonManager");

	Params::FieldManager_GetDungeonManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetEnemyBattleInformation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBattleInformation*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBattleInformation* UFieldManager::GetEnemyBattleInformation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetEnemyBattleInformation");

	Params::FieldManager_GetEnemyBattleInformation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetEnemySpawnManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEnemySpawnManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnemySpawnManager* UFieldManager::GetEnemySpawnManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetEnemySpawnManager");

	Params::FieldManager_GetEnemySpawnManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetEnvironmentManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEnvironmentManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnvironmentManager* UFieldManager::GetEnvironmentManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetEnvironmentManager");

	Params::FieldManager_GetEnvironmentManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetFieldAreaManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFieldAreaManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFieldAreaManager* UFieldManager::GetFieldAreaManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetFieldAreaManager");

	Params::FieldManager_GetFieldAreaManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetFieldObjectManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFieldObjectManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFieldObjectManager* UFieldManager::GetFieldObjectManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetFieldObjectManager");

	Params::FieldManager_GetFieldObjectManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetForcedBattleAreaManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UForcedBattleAreaManager*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForcedBattleAreaManager* UFieldManager::GetForcedBattleAreaManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetForcedBattleAreaManager");

	Params::FieldManager_GetForcedBattleAreaManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetGameScriptManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameScriptManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameScriptManager* UFieldManager::GetGameScriptManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetGameScriptManager");

	Params::FieldManager_GetGameScriptManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetMonsterBTTaskExecuter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMonsterBTTaskExecuter*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterBTTaskExecuter* UFieldManager::GetMonsterBTTaskExecuter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetMonsterBTTaskExecuter");

	Params::FieldManager_GetMonsterBTTaskExecuter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetMonsterServiceArranger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMonsterServiceArranger*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterServiceArranger* UFieldManager::GetMonsterServiceArranger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetMonsterServiceArranger");

	Params::FieldManager_GetMonsterServiceArranger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetNPCManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNPCManager*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNPCManager* UFieldManager::GetNPCManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetNPCManager");

	Params::FieldManager_GetNPCManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetOutbreakQuestPointManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOutbreakQuestPointManager*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOutbreakQuestPointManager* UFieldManager::GetOutbreakQuestPointManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetOutbreakQuestPointManager");

	Params::FieldManager_GetOutbreakQuestPointManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGameCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameCharacter* UFieldManager::GetPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetPlayer");

	Params::FieldManager_GetPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetTargetObjectManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTargetObjectManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTargetObjectManager* UFieldManager::GetTargetObjectManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetTargetObjectManager");

	Params::FieldManager_GetTargetObjectManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.GetWorldTimeManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWorldTimeManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorldTimeManager* UFieldManager::GetWorldTimeManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "GetWorldTimeManager");

	Params::FieldManager_GetWorldTimeManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldManager.IsPulledOutRivalTeamFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldManager::IsPulledOutRivalTeamFlag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldManager", "IsPulledOutRivalTeamFlag");

	Params::FieldManager_IsPulledOutRivalTeamFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BGMWorldActor.Build
// (Final, Native, Public, BlueprintCallable)

void ABGMWorldActor::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BGMWorldActor", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonGimmickBoss.OnEnemyMonsterSpawned
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonGimmickBoss::OnEnemyMonsterSpawned(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonGimmickBoss", "OnEnemyMonsterSpawned");

	Params::DungeonGimmickBoss_OnEnemyMonsterSpawned Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.HandleAreaTransitionEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IObjectCommunicationInterface::HandleAreaTransitionEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "HandleAreaTransitionEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.HandleEnteringArtifactAreaEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EArtifactType                           ArtifactType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNear                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAddEmphasis                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UniID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::HandleEnteringArtifactAreaEvent(EArtifactType ArtifactType, bool IsNear, bool IsAddEmphasis, class FName UniID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "HandleEnteringArtifactAreaEvent");

	Params::ObjectCommunicationInterface_HandleEnteringArtifactAreaEvent Parms{};

	Parms.ArtifactType = ArtifactType;
	Parms.IsNear = IsNear;
	Parms.IsAddEmphasis = IsAddEmphasis;
	Parms.UniID = UniID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.HandleExitArtifactAreaEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IObjectCommunicationInterface::HandleExitArtifactAreaEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "HandleExitArtifactAreaEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.HandleGetArtifactEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGetArtifactEventStruct          Info                                                   (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IObjectCommunicationInterface::HandleGetArtifactEvent(const struct FGetArtifactEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "HandleGetArtifactEvent");

	Params::ObjectCommunicationInterface_HandleGetArtifactEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ObjectCommunicationInterface.HandleLinkStartEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IObjectCommunicationInterface::HandleLinkStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "HandleLinkStartEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveCallEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FCallEventStruct                 Info                                                   (Parm, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveCallEvent(const struct FCallEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveCallEvent");

	Params::ObjectCommunicationInterface_OnReceiveCallEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEventStruct                     Info                                                   (Parm, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveEvent(const struct FEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveEvent");

	Params::ObjectCommunicationInterface_OnReceiveEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveFieldActionEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFieldActionEventStruct          Info                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveFieldActionEvent(const struct FFieldActionEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveFieldActionEvent");

	Params::ObjectCommunicationInterface_OnReceiveFieldActionEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveGetCoinEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGetCoinEventStruct              Info                                                   (Parm, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveGetCoinEvent(const struct FGetCoinEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveGetCoinEvent");

	Params::ObjectCommunicationInterface_OnReceiveGetCoinEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveGetItemEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGetItemEventStruct              Info                                                   (Parm, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveGetItemEvent(const struct FGetItemEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveGetItemEvent");

	Params::ObjectCommunicationInterface_OnReceiveGetItemEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveLiftEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLiftEventStruct                 Info                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveLiftEvent(const struct FLiftEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveLiftEvent");

	Params::ObjectCommunicationInterface_OnReceiveLiftEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveRideEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRideEventStruct                 Info                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveRideEvent(const struct FRideEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveRideEvent");

	Params::ObjectCommunicationInterface_OnReceiveRideEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnReceiveStealEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStealEventStruct                Info                                                   (Parm, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnReceiveStealEvent(const struct FStealEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnReceiveStealEvent");

	Params::ObjectCommunicationInterface_OnReceiveStealEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.OnRecieveReactionAfterSearch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FAfterSearchEventStruct          Info                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::OnRecieveReactionAfterSearch(const struct FAfterSearchEventStruct& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "OnRecieveReactionAfterSearch");

	Params::ObjectCommunicationInterface_OnRecieveReactionAfterSearch Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.RegisterFieldTerrainInfo
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFieldTerrainType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_FieldTerrainInfo             Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::RegisterFieldTerrainInfo(const EFieldTerrainType Type, const struct FST_FieldTerrainInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "RegisterFieldTerrainInfo");

	Params::ObjectCommunicationInterface_RegisterFieldTerrainInfo Parms{};

	Parms.Type = Type;
	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectCommunicationInterface.UnRegisterFieldTerrainInfo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFieldTerrainType                       Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IObjectCommunicationInterface::UnRegisterFieldTerrainInfo(const EFieldTerrainType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectCommunicationInterface", "UnRegisterFieldTerrainInfo");

	Params::ObjectCommunicationInterface_UnRegisterFieldTerrainInfo Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BoardSceneCapture.EndSequencerImpl
// (Final, Native, Public, BlueprintCallable)

void ABoardSceneCapture::EndSequencerImpl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoardSceneCapture", "EndSequencerImpl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BoardSceneCapture.GetMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonster* ABoardSceneCapture::GetMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoardSceneCapture", "GetMonster");

	Params::BoardSceneCapture_GetMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BoardSceneCapture.GetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* ABoardSceneCapture::GetPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoardSceneCapture", "GetPlayer");

	Params::BoardSceneCapture_GetPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BoardSceneCapture.StartSequencerImpl
// (Final, Native, Public, BlueprintCallable)

void ABoardSceneCapture::StartSequencerImpl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoardSceneCapture", "StartSequencerImpl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.OutbreakQuestRevengeBattle.SpawnRevengeMonsterCallBack
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOutbreakQuestRevengeBattle::SpawnRevengeMonsterCallBack(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutbreakQuestRevengeBattle", "SpawnRevengeMonsterCallBack");

	Params::OutbreakQuestRevengeBattle_SpawnRevengeMonsterCallBack Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectUtilInterface.OnDestroy
// (Native, Public, BlueprintCallable)

void IObjectUtilInterface::OnDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectUtilInterface", "OnDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectUtilInterface.GetObjectID
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName IObjectUtilInterface::GetObjectID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectUtilInterface", "GetObjectID");

	Params::ObjectUtilInterface_GetObjectID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinCamera.Activate
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "Activate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.AdjustBoomLength
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::AdjustBoomLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "AdjustBoomLength");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.Deactivate
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "Deactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.InitCameraCurve
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::InitCameraCurve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "InitCameraCurve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.LimitRotationAndUpdate
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ADarwinCamera::LimitRotationAndUpdate(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "LimitRotationAndUpdate");

	Params::DarwinCamera_LimitRotationAndUpdate Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.MoveWhileAbyss
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::MoveWhileAbyss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "MoveWhileAbyss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.MoveWhileAiming
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::MoveWhileAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "MoveWhileAiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.MoveWhileDeath
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::MoveWhileDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "MoveWhileDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.MoveWhileDebug
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ADarwinCamera::MoveWhileDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "MoveWhileDebug");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.DarwinCamera.MoveWhileDirection
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::MoveWhileDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "MoveWhileDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.MoveWhileNormal
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::MoveWhileNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "MoveWhileNormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RequestCameraTransition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDarwinViewBlendRequestParam     BlendRequest                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDarwinCameraResetParam          ResetParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADarwinCamera::RequestCameraTransition(const struct FDarwinViewBlendRequestParam& BlendRequest, const struct FDarwinCameraResetParam& ResetParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RequestCameraTransition");

	Params::DarwinCamera_RequestCameraTransition Parms{};

	Parms.BlendRequest = std::move(BlendRequest);
	Parms.ResetParam = std::move(ResetParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RequestCameraTransitionByMoveLinear
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           StartTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EViewBlendRateType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDarwinCameraResetParam          ResetParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   BlendRateEaseExpo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::RequestCameraTransitionByMoveLinear(class AActor* StartTarget, EViewBlendRateType Type, float BlendTime, const struct FDarwinCameraResetParam& ResetParam, float BlendRateEaseExpo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RequestCameraTransitionByMoveLinear");

	Params::DarwinCamera_RequestCameraTransitionByMoveLinear Parms{};

	Parms.StartTarget = StartTarget;
	Parms.Type = Type;
	Parms.BlendTime = BlendTime;
	Parms.ResetParam = std::move(ResetParam);
	Parms.BlendRateEaseExpo = BlendRateEaseExpo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetCamera
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDarwinCameraResetParam          ResetParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADarwinCamera::ResetCamera(const struct FDarwinCameraResetParam& ResetParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetCamera");

	Params::DarwinCamera_ResetCamera Parms{};

	Parms.ResetParam = std::move(ResetParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetObstacleJudgeRadius
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::ResetObstacleJudgeRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetObstacleJudgeRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetRotation
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::ResetRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetRotationFromKeyInput
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::ResetRotationFromKeyInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetRotationFromKeyInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetState
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::ResetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetStateAndRotation
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::ResetStateAndRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetStateAndRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetWithKeepPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          keepPosition                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::ResetWithKeepPosition(const struct FVector& keepPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetWithKeepPosition");

	Params::DarwinCamera_ResetWithKeepPosition Parms{};

	Parms.keepPosition = std::move(keepPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ResetWithKeepRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         keepRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ADarwinCamera::ResetWithKeepRotation(const struct FRotator& keepRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ResetWithKeepRotation");

	Params::DarwinCamera_ResetWithKeepRotation Parms{};

	Parms.keepRotation = std::move(keepRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RotateWhileAbyss
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::RotateWhileAbyss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RotateWhileAbyss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RotateWhileAiming
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::RotateWhileAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RotateWhileAiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RotateWhileDeath
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::RotateWhileDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RotateWhileDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RotateWhileDirection
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::RotateWhileDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RotateWhileDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.RotateWhileNormal
// (Final, Native, Protected, BlueprintCallable)

void ADarwinCamera::RotateWhileNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "RotateWhileNormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.SetBoomLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::SetBoomLength(float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "SetBoomLength");

	Params::DarwinCamera_SetBoomLength Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.SetCameraAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AspectRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::SetCameraAspectRatio(float AspectRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "SetCameraAspectRatio");

	Params::DarwinCamera_SetCameraAspectRatio Parms{};

	Parms.AspectRatio = AspectRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.SetCameraFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::SetCameraFOV(float FOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "SetCameraFOV");

	Params::DarwinCamera_SetCameraFOV Parms{};

	Parms.FOV = FOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.SetObstacleJudgeRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::SetObstacleJudgeRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "SetObstacleJudgeRadius");

	Params::DarwinCamera_SetObstacleJudgeRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.ShowCameraInfo
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::ShowCameraInfo(bool bEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "ShowCameraInfo");

	Params::DarwinCamera_ShowCameraInfo Parms{};

	Parms.bEnd = bEnd;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.DarwinCamera.SwitchPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraPostProcessType                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::SwitchPostProcess(ECameraPostProcessType Type, bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "SwitchPostProcess");

	Params::DarwinCamera_SwitchPostProcess Parms{};

	Parms.Type = Type;
	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.UpdateBoomLength
// (Final, Native, Public, BlueprintCallable)

void ADarwinCamera::UpdateBoomLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "UpdateBoomLength");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.UpdateCameraInfo
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ADarwinCamera::UpdateCameraInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "UpdateCameraInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.DarwinCamera.Zoom
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterapSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinCamera::Zoom(const struct FVector& Location, const struct FRotator& Rotation, float Length, float InterapSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "Zoom");

	Params::DarwinCamera_Zoom Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Length = Length;
	Parms.InterapSpeed = InterapSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCamera.GetBoomLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADarwinCamera::GetBoomLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCamera", "GetBoomLength");

	Params::DarwinCamera_GetBoomLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BossAvoidWall.BeginPlayInitialize
// (Final, Native, Public, BlueprintCallable)

void ABossAvoidWall::BeginPlayInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossAvoidWall", "BeginPlayInitialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BossAvoidWall.Initialize
// (Final, Native, Public, BlueprintCallable)

void ABossAvoidWall::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossAvoidWall", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHeader_01.SetHeaderType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             HeaderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIHeader_01::SetHeaderType(class FName HeaderType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHeader_01", "SetHeaderType");

	Params::UIHeader_01_SetHeaderType Parms{};

	Parms.HeaderType = HeaderType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHeader_01.SetName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Name_0                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIHeader_01::SetName(const class FText& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHeader_01", "SetName");

	Params::UIHeader_01_SetName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BossGimmicks.HitGimmickCheck
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABossGimmicks::HitGimmickCheck(const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BossGimmicks", "HitGimmickCheck");

	Params::BossGimmicks_HitGimmickCheck Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.ForcedBattleAreaBase.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AForcedBattleAreaBase::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedBattleAreaBase", "OnBeginOverlap");

	Params::ForcedBattleAreaBase_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_TacticsWord.EndTacticsCloseAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_TacticsWord::EndTacticsCloseAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_TacticsWord", "EndTacticsCloseAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_TacticsWord.EndTacticsOpenAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_TacticsWord::EndTacticsOpenAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_TacticsWord", "EndTacticsOpenAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_TacticsWord.EndTacticsWaitAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_TacticsWord::EndTacticsWaitAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_TacticsWord", "EndTacticsWaitAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_TacticsWord.Input_Button_Down_Implementation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIField_TacticsWord::Input_Button_Down_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_TacticsWord", "Input_Button_Down_Implementation");

	Params::UIField_TacticsWord_Input_Button_Down_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_TacticsWord.Input_Button_Up_Implementation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIField_TacticsWord::Input_Button_Up_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_TacticsWord", "Input_Button_Up_Implementation");

	Params::UIField_TacticsWord_Input_Button_Up_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_TacticsWord.StartTacticsAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_TacticsWord::StartTacticsAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_TacticsWord", "StartTacticsAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPDebugMenuInterface.GetDisplayItemNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPDebugMenuInterface::GetDisplayItemNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetDisplayItemNum");

	Params::BPDebugMenuInterface_GetDisplayItemNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPDebugMenuInterface.GetFontHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPDebugMenuInterface::GetFontHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetFontHeight");

	Params::BPDebugMenuInterface_GetFontHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPDebugMenuInterface.GetFontWidth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPDebugMenuInterface::GetFontWidth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetFontWidth");

	Params::BPDebugMenuInterface_GetFontWidth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPDebugMenuInterface.GetItemNameLayout
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   displayNo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPDebugMenuInterface::GetItemNameLayout(int32 displayNo, class FString* Text, float* X, float* Y, struct FLinearColor* Color) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetItemNameLayout");

	Params::BPDebugMenuInterface_GetItemNameLayout Parms{};

	Parms.displayNo = displayNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function DarwinGame.BPDebugMenuInterface.GetItemValueLayout
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   displayNo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPDebugMenuInterface::GetItemValueLayout(int32 displayNo, class FString* Text, float* X, float* Y, struct FLinearColor* Color) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetItemValueLayout");

	Params::BPDebugMenuInterface_GetItemValueLayout Parms{};

	Parms.displayNo = displayNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function DarwinGame.BPDebugMenuInterface.GetScrollLayout
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPDebugMenuInterface::GetScrollLayout(class FString* Text, float* X, float* Y, struct FLinearColor* Color) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetScrollLayout");

	Params::BPDebugMenuInterface_GetScrollLayout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function DarwinGame.BPDebugMenuInterface.GetTitleLayout
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPDebugMenuInterface::GetTitleLayout(class FString* Text, float* X, float* Y, struct FLinearColor* Color) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "GetTitleLayout");

	Params::BPDebugMenuInterface_GetTitleLayout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function DarwinGame.BPDebugMenuInterface.IsFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPDebugMenuInterface::IsFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPDebugMenuInterface", "IsFinished");

	Params::BPDebugMenuInterface_IsFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.DoSlowdownTest
// (Final, Native, Static, Public, BlueprintCallable)

void UBPFDebugParamInterface::DoSlowdownTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "DoSlowdownTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.GetBattleTableRowId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPFDebugParamInterface::GetBattleTableRowId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetBattleTableRowId");

	Params::BPFDebugParamInterface_GetBattleTableRowId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetFastTravelId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPFDebugParamInterface::GetFastTravelId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetFastTravelId");

	Params::BPFDebugParamInterface_GetFastTravelId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetFastTravelLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBPFDebugParamInterface::GetFastTravelLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetFastTravelLocation");

	Params::BPFDebugParamInterface_GetFastTravelLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetFriendMonsterSpawnDisable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetFriendMonsterSpawnDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetFriendMonsterSpawnDisable");

	Params::BPFDebugParamInterface_GetFriendMonsterSpawnDisable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsActiveWipeCamera
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsActiveWipeCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsActiveWipeCamera");

	Params::BPFDebugParamInterface_GetIsActiveWipeCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsBattleMotionCheck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsBattleMotionCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsBattleMotionCheck");

	Params::BPFDebugParamInterface_GetIsBattleMotionCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsDispLookAtTargetInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsDispLookAtTargetInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsDispLookAtTargetInfo");

	Params::BPFDebugParamInterface_GetIsDispLookAtTargetInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsFastTravel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsFastTravel");

	Params::BPFDebugParamInterface_GetIsFastTravel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsHiddenFieldComment
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsHiddenFieldComment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsHiddenFieldComment");

	Params::BPFDebugParamInterface_GetIsHiddenFieldComment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsLockCameraRelativeLocation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsLockCameraRelativeLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsLockCameraRelativeLocation");

	Params::BPFDebugParamInterface_GetIsLockCameraRelativeLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsSlowdownTest
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsSlowdownTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsSlowdownTest");

	Params::BPFDebugParamInterface_GetIsSlowdownTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsSwitchCameraController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsSwitchCameraController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsSwitchCameraController");

	Params::BPFDebugParamInterface_GetIsSwitchCameraController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetIsSwitchTargetMarkerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetIsSwitchTargetMarkerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetIsSwitchTargetMarkerController");

	Params::BPFDebugParamInterface_GetIsSwitchTargetMarkerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetNextLevelPathOfTitle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UBPFDebugParamInterface::GetNextLevelPathOfTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetNextLevelPathOfTitle");

	Params::BPFDebugParamInterface_GetNextLevelPathOfTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetTargetBoneId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPFDebugParamInterface::GetTargetBoneId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetTargetBoneId");

	Params::BPFDebugParamInterface_GetTargetBoneId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetTargetRowId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBPFDebugParamInterface::GetTargetRowId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetTargetRowId");

	Params::BPFDebugParamInterface_GetTargetRowId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetTriggerChangeFocusTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetTriggerChangeFocusTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetTriggerChangeFocusTarget");

	Params::BPFDebugParamInterface_GetTriggerChangeFocusTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetTriggerModelChange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetTriggerModelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetTriggerModelChange");

	Params::BPFDebugParamInterface_GetTriggerModelChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.GetTriggerOpenWarpMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::GetTriggerOpenWarpMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "GetTriggerOpenWarpMenu");

	Params::BPFDebugParamInterface_GetTriggerOpenWarpMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BPFDebugParamInterface.OutputLogBossCameraStartForCheckConflictWithBossPerformance
// (Final, Native, Static, Public, BlueprintCallable)

void UBPFDebugParamInterface::OutputLogBossCameraStartForCheckConflictWithBossPerformance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "OutputLogBossCameraStartForCheckConflictWithBossPerformance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.OutputLogExecAnimNotifyState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           AnimNotifyText                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPFDebugParamInterface::OutputLogExecAnimNotifyState(const class FString& AnimNotifyText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "OutputLogExecAnimNotifyState");

	Params::BPFDebugParamInterface_OutputLogExecAnimNotifyState Parms{};

	Parms.AnimNotifyText = std::move(AnimNotifyText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.OutputLogStartDespoilForCheckConflictWithBossPerformance
// (Final, Native, Static, Public, BlueprintCallable)

void UBPFDebugParamInterface::OutputLogStartDespoilForCheckConflictWithBossPerformance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "OutputLogStartDespoilForCheckConflictWithBossPerformance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.SetFastTravelId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPFDebugParamInterface::SetFastTravelId(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "SetFastTravelId");

	Params::BPFDebugParamInterface_SetFastTravelId Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.SetFastTravelLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPFDebugParamInterface::SetFastTravelLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "SetFastTravelLocation");

	Params::BPFDebugParamInterface_SetFastTravelLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.SetIsFastTravel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPFDebugParamInterface::SetIsFastTravel(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "SetIsFastTravel");

	Params::BPFDebugParamInterface_SetIsFastTravel Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.SetTriggerOffModelChange
// (Final, Native, Static, Public, BlueprintCallable)

void UBPFDebugParamInterface::SetTriggerOffModelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "SetTriggerOffModelChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.SetTriggerOffMoveCameraPreset
// (Final, Native, Static, Public, BlueprintCallable)

void UBPFDebugParamInterface::SetTriggerOffMoveCameraPreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "SetTriggerOffMoveCameraPreset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.SetTriggerOffOpenWarpMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UBPFDebugParamInterface::SetTriggerOffOpenWarpMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "SetTriggerOffOpenWarpMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BPFDebugParamInterface.UseFieldCommentHiddenFlag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFDebugParamInterface::UseFieldCommentHiddenFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFDebugParamInterface", "UseFieldCommentHiddenFlag");

	Params::BPFDebugParamInterface_UseFieldCommentHiddenFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BreathMagicBase.OnParticleCollisionHit
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EmitterTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ParticleTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                PhysMat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreathMagicBase::OnParticleCollisionHit(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreathMagicBase", "OnParticleCollisionHit");

	Params::BreathMagicBase_OnParticleCollisionHit Parms{};

	Parms.EventName = EventName;
	Parms.EmitterTime = EmitterTime;
	Parms.ParticleTime = ParticleTime;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Direction = std::move(Direction);
	Parms.Normal = std::move(Normal);
	Parms.BoneName = BoneName;
	Parms.PhysMat = PhysMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinLogbox.SetDataCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Unique                                                 (ConstParm, Parm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinLogbox::SetDataCharacter(class FName Key, class FName ID, const class FText& Unique, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinLogbox", "SetDataCharacter");

	Params::UIField_WinLogbox_SetDataCharacter Parms{};

	Parms.Key = Key;
	Parms.ID = ID;
	Parms.Unique = std::move(Unique);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinLogbox.SetDataCoin
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Unique                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinLogbox::SetDataCoin(class FName Key, const struct FST_CoinParam& CoinParam, const class FText& Unique, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinLogbox", "SetDataCoin");

	Params::UIField_WinLogbox_SetDataCoin Parms{};

	Parms.Key = Key;
	Parms.CoinParam = std::move(CoinParam);
	Parms.Unique = std::move(Unique);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinLogbox.SetDataFood
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FoodEffectId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Unique                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinLogbox::SetDataFood(class FName Key, class FName FoodEffectId, const class FText& Unique, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinLogbox", "SetDataFood");

	Params::UIField_WinLogbox_SetDataFood Parms{};

	Parms.Key = Key;
	Parms.FoodEffectId = FoodEffectId;
	Parms.Unique = std::move(Unique);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinLogbox.SetDataItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Unique                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinLogbox::SetDataItem(class FName Key, class FName ID, const class FText& Unique, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinLogbox", "SetDataItem");

	Params::UIField_WinLogbox_SetDataItem Parms{};

	Parms.Key = Key;
	Parms.ID = ID;
	Parms.Unique = std::move(Unique);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinLogbox.SetDataQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Unique                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsOpenQuestConfirmation                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinLogbox::SetDataQuest(class FName Key, class FName QuestID, const class FText& Unique, int32 Value, bool bInIsOpenQuestConfirmation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinLogbox", "SetDataQuest");

	Params::UIField_WinLogbox_SetDataQuest Parms{};

	Parms.Key = Key;
	Parms.QuestID = QuestID;
	Parms.Unique = std::move(Unique);
	Parms.Value = Value;
	Parms.bInIsOpenQuestConfirmation = bInIsOpenQuestConfirmation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinLogbox.SetDataSimple
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Unique                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinLogbox::SetDataSimple(class FName Key, const class FText& Unique, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinLogbox", "SetDataSimple");

	Params::UIField_WinLogbox_SetDataSimple Parms{};

	Parms.Key = Key;
	Parms.Unique = std::move(Unique);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BTTask_GazePlayer.CheckGazeMotion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBTTask_GazePlayer::CheckGazeMotion(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_GazePlayer", "CheckGazeMotion");

	Params::BTTask_GazePlayer_CheckGazeMotion Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldGameState.CancelChain
// (Final, Native, Public, BlueprintCallable)

void AFieldGameState::CancelChain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldGameState", "CancelChain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldGameState.EndChain
// (Final, Native, Public, BlueprintCallable)

void AFieldGameState::EndChain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldGameState", "EndChain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimatePerformanceBase.GetRotateProcessVec
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UUIEstimatePerformanceBase::GetRotateProcessVec(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimatePerformanceBase", "GetRotateProcessVec");

	Params::UIEstimatePerformanceBase_GetRotateProcessVec Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIEstimatePerformanceBase.GetRotateProcessYaw
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIEstimatePerformanceBase::GetRotateProcessYaw(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimatePerformanceBase", "GetRotateProcessYaw");

	Params::UIEstimatePerformanceBase_GetRotateProcessYaw Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.DailyQuestFunctionLibrary.OrderQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   RealYear                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RealMonth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RealDay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RealHour                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RealMinute                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDailyQuestFunctionLibrary::OrderQuest(int32 RealYear, int32 RealMonth, int32 RealDay, int32 RealHour, int32 RealMinute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DailyQuestFunctionLibrary", "OrderQuest");

	Params::DailyQuestFunctionLibrary_OrderQuest Parms{};

	Parms.RealYear = RealYear;
	Parms.RealMonth = RealMonth;
	Parms.RealDay = RealDay;
	Parms.RealHour = RealHour;
	Parms.RealMinute = RealMinute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectDataTable.GetAreaType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AssortID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EAreaType                         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const EAreaType UFieldObjectDataTable::GetAreaType(class FName AssortID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldObjectDataTable", "GetAreaType");

	Params::FieldObjectDataTable_GetAreaType Parms{};

	Parms.AssortID = AssortID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectDataTable.GetEventID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UFieldObjectDataTable::GetEventID(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldObjectDataTable", "GetEventID");

	Params::FieldObjectDataTable_GetEventID Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIStartLoopAnimation.PlayLoopAnimation
// (Final, Native, Protected, BlueprintCallable)

void UUIStartLoopAnimation::PlayLoopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStartLoopAnimation", "PlayLoopAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ExpDataTable.GetRequiredExp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GrowthType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UExpDataTable::GetRequiredExp(int32 Level, int32 GrowthType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ExpDataTable", "GetRequiredExp");

	Params::ExpDataTable_GetRequiredExp Parms{};

	Parms.Level = Level;
	Parms.GrowthType = GrowthType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.AdditionalDamageExecution.CalculateDamage
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAdditionalDamageParam           Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdditionalDamageExecution::CalculateDamage(class AGPACharacter* Target, const struct FAdditionalDamageParam& Request, float* Damage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdditionalDamageExecution", "CalculateDamage");

	Params::AdditionalDamageExecution_CalculateDamage Parms{};

	Parms.Target = Target;
	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Damage != nullptr)
		*Damage = Parms.Damage;
}


// Function DarwinGame.ScriptEventBase.AddArtifact
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ArtifactID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::AddArtifact(int32 ArtifactID, class FName AreaID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "AddArtifact");

	Params::ScriptEventBase_AddArtifact Parms{};

	Parms.ArtifactID = ArtifactID;
	Parms.AreaID = AreaID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.AddPartyMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::AddPartyMember(const int32 UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "AddPartyMember");

	Params::ScriptEventBase_AddPartyMember Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.CallEventObjectDoEnd
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::CallEventObjectDoEnd(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "CallEventObjectDoEnd");

	Params::ScriptEventBase_CallEventObjectDoEnd Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.CallEventObjectDoStart
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::CallEventObjectDoStart(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "CallEventObjectDoStart");

	Params::ScriptEventBase_CallEventObjectDoStart Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.CancelBaseAreaBattle
// (Final, Native, Protected, BlueprintCallable)

void AScriptEventBase::CancelBaseAreaBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "CancelBaseAreaBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.EndEvent
// (Final, Native, Protected, BlueprintCallable)

void AScriptEventBase::EndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "EndEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.EndingAutoSave
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::EndingAutoSave(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "EndingAutoSave");

	Params::ScriptEventBase_EndingAutoSave Parms{};

	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.ExecuteEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AScriptEventBase::ExecuteEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "ExecuteEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.ScriptEventBase.FinPlayerLookAt
// (Final, Native, Protected, BlueprintCallable)

void AScriptEventBase::FinPlayerLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "FinPlayerLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.GetPCChangeTalkID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AScriptEventBase::GetPCChangeTalkID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "GetPCChangeTalkID");

	Params::ScriptEventBase_GetPCChangeTalkID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ScriptEventBase.HasArtifact
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ArtifactID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScriptEventBase::HasArtifact(int32 ArtifactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "HasArtifact");

	Params::ScriptEventBase_HasArtifact Parms{};

	Parms.ArtifactID = ArtifactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ScriptEventBase.IsNpcLoading
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScriptEventBase::IsNpcLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "IsNpcLoading");

	Params::ScriptEventBase_IsNpcLoading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ScriptEventBase.LoadPlanEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::LoadPlanEvent(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "LoadPlanEvent");

	Params::ScriptEventBase_LoadPlanEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.MoveInverseSideFromEventActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   MoveTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::MoveInverseSideFromEventActor(float MoveTime, int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "MoveInverseSideFromEventActor");

	Params::ScriptEventBase_MoveInverseSideFromEventActor Parms{};

	Parms.MoveTime = MoveTime;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenArtifactRepositoryUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenArtifactRepositoryUI(int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenArtifactRepositoryUI");

	Params::ScriptEventBase_OpenArtifactRepositoryUI Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenDialogWindow
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             DaialogTextID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenDialogWindow(class FName DaialogTextID, int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenDialogWindow");

	Params::ScriptEventBase_OpenDialogWindow Parms{};

	Parms.DaialogTextID = DaialogTextID;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenFacilityMenu
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenFacilityMenu(const int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenFacilityMenu");

	Params::ScriptEventBase_OpenFacilityMenu Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenGroupDialogUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenGroupDialogUI(int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenGroupDialogUI");

	Params::ScriptEventBase_OpenGroupDialogUI Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenLithographyUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             MessageID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenLithographyUI(const class FName MessageID, const int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenLithographyUI");

	Params::ScriptEventBase_OpenLithographyUI Parms{};

	Parms.MessageID = MessageID;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenMainMenuQuest
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenMainMenuQuest(const int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenMainMenuQuest");

	Params::ScriptEventBase_OpenMainMenuQuest Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenNewItemTips
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFirstTimeAddItem                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenNewItemTips(class FName ItemId, int32 NextSectionNum, bool IsFirstTimeAddItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenNewItemTips");

	Params::ScriptEventBase_OpenNewItemTips Parms{};

	Parms.ItemId = ItemId;
	Parms.NextSectionNum = NextSectionNum;
	Parms.IsFirstTimeAddItem = IsFirstTimeAddItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenPCChangeUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenPCChangeUI(int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenPCChangeUI");

	Params::ScriptEventBase_OpenPCChangeUI Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenQuestOrderUI
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     QuestIdList                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsParentDisplay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsNewOrderQuest                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsClearedDisplay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenQuestOrderUI(const TArray<class FName>& QuestIdList, const class FName& NpcID, bool bIsParentDisplay, int32 NextSectionNum, bool bIsNewOrderQuest, bool bIsClearedDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenQuestOrderUI");

	Params::ScriptEventBase_OpenQuestOrderUI Parms{};

	Parms.QuestIdList = std::move(QuestIdList);
	Parms.NpcID = NpcID;
	Parms.bIsParentDisplay = bIsParentDisplay;
	Parms.NextSectionNum = NextSectionNum;
	Parms.bIsNewOrderQuest = bIsNewOrderQuest;
	Parms.bIsClearedDisplay = bIsClearedDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenQuestRewardWindow
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenQuestRewardWindow(const class FName QuestID, const int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenQuestRewardWindow");

	Params::ScriptEventBase_OpenQuestRewardWindow Parms{};

	Parms.QuestID = QuestID;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenShopUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ETradePlace                             ShopType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenShopUI(ETradePlace ShopType, int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenShopUI");

	Params::ScriptEventBase_OpenShopUI Parms{};

	Parms.ShopType = ShopType;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenStaffRoll
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenStaffRoll(const int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenStaffRoll");

	Params::ScriptEventBase_OpenStaffRoll Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenTips
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenTips(class FName TipsID, int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenTips");

	Params::ScriptEventBase_OpenTips Parms{};

	Parms.TipsID = TipsID;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.OpenTreasureAppraiseUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::OpenTreasureAppraiseUI(int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "OpenTreasureAppraiseUI");

	Params::ScriptEventBase_OpenTreasureAppraiseUI Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.PartyMonsterReLocation
// (Final, Native, Public, BlueprintCallable)

void AScriptEventBase::PartyMonsterReLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "PartyMonsterReLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.PlayIE
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::PlayIE(class FName EventID, int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "PlayIE");

	Params::ScriptEventBase_PlayIE Parms{};

	Parms.EventID = EventID;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.PlaySequencerEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::PlaySequencerEvent(class FName EventID, int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "PlaySequencerEvent");

	Params::ScriptEventBase_PlaySequencerEvent Parms{};

	Parms.EventID = EventID;
	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.ReceiveCloseTalkWindow
// (Final, Native, Public, BlueprintCallable)

void AScriptEventBase::ReceiveCloseTalkWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "ReceiveCloseTalkWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.ReceiveSelectResult
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AScriptEventBase::ReceiveSelectResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "ReceiveSelectResult");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.ScriptEventBase.RemoveAllPartyArtifact
// (Final, Native, Protected, BlueprintCallable)

void AScriptEventBase::RemoveAllPartyArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "RemoveAllPartyArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.RemoveAllPartyMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<int32> AScriptEventBase::RemoveAllPartyMember()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "RemoveAllPartyMember");

	Params::ScriptEventBase_RemoveAllPartyMember Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ScriptEventBase.RequestBaseAreaBattleEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScriptEventBase::RequestBaseAreaBattleEvent(const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "RequestBaseAreaBattleEvent");

	Params::ScriptEventBase_RequestBaseAreaBattleEvent Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ScriptEventBase.ResetGameScriptAll
// (Final, Native, Protected, BlueprintCallable)

void AScriptEventBase::ResetGameScriptAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "ResetGameScriptAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.ResetPlayerAndCameraTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       playerTransform                                        (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    isTeleport                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDarwinCameraResetParam          resetCameraParam                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AScriptEventBase::ResetPlayerAndCameraTransform(const struct FTransform& playerTransform, bool isTeleport, const struct FDarwinCameraResetParam& resetCameraParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "ResetPlayerAndCameraTransform");

	Params::ScriptEventBase_ResetPlayerAndCameraTransform Parms{};

	Parms.playerTransform = std::move(playerTransform);
	Parms.isTeleport = isTeleport;
	Parms.resetCameraParam = std::move(resetCameraParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.SetCandidateMonsterInfo
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             MonsterId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MonsterNum                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOverwrite                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::SetCandidateMonsterInfo(class FName MonsterId, const int32 MonsterNum, bool IsOverwrite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "SetCandidateMonsterInfo");

	Params::ScriptEventBase_SetCandidateMonsterInfo Parms{};

	Parms.MonsterId = MonsterId;
	Parms.MonsterNum = MonsterNum;
	Parms.IsOverwrite = IsOverwrite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.SetMyTreasure
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ArtifactID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::SetMyTreasure(int32 ArtifactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "SetMyTreasure");

	Params::ScriptEventBase_SetMyTreasure Parms{};

	Parms.ArtifactID = ArtifactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.SetSelectFastTravelID
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             FastTravelID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::SetSelectFastTravelID(class FName FastTravelID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "SetSelectFastTravelID");

	Params::ScriptEventBase_SetSelectFastTravelID Parms{};

	Parms.FastTravelID = FastTravelID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.UnLoadEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::UnLoadEvent(class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "UnLoadEvent");

	Params::ScriptEventBase_UnLoadEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.Update
// (Final, Native, Protected, BlueprintCallable)

void AScriptEventBase::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.UpdateMyTreasure
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsSoundOn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AScriptEventBase::UpdateMyTreasure(bool IsSoundOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "UpdateMyTreasure");

	Params::ScriptEventBase_UpdateMyTreasure Parms{};

	Parms.IsSoundOn = IsSoundOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ScriptEventBase.IsDispatchPartner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScriptEventBase::IsDispatchPartner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "IsDispatchPartner");

	Params::ScriptEventBase_IsDispatchPartner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ScriptEventBase.IsLoadingNpcAsset
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AScriptEventBase::IsLoadingNpcAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScriptEventBase", "IsLoadingNpcAsset");

	Params::ScriptEventBase_IsLoadingNpcAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NetworkPersonEvent.OpenNetworkTerms
// (Final, Native, Protected, BlueprintCallable)

void ANetworkPersonEvent::OpenNetworkTerms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "OpenNetworkTerms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkPersonEvent.PlaySound
// (Final, Native, Public, BlueprintCallable)

void ANetworkPersonEvent::PlaySound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "PlaySound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkPersonEvent.SetEndReplicaTalkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkPersonEvent::SetEndReplicaTalkEvent(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "SetEndReplicaTalkEvent");

	Params::NetworkPersonEvent_SetEndReplicaTalkEvent Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkPersonEvent.SetTreasureHideUpDLCountFlg
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkPersonEvent::SetTreasureHideUpDLCountFlg(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "SetTreasureHideUpDLCountFlg");

	Params::NetworkPersonEvent_SetTreasureHideUpDLCountFlg Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkPersonEvent.GetDipronUIDeleteNpcFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANetworkPersonEvent::GetDipronUIDeleteNpcFlag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "GetDipronUIDeleteNpcFlag");

	Params::NetworkPersonEvent_GetDipronUIDeleteNpcFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NetworkPersonEvent.GetEndReplicaTalkEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANetworkPersonEvent::GetEndReplicaTalkEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "GetEndReplicaTalkEvent");

	Params::NetworkPersonEvent_GetEndReplicaTalkEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NetworkPersonEvent.GetIsOpenedReplicaTips
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANetworkPersonEvent::GetIsOpenedReplicaTips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "GetIsOpenedReplicaTips");

	Params::NetworkPersonEvent_GetIsOpenedReplicaTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NetworkPersonEvent.GetTreasureHideUpDLCountFlg
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANetworkPersonEvent::GetTreasureHideUpDLCountFlg() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "GetTreasureHideUpDLCountFlg");

	Params::NetworkPersonEvent_GetTreasureHideUpDLCountFlg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NetworkPersonEvent.StartTeamRankUpSequence
// (Final, Native, Public, BlueprintCallable, Const)

void ANetworkPersonEvent::StartTeamRankUpSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkPersonEvent", "StartTeamRankUpSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkManagementSceneCapture.CopyCameraSettingsToAllSceneCapture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 SrcCamera                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneCaptureComponent2D*         Dst1                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneCaptureComponent2D*         Dst2                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkManagementSceneCapture::CopyCameraSettingsToAllSceneCapture(class UCameraComponent* SrcCamera, class USceneCaptureComponent2D* Dst1, class USceneCaptureComponent2D* Dst2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NetworkManagementSceneCapture", "CopyCameraSettingsToAllSceneCapture");

	Params::NetworkManagementSceneCapture_CopyCameraSettingsToAllSceneCapture Parms{};

	Parms.SrcCamera = SrcCamera;
	Parms.Dst1 = Dst1;
	Parms.Dst2 = Dst2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkManagementSceneCapture.GetMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonster* ANetworkManagementSceneCapture::GetMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkManagementSceneCapture", "GetMonster");

	Params::NetworkManagementSceneCapture_GetMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIFacility_MonsterStatus.Refresh
// (Final, Native, Public, BlueprintCallable)

void UUIFacility_MonsterStatus::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFacility_MonsterStatus", "Refresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterAssetManagerBase.IsCompletedLoad
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterAssetManagerBase::IsCompletedLoad(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAssetManagerBase", "IsCompletedLoad");

	Params::CharacterAssetManagerBase_IsCompletedLoad Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterAssetManagerBase.IsLoading
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterAssetManagerBase::IsLoading(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAssetManagerBase", "IsLoading");

	Params::CharacterAssetManagerBase_IsLoading Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterAssetManagerBase.RequestASyncLoadActor
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class FName ID)>         onEvent                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterAssetManagerBase::RequestASyncLoadActor(const class FName& ID, const TDelegate<void(class FName ID)>& onEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAssetManagerBase", "RequestASyncLoadActor");

	Params::CharacterAssetManagerBase_RequestASyncLoadActor Parms{};

	Parms.ID = ID;
	Parms.onEvent = onEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterAssetManagerBase.Unload
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterAssetManagerBase::Unload(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAssetManagerBase", "Unload");

	Params::CharacterAssetManagerBase_Unload Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAssetManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNPCAssetManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNPCAssetManager* UNPCAssetManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCAssetManager", "GetInstance");

	Params::NPCAssetManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAssetManager.GetNPCAssetArray
// (Final, Native, Static, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FSoftObjectPath> UNPCAssetManager::GetNPCAssetArray(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCAssetManager", "GetNPCAssetArray");

	Params::NPCAssetManager_GetNPCAssetArray Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NonActionHealExecutionBase.CalculateHeal
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_HealRequest                  Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Heal                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNonActionHealExecutionBase::CalculateHeal(class AGPACharacter* Target, const struct FST_HealRequest& Request, float* Heal) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NonActionHealExecutionBase", "CalculateHeal");

	Params::NonActionHealExecutionBase_CalculateHeal Parms{};

	Parms.Target = Target;
	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Heal != nullptr)
		*Heal = Parms.Heal;
}


// Function DarwinGame.ObjectReactionInterface.BindEventCalledWhileAccess
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FEventCalledWhileAccess          Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IObjectReactionInterface::BindEventCalledWhileAccess(const struct FEventCalledWhileAccess& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectReactionInterface", "BindEventCalledWhileAccess");

	Params::ObjectReactionInterface_BindEventCalledWhileAccess Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectReactionInterface.GetObjectReactionTypeWithCaution
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EObjectReactionType                     ReactionType                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputGuideCaution                      CautionType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IObjectReactionInterface::GetObjectReactionTypeWithCaution(EObjectReactionType* ReactionType, EInputGuideCaution* CautionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectReactionInterface", "GetObjectReactionTypeWithCaution");

	Params::ObjectReactionInterface_GetObjectReactionTypeWithCaution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReactionType != nullptr)
		*ReactionType = Parms.ReactionType;

	if (CautionType != nullptr)
		*CautionType = Parms.CautionType;
}


// Function DarwinGame.ObjectReactionInterface.HandleAimEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IObjectReactionInterface::HandleAimEvent(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectReactionInterface", "HandleAimEvent");

	Params::ObjectReactionInterface_HandleAimEvent Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectReactionInterface.HandleShakeEvent
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IObjectReactionInterface::HandleShakeEvent(const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectReactionInterface", "HandleShakeEvent");

	Params::ObjectReactionInterface_HandleShakeEvent Parms{};

	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ObjectReactionInterface.OnReceiveHit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EObjectEffectionEnum                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IObjectReactionInterface::OnReceiveHit(EObjectEffectionEnum Type, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectReactionInterface", "OnReceiveHit");

	Params::ObjectReactionInterface_OnReceiveHit Parms{};

	Parms.Type = Type;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinCheatManager.DumpClusterOutsideRefs
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ClusterName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinCheatManager::DumpClusterOutsideRefs(const class FString& ClusterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinCheatManager", "DumpClusterOutsideRefs");

	Params::DarwinCheatManager_DumpClusterOutsideRefs Parms{};

	Parms.ClusterName = std::move(ClusterName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonPointNest.OnBeginOverlapEffectCollision
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADungeonPointNest::OnBeginOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonPointNest", "OnBeginOverlapEffectCollision");

	Params::DungeonPointNest_OnBeginOverlapEffectCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonPointNest.OnEndOverlapEffectCollision
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonPointNest::OnEndOverlapEffectCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonPointNest", "OnEndOverlapEffectCollision");

	Params::DungeonPointNest_OnEndOverlapEffectCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuicksandBase.GetQuicksandDMI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* AQuicksandBase::GetQuicksandDMI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuicksandBase", "GetQuicksandDMI");

	Params::QuicksandBase_GetQuicksandDMI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DungeonGimmickMonster.OnEnemyMonsterSpawned
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonGimmickMonster::OnEnemyMonsterSpawned(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonGimmickMonster", "OnEnemyMonsterSpawned");

	Params::DungeonGimmickMonster_OnEnemyMonsterSpawned Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventFunctionLibrary.ChangeCurrentApertureWithResolution
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCineCameraComponent*             Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventFunctionLibrary::ChangeCurrentApertureWithResolution(class UCineCameraComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "ChangeCurrentApertureWithResolution");

	Params::EventFunctionLibrary_ChangeCurrentApertureWithResolution Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventFunctionLibrary.GetCecilyTextData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FST_CecilyTextData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FST_CecilyTextData UEventFunctionLibrary::GetCecilyTextData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetCecilyTextData");

	Params::EventFunctionLibrary_GetCecilyTextData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetEpisodeProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEpisodeType                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventFunctionLibrary::GetEpisodeProgress(EEpisodeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetEpisodeProgress");

	Params::EventFunctionLibrary_GetEpisodeProgress Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetEventFukidashiColor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETalkFukidashiColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETalkFukidashiColor UEventFunctionLibrary::GetEventFukidashiColor(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetEventFukidashiColor");

	Params::EventFunctionLibrary_GetEventFukidashiColor Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetGroundLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UEventFunctionLibrary::GetGroundLocation(class ACharacter* Character, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetGroundLocation");

	Params::EventFunctionLibrary_GetGroundLocation Parms{};

	Parms.Character = Character;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetLocationFromNavimesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          FromLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NaviLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRaw                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::GetLocationFromNavimesh(const struct FVector& FromLocation, struct FVector* NaviLocation, const bool IsRaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetLocationFromNavimesh");

	Params::EventFunctionLibrary_GetLocationFromNavimesh Parms{};

	Parms.FromLocation = std::move(FromLocation);
	Parms.IsRaw = IsRaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NaviLocation != nullptr)
		*NaviLocation = std::move(Parms.NaviLocation);

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetPCChangeTalkID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsBefore                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventFunctionLibrary::GetPCChangeTalkID(const bool IsBefore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetPCChangeTalkID");

	Params::EventFunctionLibrary_GetPCChangeTalkID Parms{};

	Parms.IsBefore = IsBefore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetStationObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AStationBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AStationBase* UEventFunctionLibrary::GetStationObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetStationObject");

	Params::EventFunctionLibrary_GetStationObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.GetStationReleaseEventID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             StationID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventFunctionLibrary::GetStationReleaseEventID(const class FName StationID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "GetStationReleaseEventID");

	Params::EventFunctionLibrary_GetStationReleaseEventID Parms{};

	Parms.StationID = StationID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.HasAllGetSevenStone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::HasAllGetSevenStone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "HasAllGetSevenStone");

	Params::EventFunctionLibrary_HasAllGetSevenStone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.InitializeNotSequencer
// (Final, Native, Static, Public, BlueprintCallable)

void UEventFunctionLibrary::InitializeNotSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "InitializeNotSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventFunctionLibrary.InitializeSequencer
// (Final, Native, Static, Public, BlueprintCallable)

void UEventFunctionLibrary::InitializeSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "InitializeSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventFunctionLibrary.IsEventTestFlag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::IsEventTestFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "IsEventTestFlag");

	Params::EventFunctionLibrary_IsEventTestFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.IsSkippableEvent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::IsSkippableEvent(const class FName EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "IsSkippableEvent");

	Params::EventFunctionLibrary_IsSkippableEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventFunctionLibrary.SetHideVolcaGigarss
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventFunctionLibrary::SetHideVolcaGigarss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventFunctionLibrary", "SetHideVolcaGigarss");

	Params::EventFunctionLibrary_SetHideVolcaGigarss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BTTaskBlueprintDarwin.ReceiveFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// class AAIController*                    OwnerController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ControlledPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTaskBlueprintDarwin::ReceiveFinished(class AAIController* OwnerController, class APawn* ControlledPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTaskBlueprintDarwin", "ReceiveFinished");

	Params::BTTaskBlueprintDarwin_ReceiveFinished Parms{};

	Parms.OwnerController = OwnerController;
	Parms.ControlledPawn = ControlledPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.GameDataNPC.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataNPC*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataNPC* UGameDataNPC::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataNPC", "Clone");

	Params::GameDataNPC_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataNPC.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataNPC*                     game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataNPC::Overwrite(class UGameDataNPC* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataNPC", "Overwrite");

	Params::GameDataNPC_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RivalTeamStampManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URivalTeamStampManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URivalTeamStampManager* URivalTeamStampManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamStampManager", "GetInstance");

	Params::RivalTeamStampManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BulletMagicBase.OnDamage
// (Final, Native, Public, BlueprintCallable)

void ABulletMagicBase::OnDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletMagicBase", "OnDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.BulletMagicBase.OnHit
// (Final, Native, Public, BlueprintCallable)

void ABulletMagicBase::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletMagicBase", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ResidentDataManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UResidentDataManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UResidentDataManager* UResidentDataManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ResidentDataManager", "GetInstance");

	Params::ResidentDataManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BulletPath.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ABulletPath*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABulletPath* ABulletPath::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletPath", "Clone");

	Params::BulletPath_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.BulletPath.SetPathPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartTangent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndTangent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABulletPath::SetPathPoint(const struct FVector& Start, const struct FVector& End, const struct FVector& StartTangent, const struct FVector& EndTangent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletPath", "SetPathPoint");

	Params::BulletPath_SetPathPoint Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.StartTangent = std::move(StartTangent);
	Parms.EndTangent = std::move(EndTangent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.AllOpenToClose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::AllOpenToClose(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "AllOpenToClose");

	Params::CagecartDoorBase_AllOpenToClose Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.AllOpenToHalfOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::AllOpenToHalfOpen(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "AllOpenToHalfOpen");

	Params::CagecartDoorBase_AllOpenToHalfOpen Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.CloseToAllOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::CloseToAllOpen(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "CloseToAllOpen");

	Params::CagecartDoorBase_CloseToAllOpen Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.CloseToHalfOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::CloseToHalfOpen(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "CloseToHalfOpen");

	Params::CagecartDoorBase_CloseToHalfOpen Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.HalfOpenToAllOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::HalfOpenToAllOpen(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "HalfOpenToAllOpen");

	Params::CagecartDoorBase_HalfOpenToAllOpen Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.HalfOpenToClose
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::HalfOpenToClose(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "HalfOpenToClose");

	Params::CagecartDoorBase_HalfOpenToClose Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CagecartDoorBase.InitializeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACagecartDoorBase::InitializeState(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CagecartDoorBase", "InitializeState");

	Params::CagecartDoorBase_InitializeState Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_Fukidashi.SetBalloonData
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EFukidashiEnum                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_Fukidashi::SetBalloonData(EFukidashiEnum Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_Fukidashi", "SetBalloonData");

	Params::UISign_Fukidashi_SetBalloonData Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_Fukidashi.SetBalloonDataAdvance
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ETalkFukidashiType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETalkFukidashiColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_Fukidashi::SetBalloonDataAdvance(ETalkFukidashiType Type, ETalkFukidashiColor Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_Fukidashi", "SetBalloonDataAdvance");

	Params::UISign_Fukidashi_SetBalloonDataAdvance Parms{};

	Parms.Type = Type;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_Fukidashi.SetFukidashiData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFukidashiEnum                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             FukidashiText                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   CloseTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_Fukidashi::SetFukidashiData(EFukidashiEnum Type, const class FText& FukidashiText, float CloseTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_Fukidashi", "SetFukidashiData");

	Params::UISign_Fukidashi_SetFukidashiData Parms{};

	Parms.Type = Type;
	Parms.FukidashiText = std::move(FukidashiText);
	Parms.CloseTime = CloseTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_Fukidashi.SetFukidashiDataAdvance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FukidashiText                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CloseTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETalkFukidashiType                      Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETalkFukidashiColor                     Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_Fukidashi::SetFukidashiDataAdvance(const class FString& FukidashiText, float CloseTime, const ETalkFukidashiType Type, const ETalkFukidashiColor Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_Fukidashi", "SetFukidashiDataAdvance");

	Params::UISign_Fukidashi_SetFukidashiDataAdvance Parms{};

	Parms.FukidashiText = std::move(FukidashiText);
	Parms.CloseTime = CloseTime;
	Parms.Type = Type;
	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventTrigger.OnStartEvent
// (Final, Native, Protected, BlueprintCallable)

void AEventTrigger::OnStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "OnStartEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventTrigger.SetEventIDToEventSender
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             event_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::SetEventIDToEventSender(class FName event_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "SetEventIDToEventSender");

	Params::EventTrigger_SetEventIDToEventSender Parms{};

	Parms.event_id = event_id;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventTrigger.SetHitBoxSideNormal
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::SetHitBoxSideNormal(const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "SetHitBoxSideNormal");

	Params::EventTrigger_SetHitBoxSideNormal Parms{};

	Parms.Normal = std::move(Normal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventTrigger.SetIsOverlapEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    isOverlap                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::SetIsOverlapEvent(bool isOverlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "SetIsOverlapEvent");

	Params::EventTrigger_SetIsOverlapEvent Parms{};

	Parms.isOverlap = isOverlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventTrigger.SetOverlapActorLocation
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::SetOverlapActorLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "SetOverlapActorLocation");

	Params::EventTrigger_SetOverlapActorLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventTrigger.SetOverlapActorMovementVector
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::SetOverlapActorMovementVector(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "SetOverlapActorMovementVector");

	Params::EventTrigger_SetOverlapActorMovementVector Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventTrigger.CanPlayEventUniqueCondition
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             event_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventTrigger::CanPlayEventUniqueCondition(class FName event_id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "CanPlayEventUniqueCondition");

	Params::EventTrigger_CanPlayEventUniqueCondition Parms{};

	Parms.event_id = event_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventTrigger.Debug_IsNotPlayEvent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEventTrigger::Debug_IsNotPlayEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "Debug_IsNotPlayEvent");

	Params::EventTrigger_Debug_IsNotPlayEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.ApplyDitherParam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDitheringComponent::ApplyDitherParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "ApplyDitherParam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.ForceApplyDitherParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ForceAlpha                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDitheringComponent::ForceApplyDitherParam(float ForceAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "ForceApplyDitherParam");

	Params::DitheringComponent_ForceApplyDitherParam Parms{};

	Parms.ForceAlpha = ForceAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.GetAttachedChildren
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UDitheringComponent*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UDitheringComponent*> UDitheringComponent::GetAttachedChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "GetAttachedChildren");

	Params::DitheringComponent_GetAttachedChildren Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.GetMesh
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* UDitheringComponent::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "GetMesh");

	Params::DitheringComponent_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.SetAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Alpha_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDitheringComponent::SetAlpha(float Alpha_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "SetAlpha");

	Params::DitheringComponent_SetAlpha Parms{};

	Parms.Alpha_0 = Alpha_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.SetDirty
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    dirty                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDitheringComponent::SetDirty(bool dirty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "SetDirty");

	Params::DitheringComponent_SetDirty Parms{};

	Parms.dirty = dirty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.SetEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    enable_0                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDitheringComponent::SetEnable(bool enable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "SetEnable");

	Params::DitheringComponent_SetEnable Parms{};

	Parms.enable_0 = enable_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.SetFadeEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    enable_0                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDitheringComponent::SetFadeEnable(bool enable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "SetFadeEnable");

	Params::DitheringComponent_SetFadeEnable Parms{};

	Parms.enable_0 = enable_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.SetOffset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Offset_0                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDitheringComponent::SetOffset(int32 Offset_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "SetOffset");

	Params::DitheringComponent_SetOffset Parms{};

	Parms.Offset_0 = Offset_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringComponent.CheckTickDisable
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDitheringComponent::CheckTickDisable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "CheckTickDisable");

	Params::DitheringComponent_CheckTickDisable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.GetAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDitheringComponent::GetAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "GetAlpha");

	Params::DitheringComponent_GetAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.GetDirty
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDitheringComponent::GetDirty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "GetDirty");

	Params::DitheringComponent_GetDirty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.GetEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDitheringComponent::GetEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "GetEnable");

	Params::DitheringComponent_GetEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.GetFadeEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDitheringComponent::GetFadeEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "GetFadeEnable");

	Params::DitheringComponent_GetFadeEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringComponent.IsDithering
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDitheringComponent::IsDithering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringComponent", "IsDithering");

	Params::DitheringComponent_IsDithering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SwitchDitheringComponent.CalcAlpha
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    switchEnable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USwitchDitheringComponent::CalcAlpha(bool switchEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchDitheringComponent", "CalcAlpha");

	Params::SwitchDitheringComponent_CalcAlpha Parms{};

	Parms.switchEnable = switchEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SwitchDitheringComponent.SetSwitchAlphaEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    switchEnable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchDitheringComponent::SetSwitchAlphaEnable(bool switchEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchDitheringComponent", "SetSwitchAlphaEnable");

	Params::SwitchDitheringComponent_SetSwitchAlphaEnable Parms{};

	Parms.switchEnable = switchEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchDitheringComponent.GetSwitchAlpha
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USwitchDitheringComponent::GetSwitchAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchDitheringComponent", "GetSwitchAlpha");

	Params::SwitchDitheringComponent_GetSwitchAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SceneCaptureUtility.SpawnCapture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Capture                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASceneCaptureBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASceneCaptureBase* USceneCaptureUtility::SpawnCapture(TSoftClassPtr<class UClass> Capture, class UTextureRenderTarget2D* RenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneCaptureUtility", "SpawnCapture");

	Params::SceneCaptureUtility_SpawnCapture Parms{};

	Parms.Capture = Capture;
	Parms.RenderTarget = RenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SceneCaptureUtility.SpawnCaptureLight
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             DirectionalLight                                       (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ADirectionalLight*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADirectionalLight* USceneCaptureUtility::SpawnCaptureLight(TSoftClassPtr<class UClass> DirectionalLight, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneCaptureUtility", "SpawnCaptureLight");

	Params::SceneCaptureUtility_SpawnCaptureLight Parms{};

	Parms.DirectionalLight = DirectionalLight;
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SceneCaptureUtility.SpawnCaptureLightActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Light                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* USceneCaptureUtility::SpawnCaptureLightActor(TSoftClassPtr<class UClass> Light)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneCaptureUtility", "SpawnCaptureLightActor");

	Params::SceneCaptureUtility_SpawnCaptureLightActor Parms{};

	Parms.Light = Light;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SceneCaptureUtility.SpawnTwoCameraCapture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Capture                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           SubRenderTarge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASceneCaptureBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASceneCaptureBase* USceneCaptureUtility::SpawnTwoCameraCapture(TSoftClassPtr<class UClass> Capture, class UTextureRenderTarget2D* RenderTarget, class UTextureRenderTarget2D* SubRenderTarge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SceneCaptureUtility", "SpawnTwoCameraCapture");

	Params::SceneCaptureUtility_SpawnTwoCameraCapture Parms{};

	Parms.Capture = Capture;
	Parms.RenderTarget = RenderTarget;
	Parms.SubRenderTarge = SubRenderTarge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CameraDitheringComponent.Enter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UCameraDitheringComponent::Enter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraDitheringComponent", "Enter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CameraDitheringComponent.Exit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UCameraDitheringComponent::Exit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraDitheringComponent", "Exit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CameraInterface.AssistMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  TargetToAim                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICameraInterface::AssistMode(bool bEnd, class USceneComponent* TargetToAim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraInterface", "AssistMode");

	Params::CameraInterface_AssistMode Parms{};

	Parms.bEnd = bEnd;
	Parms.TargetToAim = TargetToAim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CameraInterface.BattleMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICameraInterface::BattleMode(bool bEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraInterface", "BattleMode");

	Params::CameraInterface_BattleMode Parms{};

	Parms.bEnd = bEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CameraInterface.ChangeState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     NextStateTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICameraInterface::ChangeState(const struct FGameplayTag& NextStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraInterface", "ChangeState");

	Params::CameraInterface_ChangeState Parms{};

	Parms.NextStateTag = std::move(NextStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CameraInterface.DirectionMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraDirectionType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICameraInterface::DirectionMode(bool bEnd, ECameraDirectionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraInterface", "DirectionMode");

	Params::CameraInterface_DirectionMode Parms{};

	Parms.bEnd = bEnd;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CameraInterface.GetCamera
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ICameraInterface::GetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraInterface", "GetCamera");

	Params::CameraInterface_GetCamera Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.PointEnvironmentSoundBase.SetCurrentPatternID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnvironmentSoundPatternID              ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointEnvironmentSoundBase::SetCurrentPatternID(EEnvironmentSoundPatternID ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointEnvironmentSoundBase", "SetCurrentPatternID");

	Params::PointEnvironmentSoundBase_SetCurrentPatternID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RiverEnvSound.OnSoundActiveRangeBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URiverEnvSound::OnSoundActiveRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverEnvSound", "OnSoundActiveRangeBeginOverlap");

	Params::RiverEnvSound_OnSoundActiveRangeBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RiverEnvSound.OnSoundActiveRangeEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URiverEnvSound::OnSoundActiveRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverEnvSound", "OnSoundActiveRangeEndOverlap");

	Params::RiverEnvSound_OnSoundActiveRangeEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStationLandIconMark.PlayLoopAnim
// (Final, Native, Protected)

void UUIStationLandIconMark::PlayLoopAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStationLandIconMark", "PlayLoopAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ChangeAreaTriggerBase.OnBeginOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChangeAreaTriggerBase::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChangeAreaTriggerBase", "OnBeginOverlap");

	Params::ChangeAreaTriggerBase_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ChangeAreaTriggerBase.OnEndOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChangeAreaTriggerBase::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChangeAreaTriggerBase", "OnEndOverlap");

	Params::ChangeAreaTriggerBase_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataQuest.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataQuest*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataQuest* UGameDataQuest::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataQuest", "Clone");

	Params::GameDataQuest_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataQuest.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataQuest*                   game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataQuest::Overwrite(class UGameDataQuest* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataQuest", "Overwrite");

	Params::GameDataQuest_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.EndCurveMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::EndCurveMove(bool bLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "EndCurveMove");

	Params::SwitchCollisionMovementComponent_EndCurveMove Parms{};

	Parms.bLoop = bLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.SetCurveMoveEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::SetCurveMoveEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "SetCurveMoveEnabled");

	Params::SwitchCollisionMovementComponent_SetCurveMoveEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.SetDirectionOFRootMotion
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::SetDirectionOFRootMotion(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "SetDirectionOFRootMotion");

	Params::SwitchCollisionMovementComponent_SetDirectionOFRootMotion Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.SetFallStartLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::SetFallStartLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "SetFallStartLocation");

	Params::SwitchCollisionMovementComponent_SetFallStartLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.SetMoveOnCurve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::SetMoveOnCurve(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "SetMoveOnCurve");

	Params::SwitchCollisionMovementComponent_SetMoveOnCurve Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.SetMoveValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MoveValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::SetMoveValue(float MoveValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "SetMoveValue");

	Params::SwitchCollisionMovementComponent_SetMoveValue Parms{};

	Parms.MoveValue = MoveValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.SetOverrideRootMotionVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USwitchCollisionMovementComponent::SetOverrideRootMotionVelocity(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "SetOverrideRootMotionVelocity");

	Params::SwitchCollisionMovementComponent_SetOverrideRootMotionVelocity Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.StartCurveMove
// (Final, Native, Public, BlueprintCallable)

void USwitchCollisionMovementComponent::StartCurveMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "StartCurveMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SwitchCollisionMovementComponent.CalculateJumpZVelocity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USwitchCollisionMovementComponent::CalculateJumpZVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "CalculateJumpZVelocity");

	Params::SwitchCollisionMovementComponent_CalculateJumpZVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SwitchCollisionMovementComponent.GetCurrentSinkValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const float USwitchCollisionMovementComponent::GetCurrentSinkValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "GetCurrentSinkValue");

	Params::SwitchCollisionMovementComponent_GetCurrentSinkValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SwitchCollisionMovementComponent.IsActionableBurial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USwitchCollisionMovementComponent::IsActionableBurial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "IsActionableBurial");

	Params::SwitchCollisionMovementComponent_IsActionableBurial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SwitchCollisionMovementComponent.IsMovingOnCurve
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USwitchCollisionMovementComponent::IsMovingOnCurve() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "IsMovingOnCurve");

	Params::SwitchCollisionMovementComponent_IsMovingOnCurve Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SwitchCollisionMovementComponent.IsSinking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USwitchCollisionMovementComponent::IsSinking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwitchCollisionMovementComponent", "IsSinking");

	Params::SwitchCollisionMovementComponent_IsSinking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmojiIconDataTable.GetEmojiIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             emojiId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_EmojiIconData                emojiIcon                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UEmojiIconDataTable::GetEmojiIcon(const class FName& emojiId, struct FST_EmojiIconData* emojiIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmojiIconDataTable", "GetEmojiIcon");

	Params::EmojiIconDataTable_GetEmojiIcon Parms{};

	Parms.emojiId = emojiId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (emojiIcon != nullptr)
		*emojiIcon = std::move(Parms.emojiIcon);
}


// Function DarwinGame.EmojiIconDataTable.GetEmojiPlatformIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             emojiId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_ResourceInputIcons           emojiIcon                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// int32                                   GetCurrentKeyMap                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmojiIconDataTable::GetEmojiPlatformIcon(const class FName& emojiId, struct FST_ResourceInputIcons* emojiIcon, int32 GetCurrentKeyMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmojiIconDataTable", "GetEmojiPlatformIcon");

	Params::EmojiIconDataTable_GetEmojiPlatformIcon Parms{};

	Parms.emojiId = emojiId;
	Parms.GetCurrentKeyMap = GetCurrentKeyMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (emojiIcon != nullptr)
		*emojiIcon = std::move(Parms.emojiIcon);
}


// Function DarwinGame.UIField_WinTutorial.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TableName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinTutorial::SetData(class FName TableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinTutorial", "SetData");

	Params::UIField_WinTutorial_SetData Parms{};

	Parms.TableName = TableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinTutorial.SetTextData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)

void UUIField_WinTutorial::SetTextData(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinTutorial", "SetTextData");

	Params::UIField_WinTutorial_SetTextData Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SealStatusInterface.SetReflectionRelease
// (Native, Public, BlueprintCallable)

void ISealStatusInterface::SetReflectionRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SealStatusInterface", "SetReflectionRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SealStatusInterface.SetReflectionSeal
// (Native, Public, BlueprintCallable)

void ISealStatusInterface::SetReflectionSeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SealStatusInterface", "SetReflectionSeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SealStatusInterface.ToReflectionRelease
// (Native, Public, BlueprintCallable)

void ISealStatusInterface::ToReflectionRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SealStatusInterface", "ToReflectionRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SealStatusInterface.ToReflectionSeal
// (Native, Public, BlueprintCallable)

void ISealStatusInterface::ToReflectionSeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SealStatusInterface", "ToReflectionSeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStationLandIcon.PlayWaitAnim
// (Final, Native, Protected)

void UUIStationLandIcon::PlayWaitAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStationLandIcon", "PlayWaitAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DataTableExportLibrary.ConvertRotaterToCSVString
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Rotator                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDataTableExportLibrary::ConvertRotaterToCSVString(const struct FRotator& Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "ConvertRotaterToCSVString");

	Params::DataTableExportLibrary_ConvertRotaterToCSVString Parms{};

	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DataTableExportLibrary.ConvertVectorToCSVString
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDataTableExportLibrary::ConvertVectorToCSVString(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "ConvertVectorToCSVString");

	Params::DataTableExportLibrary_ConvertVectorToCSVString Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DataTableExportLibrary.CreateDataTableCSVHeader
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    ExportDataTableStruct                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDataTableExportLibrary::CreateDataTableCSVHeader(class UScriptStruct* ExportDataTableStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "CreateDataTableCSVHeader");

	Params::DataTableExportLibrary_CreateDataTableCSVHeader Parms{};

	Parms.ExportDataTableStruct = ExportDataTableStruct;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DataTableExportLibrary.CreateLocationAndRotationCSVLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           CsvLine                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataTableExportLibrary::CreateLocationAndRotationCSVLine(const class FName ID, const struct FVector& Position, const struct FRotator& Rotation, class FString* CsvLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "CreateLocationAndRotationCSVLine");

	Params::DataTableExportLibrary_CreateLocationAndRotationCSVLine Parms{};

	Parms.ID = ID;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CsvLine != nullptr)
		*CsvLine = std::move(Parms.CsvLine);
}


// Function DarwinGame.DataTableExportLibrary.CreatePointCSVLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CsvLine                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataTableExportLibrary::CreatePointCSVLine(const class FName ID, const struct FVector& Position, const struct FRotator& Rotation, const struct FVector& Scale, class FString* CsvLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "CreatePointCSVLine");

	Params::DataTableExportLibrary_CreatePointCSVLine Parms{};

	Parms.ID = ID;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CsvLine != nullptr)
		*CsvLine = std::move(Parms.CsvLine);
}


// Function DarwinGame.DataTableExportLibrary.CreateQuestDestinationRectCSVLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Size                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestDestinationRectShapeType          Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRandom                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CsvLine                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataTableExportLibrary::CreateQuestDestinationRectCSVLine(const class FName ID, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Size, const EQuestDestinationRectShapeType Type, const class FName AreaID, const bool IsRandom, class FString* CsvLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "CreateQuestDestinationRectCSVLine");

	Params::DataTableExportLibrary_CreateQuestDestinationRectCSVLine Parms{};

	Parms.ID = ID;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Size = std::move(Size);
	Parms.Type = Type;
	Parms.AreaID = AreaID;
	Parms.IsRandom = IsRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CsvLine != nullptr)
		*CsvLine = std::move(Parms.CsvLine);
}


// Function DarwinGame.DataTableExportLibrary.FillDataTableFromCSVString
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CSVHeader                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CSVRowData                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataTableExportLibrary::FillDataTableFromCSVString(class UDataTable* DataTable, const class FString& CSVHeader, const class FString& CSVRowData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DataTableExportLibrary", "FillDataTableFromCSVString");

	Params::DataTableExportLibrary_FillDataTableFromCSVString Parms{};

	Parms.DataTable = DataTable;
	Parms.CSVHeader = std::move(CSVHeader);
	Parms.CSVRowData = std::move(CSVRowData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterAssetManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCharacterAssetManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterAssetManager* UCharacterAssetManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterAssetManager", "GetInstance");

	Params::CharacterAssetManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterAssetManager.RequestCommonASyncLoadActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCommonSpawnParam                spawnParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class FName ID, struct FCommonSpawnParam& spawnParam)>onEvent                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterAssetManager::RequestCommonASyncLoadActor(const class FName& ID, const struct FCommonSpawnParam& spawnParam, const TDelegate<void(class FName ID, struct FCommonSpawnParam& spawnParam)>& onEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAssetManager", "RequestCommonASyncLoadActor");

	Params::CharacterAssetManager_RequestCommonASyncLoadActor Parms{};

	Parms.ID = ID;
	Parms.spawnParam = std::move(spawnParam);
	Parms.onEvent = onEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterAssetManager.RequestSimpleASyncLoadActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class FName ID, struct FTransform& Transform)>onEvent                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterAssetManager::RequestSimpleASyncLoadActor(const class FName& ID, const struct FTransform& Transform, const TDelegate<void(class FName ID, struct FTransform& Transform)>& onEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAssetManager", "RequestSimpleASyncLoadActor");

	Params::CharacterAssetManager_RequestSimpleASyncLoadActor Parms{};

	Parms.ID = ID;
	Parms.Transform = std::move(Transform);
	Parms.onEvent = onEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataStation.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataStation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataStation* UGameDataStation::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStation", "Clone");

	Params::GameDataStation_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStation.ExistElevator
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataStation::ExistElevator(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStation", "ExistElevator");

	Params::GameDataStation_ExistElevator Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStation.GetConsoleLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameDataStation::GetConsoleLocation(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStation", "GetConsoleLocation");

	Params::GameDataStation_GetConsoleLocation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStation.GetElevatorLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameDataStation::GetElevatorLocation(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStation", "GetElevatorLocation");

	Params::GameDataStation_GetElevatorLocation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStation.GetStationLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameDataStation::GetStationLocation(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStation", "GetStationLocation");

	Params::GameDataStation_GetStationLocation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStation.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataStation*                 game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataStation::Overwrite(class UGameDataStation* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStation", "Overwrite");

	Params::GameDataStation_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetObjectManager.SpawnTargetObjectFromArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAreaType                               AreaType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetObjectManager::SpawnTargetObjectFromArea(EAreaType AreaType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetObjectManager", "SpawnTargetObjectFromArea");

	Params::TargetObjectManager_SpawnTargetObjectFromArea Parms{};

	Parms.AreaType = AreaType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_02.ItemChangeFocusCallback
// (Final, Native, Protected)

void UUIItemmenu_02::ItemChangeFocusCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_02", "ItemChangeFocusCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DebugLauncherActor.UpdateInput
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamePaused                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKeyInput                        KeyInput                                               (Parm, NativeAccessSpecifierPublic)
// struct FKeyInput                        OutKeyInput                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FEventReply                      Output                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void ADebugLauncherActor::UpdateInput(const float DeltaTime, const bool bGamePaused, const struct FKeyInput& KeyInput, struct FKeyInput* OutKeyInput, struct FEventReply* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugLauncherActor", "UpdateInput");

	Params::DebugLauncherActor_UpdateInput Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.bGamePaused = bGamePaused;
	Parms.KeyInput = std::move(KeyInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKeyInput != nullptr)
		*OutKeyInput = std::move(Parms.OutKeyInput);

	if (Output != nullptr)
		*Output = std::move(Parms.Output);
}


// Function DarwinGame.DebugLauncherActor.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADebugLauncherActor::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugLauncherActor", "IsActive");

	Params::DebugLauncherActor_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DebugLauncherActor.IsIdle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADebugLauncherActor::IsIdle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugLauncherActor", "IsIdle");

	Params::DebugLauncherActor_IsIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.CalcFloorStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_Status                       Status                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::CalcFloorStatus(const struct FST_Status& Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "CalcFloorStatus");

	Params::CharacterCalculationFunctionLibrary_CalcFloorStatus Parms{};

	Parms.Status = std::move(Status);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.CalculateAttributeStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_Status                       outAttributePercentage                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TMap<class FName, int32>                AttributeList                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::CalculateAttributeStatus(struct FST_Status* outAttributePercentage, const TMap<class FName, int32>& AttributeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "CalculateAttributeStatus");

	Params::CharacterCalculationFunctionLibrary_CalculateAttributeStatus Parms{};

	Parms.AttributeList = std::move(AttributeList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outAttributePercentage != nullptr)
		*outAttributePercentage = std::move(Parms.outAttributePercentage);
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.CalculateCoinStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFeatureEffectStatusResult       outResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<struct FST_CoinData>             Coins                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::CalculateCoinStatus(struct FFeatureEffectStatusResult* outResult, const TArray<struct FST_CoinData>& Coins)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "CalculateCoinStatus");

	Params::CharacterCalculationFunctionLibrary_CalculateCoinStatus Parms{};

	Parms.Coins = std::move(Coins);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outResult != nullptr)
		*outResult = std::move(Parms.outResult);
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.CalculateFeatureStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFeatureEffectStatusResult       outResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<struct FFeaturePossessionInfo>   Features                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMainPartyMonster                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::CalculateFeatureStatus(struct FFeatureEffectStatusResult* outResult, const TArray<struct FFeaturePossessionInfo>& Features, bool IsMainPartyMonster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "CalculateFeatureStatus");

	Params::CharacterCalculationFunctionLibrary_CalculateFeatureStatus Parms{};

	Parms.Features = std::move(Features);
	Parms.IsMainPartyMonster = IsMainPartyMonster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outResult != nullptr)
		*outResult = std::move(Parms.outResult);
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.CalculateFoodStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFoodEffectStatusResult          outFoodResult                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     FoodList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::CalculateFoodStatus(struct FFoodEffectStatusResult* outFoodResult, class FName KindId, const TArray<class FName>& FoodList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "CalculateFoodStatus");

	Params::CharacterCalculationFunctionLibrary_CalculateFoodStatus Parms{};

	Parms.KindId = KindId;
	Parms.FoodList = std::move(FoodList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outFoodResult != nullptr)
		*outFoodResult = std::move(Parms.outFoodResult);
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetAdvanceStatus_FriendMonster
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameDataFriendMonster           dataFriend                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    isMaxHp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetAdvanceStatus_FriendMonster(const struct FGameDataFriendMonster& dataFriend, bool isMaxHp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetAdvanceStatus_FriendMonster");

	Params::CharacterCalculationFunctionLibrary_GetAdvanceStatus_FriendMonster Parms{};

	Parms.dataFriend = std::move(dataFriend);
	Parms.isMaxHp = isMaxHp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetBaseStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       IndividualValue                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetBaseStatus(class FName KindId, int32 Level, const struct FST_Status& IndividualValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetBaseStatus");

	Params::CharacterCalculationFunctionLibrary_GetBaseStatus Parms{};

	Parms.KindId = KindId;
	Parms.Level = Level;
	Parms.IndividualValue = std::move(IndividualValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetCorrectedStandardStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       levelRate                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FST_Status                       Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetCorrectedStandardStatus(class FName KindId, int32 Level, const struct FST_Status& levelRate, const struct FST_Status& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetCorrectedStandardStatus");

	Params::CharacterCalculationFunctionLibrary_GetCorrectedStandardStatus Parms{};

	Parms.KindId = KindId;
	Parms.Level = Level;
	Parms.levelRate = std::move(levelRate);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetDungeonStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterType                            MonsterType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       levelRate                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FST_Status                       Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetDungeonStatus(class FName KindId, int32 Level, EMonsterType MonsterType, const struct FST_Status& levelRate, const struct FST_Status& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetDungeonStatus");

	Params::CharacterCalculationFunctionLibrary_GetDungeonStatus Parms{};

	Parms.KindId = KindId;
	Parms.Level = Level;
	Parms.MonsterType = MonsterType;
	Parms.levelRate = std::move(levelRate);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetIndividualStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetIndividualStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetIndividualStatus");

	Params::CharacterCalculationFunctionLibrary_GetIndividualStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetStandardStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetStandardStatus(class FName KindId, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetStandardStatus");

	Params::CharacterCalculationFunctionLibrary_GetStandardStatus Parms{};

	Parms.KindId = KindId;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_Status                       AdvanceStatus                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FFeatureEffectStatusResult       CoinStatus                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FFeatureEffectStatusResult       conditionalFeature                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FFoodEffectStatusResult          FoodStatus                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FST_Status                       AttributePercentage                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    isBelongToAlly                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetStatus(const struct FST_Status& AdvanceStatus, const struct FFeatureEffectStatusResult& CoinStatus, const struct FFeatureEffectStatusResult& conditionalFeature, const struct FFoodEffectStatusResult& FoodStatus, const struct FST_Status& AttributePercentage, bool isBelongToAlly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetStatus");

	Params::CharacterCalculationFunctionLibrary_GetStatus Parms{};

	Parms.AdvanceStatus = std::move(AdvanceStatus);
	Parms.CoinStatus = std::move(CoinStatus);
	Parms.conditionalFeature = std::move(conditionalFeature);
	Parms.FoodStatus = std::move(FoodStatus);
	Parms.AttributePercentage = std::move(AttributePercentage);
	Parms.isBelongToAlly = isBelongToAlly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.GetStatus_FriendMonster
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameDataFriendMonster           dataFriend                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    isMaxHp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UCharacterCalculationFunctionLibrary::GetStatus_FriendMonster(const struct FGameDataFriendMonster& dataFriend, bool isMaxHp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "GetStatus_FriendMonster");

	Params::CharacterCalculationFunctionLibrary_GetStatus_FriendMonster Parms{};

	Parms.dataFriend = std::move(dataFriend);
	Parms.isMaxHp = isMaxHp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.IsMainParty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameDataFriendMonster           friendMonster                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCalculationFunctionLibrary::IsMainParty(const struct FGameDataFriendMonster& friendMonster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "IsMainParty");

	Params::CharacterCalculationFunctionLibrary_IsMainParty Parms{};

	Parms.friendMonster = std::move(friendMonster);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.TakeBreakFriendMonsterDataBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::TakeBreakFriendMonsterDataBase(int32 Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "TakeBreakFriendMonsterDataBase");

	Params::CharacterCalculationFunctionLibrary_TakeBreakFriendMonsterDataBase Parms{};

	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.TakeBreakFriendMonsterOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsUIAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::TakeBreakFriendMonsterOnly(int32 Percentage, bool IsUIAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "TakeBreakFriendMonsterOnly");

	Params::CharacterCalculationFunctionLibrary_TakeBreakFriendMonsterOnly Parms{};

	Parms.Percentage = Percentage;
	Parms.IsUIAnim = IsUIAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.TakeBreakPlayerOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsUIAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::TakeBreakPlayerOnly(int32 Percentage, bool IsUIAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "TakeBreakPlayerOnly");

	Params::CharacterCalculationFunctionLibrary_TakeBreakPlayerOnly Parms{};

	Parms.Percentage = Percentage;
	Parms.IsUIAnim = IsUIAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterCalculationFunctionLibrary.TakeBreakPlayerSide
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsUIAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCalculationFunctionLibrary::TakeBreakPlayerSide(int32 Percentage, bool IsUIAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCalculationFunctionLibrary", "TakeBreakPlayerSide");

	Params::CharacterCalculationFunctionLibrary_TakeBreakPlayerSide Parms{};

	Parms.Percentage = Percentage;
	Parms.IsUIAnim = IsUIAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SaveGameFunctionLibrary.ExecuteAllSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameFunctionLibrary::ExecuteAllSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameFunctionLibrary", "ExecuteAllSave");

	Params::SaveGameFunctionLibrary_ExecuteAllSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SaveGameFunctionLibrary.ExecuteAutoSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameFunctionLibrary::ExecuteAutoSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameFunctionLibrary", "ExecuteAutoSave");

	Params::SaveGameFunctionLibrary_ExecuteAutoSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SaveGameFunctionLibrary.ExecuteAutoSaveLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EPersistentLevelID                      persisten_level_id                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameFunctionLibrary::ExecuteAutoSaveLocation(const struct FVector& Location, const struct FRotator& Rotation, EPersistentLevelID persisten_level_id, class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameFunctionLibrary", "ExecuteAutoSaveLocation");

	Params::SaveGameFunctionLibrary_ExecuteAutoSaveLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.persisten_level_id = persisten_level_id;
	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SaveGameFunctionLibrary.ExecuteCommonSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameFunctionLibrary::ExecuteCommonSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameFunctionLibrary", "ExecuteCommonSave");

	Params::SaveGameFunctionLibrary_ExecuteCommonSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SaveGameFunctionLibrary.ExecuteManualSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameFunctionLibrary::ExecuteManualSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameFunctionLibrary", "ExecuteManualSave");

	Params::SaveGameFunctionLibrary_ExecuteManualSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SaveGameFunctionLibrary.IsAutoSaveNow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USaveGameFunctionLibrary::IsAutoSaveNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveGameFunctionLibrary", "IsAutoSaveNow");

	Params::SaveGameFunctionLibrary_IsAutoSaveNow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIEvent_FullScreenImageBase.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ImageKey                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIEvent_FullScreenImageBase::SetData(const class FName& ImageKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEvent_FullScreenImageBase", "SetData");

	Params::UIEvent_FullScreenImageBase_SetData Parms{};

	Parms.ImageKey = ImageKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterFunctionLibrary.AddPlayerMoney
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Money                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterFunctionLibrary::AddPlayerMoney(int32 Money)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "AddPlayerMoney");

	Params::CharacterFunctionLibrary_AddPlayerMoney Parms{};

	Parms.Money = Money;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterFunctionLibrary.ChangePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterFunctionLibrary::ChangePlayer(class FName KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "ChangePlayer");

	Params::CharacterFunctionLibrary_ChangePlayer Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterFunctionLibrary.FindActionDetailIDByActionOverViewID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionOverviewID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UCharacterFunctionLibrary::FindActionDetailIDByActionOverViewID(class FName ActionOverviewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "FindActionDetailIDByActionOverViewID");

	Params::CharacterFunctionLibrary_FindActionDetailIDByActionOverViewID Parms{};

	Parms.ActionOverviewID = ActionOverviewID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.GetBrave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<EBraveReason>                    BraveReasons                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterFunctionLibrary::GetBrave(const TArray<EBraveReason>& BraveReasons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "GetBrave");

	Params::CharacterFunctionLibrary_GetBrave Parms{};

	Parms.BraveReasons = std::move(BraveReasons);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterFunctionLibrary.GetHostilityRegisterType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterRegisterType UCharacterFunctionLibrary::GetHostilityRegisterType(class AGPACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "GetHostilityRegisterType");

	Params::CharacterFunctionLibrary_GetHostilityRegisterType Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.GetRegisterType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterRegisterType UCharacterFunctionLibrary::GetRegisterType(class AGPACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "GetRegisterType");

	Params::CharacterFunctionLibrary_GetRegisterType Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.IsGroupMate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    character00                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    character01                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterFunctionLibrary::IsGroupMate(class AGPACharacter* character00, class AGPACharacter* character01)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "IsGroupMate");

	Params::CharacterFunctionLibrary_IsGroupMate Parms{};

	Parms.character00 = character00;
	Parms.character01 = character01;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.MakeEmoteBlinkOverwriteOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEmoteBlinkOverwriteOption*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmoteBlinkOverwriteOption* UCharacterFunctionLibrary::MakeEmoteBlinkOverwriteOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "MakeEmoteBlinkOverwriteOption");

	Params::CharacterFunctionLibrary_MakeEmoteBlinkOverwriteOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.MakeEmoteRuntimeOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEmoteRuntimeOption*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmoteRuntimeOption* UCharacterFunctionLibrary::MakeEmoteRuntimeOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "MakeEmoteRuntimeOption");

	Params::CharacterFunctionLibrary_MakeEmoteRuntimeOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.MakeEmoteStampOverwriteOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEmoteStampOverwriteOption*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmoteStampOverwriteOption* UCharacterFunctionLibrary::MakeEmoteStampOverwriteOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "MakeEmoteStampOverwriteOption");

	Params::CharacterFunctionLibrary_MakeEmoteStampOverwriteOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.MakeEmoteVocalizeOverwriteOption
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEmoteVocalizeOverwriteOption*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEmoteVocalizeOverwriteOption* UCharacterFunctionLibrary::MakeEmoteVocalizeOverwriteOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "MakeEmoteVocalizeOverwriteOption");

	Params::CharacterFunctionLibrary_MakeEmoteVocalizeOverwriteOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterFunctionLibrary.UseBrave
// (Final, Native, Static, Public, BlueprintCallable)

void UCharacterFunctionLibrary::UseBrave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterFunctionLibrary", "UseBrave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInputInterface.ComboKeyAction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInputInterface::ComboKeyAction(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInputInterface", "ComboKeyAction");

	Params::CharacterInputInterface_ComboKeyAction Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInputInterface.FilterFaceButtonInputs
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInputInterface::FilterFaceButtonInputs(EAxisMappingType Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInputInterface", "FilterFaceButtonInputs");

	Params::CharacterInputInterface_FilterFaceButtonInputs Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInputInterface.Move
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInputInterface::Move(const struct FVector& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInputInterface", "Move");

	Params::CharacterInputInterface_Move Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInputInterface.OnInputInterrupted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInputInterface::OnInputInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInputInterface", "OnInputInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInputInterface.Rotate
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInputInterface::Rotate(const struct FVector& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInputInterface", "Rotate");

	Params::CharacterInputInterface_Rotate Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInputInterface.TakeAction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInputInterface::TakeAction(const struct FGameplayTag& Tag, bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInputInterface", "TakeAction");

	Params::CharacterInputInterface_TakeAction Parms{};

	Parms.Tag = std::move(Tag);
	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.Aim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::Aim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "Aim");

	Params::CharacterInterface_Aim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ApplyAttribute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ApplyAttribute(class FName AttributeID, int32 AddLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ApplyAttribute");

	Params::CharacterInterface_ApplyAttribute Parms{};

	Parms.AttributeID = AttributeID;
	Parms.AddLevel = AddLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ApplyAttributeGameplayEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AttributeID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle ICharacterInterface::ApplyAttributeGameplayEffect(const class FName AttributeID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ApplyAttributeGameplayEffect");

	Params::CharacterInterface_ApplyAttributeGameplayEffect Parms{};

	Parms.AttributeID = AttributeID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.ApplyAttributeGameplayEffectWithLotteryData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AGPACharacter*                    Sorce                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLotteryAttributeParam           Lottery                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle ICharacterInterface::ApplyAttributeGameplayEffectWithLotteryData(class AGPACharacter* Sorce, const class FName AttributeID, int32 Level, const struct FLotteryAttributeParam& Lottery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ApplyAttributeGameplayEffectWithLotteryData");

	Params::CharacterInterface_ApplyAttributeGameplayEffectWithLotteryData Parms{};

	Parms.Sorce = Sorce;
	Parms.AttributeID = AttributeID;
	Parms.Level = Level;
	Parms.Lottery = std::move(Lottery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.ApplyDeathGameplayEffect
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDeadCause                       Cause                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle ICharacterInterface::ApplyDeathGameplayEffect(const struct FDeadCause& Cause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ApplyDeathGameplayEffect");

	Params::CharacterInterface_ApplyDeathGameplayEffect Parms{};

	Parms.Cause = std::move(Cause);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.CallEndLink
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::CallEndLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "CallEndLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.CancelAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)

void ICharacterInterface::CancelAbility(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "CancelAbility");

	Params::CharacterInterface_CancelAbility Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.CancelActionState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::CancelActionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "CancelActionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeAbnormalState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     NextAbnormalStateTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ChangeAbnormalState(const struct FGameplayTag& NextAbnormalStateTag, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeAbnormalState");

	Params::CharacterInterface_ChangeAbnormalState Parms{};

	Parms.NextAbnormalStateTag = std::move(NextAbnormalStateTag);
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeActionState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     NextActionStateTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ChangeActionState(const struct FGameplayTag& NextActionStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeActionState");

	Params::CharacterInterface_ChangeActionState Parms{};

	Parms.NextActionStateTag = std::move(NextActionStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeActionStateWithResult
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     NextActionStateTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionResult                    ActionResult                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ICharacterInterface::ChangeActionStateWithResult(const struct FGameplayTag& NextActionStateTag, const struct FActionResult& ActionResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeActionStateWithResult");

	Params::CharacterInterface_ChangeActionStateWithResult Parms{};

	Parms.NextActionStateTag = std::move(NextActionStateTag);
	Parms.ActionResult = std::move(ActionResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeDefaultMoveState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::ChangeDefaultMoveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeDefaultMoveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeMoveState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     NextMoveStateTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ChangeMoveState(const struct FGameplayTag& NextMoveStateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeMoveState");

	Params::CharacterInterface_ChangeMoveState Parms{};

	Parms.NextMoveStateTag = std::move(NextMoveStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeOpeMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EOperationModeEnum                      Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ChangeOpeMode(EOperationModeEnum Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeOpeMode");

	Params::CharacterInterface_ChangeOpeMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ChangeStatus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ChangeStatus(int32 BitMask, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ChangeStatus");

	Params::CharacterInterface_ChangeStatus Parms{};

	Parms.BitMask = BitMask;
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.CloseLinkMenu
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::CloseLinkMenu(ELinkType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "CloseLinkMenu");

	Params::CharacterInterface_CloseLinkMenu Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.DebugMoveMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::DebugMoveMode(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "DebugMoveMode");

	Params::CharacterInterface_DebugMoveMode Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.DetachEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           HandleID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::DetachEffect(const class FString& HandleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "DetachEffect");

	Params::CharacterInterface_DetachEffect Parms{};

	Parms.HandleID = std::move(HandleID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.EndActionState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::EndActionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "EndActionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.EndLink
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bCanceled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::EndLink(bool bCanceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "EndLink");

	Params::CharacterInterface_EndLink Parms{};

	Parms.bCanceled = bCanceled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.Equip
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             equipmentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESocket                                 SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::Equip(class FName equipmentName, ESocket SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "Equip");

	Params::CharacterInterface_Equip Parms{};

	Parms.equipmentName = equipmentName;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ExecuteAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::ExecuteAbility(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ExecuteAbility");

	Params::CharacterInterface_ExecuteAbility Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.ExecuteLinkAction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ExecuteLinkAction(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ExecuteLinkAction");

	Params::CharacterInterface_ExecuteLinkAction Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.FastTravel
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::FastTravel(const int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "FastTravel");

	Params::CharacterInterface_FastTravel Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.CharacterInterface.GetNickName
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ICharacterInterface::GetNickName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetNickName");

	Params::CharacterInterface_GetNickName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetOriginID
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICharacterInterface::GetOriginID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetOriginID");

	Params::CharacterInterface_GetOriginID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetOwningTags
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void ICharacterInterface::GetOwningTags(struct FGameplayTagContainer* Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetOwningTags");

	Params::CharacterInterface_GetOwningTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Tags != nullptr)
		*Tags = std::move(Parms.Tags);
}


// Function DarwinGame.CharacterInterface.HandleBattleEndEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::HandleBattleEndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "HandleBattleEndEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.HandleBattleStartEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::HandleBattleStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "HandleBattleStartEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.HasAttribute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::HasAttribute(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "HasAttribute");

	Params::CharacterInterface_HasAttribute Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.HasTag
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::HasTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "HasTag");

	Params::CharacterInterface_HasTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.HoldWeapon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             equipmentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::HoldWeapon(class FName equipmentName, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "HoldWeapon");

	Params::CharacterInterface_HoldWeapon Parms{};

	Parms.equipmentName = equipmentName;
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.IsAbilityRunning
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::IsAbilityRunning(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "IsAbilityRunning");

	Params::CharacterInterface_IsAbilityRunning Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.IsLinkMenuOpened
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::IsLinkMenuOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "IsLinkMenuOpened");

	Params::CharacterInterface_IsLinkMenuOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.Land
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::Land()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "Land");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.CharacterInterface.Launch
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::Launch(const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "Launch");

	Params::CharacterInterface_Launch Parms{};

	Parms.Velocity = std::move(Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.CharacterInterface.OpenLinkMenu
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::OpenLinkMenu(ELinkType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "OpenLinkMenu");

	Params::CharacterInterface_OpenLinkMenu Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.PlayParticle
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EffectId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Socke                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAttached                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HandleID                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::PlayParticle(class FName EffectId, class FName Socke, bool IsAttached, class FString* HandleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "PlayParticle");

	Params::CharacterInterface_PlayParticle Parms{};

	Parms.EffectId = EffectId;
	Parms.Socke = Socke;
	Parms.IsAttached = IsAttached;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HandleID != nullptr)
		*HandleID = std::move(Parms.HandleID);

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.PlayTrail
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EffectId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FirstSocket                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SecondSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         ScaleMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HandleID                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::PlayTrail(class FName EffectId, class FName FirstSocket, class FName SecondSocket, ETrailWidthMode ScaleMode, class FString* HandleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "PlayTrail");

	Params::CharacterInterface_PlayTrail Parms{};

	Parms.EffectId = EffectId;
	Parms.FirstSocket = FirstSocket;
	Parms.SecondSocket = SecondSocket;
	Parms.ScaleMode = ScaleMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HandleID != nullptr)
		*HandleID = std::move(Parms.HandleID);

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.ReadyToShot
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ReadyToShot(bool Complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ReadyToShot");

	Params::CharacterInterface_ReadyToShot Parms{};

	Parms.Complete = Complete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.CharacterInterface.ReleaseAttribute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::ReleaseAttribute(class FName AttributeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ReleaseAttribute");

	Params::CharacterInterface_ReleaseAttribute Parms{};

	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.ResetRotation
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ICharacterInterface::ResetRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ResetRotation");

	Params::CharacterInterface_ResetRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.CharacterInterface.ResetState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::ResetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "ResetState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.RestartFromAbyss
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterInterface::RestartFromAbyss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "RestartFromAbyss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.SetPauseAllAttribute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Pause                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::SetPauseAllAttribute(bool Pause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "SetPauseAllAttribute");

	Params::CharacterInterface_SetPauseAllAttribute Parms{};

	Parms.Pause = Pause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.SetReadyWeapon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             equipmentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ready                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::SetReadyWeapon(class FName equipmentName, bool Ready)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "SetReadyWeapon");

	Params::CharacterInterface_SetReadyWeapon Parms{};

	Parms.equipmentName = equipmentName;
	Parms.Ready = Ready;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.SwitchToBattleMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SkipMotion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::SwitchToBattleMode(bool IsEnd, bool SkipMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "SwitchToBattleMode");

	Params::CharacterInterface_SwitchToBattleMode Parms{};

	Parms.IsEnd = IsEnd;
	Parms.SkipMotion = SkipMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.SwitchToCutSceneMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::SwitchToCutSceneMode(bool IsEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "SwitchToCutSceneMode");

	Params::CharacterInterface_SwitchToCutSceneMode Parms{};

	Parms.IsEnd = IsEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.Talk
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Partner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsCameraEnabled                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEnd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterInterface::Talk(class AActor* Partner, bool IsCameraEnabled, bool IsEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "Talk");

	Params::CharacterInterface_Talk Parms{};

	Parms.Partner = Partner;
	Parms.IsCameraEnabled = IsCameraEnabled;
	Parms.IsEnd = IsEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterInterface.CanChangeToSpecifiedState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NextMoveStateTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::CanChangeToSpecifiedState(const struct FGameplayTag& NextMoveStateTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "CanChangeToSpecifiedState");

	Params::CharacterInterface_CanChangeToSpecifiedState Parms{};

	Parms.NextMoveStateTag = std::move(NextMoveStateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetAnimInstance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* ICharacterInterface::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetAnimInstance");

	Params::CharacterInterface_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetControlRot
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ICharacterInterface::GetControlRot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetControlRot");

	Params::CharacterInterface_GetControlRot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetCurrentActionStateTag
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICharacterInterface::GetCurrentActionStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetCurrentActionStateTag");

	Params::CharacterInterface_GetCurrentActionStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetCurrentMoveStateTag
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICharacterInterface::GetCurrentMoveStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetCurrentMoveStateTag");

	Params::CharacterInterface_GetCurrentMoveStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetCurrentStateTag
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICharacterInterface::GetCurrentStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetCurrentStateTag");

	Params::CharacterInterface_GetCurrentStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetEquipment
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FName                             equipmentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ICharacterInterface::GetEquipment(class FName equipmentName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetEquipment");

	Params::CharacterInterface_GetEquipment Parms{};

	Parms.equipmentName = equipmentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetEquipments
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AActor*> ICharacterInterface::GetEquipments() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetEquipments");

	Params::CharacterInterface_GetEquipments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetLinkType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ELinkType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELinkType ICharacterInterface::GetLinkType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetLinkType");

	Params::CharacterInterface_GetLinkType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetPrevStateTag
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICharacterInterface::GetPrevStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetPrevStateTag");

	Params::CharacterInterface_GetPrevStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetReadyWeapon
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ICharacterInterface::GetReadyWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetReadyWeapon");

	Params::CharacterInterface_GetReadyWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetTarget
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ICharacterInterface::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetTarget");

	Params::CharacterInterface_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.GetTargetToInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ICharacterInterface::GetTargetToInteract() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "GetTargetToInteract");

	Params::CharacterInterface_GetTargetToInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.IsAiming
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::IsAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "IsAiming");

	Params::CharacterInterface_IsAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterInterface.IsReadyToShot
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterInterface::IsReadyToShot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInterface", "IsReadyToShot");

	Params::CharacterInterface_IsReadyToShot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterMovementFunctionLibrary.DrawActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DrawPoint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementFunctionLibrary::DrawActor(class AActor* Actor, const struct FVector& DrawPoint, float Scale, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterMovementFunctionLibrary", "DrawActor");

	Params::CharacterMovementFunctionLibrary_DrawActor Parms{};

	Parms.Actor = Actor;
	Parms.DrawPoint = std::move(DrawPoint);
	Parms.Scale = Scale;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.ChangeOperationMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EOperationModeEnum                      Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::ChangeOperationMode(EOperationModeEnum Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "ChangeOperationMode");

	Params::CharacterMovementInterface_ChangeOperationMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.GetFallingAltitude
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICharacterMovementInterface::GetFallingAltitude()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "GetFallingAltitude");

	Params::CharacterMovementInterface_GetFallingAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterMovementInterface.OnAim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnAim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnAim");

	Params::CharacterMovementInterface_OnAim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnBattle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnBattle(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnBattle");

	Params::CharacterMovementInterface_OnBattle Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnClimb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnClimb(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnClimb");

	Params::CharacterMovementInterface_OnClimb Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnClimbMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnClimbMove(float Time, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnClimbMove");

	Params::CharacterMovementInterface_OnClimbMove Parms{};

	Parms.Time = Time;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnCrouch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnCrouch(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnCrouch");

	Params::CharacterMovementInterface_OnCrouch Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnDead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnDead(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnDead");

	Params::CharacterMovementInterface_OnDead Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnFall
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterMovementInterface::OnFall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnFall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnHop
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnHop(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnHop");

	Params::CharacterMovementInterface_OnHop Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnHopMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnHopMove(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnHopMove");

	Params::CharacterMovementInterface_OnHopMove Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnJump
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterMovementInterface::OnJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnLock
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnLock(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnLock");

	Params::CharacterMovementInterface_OnLock Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnMove(float Axis, float Direction, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnMove");

	Params::CharacterMovementInterface_OnMove Parms{};

	Parms.Axis = Axis;
	Parms.Direction = Direction;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnMovementStop
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterMovementInterface::OnMovementStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnMovementStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnRide
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequence*                    RideAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnRide(class UAnimSequence* RideAnim, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnRide");

	Params::CharacterMovementInterface_OnRide Parms{};

	Parms.RideAnim = RideAnim;
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnSlope
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnSlope(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnSlope");

	Params::CharacterMovementInterface_OnSlope Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnStealCharge
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnStealCharge(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnStealCharge");

	Params::CharacterMovementInterface_OnStealCharge Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnStealMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnStealMove(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnStealMove");

	Params::CharacterMovementInterface_OnStealMove Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnSwim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnSwim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnSwim");

	Params::CharacterMovementInterface_OnSwim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.OnTalk
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterface::OnTalk(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "OnTalk");

	Params::CharacterMovementInterface_OnTalk Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterface.GetAltitudeThreshold
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D ICharacterMovementInterface::GetAltitudeThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterface", "GetAltitudeThreshold");

	Params::CharacterMovementInterface_GetAltitudeThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Aim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Aim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Aim");

	Params::CharacterMovementInterfaceForABP_Aim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.BattleMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::BattleMode(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "BattleMode");

	Params::CharacterMovementInterfaceForABP_BattleMode Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Climb
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       LHand                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       RHand                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       LFoot                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       RFoot                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Climb(const struct FTransform& LHand, const struct FTransform& RHand, const struct FTransform& LFoot, const struct FTransform& RFoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Climb");

	Params::CharacterMovementInterfaceForABP_Climb Parms{};

	Parms.LHand = std::move(LHand);
	Parms.RHand = std::move(RHand);
	Parms.LFoot = std::move(LFoot);
	Parms.RFoot = std::move(RFoot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Dead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    FaceUp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Dead(bool FaceUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Dead");

	Params::CharacterMovementInterfaceForABP_Dead Parms{};

	Parms.FaceUp = FaceUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Dive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Dive(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Dive");

	Params::CharacterMovementInterfaceForABP_Dive Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Equip
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlayMotion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Equip(bool End, bool PlayMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Equip");

	Params::CharacterMovementInterfaceForABP_Equip Parms{};

	Parms.End = End;
	Parms.PlayMotion = PlayMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.EquipSlingShot
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::EquipSlingShot(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "EquipSlingShot");

	Params::CharacterMovementInterfaceForABP_EquipSlingShot Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.FieldLinkMode
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::FieldLinkMode(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "FieldLinkMode");

	Params::CharacterMovementInterfaceForABP_FieldLinkMode Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.ForceStandUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterMovementInterfaceForABP::ForceStandUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "ForceStandUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.IsDiving
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterMovementInterfaceForABP::IsDiving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "IsDiving");

	Params::CharacterMovementInterfaceForABP_IsDiving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Jump
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Foot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Jump(float Foot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Jump");

	Params::CharacterMovementInterfaceForABP_Jump Parms{};

	Parms.Foot = Foot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Land
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamaged                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Land(float Speed, float Direction, float PlayRate, bool bDamaged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Land");

	Params::CharacterMovementInterfaceForABP_Land Parms{};

	Parms.Speed = Speed;
	Parms.Direction = Direction;
	Parms.PlayRate = PlayRate;
	Parms.bDamaged = bDamaged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Look
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Look(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Look");

	Params::CharacterMovementInterfaceForABP_Look Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Move
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Move(float Axis, float Direction, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Move");

	Params::CharacterMovementInterfaceForABP_Move Parms{};

	Parms.Axis = Axis;
	Parms.Direction = Direction;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.SetExcursion
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Hip                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Neck                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::SetExcursion(float Hip, float Neck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "SetExcursion");

	Params::CharacterMovementInterfaceForABP_SetExcursion Parms{};

	Parms.Hip = Hip;
	Parms.Neck = Neck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.StartParkour
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Foot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::StartParkour(float Foot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "StartParkour");

	Params::CharacterMovementInterfaceForABP_StartParkour Parms{};

	Parms.Foot = Foot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Stop
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ICharacterMovementInterfaceForABP::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterMovementInterfaceForABP.Swim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterMovementInterfaceForABP::Swim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementInterfaceForABP", "Swim");

	Params::CharacterMovementInterfaceForABP_Swim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NoEntryAreaBase.OnBeginOverlap
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANoEntryAreaBase::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoEntryAreaBase", "OnBeginOverlap");

	Params::NoEntryAreaBase_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NoEntryAreaBase.OnCheckLanding
// (Native, Protected)
// Parameters:
// class AActor*                           PlayerActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoEntryAreaBase::OnCheckLanding(class AActor* PlayerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoEntryAreaBase", "OnCheckLanding");

	Params::NoEntryAreaBase_OnCheckLanding Parms{};

	Parms.PlayerActor = PlayerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NoEntryAreaBase.OnEndOverlap
// (Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoEntryAreaBase::OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoEntryAreaBase", "OnEndOverlap");

	Params::NoEntryAreaBase_OnEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TreasureBoxBase.EffectiveRangeCheck
// (Final, Native, Private)
// Parameters:
// class APlayerCameraManager*             cameraManager                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActorSizeLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureBoxBase::EffectiveRangeCheck(class APlayerCameraManager* cameraManager, float ActorSizeLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureBoxBase", "EffectiveRangeCheck");

	Params::TreasureBoxBase_EffectiveRangeCheck Parms{};

	Parms.cameraManager = cameraManager;
	Parms.ActorSizeLength = ActorSizeLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TreasureBoxBase.GetRootBoxMesh
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ATreasureBoxBase::GetRootBoxMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureBoxBase", "GetRootBoxMesh");

	Params::TreasureBoxBase_GetRootBoxMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.Aim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::Aim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "Aim");

	Params::DarwinAnimInstance_Aim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.AnimNotify_EmoteBodyEnd_Group1
// (Final, Native, Protected, BlueprintCallable)

void UDarwinAnimInstance::AnimNotify_EmoteBodyEnd_Group1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "AnimNotify_EmoteBodyEnd_Group1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.AnimNotify_EmoteBodyEnd_Group2
// (Final, Native, Protected, BlueprintCallable)

void UDarwinAnimInstance::AnimNotify_EmoteBodyEnd_Group2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "AnimNotify_EmoteBodyEnd_Group2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.ChangeAnimState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::ChangeAnimState(const struct FGameplayTag& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "ChangeAnimState");

	Params::DarwinAnimInstance_ChangeAnimState Parms{};

	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.ChangeState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::ChangeState(const struct FGameplayTag& State, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "ChangeState");

	Params::DarwinAnimInstance_ChangeState Parms{};

	Parms.State = std::move(State);
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.ClearLookAtTarget
// (Final, Native, Public, BlueprintCallable)

void UDarwinAnimInstance::ClearLookAtTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "ClearLookAtTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.Dive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::Dive(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "Dive");

	Params::DarwinAnimInstance_Dive Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.GetEcologicalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEcologicalState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEcologicalState UDarwinAnimInstance::GetEcologicalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetEcologicalState");

	Params::DarwinAnimInstance_GetEcologicalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.HasTag
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::HasTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "HasTag");

	Params::DarwinAnimInstance_HasTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsEcoSleepGetup
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsEcoSleepGetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsEcoSleepGetup");

	Params::DarwinAnimInstance_IsEcoSleepGetup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.Move
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::Move(float Axis, float Direction, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "Move");

	Params::DarwinAnimInstance_Move Parms{};

	Parms.Axis = Axis;
	Parms.Direction = Direction;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.NotifyEmoteBodyEnd
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::NotifyEmoteBodyEnd(EEmoteMotionSwitch Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "NotifyEmoteBodyEnd");

	Params::DarwinAnimInstance_NotifyEmoteBodyEnd Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.OnAbnormalStateEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinAnimInstance::OnAbnormalStateEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "OnAbnormalStateEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.OnLand
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UDarwinAnimInstance::OnLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "OnLand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.OnMontageStart
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::OnMontageStart(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "OnMontageStart");

	Params::DarwinAnimInstance_OnMontageStart Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.ResetRootMode
// (Final, Native, Public, BlueprintCallable)

void UDarwinAnimInstance::ResetRootMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "ResetRootMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.SetLookAtEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::SetLookAtEnable(const bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "SetLookAtEnable");

	Params::DarwinAnimInstance_SetLookAtEnable Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.SetLookAtTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::SetLookAtTarget(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "SetLookAtTarget");

	Params::DarwinAnimInstance_SetLookAtTarget Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.SetupEcologicalGestureAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEcoGestureAnimDataID                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinAnimInstance::SetupEcologicalGestureAnimation(EEcoGestureAnimDataID ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "SetupEcologicalGestureAnimation");

	Params::DarwinAnimInstance_SetupEcologicalGestureAnimation Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinAnimInstance.GetBodyEmoteSetting
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEmoteBodyMotionSetting    ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FEmoteBodyMotionSetting UDarwinAnimInstance::GetBodyEmoteSetting(EEmoteMotionSwitch Group) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetBodyEmoteSetting");

	Params::DarwinAnimInstance_GetBodyEmoteSetting Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.GetEmoteBodyInfo
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEmoteBodyMotionInfo       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FEmoteBodyMotionInfo UDarwinAnimInstance::GetEmoteBodyInfo(EEmoteMotionSwitch Group) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetEmoteBodyInfo");

	Params::DarwinAnimInstance_GetEmoteBodyInfo Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.GetEmoteBodyPhaseAnim
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteBodyMotionPhase                   phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UDarwinAnimInstance::GetEmoteBodyPhaseAnim(EEmoteMotionSwitch Group, EEmoteBodyMotionPhase phase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetEmoteBodyPhaseAnim");

	Params::DarwinAnimInstance_GetEmoteBodyPhaseAnim Parms{};

	Parms.Group = Group;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.GetEmoteBodyPhaseAnimFromMotionRequest
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEmoteBodyMotionRequest          Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEmoteBodyMotionPhase                   phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UDarwinAnimInstance::GetEmoteBodyPhaseAnimFromMotionRequest(const struct FEmoteBodyMotionRequest& Request, EEmoteBodyMotionPhase phase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetEmoteBodyPhaseAnimFromMotionRequest");

	Params::DarwinAnimInstance_GetEmoteBodyPhaseAnimFromMotionRequest Parms{};

	Parms.Request = std::move(Request);
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.GetLookAtParamHead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_LookAtParams                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_LookAtParams UDarwinAnimInstance::GetLookAtParamHead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetLookAtParamHead");

	Params::DarwinAnimInstance_GetLookAtParamHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.GetLookAtParamSpine
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_LookAtParams                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_LookAtParams UDarwinAnimInstance::GetLookAtParamSpine() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetLookAtParamSpine");

	Params::DarwinAnimInstance_GetLookAtParamSpine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.GetRootMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERootMotionMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERootMotionMode UDarwinAnimInstance::GetRootMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "GetRootMode");

	Params::DarwinAnimInstance_GetRootMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.HasAbnormalAnimationTag
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::HasAbnormalAnimationTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "HasAbnormalAnimationTag");

	Params::DarwinAnimInstance_HasAbnormalAnimationTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.HasEndTrigger
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::HasEndTrigger(EEmoteMotionSwitch Group) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "HasEndTrigger");

	Params::DarwinAnimInstance_HasEndTrigger Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsAbnormal
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsAbnormal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsAbnormal");

	Params::DarwinAnimInstance_IsAbnormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsBeginBodyEmotePhase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteBodyMotionPhase                   phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsBeginBodyEmotePhase(EEmoteMotionSwitch Group, EEmoteBodyMotionPhase phase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsBeginBodyEmotePhase");

	Params::DarwinAnimInstance_IsBeginBodyEmotePhase Parms{};

	Parms.Group = Group;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsDead
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsDead");

	Params::DarwinAnimInstance_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsEcoSleep
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsEcoSleep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsEcoSleep");

	Params::DarwinAnimInstance_IsEcoSleep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsEquipping
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsEquipping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsEquipping");

	Params::DarwinAnimInstance_IsEquipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsParalysis
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsParalysis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsParalysis");

	Params::DarwinAnimInstance_IsParalysis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsPlayEmoteBody_Inner
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsPlayEmoteBody_Inner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsPlayEmoteBody_Inner");

	Params::DarwinAnimInstance_IsPlayEmoteBody_Inner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsSleep
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsSleep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsSleep");

	Params::DarwinAnimInstance_IsSleep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsStun
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsStun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsStun");

	Params::DarwinAnimInstance_IsStun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsTriggerEmoteBodyEndToIdle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainingTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   boarder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsTriggerEmoteBodyEndToIdle(EEmoteMotionSwitch Group, float RemainingTime, float boarder) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsTriggerEmoteBodyEndToIdle");

	Params::DarwinAnimInstance_IsTriggerEmoteBodyEndToIdle Parms{};

	Parms.Group = Group;
	Parms.RemainingTime = RemainingTime;
	Parms.boarder = boarder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsTriggerEmoteBodyLoopToEnd
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsTriggerEmoteBodyLoopToEnd(EEmoteMotionSwitch Group) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsTriggerEmoteBodyLoopToEnd");

	Params::DarwinAnimInstance_IsTriggerEmoteBodyLoopToEnd Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsTriggerEmoteBodyLoopToIdle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsTriggerEmoteBodyLoopToIdle(EEmoteMotionSwitch Group) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsTriggerEmoteBodyLoopToIdle");

	Params::DarwinAnimInstance_IsTriggerEmoteBodyLoopToIdle Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsTriggerEmoteBodyStartToIdle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsTriggerEmoteBodyStartToIdle(EEmoteMotionSwitch Group) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsTriggerEmoteBodyStartToIdle");

	Params::DarwinAnimInstance_IsTriggerEmoteBodyStartToIdle Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsTriggerEmoteBodyStartToLoop
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemainingTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   boarder                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsTriggerEmoteBodyStartToLoop(EEmoteMotionSwitch Group, float RemainingTime, float boarder) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsTriggerEmoteBodyStartToLoop");

	Params::DarwinAnimInstance_IsTriggerEmoteBodyStartToLoop Parms{};

	Parms.Group = Group;
	Parms.RemainingTime = RemainingTime;
	Parms.boarder = boarder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinAnimInstance.IsValidEmoteBodyAnim
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteMotionSwitch                      Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteBodyMotionPhase                   phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinAnimInstance::IsValidEmoteBodyAnim(EEmoteMotionSwitch Group, EEmoteBodyMotionPhase phase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinAnimInstance", "IsValidEmoteBodyAnim");

	Params::DarwinAnimInstance_IsValidEmoteBodyAnim Parms{};

	Parms.Group = Group;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCCSAnimInstance.AnimNotify_EndExAction
// (Final, Native, Public, BlueprintCallable)

void UNPCCSAnimInstance::AnimNotify_EndExAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCSAnimInstance", "AnimNotify_EndExAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCCSAnimInstance.SetLookAtActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCCSAnimInstance::SetLookAtActor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCSAnimInstance", "SetLookAtActor");

	Params::NPCCSAnimInstance_SetLookAtActor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCCSAnimInstance.SetTargetLook
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLookStart                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCCSAnimInstance::SetTargetLook(const bool IsLookStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCSAnimInstance", "SetTargetLook");

	Params::NPCCSAnimInstance_SetTargetLook Parms{};

	Parms.IsLookStart = IsLookStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCCSAnimInstance.UpdateLookAtLocation
// (Final, Native, Public, BlueprintCallable)

void UNPCCSAnimInstance::UpdateLookAtLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCSAnimInstance", "UpdateLookAtLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterStateInterfaceForABP.ChangeAnimState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterStateInterfaceForABP::ChangeAnimState(const struct FGameplayTag& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStateInterfaceForABP", "ChangeAnimState");

	Params::CharacterStateInterfaceForABP_ChangeAnimState Parms{};

	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterStateInterfaceForABP.ChangeState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterStateInterfaceForABP::ChangeState(const struct FGameplayTag& State, bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStateInterfaceForABP", "ChangeState");

	Params::CharacterStateInterfaceForABP_ChangeState Parms{};

	Parms.State = std::move(State);
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterStateInterfaceForABP.HasTag
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICharacterStateInterfaceForABP::HasTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStateInterfaceForABP", "HasTag");

	Params::CharacterStateInterfaceForABP_HasTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringInterface.AddSlaveDithering
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDitheringComponent*              slave                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDitheringInterface::AddSlaveDithering(class UDitheringComponent* slave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringInterface", "AddSlaveDithering");

	Params::DitheringInterface_AddSlaveDithering Parms{};

	Parms.slave = slave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DitheringInterface.GetDithering
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDitheringComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDitheringComponent* IDitheringInterface::GetDithering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringInterface", "GetDithering");

	Params::DitheringInterface_GetDithering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DitheringInterface.ReleaseSlaveDithering
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDitheringComponent*              slave                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDitheringInterface::ReleaseSlaveDithering(class UDitheringComponent* slave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DitheringInterface", "ReleaseSlaveDithering");

	Params::DitheringInterface_ReleaseSlaveDithering Parms{};

	Parms.slave = slave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CharacterSystemLibrary.GetStandActorLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StandLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSystemLibrary::GetStandActorLocation(class AGPACharacter* Target, struct FVector* StandLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterSystemLibrary", "GetStandActorLocation");

	Params::CharacterSystemLibrary_GetStandActorLocation Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StandLocation != nullptr)
		*StandLocation = std::move(Parms.StandLocation);

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterSystemLibrary.IsLeftFootFront
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSystemLibrary::IsLeftFootFront(class AGameCharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterSystemLibrary", "IsLeftFootFront");

	Params::CharacterSystemLibrary_IsLeftFootFront Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterSystemLibrary.IsStandable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSystemLibrary::IsStandable(class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterSystemLibrary", "IsStandable");

	Params::CharacterSystemLibrary_IsStandable Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CharacterSystemLibrary.IsSuccessSection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSystemLibrary::IsSuccessSection(class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterSystemLibrary", "IsSuccessSection");

	Params::CharacterSystemLibrary_IsSuccessSection Parms{};

	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinGameplayCue.GetActionDetailID
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           MyTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Parameters                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADarwinGameplayCue::GetActionDetailID(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinGameplayCue", "GetActionDetailID");

	Params::DarwinGameplayCue_GetActionDetailID Parms{};

	Parms.MyTarget = MyTarget;
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinGameplayCue.SetAbnormalStateTag
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinGameplayCue::SetAbnormalStateTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinGameplayCue", "SetAbnormalStateTag");

	Params::DarwinGameplayCue_SetAbnormalStateTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinGameplayCue.SetIsChangeMotion
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADarwinGameplayCue::SetIsChangeMotion(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinGameplayCue", "SetIsChangeMotion");

	Params::DarwinGameplayCue_SetIsChangeMotion Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFlagmenu_00.OnChangeFocusFunc
// (Final, Native, Protected)

void UUIFlagmenu_00::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFlagmenu_00", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.AddBelongingsCoin
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoinBlueprintFunctionLibrary::AddBelongingsCoin(const struct FST_CoinParam& CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "AddBelongingsCoin");

	Params::CoinBlueprintFunctionLibrary_AddBelongingsCoin Parms{};

	Parms.CoinParam = std::move(CoinParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.CoinBaseNameOf
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCoinBlueprintFunctionLibrary::CoinBaseNameOf(const struct FST_CoinParam& CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "CoinBaseNameOf");

	Params::CoinBlueprintFunctionLibrary_CoinBaseNameOf Parms{};

	Parms.CoinParam = std::move(CoinParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.CreateCoin
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_CoinParam                    CoinParam                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    isRarityUp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoinBlueprintFunctionLibrary::CreateCoin(int32 Level, int32 KindId, struct FST_CoinParam* CoinParam, bool isRarityUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "CreateCoin");

	Params::CoinBlueprintFunctionLibrary_CreateCoin Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.isRarityUp = isRarityUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CoinParam != nullptr)
		*CoinParam = std::move(Parms.CoinParam);

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.CreateCoinFixed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_CoinParam                    CoinParam                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoinBlueprintFunctionLibrary::CreateCoinFixed(int32 ID, struct FST_CoinParam* CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "CreateCoinFixed");

	Params::CoinBlueprintFunctionLibrary_CreateCoinFixed Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CoinParam != nullptr)
		*CoinParam = std::move(Parms.CoinParam);

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.CreateCoinFixedGroup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   GroupID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_CoinParam>            CoinParamArray                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoinBlueprintFunctionLibrary::CreateCoinFixedGroup(int32 GroupID, TArray<struct FST_CoinParam>* CoinParamArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "CreateCoinFixedGroup");

	Params::CoinBlueprintFunctionLibrary_CreateCoinFixedGroup Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CoinParamArray != nullptr)
		*CoinParamArray = std::move(Parms.CoinParamArray);

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinAttributeType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EResistanceType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EResistanceType UCoinBlueprintFunctionLibrary::GetCoinAttributeType(const struct FST_CoinParam& CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinAttributeType");

	Params::CoinBlueprintFunctionLibrary_GetCoinAttributeType Parms{};

	Parms.CoinParam = std::move(CoinParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinFeatureIconId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinFeature                  CoinFeature                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoinBlueprintFunctionLibrary::GetCoinFeatureIconId(const struct FST_CoinFeature& CoinFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinFeatureIconId");

	Params::CoinBlueprintFunctionLibrary_GetCoinFeatureIconId Parms{};

	Parms.CoinFeature = std::move(CoinFeature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinIconTypes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinFeature                  CoinFeature                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<int32> UCoinBlueprintFunctionLibrary::GetCoinIconTypes(const struct FST_CoinFeature& CoinFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinIconTypes");

	Params::CoinBlueprintFunctionLibrary_GetCoinIconTypes Parms{};

	Parms.CoinFeature = std::move(CoinFeature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinIsPlayEquipAnim
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinFeature                  CoinFeature                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoinBlueprintFunctionLibrary::GetCoinIsPlayEquipAnim(const struct FST_CoinFeature& CoinFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinIsPlayEquipAnim");

	Params::CoinBlueprintFunctionLibrary_GetCoinIsPlayEquipAnim Parms{};

	Parms.CoinFeature = std::move(CoinFeature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinListName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Name_0                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    IsEnableIndefSgl                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoinBlueprintFunctionLibrary::GetCoinListName(const struct FST_CoinParam& CoinParam, class FText* Name_0, bool IsEnableIndefSgl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinListName");

	Params::CoinBlueprintFunctionLibrary_GetCoinListName Parms{};

	Parms.CoinParam = std::move(CoinParam);
	Parms.IsEnableIndefSgl = IsEnableIndefSgl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Name_0                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    IsEnableIndefSgl                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoinBlueprintFunctionLibrary::GetCoinName(const struct FST_CoinParam& CoinParam, class FText* Name_0, bool IsEnableIndefSgl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinName");

	Params::CoinBlueprintFunctionLibrary_GetCoinName Parms{};

	Parms.CoinParam = std::move(CoinParam);
	Parms.IsEnableIndefSgl = IsEnableIndefSgl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinName50Order
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoinBlueprintFunctionLibrary::GetCoinName50Order(const struct FST_CoinParam& CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinName50Order");

	Params::CoinBlueprintFunctionLibrary_GetCoinName50Order Parms{};

	Parms.CoinParam = std::move(CoinParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinParamType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EStatusParamType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusParamType UCoinBlueprintFunctionLibrary::GetCoinParamType(const struct FST_CoinParam& CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinParamType");

	Params::CoinBlueprintFunctionLibrary_GetCoinParamType Parms{};

	Parms.CoinParam = std::move(CoinParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.GetCoinRarityIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECoinRarity                             Rarity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCoinBlueprintFunctionLibrary::GetCoinRarityIcon(ECoinRarity Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "GetCoinRarityIcon");

	Params::CoinBlueprintFunctionLibrary_GetCoinRarityIcon Parms{};

	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinBlueprintFunctionLibrary.RemoveBelongingsCoin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Uid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoinBlueprintFunctionLibrary::RemoveBelongingsCoin(int32 Uid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoinBlueprintFunctionLibrary", "RemoveBelongingsCoin");

	Params::CoinBlueprintFunctionLibrary_RemoveBelongingsCoin Parms{};

	Parms.Uid = Uid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFacilityFoodItem.GetIsLuxuryFoodId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFacilityFoodItem::GetIsLuxuryFoodId(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIFacilityFoodItem", "GetIsLuxuryFoodId");

	Params::UIFacilityFoodItem_GetIsLuxuryFoodId Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CoinObjectBase.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACoinObjectBase::Initialize(const struct FST_CoinParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoinObjectBase", "Initialize");

	Params::CoinObjectBase_Initialize Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CoinObjectBase.GetCoinParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_CoinParam                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FST_CoinParam ACoinObjectBase::GetCoinParam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoinObjectBase", "GetCoinParam");

	Params::CoinObjectBase_GetCoinParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIGlut_IconRange.SetDataUid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     InItemIdList                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InUid                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGlut_IconRange::SetDataUid(const TArray<class FName>& InItemIdList, const int32& InUid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_IconRange", "SetDataUid");

	Params::UIGlut_IconRange_SetDataUid Parms{};

	Parms.InItemIdList = std::move(InItemIdList);
	Parms.InUid = InUid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollectionPointDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UCollectionPointDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UQuestManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UQuestManager* UQuestManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestManager", "GetInstance");

	Params::QuestManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.AddQuestDestinationRect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::AddQuestDestinationRect(const class FName ID, const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "AddQuestDestinationRect");

	Params::QuestManager_AddQuestDestinationRect Parms{};

	Parms.ID = ID;
	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.AddQuestDestinationRectList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::AddQuestDestinationRectList(const class FName ID, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "AddQuestDestinationRectList");

	Params::QuestManager_AddQuestDestinationRectList Parms{};

	Parms.ID = ID;
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.CancelBaseAreaBattleQuest
// (Final, Native, Public, BlueprintCallable)

void UQuestManager::CancelBaseAreaBattleQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "CancelBaseAreaBattleQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.CancelDailyQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::CancelDailyQuest(const class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "CancelDailyQuest");

	Params::QuestManager_CancelDailyQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.ClearQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOpenClearUI                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::ClearQuest(const class FName& QuestID, bool IsOpenClearUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ClearQuest");

	Params::QuestManager_ClearQuest Parms{};

	Parms.QuestID = QuestID;
	Parms.IsOpenClearUI = IsOpenClearUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.ClearQuestDestinationRects
// (Final, Native, Public, BlueprintCallable)

void UQuestManager::ClearQuestDestinationRects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ClearQuestDestinationRects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainCoin
// (Final, Native, Public, BlueprintCallable)

void UQuestManager::GainCoin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainCoin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainFieldLink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFieldLinkType                          Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::GainFieldLink(const EFieldLinkType Type, const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainFieldLink");

	Params::QuestManager_GainFieldLink Parms{};

	Parms.Type = Type;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainGold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GainGold_0                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::GainGold(const int32 GainGold_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainGold");

	Params::QuestManager_GainGold Parms{};

	Parms.GainGold_0 = GainGold_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainKillMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MonsterParameterId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::GainKillMonster(class FName MonsterParameterId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainKillMonster");

	Params::QuestManager_GainKillMonster Parms{};

	Parms.MonsterParameterId = MonsterParameterId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainMonsterVisionNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAreaType                               Area                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::GainMonsterVisionNum(const EAreaType Area, const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainMonsterVisionNum");

	Params::QuestManager_GainMonsterVisionNum Parms{};

	Parms.Area = Area;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainPlayerActionNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EQuestClearPlayerActionType             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::GainPlayerActionNum(EQuestClearPlayerActionType Type, const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainPlayerActionNum");

	Params::QuestManager_GainPlayerActionNum Parms{};

	Parms.Type = Type;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GainTeamCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EQuestClearTEamCommandType              Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::GainTeamCommand(const EQuestClearTEamCommandType Type, const int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GainTeamCommand");

	Params::QuestManager_GainTeamCommand Parms{};

	Parms.Type = Type;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GetActiveChildQuestIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParentQuestID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetActiveChildQuestIDs(class FName ParentQuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetActiveChildQuestIDs");

	Params::QuestManager_GetActiveChildQuestIDs Parms{};

	Parms.ParentQuestID = ParentQuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetActiveParentQuestIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetActiveParentQuestIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetActiveParentQuestIDs");

	Params::QuestManager_GetActiveParentQuestIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetClearedQuestIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetClearedQuestIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetClearedQuestIDs");

	Params::QuestManager_GetClearedQuestIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetOpenQuestIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetOpenQuestIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetOpenQuestIDs");

	Params::QuestManager_GetOpenQuestIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetOrderQuestIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetOrderQuestIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetOrderQuestIDs");

	Params::QuestManager_GetOrderQuestIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetQuestBaseAreaBattleData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestBaseAreaBattleData      QuestBaseArea                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestBaseAreaBattleData(const class FName& QuestID, bool* Result, struct FST_QuestBaseAreaBattleData* QuestBaseArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestBaseAreaBattleData");

	Params::QuestManager_GetQuestBaseAreaBattleData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestBaseArea != nullptr)
		*QuestBaseArea = std::move(Parms.QuestBaseArea);
}


// Function DarwinGame.QuestManager.GetQuestClearJudgeData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListClear               QuestClear                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestClearJudgeData(const class FName& QuestID, bool* Result, struct FST_QuestListClear* QuestClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestClearJudgeData");

	Params::QuestManager_GetQuestClearJudgeData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestClear != nullptr)
		*QuestClear = std::move(Parms.QuestClear);
}


// Function DarwinGame.QuestManager.GetQuestClearRandomTableData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListClearRandomTable    QuestClearRandomTable                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestClearRandomTableData(const class FName& TableId, bool* Result, struct FST_QuestListClearRandomTable* QuestClearRandomTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestClearRandomTableData");

	Params::QuestManager_GetQuestClearRandomTableData Parms{};

	Parms.TableId = TableId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestClearRandomTable != nullptr)
		*QuestClearRandomTable = std::move(Parms.QuestClearRandomTable);
}


// Function DarwinGame.QuestManager.GetQuestDestinationRects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class FName, class UObject*>       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, class UObject*> UQuestManager::GetQuestDestinationRects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestDestinationRects");

	Params::QuestManager_GetQuestDestinationRects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetQuestEmergencyData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestEmergencyData           Emergency                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestEmergencyData(const class FName& QuestID, bool* Result, struct FST_QuestEmergencyData* Emergency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestEmergencyData");

	Params::QuestManager_GetQuestEmergencyData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (Emergency != nullptr)
		*Emergency = std::move(Parms.Emergency);
}


// Function DarwinGame.QuestManager.GetQuestListData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListDataInfo            QuestData                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestListData(const class FName& QuestID, bool* Result, struct FST_QuestListDataInfo* QuestData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestListData");

	Params::QuestManager_GetQuestListData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestData != nullptr)
		*QuestData = std::move(Parms.QuestData);
}


// Function DarwinGame.QuestManager.GetQuestOpenJudgeData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListOpen                QuestOpen                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestOpenJudgeData(const class FName& QuestID, bool* Result, struct FST_QuestListOpen* QuestOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestOpenJudgeData");

	Params::QuestManager_GetQuestOpenJudgeData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestOpen != nullptr)
		*QuestOpen = std::move(Parms.QuestOpen);
}


// Function DarwinGame.QuestManager.GetQuestOrderJudgeData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListOrder               QuestOrder                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestOrderJudgeData(const class FName& QuestID, bool* Result, struct FST_QuestListOrder* QuestOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestOrderJudgeData");

	Params::QuestManager_GetQuestOrderJudgeData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestOrder != nullptr)
		*QuestOrder = std::move(Parms.QuestOrder);
}


// Function DarwinGame.QuestManager.GetQuestPointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListPoint               QuestPoint                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestPointData(const class FName& QuestID, bool* Result, struct FST_QuestListPoint* QuestPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestPointData");

	Params::QuestManager_GetQuestPointData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestPoint != nullptr)
		*QuestPoint = std::move(Parms.QuestPoint);
}


// Function DarwinGame.QuestManager.GetQuestRewardData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListReward              QuestReward                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestRewardData(const class FName& QuestID, bool* Result, struct FST_QuestListReward* QuestReward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestRewardData");

	Params::QuestManager_GetQuestRewardData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestReward != nullptr)
		*QuestReward = std::move(Parms.QuestReward);
}


// Function DarwinGame.QuestManager.InitData
// (Final, Native, Public, BlueprintCallable)

void UQuestManager::InitData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "InitData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.OpenQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::OpenQuest(const class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OpenQuest");

	Params::QuestManager_OpenQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.OrderQuest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOpenOrderUI                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSetNewMark                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::OrderQuest(const class FName& QuestID, bool IsOpenOrderUI, bool IsSetNewMark)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OrderQuest");

	Params::QuestManager_OrderQuest Parms{};

	Parms.QuestID = QuestID;
	Parms.IsOpenOrderUI = IsOpenOrderUI;
	Parms.IsSetNewMark = IsSetNewMark;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.RemoveQuestDestinationRects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RemoveQuestDestinationRects(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RemoveQuestDestinationRects");

	Params::QuestManager_RemoveQuestDestinationRects Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.SetOrderedDailyQuest
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetOrderedDailyQuest(const class FName& QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "SetOrderedDailyQuest");

	Params::QuestManager_SetOrderedDailyQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.SetSelectedQuestID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetSelectedQuestID(const class FName& QuestID, bool IsMain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "SetSelectedQuestID");

	Params::QuestManager_SetSelectedQuestID Parms{};

	Parms.QuestID = QuestID;
	Parms.IsMain = IsMain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.UpdateQuestCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EQuestClearJudgeType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::UpdateQuestCount(EQuestClearJudgeType Type, const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "UpdateQuestCount");

	Params::QuestManager_UpdateQuestCount Parms{};

	Parms.Type = Type;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestManager.GetOrderDailyQuestIDs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetOrderDailyQuestIDs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetOrderDailyQuestIDs");

	Params::QuestManager_GetOrderDailyQuestIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetOrderDailyQuestIDsWithoutAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UQuestManager::GetOrderDailyQuestIDsWithoutAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetOrderDailyQuestIDsWithoutAll");

	Params::QuestManager_GetOrderDailyQuestIDsWithoutAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetQuestListTextData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_QuestListTextDataInfo        QuestTextData                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UQuestManager::GetQuestListTextData(const class FName& QuestID, bool* Result, struct FST_QuestListTextDataInfo* QuestTextData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestListTextData");

	Params::QuestManager_GetQuestListTextData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (QuestTextData != nullptr)
		*QuestTextData = std::move(Parms.QuestTextData);
}


// Function DarwinGame.QuestManager.GetQuestState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EQuestState UQuestManager::GetQuestState(const class FName QuestID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetQuestState");

	Params::QuestManager_GetQuestState Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.GetSelectedQuestID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IsMain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UQuestManager::GetSelectedQuestID(bool IsMain) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetSelectedQuestID");

	Params::QuestManager_GetSelectedQuestID Parms{};

	Parms.IsMain = IsMain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.IsActiveQuest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsActiveQuest(const class FName QuestID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsActiveQuest");

	Params::QuestManager_IsActiveQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.QuestManager.IsAllClearDailyQuestWithoutAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsAllClearDailyQuestWithoutAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsAllClearDailyQuestWithoutAll");

	Params::QuestManager_IsAllClearDailyQuestWithoutAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CollectionPointManager.RespawnAllPoint
// (Final, Native, Public, BlueprintCallable)

void UCollectionPointManager::RespawnAllPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointManager", "RespawnAllPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollectionPointManager.RespawnAllPointAfterTime
// (Final, Native, Public, BlueprintCallable)

void UCollectionPointManager::RespawnAllPointAfterTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointManager", "RespawnAllPointAfterTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonGimmickPiller.GetGimmick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADungeonPiller*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADungeonPiller* ADungeonGimmickPiller::GetGimmick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonGimmickPiller", "GetGimmick");

	Params::DungeonGimmickPiller_GetGimmick Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.CollectionPointObjectBase.EffectiveRangeCheck
// (Final, Native, Private)
// Parameters:
// class APlayerCameraManager*             cameraManager                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActorSizeLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectionPointObjectBase::EffectiveRangeCheck(class APlayerCameraManager* cameraManager, float ActorSizeLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointObjectBase", "EffectiveRangeCheck");

	Params::CollectionPointObjectBase_EffectiveRangeCheck Parms{};

	Parms.cameraManager = cameraManager;
	Parms.ActorSizeLength = ActorSizeLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollectionPointObjectBase.GetCollectionPointID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ACollectionPointObjectBase::GetCollectionPointID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointObjectBase", "GetCollectionPointID");

	Params::CollectionPointObjectBase_GetCollectionPointID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CollectionPointObjectBase.OnChangeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECollectionPointState                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFadeSkip                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectionPointObjectBase::OnChangeState(ECollectionPointState State, bool IsFadeSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointObjectBase", "OnChangeState");

	Params::CollectionPointObjectBase_OnChangeState Parms{};

	Parms.State = State;
	Parms.IsFadeSkip = IsFadeSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollectionPointObjectBase.GetAfterMesh
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ACollectionPointObjectBase::GetAfterMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointObjectBase", "GetAfterMesh");

	Params::CollectionPointObjectBase_GetAfterMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.CollectionPointObjectBase.GetBeforeMesh
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ACollectionPointObjectBase::GetBeforeMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectionPointObjectBase", "GetBeforeMesh");

	Params::CollectionPointObjectBase_GetBeforeMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.CollisionManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCollisionManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCollisionManager* UCollisionManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CollisionManager", "GetInstance");

	Params::CollisionManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CollisionManager.CreateShootAttackCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OrderId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAttackCollisionBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAttackCollisionBase* UCollisionManager::CreateShootAttackCollision(class FName actionDetailID, class FName OrderId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "CreateShootAttackCollision");

	Params::CollisionManager_CreateShootAttackCollision Parms{};

	Parms.actionDetailID = actionDetailID;
	Parms.OrderId = OrderId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CollisionManager.CreateTouchAttackCollision
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_TouchAttackCollision         Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AAttackCollisionBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAttackCollisionBase* UCollisionManager::CreateTouchAttackCollision(class FName actionDetailID, const struct FST_TouchAttackCollision& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "CreateTouchAttackCollision");

	Params::CollisionManager_CreateTouchAttackCollision Parms{};

	Parms.actionDetailID = actionDetailID;
	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CollisionManager.GetAttackCollisionData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAttackCollisionData*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttackCollisionData* UCollisionManager::GetAttackCollisionData(int32 UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "GetAttackCollisionData");

	Params::CollisionManager_GetAttackCollisionData Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CollisionManager.ReleaseRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    calledAC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollisionManager::ReleaseRequest(int32 UniqueId, bool calledAC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "ReleaseRequest");

	Params::CollisionManager_ReleaseRequest Parms{};

	Parms.UniqueId = UniqueId;
	Parms.calledAC = calledAC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollisionManager.RemoveAttackData
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollisionManager::RemoveAttackData(int32 UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "RemoveAttackData");

	Params::CollisionManager_RemoveAttackData Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollisionManager.ReserveRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollisionManager::ReserveRequest(int32 UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "ReserveRequest");

	Params::CollisionManager_ReserveRequest Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CollisionManager.ReturnCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAttackCollisionBase*             collision                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollisionManager::ReturnCollision(class AAttackCollisionBase* collision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollisionManager", "ReturnCollision");

	Params::CollisionManager_ReturnCollision Parms{};

	Parms.collision = collision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CommonEmoteSettingDataTable.GetFaceType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EEmoteType                              emoteType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteFaceType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEmoteFaceType UCommonEmoteSettingDataTable::GetFaceType(EEmoteType emoteType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonEmoteSettingDataTable", "GetFaceType");

	Params::CommonEmoteSettingDataTable_GetFaceType Parms{};

	Parms.emoteType = emoteType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.CommonEmoteSettingDataTable.GetStampParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EEmoteType                              emoteType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStampIconType                          outIconType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmoteStampSetting               outSetting                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonEmoteSettingDataTable::GetStampParameter(EEmoteType emoteType, EStampIconType* outIconType, struct FEmoteStampSetting* outSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CommonEmoteSettingDataTable", "GetStampParameter");

	Params::CommonEmoteSettingDataTable_GetStampParameter Parms{};

	Parms.emoteType = emoteType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outIconType != nullptr)
		*outIconType = Parms.outIconType;

	if (outSetting != nullptr)
		*outSetting = std::move(Parms.outSetting);

	return Parms.ReturnValue;
}


// Function DarwinGame.CommunicationComponent.EndInteraction
// (Final, Native, Public, BlueprintCallable)

void UCommunicationComponent::EndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommunicationComponent", "EndInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CommunicationComponent.FieldSearch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommunicationComponent::FieldSearch(float Range, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommunicationComponent", "FieldSearch");

	Params::CommunicationComponent_FieldSearch Parms{};

	Parms.Range = Range;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CommunicationComponent.SearchArtifact
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Brightness                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommunicationComponent::SearchArtifact(const struct FVector& Center, float Range, float Time, float Brightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommunicationComponent", "SearchArtifact");

	Params::CommunicationComponent_SearchArtifact Parms{};

	Parms.Center = std::move(Center);
	Parms.Range = Range;
	Parms.Time = Time;
	Parms.Brightness = Brightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CommunicationComponent.SearchNPC
// (Final, Native, Public, BlueprintCallable)

void UCommunicationComponent::SearchNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommunicationComponent", "SearchNPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimate_Menu_00.End
// (Final, Native, Private)

void UUIEstimate_Menu_00::End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_Menu_00", "End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimate_Menu_00.OpenBonusDialog
// (Final, Native, Private)

void UUIEstimate_Menu_00::OpenBonusDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_Menu_00", "OpenBonusDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CustomEquipmentFunctionLibrary.AddRivalTeamEquipment
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERivalTeamForce                         Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLeader                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEquipmentFunctionLibrary::AddRivalTeamEquipment(class AGPACharacter* Target, ERivalTeamForce Force, bool bIsLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomEquipmentFunctionLibrary", "AddRivalTeamEquipment");

	Params::CustomEquipmentFunctionLibrary_AddRivalTeamEquipment Parms{};

	Parms.Target = Target;
	Parms.Force = Force;
	Parms.bIsLeader = bIsLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CustomEquipmentFunctionLibrary.ChangeCustomEquipment
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomEquipmentInfomation       Info                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCustomEquipmentFunctionLibrary::ChangeCustomEquipment(class AGPACharacter* Target, const struct FCustomEquipmentInfomation& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomEquipmentFunctionLibrary", "ChangeCustomEquipment");

	Params::CustomEquipmentFunctionLibrary_ChangeCustomEquipment Parms{};

	Parms.Target = Target;
	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CustomEquipmentFunctionLibrary.ChangeCustomMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEquipmentFunctionLibrary::ChangeCustomMaterial(class AGPACharacter* Target, class FName KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomEquipmentFunctionLibrary", "ChangeCustomMaterial");

	Params::CustomEquipmentFunctionLibrary_ChangeCustomMaterial Parms{};

	Parms.Target = Target;
	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CustomEquipmentFunctionLibrary.GenerateCustomEquipment
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_MonsterCustomEquipmentData   Equipment                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCustomEquipmentFunctionLibrary::GenerateCustomEquipment(class AGPACharacter* Target, const struct FST_MonsterCustomEquipmentData& Equipment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomEquipmentFunctionLibrary", "GenerateCustomEquipment");

	Params::CustomEquipmentFunctionLibrary_GenerateCustomEquipment Parms{};

	Parms.Target = Target;
	Parms.Equipment = std::move(Equipment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.CustomEquipmentFunctionLibrary.LotteryRivalTeamEquipment
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomEquipmentFunctionLibrary::LotteryRivalTeamEquipment(class AMonster* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomEquipmentFunctionLibrary", "LotteryRivalTeamEquipment");

	Params::CustomEquipmentFunctionLibrary_LotteryRivalTeamEquipment Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DamageCollisionComponent.AddTask
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageCollisionTask*             Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageCollisionComponent::AddTask(int32 Key, class UDamageCollisionTask* Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageCollisionComponent", "AddTask");

	Params::DamageCollisionComponent_AddTask Parms{};

	Parms.Key = Key;
	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DamageCollisionComponent.RemoveTask
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageCollisionComponent::RemoveTask(int32 Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageCollisionComponent", "RemoveTask");

	Params::DamageCollisionComponent_RemoveTask Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DamageElementInterface.IsTypeHide
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionHiddenType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsTypeHide(ECollisionHiddenType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsTypeHide");

	Params::DamageElementInterface_IsTypeHide Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.SetEnableWeakPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDamageElementInterface::SetEnableWeakPoint(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "SetEnableWeakPoint");

	Params::DamageElementInterface_SetEnableWeakPoint Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DamageElementInterface.SetHide
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECollisionHiddenType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDamageElementInterface::SetHide(ECollisionHiddenType Type, bool hide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "SetHide");

	Params::DamageElementInterface_SetHide Parms{};

	Parms.Type = Type;
	Parms.hide = hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DamageElementInterface.GetAimWeight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDamageElementInterface::GetAimWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "GetAimWeight");

	Params::DamageElementInterface_GetAimWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.GetDamageRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDamageElementInterface::GetDamageRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "GetDamageRate");

	Params::DamageElementInterface_GetDamageRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsCenterPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsCenterPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsCenterPoint");

	Params::DamageElementInterface_IsCenterPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsEnableWeakPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsEnableWeakPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsEnableWeakPoint");

	Params::DamageElementInterface_IsEnableWeakPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsIgnoreAimSelectableList
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsIgnoreAimSelectableList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsIgnoreAimSelectableList");

	Params::DamageElementInterface_IsIgnoreAimSelectableList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsMustAimed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsMustAimed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsMustAimed");

	Params::DamageElementInterface_IsMustAimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsNeverTargeted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsNeverTargeted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsNeverTargeted");

	Params::DamageElementInterface_IsNeverTargeted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsNotAbleToPenetrate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsNotAbleToPenetrate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsNotAbleToPenetrate");

	Params::DamageElementInterface_IsNotAbleToPenetrate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DamageElementInterface.IsWeakPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDamageElementInterface::IsWeakPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageElementInterface", "IsWeakPoint");

	Params::DamageElementInterface_IsWeakPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinEventFlagDefinition.IsDebugEventEnableFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinEventFlagDefinition::IsDebugEventEnableFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinEventFlagDefinition", "IsDebugEventEnableFlag");

	Params::DarwinEventFlagDefinition_IsDebugEventEnableFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinEventFlagDefinition.SetDebugEventEnableFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinEventFlagDefinition::SetDebugEventEnableFlag(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinEventFlagDefinition", "SetDebugEventEnableFlag");

	Params::DarwinEventFlagDefinition_SetDebugEventEnableFlag Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.SetCharacterCustomEquip
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    GPACharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomEquipmentKind                    CustomKind                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AdditionalEquipment                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AdditionalMaterial                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERivalTeamForce                         RivalTeamForce                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLeader                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::SetCharacterCustomEquip(class AGPACharacter* GPACharacter, const class FName KindId, const ECustomEquipmentKind CustomKind, const bool AdditionalEquipment, const bool AdditionalMaterial, const ERivalTeamForce RivalTeamForce, const bool IsLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DarwinLevelSequenceDirector", "SetCharacterCustomEquip");

	Params::DarwinLevelSequenceDirector_SetCharacterCustomEquip Parms{};

	Parms.GPACharacter = GPACharacter;
	Parms.KindId = KindId;
	Parms.CustomKind = CustomKind;
	Parms.AdditionalEquipment = AdditionalEquipment;
	Parms.AdditionalMaterial = AdditionalMaterial;
	Parms.RivalTeamForce = RivalTeamForce;
	Parms.IsLeader = IsLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.AddLookAtTarget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::AddLookAtTarget(class AGameCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "AddLookAtTarget");

	Params::DarwinLevelSequenceDirector_AddLookAtTarget Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.ChangeFacial
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::ChangeFacial(class AGameCharacter* Character, EEmoteType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "ChangeFacial");

	Params::DarwinLevelSequenceDirector_ChangeFacial Parms{};

	Parms.Character = Character;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CheckAndOpenTips
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::CheckAndOpenTips(const class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CheckAndOpenTips");

	Params::DarwinLevelSequenceDirector_CheckAndOpenTips Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CheckBonFireIsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::CheckBonFireIsActive(const class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CheckBonFireIsActive");

	Params::DarwinLevelSequenceDirector_CheckBonFireIsActive Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.ClearNpcNickName
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::ClearNpcNickName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "ClearNpcNickName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseAllMovie
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseAllMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseAllMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseAllOpenUI
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseAllOpenUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseAllOpenUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseBoardMenuMessageWindow
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseBoardMenuMessageWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseBoardMenuMessageWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseMovie
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseNetworkReturnMessageWindow
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseNetworkReturnMessageWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseNetworkReturnMessageWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseSubTitleLogo
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseSubTitleLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseSubTitleLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CloseWaitUI
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::CloseWaitUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CloseWaitUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.CreateTextID
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FDrawTextInfo                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDrawTextInfo UDarwinLevelSequenceDirector::CreateTextID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "CreateTextID");

	Params::DarwinLevelSequenceDirector_CreateTextID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.DarwinResetBindings
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              LevelSequenceActor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::DarwinResetBindings(class ALevelSequenceActor* LevelSequenceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "DarwinResetBindings");

	Params::DarwinLevelSequenceDirector_DarwinResetBindings Parms{};

	Parms.LevelSequenceActor = LevelSequenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.DisplayMovie
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             movieName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLoop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::DisplayMovie(class FName movieName, bool IsLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "DisplayMovie");

	Params::DarwinLevelSequenceDirector_DisplayMovie Parms{};

	Parms.movieName = movieName;
	Parms.IsLoop = IsLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.DisplayNpcNickName
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAnotherLayout                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::DisplayNpcNickName(const class FName NpcID, bool IsAnotherLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "DisplayNpcNickName");

	Params::DarwinLevelSequenceDirector_DisplayNpcNickName Parms{};

	Parms.NpcID = NpcID;
	Parms.IsAnotherLayout = IsAnotherLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.DisplayPicture
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             PictureID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOverMovieUI                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::DisplayPicture(const class FName PictureID, bool IsOverMovieUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "DisplayPicture");

	Params::DarwinLevelSequenceDirector_DisplayPicture Parms{};

	Parms.PictureID = PictureID;
	Parms.IsOverMovieUI = IsOverMovieUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.FadeInMovie
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   second                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::FadeInMovie(float second)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "FadeInMovie");

	Params::DarwinLevelSequenceDirector_FadeInMovie Parms{};

	Parms.second = second;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.FadeOutMovie
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   second                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::FadeOutMovie(float second)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "FadeOutMovie");

	Params::DarwinLevelSequenceDirector_FadeOutMovie Parms{};

	Parms.second = second;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.FinishLookAtAllTrackCharacters
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::FinishLookAtAllTrackCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "FinishLookAtAllTrackCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.HideCharactersForPlayer
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              rootActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::HideCharactersForPlayer(class ALevelSequenceActor* rootActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "HideCharactersForPlayer");

	Params::DarwinLevelSequenceDirector_HideCharactersForPlayer Parms{};

	Parms.rootActor = rootActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.HideDefaultRebindCharacters
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              rootActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FST_SequencerRebindOrder>rebindOders                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::HideDefaultRebindCharacters(class ALevelSequenceActor* rootActor, const TMap<class FString, struct FST_SequencerRebindOrder>& rebindOders)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "HideDefaultRebindCharacters");

	Params::DarwinLevelSequenceDirector_HideDefaultRebindCharacters Parms{};

	Parms.rootActor = rootActor;
	Parms.rebindOders = std::move(rebindOders);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.InitLookAtTargets
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::InitLookAtTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "InitLookAtTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.IsFindBindingTag
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              rootActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CheckTag                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::IsFindBindingTag(class ALevelSequenceActor* rootActor, const class FString& CheckTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "IsFindBindingTag");

	Params::DarwinLevelSequenceDirector_IsFindBindingTag Parms{};

	Parms.rootActor = rootActor;
	Parms.CheckTag = std::move(CheckTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.IsOpenWaitUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::IsOpenWaitUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "IsOpenWaitUI");

	Params::DarwinLevelSequenceDirector_IsOpenWaitUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.JumpToMarkedFrame
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           InLabel                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::JumpToMarkedFrame(const class FString& InLabel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "JumpToMarkedFrame");

	Params::DarwinLevelSequenceDirector_JumpToMarkedFrame Parms{};

	Parms.InLabel = std::move(InLabel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenArtifactRepository
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenArtifactRepository()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenArtifactRepository");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenArtifactTomasonUI
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenArtifactTomasonUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenArtifactTomasonUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenBoardMenuMessageWindow
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenBoardMenuMessageWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenBoardMenuMessageWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenLithographyUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             MessageID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::OpenLithographyUI(const class FName MessageID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenLithographyUI");

	Params::DarwinLevelSequenceDirector_OpenLithographyUI Parms{};

	Parms.MessageID = MessageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenNetworkReturnMessageWindow
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenNetworkReturnMessageWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenNetworkReturnMessageWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenPressAnyButton
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenPressAnyButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenPressAnyButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenQuestRewardWindow
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::OpenQuestRewardWindow(const class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenQuestRewardWindow");

	Params::DarwinLevelSequenceDirector_OpenQuestRewardWindow Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenSubTitleLogo
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenSubTitleLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenSubTitleLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenTitleLogo
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenTitleLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenTitleLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.OpenTreasureAppraise
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::OpenTreasureAppraise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "OpenTreasureAppraise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PauseCharacters
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   blendFrame                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::PauseCharacters(float blendFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PauseCharacters");

	Params::DarwinLevelSequenceDirector_PauseCharacters Parms{};

	Parms.blendFrame = blendFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PlayBlink
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteBlinkType                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::PlayBlink(class AGameCharacter* Character, EEmoteBlinkType Type, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PlayBlink");

	Params::DarwinLevelSequenceDirector_PlayBlink Parms{};

	Parms.Character = Character;
	Parms.Type = Type;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PlayEmoteBody
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::PlayEmoteBody(class AGameCharacter* Character, EEmoteType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PlayEmoteBody");

	Params::DarwinLevelSequenceDirector_PlayEmoteBody Parms{};

	Parms.Character = Character;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PlayUIOneShot
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UIName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::PlayUIOneShot(class FName EventID, class FName UIName, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PlayUIOneShot");

	Params::DarwinLevelSequenceDirector_PlayUIOneShot Parms{};

	Parms.EventID = EventID;
	Parms.UIName = UIName;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PlayVocalize
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteVocalizeType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::PlayVocalize(class AGameCharacter* Character, EEmoteVocalizeType Type, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PlayVocalize");

	Params::DarwinLevelSequenceDirector_PlayVocalize Parms{};

	Parms.Character = Character;
	Parms.Type = Type;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PlayVocalizeSyncDrawText
// (Final, Native, Private, BlueprintCallable)

void UDarwinLevelSequenceDirector::PlayVocalizeSyncDrawText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PlayVocalizeSyncDrawText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.PrepareMovie
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             movieName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLoop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::PrepareMovie(class FName movieName, bool IsLoop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "PrepareMovie");

	Params::DarwinLevelSequenceDirector_PrepareMovie Parms{};

	Parms.movieName = movieName;
	Parms.IsLoop = IsLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.RebindCharacters
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              rootActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FST_SequencerRebindOrder>rebindOders                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::RebindCharacters(class ALevelSequenceActor* rootActor, const TMap<class FString, struct FST_SequencerRebindOrder>& rebindOders)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "RebindCharacters");

	Params::DarwinLevelSequenceDirector_RebindCharacters Parms{};

	Parms.rootActor = rootActor;
	Parms.rebindOders = std::move(rebindOders);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.ReleaseLookAtTargets
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::ReleaseLookAtTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "ReleaseLookAtTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.RemovePicture
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::RemovePicture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "RemovePicture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.RemoveSkipUI
// (Final, Native, Public, BlueprintCallable)

void UDarwinLevelSequenceDirector::RemoveSkipUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "RemoveSkipUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.ResumeCharacters
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   blendFrame                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::ResumeCharacters(float blendFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "ResumeCharacters");

	Params::DarwinLevelSequenceDirector_ResumeCharacters Parms{};

	Parms.blendFrame = blendFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.SetEnableFootIK
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetFlag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::SetEnableFootIK(class AGameCharacter* TargetCharacter, bool bSetFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "SetEnableFootIK");

	Params::DarwinLevelSequenceDirector_SetEnableFootIK Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.bSetFlag = bSetFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.SetEnableFootIKAll
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bSetFlag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::SetEnableFootIKAll(bool bSetFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "SetEnableFootIKAll");

	Params::DarwinLevelSequenceDirector_SetEnableFootIKAll Parms{};

	Parms.bSetFlag = bSetFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.SetLastBattleSevenStoneVisiblity
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::SetLastBattleSevenStoneVisiblity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "SetLastBattleSevenStoneVisiblity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.SetRendringMode
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::SetRendringMode(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "SetRendringMode");

	Params::DarwinLevelSequenceDirector_SetRendringMode Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.SetVocalizeSyncDrawText
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::SetVocalizeSyncDrawText(class AGameCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "SetVocalizeSyncDrawText");

	Params::DarwinLevelSequenceDirector_SetVocalizeSyncDrawText Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.StopBlink
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::StopBlink(class AGameCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "StopBlink");

	Params::DarwinLevelSequenceDirector_StopBlink Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.StopEmoteBody
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::StopEmoteBody(class AGameCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "StopEmoteBody");

	Params::DarwinLevelSequenceDirector_StopEmoteBody Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.StopEmoteBodyOfAllFriend
// (Final, Native, Protected, BlueprintCallable)

void UDarwinLevelSequenceDirector::StopEmoteBodyOfAllFriend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "StopEmoteBodyOfAllFriend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.StopVocalize
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::StopVocalize(class AGameCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "StopVocalize");

	Params::DarwinLevelSequenceDirector_StopVocalize Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.StopVocalizeSyncDrawText
// (Final, Native, Private, BlueprintCallable)

void UDarwinLevelSequenceDirector::StopVocalizeSyncDrawText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "StopVocalizeSyncDrawText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.UpdateAnimTrack
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGameCharacter*                   Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::UpdateAnimTrack(const class AGameCharacter* Character, const class FName ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "UpdateAnimTrack");

	Params::DarwinLevelSequenceDirector_UpdateAnimTrack Parms{};

	Parms.Character = Character;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.UpdateAnimTrackFromMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarwinLevelSequenceDirector::UpdateAnimTrackFromMesh(const class USkeletalMeshComponent* Mesh, const class FName ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "UpdateAnimTrackFromMesh");

	Params::DarwinLevelSequenceDirector_UpdateAnimTrackFromMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinLevelSequenceDirector.FrameRate
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDarwinLevelSequenceDirector::FrameRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "FrameRate");

	Params::DarwinLevelSequenceDirector_FrameRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.IsOpenBoardMenuMessageWindow
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::IsOpenBoardMenuMessageWindow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "IsOpenBoardMenuMessageWindow");

	Params::DarwinLevelSequenceDirector_IsOpenBoardMenuMessageWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinLevelSequenceDirector.IsOpenNetworkReturnMessageWindow
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDarwinLevelSequenceDirector::IsOpenNetworkReturnMessageWindow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinLevelSequenceDirector", "IsOpenNetworkReturnMessageWindow");

	Params::DarwinLevelSequenceDirector_IsOpenNetworkReturnMessageWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DarwinWidgetComponent.Close
// (Final, Native, Public, BlueprintCallable)

void UDarwinWidgetComponent::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinWidgetComponent", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinWidgetComponent.open
// (Final, Native, Public, BlueprintCallable)

void UDarwinWidgetComponent::open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinWidgetComponent", "open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DarwinWidgetComponent.Remove
// (Final, Native, Public, BlueprintCallable)

void UDarwinWidgetComponent::Remove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarwinWidgetComponent", "Remove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DebugEventRectActor.SetMaterialColorToEventType
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMoveForce                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugEventRectActor::SetMaterialColorToEventType(const bool IsActive, const bool IsMoveForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugEventRectActor", "SetMaterialColorToEventType");

	Params::DebugEventRectActor_SetMaterialColorToEventType Parms{};

	Parms.IsActive = IsActive;
	Parms.IsMoveForce = IsMoveForce;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.ParamDataAsset.AddParamValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ListName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             IndexName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AddValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UParamDataAsset::AddParamValue(class FName ListName, class FName IndexName, class FName ParamName, float AddValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamDataAsset", "AddParamValue");

	Params::ParamDataAsset_AddParamValue Parms{};

	Parms.ListName = ListName;
	Parms.IndexName = IndexName;
	Parms.ParamName = ParamName;
	Parms.AddValue = AddValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ParamDataAsset.GetParamValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ListName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             IndexName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UParamDataAsset::GetParamValue(class FName ListName, class FName IndexName, class FName ParamName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamDataAsset", "GetParamValue");

	Params::ParamDataAsset_GetParamValue Parms{};

	Parms.ListName = ListName;
	Parms.IndexName = IndexName;
	Parms.ParamName = ParamName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ParamDataAsset.Import
// (Final, Native, Public)

void UParamDataAsset::Import()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamDataAsset", "Import");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ParamDataAsset.ResetList
// (Final, Native, Public, BlueprintCallable)

void UParamDataAsset::ResetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamDataAsset", "ResetList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ParamDataAsset.ResetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ListName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             IndexName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParamName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UParamDataAsset::ResetValue(class FName ListName, class FName IndexName, class FName ParamName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParamDataAsset", "ResetValue");

	Params::ParamDataAsset_ResetValue Parms{};

	Parms.ListName = ListName;
	Parms.IndexName = IndexName;
	Parms.ParamName = ParamName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DebugWarpListData.SortList
// (Final, Native, Public, BlueprintCallable)

void UDebugWarpListData::SortList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugWarpListData", "SortList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICoinMenu_Top.Refresh
// (Final, Native, Public, BlueprintCallable)

void UUICoinMenu_Top::Refresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoinMenu_Top", "Refresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DesertGimmick.BossHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBoss*                     Boss                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Result                                                 (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADesertGimmick::BossHit(class AMonsterBoss* Boss, const struct FHitResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "BossHit");

	Params::DesertGimmick_BossHit Parms{};

	Parms.Boss = Boss;
	Parms.Result = std::move(Result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DesertGimmick.GetBossHitResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult ADesertGimmick::GetBossHitResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "GetBossHitResult");

	Params::DesertGimmick_GetBossHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DesertGimmick.GetHitBoss
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMonsterBoss*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterBoss* ADesertGimmick::GetHitBoss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "GetHitBoss");

	Params::DesertGimmick_GetHitBoss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DesertGimmick.GimmickBreakEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    destroy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADesertGimmick::GimmickBreakEffect(bool destroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "GimmickBreakEffect");

	Params::DesertGimmick_GimmickBreakEffect Parms{};

	Parms.destroy = destroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DesertGimmick.GimmickRevive
// (Final, Native, Public, BlueprintCallable)

void ADesertGimmick::GimmickRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "GimmickRevive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DesertGimmick.HitCheckCylindrical
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          attacklocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   attackradius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   attackhalfheight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   targetradius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   targethalfheight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADesertGimmick::HitCheckCylindrical(const struct FVector& attacklocation, float attackradius, float attackhalfheight, const struct FVector& TargetLocation, float targetradius, float targethalfheight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "HitCheckCylindrical");

	Params::DesertGimmick_HitCheckCylindrical Parms{};

	Parms.attacklocation = std::move(attacklocation);
	Parms.attackradius = attackradius;
	Parms.attackhalfheight = attackhalfheight;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.targetradius = targetradius;
	Parms.targethalfheight = targethalfheight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DesertGimmick.HitCheckUnderGround
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          attacklocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   attackradius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   targetradius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADesertGimmick::HitCheckUnderGround(const struct FVector& attacklocation, float attackradius, const struct FVector& TargetLocation, float targetradius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "HitCheckUnderGround");

	Params::DesertGimmick_HitCheckUnderGround Parms{};

	Parms.attacklocation = std::move(attacklocation);
	Parms.attackradius = attackradius;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.targetradius = targetradius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.DesertGimmick.IsBossHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADesertGimmick::IsBossHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesertGimmick", "IsBossHit");

	Params::DesertGimmick_IsBossHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIFieldActionGauge.PlaySuccessAnim
// (Native, Protected, BlueprintCallable)

void UUIFieldActionGauge::PlaySuccessAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFieldActionGauge", "PlaySuccessAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFieldActionGauge.SetGuideType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputGuideType                         GuideType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldActionGauge::SetGuideType(EInputGuideType GuideType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFieldActionGauge", "SetGuideType");

	Params::UIFieldActionGauge_SetGuideType Parms{};

	Parms.GuideType = GuideType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFieldActionGauge.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFieldActionGauge::SetPercent(float Percent, bool HasInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFieldActionGauge", "SetPercent");

	Params::UIFieldActionGauge_SetPercent Parms{};

	Parms.Percent = Percent;
	Parms.HasInput = HasInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFieldActionGauge.SuccessAnimEnd
// (Final, Native, Private)

void UUIFieldActionGauge::SuccessAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFieldActionGauge", "SuccessAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICommonmenu_04.OnChangeFocusFunc
// (Final, Native, Private)

void UUICommonmenu_04::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICommonmenu_04", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DispatchDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UDispatchDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DispatchDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DispatchSceneCapture.EndSequencer
// (Event, Public, BlueprintEvent)

void ADispatchSceneCapture::EndSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DispatchSceneCapture", "EndSequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.DispatchSceneCapture.StartSequencer
// (Event, Public, BlueprintEvent)

void ADispatchSceneCapture::StartSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DispatchSceneCapture", "StartSequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.DispatchSceneCapture.UpdateTagNames
// (Final, Native, Public, BlueprintCallable)

void ADispatchSceneCapture::UpdateTagNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DispatchSceneCapture", "UpdateTagNames");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UDungeonDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonGimmickNPC.InitNPC
// (Final, Native, Private)
// Parameters:
// class ANPCBase*                         NpcObj                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADungeonGimmickNPC::InitNPC(class ANPCBase* NpcObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonGimmickNPC", "InitNPC");

	Params::DungeonGimmickNPC_InitNPC Parms{};

	Parms.NpcObj = NpcObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonGimmickStarScar.MonserDefeatCallback
// (Final, Native, Private)

void ADungeonGimmickStarScar::MonserDefeatCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonGimmickStarScar", "MonserDefeatCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.DungeonStarScar.GetCoreStaticMeshComponent
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ADungeonStarScar::GetCoreStaticMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonStarScar", "GetCoreStaticMeshComponent");

	Params::DungeonStarScar_GetCoreStaticMeshComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectBlueprintFunctionLibrary.SetAutoDestory
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAutoDestory                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectBlueprintFunctionLibrary::SetAutoDestory(class UParticleSystemComponent* Component, bool isAutoDestory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EffectBlueprintFunctionLibrary", "SetAutoDestory");

	Params::EffectBlueprintFunctionLibrary_SetAutoDestory Parms{};

	Parms.Component = Component;
	Parms.isAutoDestory = isAutoDestory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEffectManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEffectManager* UEffectManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EffectManager", "GetInstance");

	Params::EffectManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.ReturnEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEffectBase*                      Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectManager::ReturnEffect(class AEffectBase* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "ReturnEffect");

	Params::EffectManager_ReturnEffect Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectManager.SearchEffectClass
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UEffectManager::SearchEffectClass(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SearchEffectClass");

	Params::EffectManager_SearchEffectClass Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SearchPresetCount
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEffectManager::SearchPresetCount(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SearchPresetCount");

	Params::EffectManager_SearchPresetCount Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SetMonsterEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEffectBase*                      monsterEffect                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectDataTableID                      EffectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    MonsterType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    leave                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEffectManager::SetMonsterEffect(class AEffectBase* monsterEffect, EEffectDataTableID EffectType, EMonsterRegisterType MonsterType, bool leave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SetMonsterEffect");

	Params::EffectManager_SetMonsterEffect Parms{};

	Parms.monsterEffect = monsterEffect;
	Parms.EffectType = EffectType;
	Parms.MonsterType = MonsterType;
	Parms.leave = leave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EffectManager.SpawnAttachActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          local_location                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         local_rotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          local_scale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnAttachActor(class FName ID, class AActor* Parent, class FName socket, const struct FVector& local_location, const struct FRotator& local_rotation, const struct FVector& local_scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnAttachActor");

	Params::EffectManager_SpawnAttachActor Parms{};

	Parms.ID = ID;
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.local_location = std::move(local_location);
	Parms.local_rotation = std::move(local_rotation);
	Parms.local_scale = std::move(local_scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnAttachComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          local_location                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         local_rotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          local_scale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnAttachComponent(class FName ID, class USceneComponent* Parent, class FName socket, const struct FVector& local_location, const struct FRotator& local_rotation, const struct FVector& local_scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnAttachComponent");

	Params::EffectManager_SpawnAttachComponent Parms{};

	Parms.ID = ID;
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.local_location = std::move(local_location);
	Parms.local_rotation = std::move(local_rotation);
	Parms.local_scale = std::move(local_scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnAttackMagic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAttackMagicEffectID                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicGradeEffectID                     Gragde                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicShotPhaseEffectID                 phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnAttackMagic(EAttackMagicEffectID Type, EMagicGradeEffectID Gragde, EMagicShotPhaseEffectID phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnAttackMagic");

	Params::EffectManager_SpawnAttackMagic Parms{};

	Parms.Type = Type;
	Parms.Gragde = Gragde;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnBattleCommon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBattleCommonEffectID                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnBattleCommon(EBattleCommonEffectID Type, EEffectSizeID Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnBattleCommon");

	Params::EffectManager_SpawnBattleCommon Parms{};

	Parms.Type = Type;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnBlessMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBlessMoveEffectID                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicGradeEffectID                     Gragde                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBlessMovePhaseEffectID                 phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnBlessMove(EBlessMoveEffectID Type, EMagicGradeEffectID Gragde, EBlessMovePhaseEffectID phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnBlessMove");

	Params::EffectManager_SpawnBlessMove Parms{};

	Parms.Type = Type;
	Parms.Gragde = Gragde;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnBoss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBossEffectID                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKindEffectID                           Kind                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnBoss(EBossEffectID Type, EKindEffectID Kind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnBoss");

	Params::EffectManager_SpawnBoss Parms{};

	Parms.Type = Type;
	Parms.Kind = Kind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnCharacterCommon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterCommonEffectID                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnCharacterCommon(ECharacterCommonEffectID Type, EEffectSizeID Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnCharacterCommon");

	Params::EffectManager_SpawnCharacterCommon Parms{};

	Parms.Type = Type;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageEffectID                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnDamage(EDamageEffectID Type, EEffectSizeID Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnDamage");

	Params::EffectManager_SpawnDamage Parms{};

	Parms.Type = Type;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnEffect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          world_location                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         world_rotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          world_scale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnEffect(class FName ID, const struct FVector& world_location, const struct FRotator& world_rotation, const struct FVector& world_scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnEffect");

	Params::EffectManager_SpawnEffect Parms{};

	Parms.ID = ID;
	Parms.world_location = std::move(world_location);
	Parms.world_rotation = std::move(world_rotation);
	Parms.world_scale = std::move(world_scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnEmotion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmotionEffectID                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnEmotion(EEmotionEffectID Type, EEffectSizeID Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnEmotion");

	Params::EffectManager_SpawnEmotion Parms{};

	Parms.Type = Type;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnFootSmoke
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurfaceEffectTypeID            SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootSmokeActionEffectTypeID            Pattern                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnFootSmoke(EPhysicalSurfaceEffectTypeID SurfaceType, EFootSmokeActionEffectTypeID Pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnFootSmoke");

	Params::EffectManager_SpawnFootSmoke Parms{};

	Parms.SurfaceType = SurfaceType;
	Parms.Pattern = Pattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnFootTerrain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFootTerrainTypeID                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootSmokeActionEffectTypeID            Pattern                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnFootTerrain(EFootTerrainTypeID Type, EFootSmokeActionEffectTypeID Pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnFootTerrain");

	Params::EffectManager_SpawnFootTerrain Parms{};

	Parms.Type = Type;
	Parms.Pattern = Pattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnObjectBreak
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObjectBreakEffectID                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnObjectBreak(EObjectBreakEffectID Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnObjectBreak");

	Params::EffectManager_SpawnObjectBreak Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnObjectCommon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObjectCommonEffectID                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectPatternID                        Pattern                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnObjectCommon(EObjectCommonEffectID Type, EEffectPatternID Pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnObjectCommon");

	Params::EffectManager_SpawnObjectCommon Parms{};

	Parms.Type = Type;
	Parms.Pattern = Pattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnSelfBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESelfBuffEffectID                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnSelfBuff(ESelfBuffEffectID Type, EEffectSizeID Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnSelfBuff");

	Params::EffectManager_SpawnSelfBuff Parms{};

	Parms.Type = Type;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESkillEffectID                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKindEffectID                           Kind                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicShotPhaseEffectID                 phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnSkill(ESkillEffectID Type, EKindEffectID Kind, EMagicShotPhaseEffectID phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnSkill");

	Params::EffectManager_SpawnSkill Parms{};

	Parms.Type = Type;
	Parms.Kind = Kind;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnSkillChain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESkillChainEffectID                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillChainPhaseEffectID                phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnSkillChain(ESkillChainEffectID Type, ESkillChainPhaseEffectID phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnSkillChain");

	Params::EffectManager_SpawnSkillChain Parms{};

	Parms.Type = Type;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnSlingshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlingshotEffectID                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicGradeEffectID                     Gragde                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnSlingshot(ESlingshotEffectID Type, EMagicGradeEffectID Gragde)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnSlingshot");

	Params::EffectManager_SpawnSlingshot Parms{};

	Parms.Type = Type;
	Parms.Gragde = Gragde;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStatusEffectID                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnStatus(EStatusEffectID Type, EEffectSizeID Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnStatus");

	Params::EffectManager_SpawnStatus Parms{};

	Parms.Type = Type;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnSupportMagic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESupportMagicEffectID                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicGradeEffectID                     Gragde                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicShotPhaseEffectID                 phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnSupportMagic(ESupportMagicEffectID Type, EMagicGradeEffectID Gragde, EMagicShotPhaseEffectID phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnSupportMagic");

	Params::EffectManager_SpawnSupportMagic Parms{};

	Parms.Type = Type;
	Parms.Gragde = Gragde;
	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.SpawnSupportMagicHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESupportMagicEffectID                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicGradeEffectID                     Gragde                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMagicShotPhaseEffectID                 phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           SizeID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEffectBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEffectBase* UEffectManager::SpawnSupportMagicHit(ESupportMagicEffectID Type, EMagicGradeEffectID Gragde, EMagicShotPhaseEffectID phase, EEffectSizeID SizeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "SpawnSupportMagicHit");

	Params::EffectManager_SpawnSupportMagicHit Parms{};

	Parms.Type = Type;
	Parms.Gragde = Gragde;
	Parms.phase = phase;
	Parms.SizeID = SizeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EffectManager.GetKey
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UEffectManager::GetKey() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectManager", "GetKey");

	Params::EffectManager_GetKey Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteFaceComponent.CancelEmoteBlink
// (Final, Native, Public, BlueprintCallable)

void UEmoteFaceComponent::CancelEmoteBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "CancelEmoteBlink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.CancelEmoteFace
// (Final, Native, Public, BlueprintCallable)

void UEmoteFaceComponent::CancelEmoteFace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "CancelEmoteFace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.CancelEmoteVocalize
// (Final, Native, Public, BlueprintCallable)

void UEmoteFaceComponent::CancelEmoteVocalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "CancelEmoteVocalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.IsPlayEmoteBlink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCheckApplyRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmoteFaceComponent::IsPlayEmoteBlink(bool bCheckApplyRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "IsPlayEmoteBlink");

	Params::EmoteFaceComponent_IsPlayEmoteBlink Parms{};

	Parms.bCheckApplyRate = bCheckApplyRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteFaceComponent.IsPlayEmoteVocalize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCheckApplyRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmoteFaceComponent::IsPlayEmoteVocalize(bool bCheckApplyRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "IsPlayEmoteVocalize");

	Params::EmoteFaceComponent_IsPlayEmoteVocalize Parms{};

	Parms.bCheckApplyRate = bCheckApplyRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteFaceComponent.PlayEmoteBlink
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEmoteBlinkSetting               BlinkType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEmoteFaceComponent::PlayEmoteBlink(const struct FEmoteBlinkSetting& BlinkType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "PlayEmoteBlink");

	Params::EmoteFaceComponent_PlayEmoteBlink Parms{};

	Parms.BlinkType = std::move(BlinkType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.PlayEmoteFace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEmoteFaceType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEmoteFaceOverwriteOption*        Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteFaceComponent::PlayEmoteFace(EEmoteFaceType Type, class UEmoteFaceOverwriteOption* Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "PlayEmoteFace");

	Params::EmoteFaceComponent_PlayEmoteFace Parms{};

	Parms.Type = Type;
	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.PlayEmoteVocalize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEmoteVocalizeSetting            BlinkType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEmoteFaceComponent::PlayEmoteVocalize(const struct FEmoteVocalizeSetting& BlinkType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "PlayEmoteVocalize");

	Params::EmoteFaceComponent_PlayEmoteVocalize Parms{};

	Parms.BlinkType = std::move(BlinkType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.SetEnableApplyEmoteFace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteFaceComponent::SetEnableApplyEmoteFace(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "SetEnableApplyEmoteFace");

	Params::EmoteFaceComponent_SetEnableApplyEmoteFace Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.StopEmoteBlink
// (Final, Native, Public, BlueprintCallable)

void UEmoteFaceComponent::StopEmoteBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "StopEmoteBlink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.StopEmoteFace
// (Final, Native, Public, BlueprintCallable)

void UEmoteFaceComponent::StopEmoteFace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "StopEmoteFace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.StopEmoteVocalize
// (Final, Native, Public, BlueprintCallable)

void UEmoteFaceComponent::StopEmoteVocalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "StopEmoteVocalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteFaceComponent.IsPlayEmoteFace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bCheckApplyRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmoteFaceComponent::IsPlayEmoteFace(bool bCheckApplyRate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteFaceComponent", "IsPlayEmoteFace");

	Params::EmoteFaceComponent_IsPlayEmoteFace Parms{};

	Parms.bCheckApplyRate = bCheckApplyRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteInterfaceForABP.CancelEmoteBody
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IEmoteInterfaceForABP::CancelEmoteBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "CancelEmoteBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.EndEmoteBody
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IEmoteInterfaceForABP::EndEmoteBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "EndEmoteBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.GetCurrentEmoteBodyRequest
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteBodyMotionRequest          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FEmoteBodyMotionRequest IEmoteInterfaceForABP::GetCurrentEmoteBodyRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "GetCurrentEmoteBodyRequest");

	Params::EmoteInterfaceForABP_GetCurrentEmoteBodyRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteInterfaceForABP.GetEnableApplyEmoteFace
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEmoteInterfaceForABP::GetEnableApplyEmoteFace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "GetEnableApplyEmoteFace");

	Params::EmoteInterfaceForABP_GetEnableApplyEmoteFace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteInterfaceForABP.RequestEmoteBody
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteBodyMotionRequest          Request                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::RequestEmoteBody(const struct FEmoteBodyMotionRequest& Request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "RequestEmoteBody");

	Params::EmoteInterfaceForABP_RequestEmoteBody Parms{};

	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteBlinkBlendRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlendRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteBlinkBlendRate(float BlendRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteBlinkBlendRate");

	Params::EmoteInterfaceForABP_SetEmoteBlinkBlendRate Parms{};

	Parms.BlendRate = BlendRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteBlinkNextData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteBlinkData                  BlinkData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteBlinkNextData(const struct FEmoteBlinkData& BlinkData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteBlinkNextData");

	Params::EmoteInterfaceForABP_SetEmoteBlinkNextData Parms{};

	Parms.BlinkData = std::move(BlinkData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteBlinkNextRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlinkRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteBlinkNextRate(float BlinkRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteBlinkNextRate");

	Params::EmoteInterfaceForABP_SetEmoteBlinkNextRate Parms{};

	Parms.BlinkRate = BlinkRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteBlinkNowData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteBlinkData                  BlinkData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteBlinkNowData(const struct FEmoteBlinkData& BlinkData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteBlinkNowData");

	Params::EmoteInterfaceForABP_SetEmoteBlinkNowData Parms{};

	Parms.BlinkData = std::move(BlinkData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteBlinkNowRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlinkRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteBlinkNowRate(float BlinkRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteBlinkNowRate");

	Params::EmoteInterfaceForABP_SetEmoteBlinkNowRate Parms{};

	Parms.BlinkRate = BlinkRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteFaceApplyRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteFaceApplyRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteFaceApplyRate");

	Params::EmoteInterfaceForABP_SetEmoteFaceApplyRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteFacialAnim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequence*                    FacialAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteFacialAnim(class UAnimSequence* FacialAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteFacialAnim");

	Params::EmoteInterfaceForABP_SetEmoteFacialAnim Parms{};

	Parms.FacialAnim = FacialAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteFacialBlendRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlendRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteFacialBlendRate(float BlendRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteFacialBlendRate");

	Params::EmoteInterfaceForABP_SetEmoteFacialBlendRate Parms{};

	Parms.BlendRate = BlendRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteFacialNextData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteFacialRequestData          FacialData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteFacialNextData(const struct FEmoteFacialRequestData& FacialData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteFacialNextData");

	Params::EmoteInterfaceForABP_SetEmoteFacialNextData Parms{};

	Parms.FacialData = std::move(FacialData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteFacialNowData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteFacialRequestData          FacialData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteFacialNowData(const struct FEmoteFacialRequestData& FacialData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteFacialNowData");

	Params::EmoteInterfaceForABP_SetEmoteFacialNowData Parms{};

	Parms.FacialData = std::move(FacialData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteVocalizeBlendRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BlendRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteVocalizeBlendRate(float BlendRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteVocalizeBlendRate");

	Params::EmoteInterfaceForABP_SetEmoteVocalizeBlendRate Parms{};

	Parms.BlendRate = BlendRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteVocalizeNextData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteVocalizeAnimData           VocalizeData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteVocalizeNextData(const struct FEmoteVocalizeAnimData& VocalizeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteVocalizeNextData");

	Params::EmoteInterfaceForABP_SetEmoteVocalizeNextData Parms{};

	Parms.VocalizeData = std::move(VocalizeData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteVocalizeNextRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   VocalizeRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteVocalizeNextRate(float VocalizeRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteVocalizeNextRate");

	Params::EmoteInterfaceForABP_SetEmoteVocalizeNextRate Parms{};

	Parms.VocalizeRate = VocalizeRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteVocalizeNowData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FEmoteVocalizeAnimData           VocalizeData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteVocalizeNowData(const struct FEmoteVocalizeAnimData& VocalizeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteVocalizeNowData");

	Params::EmoteInterfaceForABP_SetEmoteVocalizeNowData Parms{};

	Parms.VocalizeData = std::move(VocalizeData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEmoteVocalizeNowRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   VocalizeRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEmoteVocalizeNowRate(float VocalizeRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEmoteVocalizeNowRate");

	Params::EmoteInterfaceForABP_SetEmoteVocalizeNowRate Parms{};

	Parms.VocalizeRate = VocalizeRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.SetEnableApplyEmoteFace
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEmoteInterfaceForABP::SetEnableApplyEmoteFace(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "SetEnableApplyEmoteFace");

	Params::EmoteInterfaceForABP_SetEnableApplyEmoteFace Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EmoteInterfaceForABP.HasEmoteFacialAnimData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEmoteInterfaceForABP::HasEmoteFacialAnimData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "HasEmoteFacialAnimData");

	Params::EmoteInterfaceForABP_HasEmoteFacialAnimData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteInterfaceForABP.HasValidEmoteFacialAnim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EEmoteFaceType                          FaceType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteFaceValidType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEmoteFaceValidType IEmoteInterfaceForABP::HasValidEmoteFacialAnim(EEmoteFaceType FaceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "HasValidEmoteFacialAnim");

	Params::EmoteInterfaceForABP_HasValidEmoteFacialAnim Parms{};

	Parms.FaceType = FaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EmoteInterfaceForABP.IsPlayEmoteBody
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEmoteInterfaceForABP::IsPlayEmoteBody() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteInterfaceForABP", "IsPlayEmoteBody");

	Params::EmoteInterfaceForABP_IsPlayEmoteBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnGeneratorAssetParent.SetGeneratorsID
// (Final, Native, Private, BlueprintCallable)

void UEnemySpawnGeneratorAssetParent::SetGeneratorsID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorAssetParent", "SetGeneratorsID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorAssetParent.UpdateProperty
// (Final, Native, Private, BlueprintCallable)

void UEnemySpawnGeneratorAssetParent::UpdateProperty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorAssetParent", "UpdateProperty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnGeneratorForStar.SetStarID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnGeneratorForStar::SetStarID(const class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnGeneratorForStar", "SetStarID");

	Params::EnemySpawnGeneratorForStar_SetStarID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.AddGenerator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEnemySpawnGeneratorBase*         Generator                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::AddGenerator(class UEnemySpawnGeneratorBase* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "AddGenerator");

	Params::EnemySpawnManager_AddGenerator Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.ChangeEventFlagCallBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsChanged                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::ChangeEventFlagCallBack(bool bEnable, bool bIsChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "ChangeEventFlagCallBack");

	Params::EnemySpawnManager_ChangeEventFlagCallBack Parms{};

	Parms.bEnable = bEnable;
	Parms.bIsChanged = bIsChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.FreeGenerators
// (Final, Native, Protected, BlueprintCallable)

void UEnemySpawnManager::FreeGenerators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "FreeGenerators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.NoticeDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnPointID                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::NoticeDead(const class FName SpawnPointID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "NoticeDead");

	Params::EnemySpawnManager_NoticeDead Parms{};

	Parms.SpawnPointID = SpawnPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.RemoveGenerator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEnemySpawnGeneratorBase*         Generator                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::RemoveGenerator(const class UEnemySpawnGeneratorBase* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "RemoveGenerator");

	Params::EnemySpawnManager_RemoveGenerator Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.RequestSpawnDefenceBattleMonsters
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          spawnPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERivalTeamForce                         Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   weaveCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   maxWeaveCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AMonsterBase* deaded)>end_func                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UEnemySpawnManager::RequestSpawnDefenceBattleMonsters(const struct FVector& spawnPoint, int32 SpawnRadius, ERivalTeamForce Force, int32 weaveCount, int32 maxWeaveCount, TDelegate<void(class AMonsterBase* deaded)> end_func)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "RequestSpawnDefenceBattleMonsters");

	Params::EnemySpawnManager_RequestSpawnDefenceBattleMonsters Parms{};

	Parms.spawnPoint = std::move(spawnPoint);
	Parms.SpawnRadius = SpawnRadius;
	Parms.Force = Force;
	Parms.weaveCount = weaveCount;
	Parms.maxWeaveCount = maxWeaveCount;
	Parms.end_func = end_func;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.RequestSpawnRevengeMonster
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          spawnPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BattleID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Subtract                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AMonsterBase* spawned)>begin_func                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class AMonsterBase* deaded)>end_func                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UEnemySpawnManager::RequestSpawnRevengeMonster(const struct FVector& spawnPoint, int32 SpawnRadius, class FName BattleID, int32 Subtract, TDelegate<void(class AMonsterBase* spawned)> begin_func, TDelegate<void(class AMonsterBase* deaded)> end_func)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "RequestSpawnRevengeMonster");

	Params::EnemySpawnManager_RequestSpawnRevengeMonster Parms{};

	Parms.spawnPoint = std::move(spawnPoint);
	Parms.SpawnRadius = SpawnRadius;
	Parms.BattleID = BattleID;
	Parms.Subtract = Subtract;
	Parms.begin_func = begin_func;
	Parms.end_func = end_func;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.SetSpawnAndDistanceCheckSkip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    skipFlag                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::SetSpawnAndDistanceCheckSkip(const bool skipFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "SetSpawnAndDistanceCheckSkip");

	Params::EnemySpawnManager_SetSpawnAndDistanceCheckSkip Parms{};

	Parms.skipFlag = skipFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.SetSpawnSkip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    skipFlag                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::SetSpawnSkip(const bool skipFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "SetSpawnSkip");

	Params::EnemySpawnManager_SetSpawnSkip Parms{};

	Parms.skipFlag = skipFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.SpawnImmediately
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnPointID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemySpawnManager::SpawnImmediately(class FName SpawnPointID, bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "SpawnImmediately");

	Params::EnemySpawnManager_SpawnImmediately Parms{};

	Parms.SpawnPointID = SpawnPointID;
	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnemySpawnManager.HasActiveMonsters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SpawnPointID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnManager::HasActiveMonsters(class FName SpawnPointID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "HasActiveMonsters");

	Params::EnemySpawnManager_HasActiveMonsters Parms{};

	Parms.SpawnPointID = SpawnPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnemySpawnManager.IsSpawnSkip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEnemySpawnManager::IsSpawnSkip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawnManager", "IsSpawnSkip");

	Params::EnemySpawnManager_IsSpawnSkip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentBlueprintFunctionLibrary.EaseLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ParamA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParamB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UEnvironmentBlueprintFunctionLibrary::EaseLinearColor(const struct FLinearColor& ParamA, const struct FLinearColor& ParamB, float Alpha, EEasingFunc EasingFunc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnvironmentBlueprintFunctionLibrary", "EaseLinearColor");

	Params::EnvironmentBlueprintFunctionLibrary_EaseLinearColor Parms{};

	Parms.ParamA = std::move(ParamA);
	Parms.ParamB = std::move(ParamB);
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentBlueprintFunctionLibrary.EaseVector4
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                         ParamA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ParamB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UEnvironmentBlueprintFunctionLibrary::EaseVector4(const struct FVector4& ParamA, const struct FVector4& ParamB, float Alpha, EEasingFunc EasingFunc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnvironmentBlueprintFunctionLibrary", "EaseVector4");

	Params::EnvironmentBlueprintFunctionLibrary_EaseVector4 Parms{};

	Parms.ParamA = std::move(ParamA);
	Parms.ParamB = std::move(ParamB);
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentBlueprintFunctionLibrary.GetCurveColorValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveLinearColor*                CurveFloat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UEnvironmentBlueprintFunctionLibrary::GetCurveColorValue(float Alpha, class UCurveLinearColor* CurveFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnvironmentBlueprintFunctionLibrary", "GetCurveColorValue");

	Params::EnvironmentBlueprintFunctionLibrary_GetCurveColorValue Parms{};

	Parms.Alpha = Alpha;
	Parms.CurveFloat = CurveFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentBlueprintFunctionLibrary.GetCurveFloatValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      CurveFloat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnvironmentBlueprintFunctionLibrary::GetCurveFloatValue(float Alpha, class UCurveFloat* CurveFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnvironmentBlueprintFunctionLibrary", "GetCurveFloatValue");

	Params::EnvironmentBlueprintFunctionLibrary_GetCurveFloatValue Parms{};

	Parms.Alpha = Alpha;
	Parms.CurveFloat = CurveFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentBlueprintFunctionLibrary.GetCurveVectorValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     CurveFloat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UEnvironmentBlueprintFunctionLibrary::GetCurveVectorValue(float Alpha, class UCurveVector* CurveFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EnvironmentBlueprintFunctionLibrary", "GetCurveVectorValue");

	Params::EnvironmentBlueprintFunctionLibrary_GetCurveVectorValue Parms{};

	Parms.Alpha = Alpha;
	Parms.CurveFloat = CurveFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentManager.ChangeEnvironment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EnvironmentID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::ChangeEnvironment(class FName EnvironmentID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "ChangeEnvironment");

	Params::EnvironmentManager_ChangeEnvironment Parms{};

	Parms.EnvironmentID = EnvironmentID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentManager.ChangeEnvironmentFromEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EnvironmentID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::ChangeEnvironmentFromEvent(class FName EnvironmentID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "ChangeEnvironmentFromEvent");

	Params::EnvironmentManager_ChangeEnvironmentFromEvent Parms{};

	Parms.EnvironmentID = EnvironmentID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentManager.GetEnvironmentObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnvironmentObject*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEnvironmentObject* UEnvironmentManager::GetEnvironmentObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetEnvironmentObject");

	Params::EnvironmentManager_GetEnvironmentObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentManager.ReturnEnvironmentFromEvent
// (Final, Native, Public, BlueprintCallable)

void UEnvironmentManager::ReturnEnvironmentFromEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "ReturnEnvironmentFromEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentManager.SetSkyEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentManager::SetSkyEnable(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "SetSkyEnable");

	Params::EnvironmentManager_SetSkyEnable Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EnvironmentManager.GetEnvironmentType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEnvironmentType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnvironmentType UEnvironmentManager::GetEnvironmentType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentManager", "GetEnvironmentType");

	Params::EnvironmentManager_GetEnvironmentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EnvironmentSettingsDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UEnvironmentSettingsDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentSettingsDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EstimateSequenceSceneCapture.EndSequencer
// (Event, Public, BlueprintEvent)

void AEstimateSequenceSceneCapture::EndSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "EndSequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EstimateSequenceSceneCapture.GetCoinsActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AEstimateSequenceSceneCapture::GetCoinsActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "GetCoinsActor");

	Params::EstimateSequenceSceneCapture_GetCoinsActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EstimateSequenceSceneCapture.GetEstimateCaptureComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneCaptureComponent2D* AEstimateSequenceSceneCapture::GetEstimateCaptureComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "GetEstimateCaptureComponent");

	Params::EstimateSequenceSceneCapture_GetEstimateCaptureComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EstimateSequenceSceneCapture.GetPanelActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AStaticMeshActor*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AStaticMeshActor* AEstimateSequenceSceneCapture::GetPanelActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "GetPanelActor");

	Params::EstimateSequenceSceneCapture_GetPanelActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EstimateSequenceSceneCapture.GetSequenceData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FST_EstimateSequenceData> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FST_EstimateSequenceData> AEstimateSequenceSceneCapture::GetSequenceData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "GetSequenceData");

	Params::EstimateSequenceSceneCapture_GetSequenceData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EstimateSequenceSceneCapture.StartFlySequencer
// (Event, Public, BlueprintEvent)

void AEstimateSequenceSceneCapture::StartFlySequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "StartFlySequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EstimateSequenceSceneCapture.StartSequencer
// (Event, Public, BlueprintEvent)

void AEstimateSequenceSceneCapture::StartSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateSequenceSceneCapture", "StartSequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EstimateTreasureObjectBase.SetDefaultMaterial
// (Final, Native, Public, BlueprintCallable)

void AEstimateTreasureObjectBase::SetDefaultMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateTreasureObjectBase", "SetDefaultMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EstimateTreasureObjectBase.SetSilhouetteMaterial
// (Final, Native, Public, BlueprintCallable)

void AEstimateTreasureObjectBase::SetSilhouetteMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EstimateTreasureObjectBase", "SetSilhouetteMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventCrashableComponent.ComponentOnReceiveEventBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FEventStruct                     Info                                                   (Parm, NativeAccessSpecifierPublic)
// class AFieldObjectBase*                 Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventCrashableComponent::ComponentOnReceiveEventBP(const struct FEventStruct& Info, class AFieldObjectBase* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventCrashableComponent", "ComponentOnReceiveEventBP");

	Params::EventCrashableComponent_ComponentOnReceiveEventBP Parms{};

	Parms.Info = std::move(Info);
	Parms.Parent = Parent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventExecuter.CallEndEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEventExecuter::CallEndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "CallEndEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EventExecuter.DestoryScriptEvent
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ScriptEventID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventExecuter::DestoryScriptEvent(const class FName& ScriptEventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "DestoryScriptEvent");

	Params::EventExecuter_DestoryScriptEvent Parms{};

	Parms.ScriptEventID = ScriptEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventExecuter.EndScriptEvent
// (Final, Native, Public, BlueprintCallable)

void UEventExecuter::EndScriptEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "EndScriptEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventExecuter.ExecuteEvent
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FST_EventData                    EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEventExecuter::ExecuteEvent(const struct FST_EventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "ExecuteEvent");

	Params::EventExecuter_ExecuteEvent Parms{};

	Parms.EventData = std::move(EventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventExecuter.ExecuteHubReception
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEventExecuter::ExecuteHubReception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "ExecuteHubReception");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EventExecuter.GetCurrentEventType
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EEventType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEventType UEventExecuter::GetCurrentEventType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "GetCurrentEventType");

	Params::EventExecuter_GetCurrentEventType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.EventExecuter.PlayScriptEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventExecuter::PlayScriptEvent(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "PlayScriptEvent");

	Params::EventExecuter_PlayScriptEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventExecuter.ReceiveCloseTalkWindow
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEventExecuter::ReceiveCloseTalkWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "ReceiveCloseTalkWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EventExecuter.ReceiveSelectResult
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SelectIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventExecuter::ReceiveSelectResult(int32 SelectIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "ReceiveSelectResult");

	Params::EventExecuter_ReceiveSelectResult Parms{};

	Parms.SelectIndex = SelectIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventExecuter.SkipSequencer
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEventExecuter::SkipSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "SkipSequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EventExecuter.GetPlayingScriptEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AScriptEventBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AScriptEventBase* UEventExecuter::GetPlayingScriptEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventExecuter", "GetPlayingScriptEvent");

	Params::EventExecuter_GetPlayingScriptEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventLoader.IsAlredyAddLoadPlanEventList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventLoader::IsAlredyAddLoadPlanEventList(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "IsAlredyAddLoadPlanEventList");

	Params::EventLoader_IsAlredyAddLoadPlanEventList Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventLoader.OnLoadLevelSequenceComplete
// (Final, Native, Private, BlueprintCallable)

void UEventLoader::OnLoadLevelSequenceComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "OnLoadLevelSequenceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventLoader.StackLoadPlanEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventLoader::StackLoadPlanEvent(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "StackLoadPlanEvent");

	Params::EventLoader_StackLoadPlanEvent Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventLoader.UnLoadEventAsset
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventLoader::UnLoadEventAsset(const class FName& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "UnLoadEventAsset");

	Params::EventLoader_UnLoadEventAsset Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventLoader.UnLoadEventAssetAll
// (Final, Native, Public, BlueprintCallable)

void UEventLoader::UnLoadEventAssetAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "UnLoadEventAssetAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventLoader.GetCreateLevelSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALevelSequenceActor*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class ALevelSequenceActor*> UEventLoader::GetCreateLevelSequence(const class FName& EventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "GetCreateLevelSequence");

	Params::EventLoader_GetCreateLevelSequence Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventLoader.GetUIOneShotID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UIName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventLoader::GetUIOneShotID(class FName EventID, class FName UIName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "GetUIOneShotID");

	Params::EventLoader_GetUIOneShotID Parms{};

	Parms.EventID = EventID;
	Parms.UIName = UIName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventLoader.IsLoadCompleteEventAsset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventLoader::IsLoadCompleteEventAsset(const class FName& EventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "IsLoadCompleteEventAsset");

	Params::EventLoader_IsLoadCompleteEventAsset Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventLoader.IsLoadSuccessEventAsset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventLoader::IsLoadSuccessEventAsset(const class FName& EventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "IsLoadSuccessEventAsset");

	Params::EventLoader_IsLoadSuccessEventAsset Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventLoader.LogUIOneShotData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventLoader::LogUIOneShotData(const class FName& EventID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventLoader", "LogUIOneShotData");

	Params::EventLoader_LogUIOneShotData Parms{};

	Parms.EventID = EventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventMonsterSpawnedCallback.OnSpawnedMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     spawned                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventMonsterSpawnedCallback::OnSpawnedMonster(class AMonsterBase* spawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventMonsterSpawnedCallback", "OnSpawnedMonster");

	Params::EventMonsterSpawnedCallback_OnSpawnedMonster Parms{};

	Parms.spawned = spawned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSender.CallForceMoveEvent
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             CallEventID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MovePostion                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveTime                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSender::CallForceMoveEvent(const class FName& CallEventID, const struct FVector& MovePostion, const float& MoveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "CallForceMoveEvent");

	Params::EventSender_CallForceMoveEvent Parms{};

	Parms.CallEventID = CallEventID;
	Parms.MovePostion = std::move(MovePostion);
	Parms.MoveTime = MoveTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.EventSender.CallSendEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UEventSender::CallSendEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "CallSendEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.EventSender.GetEventID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventSender::GetEventID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "GetEventID");

	Params::EventSender_GetEventID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSender.Init
// (Final, Native, Private, BlueprintCallable)

void UEventSender::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSender.SetActiveEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSender::SetActiveEvent(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "SetActiveEvent");

	Params::EventSender_SetActiveEvent Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSender.SetEventID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             event_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSender::SetEventID(class FName event_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "SetEventID");

	Params::EventSender_SetEventID Parms{};

	Parms.event_id = event_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSender.SetSendEventID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SendEventID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSender::SetSendEventID(class FName SendEventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSender", "SetSendEventID");

	Params::EventSender_SetSendEventID Parms{};

	Parms.SendEventID = SendEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEventSystemManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventSystemManager* UEventSystemManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventSystemManager", "GetInstance");

	Params::EventSystemManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.DestoryEventSystemManager
// (Final, Native, Public, BlueprintCallable)

void UEventSystemManager::DestoryEventSystemManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "DestoryEventSystemManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.DestoryEventSystemManagerActor
// (Final, Native, Public, BlueprintCallable)

void UEventSystemManager::DestoryEventSystemManagerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "DestoryEventSystemManagerActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.GetEventExecuter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEventExecuter*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventExecuter* UEventSystemManager::GetEventExecuter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetEventExecuter");

	Params::EventSystemManager_GetEventExecuter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetEventManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEventManager*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventManager* UEventSystemManager::GetEventManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetEventManager");

	Params::EventSystemManager_GetEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetEventSystemManagerActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEventSystemManagerActor*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEventSystemManagerActor* UEventSystemManager::GetEventSystemManagerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetEventSystemManagerActor");

	Params::EventSystemManager_GetEventSystemManagerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetSequencerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USequencerController*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USequencerController* UEventSystemManager::GetSequencerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetSequencerController");

	Params::EventSystemManager_GetSequencerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.ResetCSSkipState
// (Final, Native, Public, BlueprintCallable)

void UEventSystemManager::ResetCSSkipState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "ResetCSSkipState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.SetCSSkipDone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSystemManager::SetCSSkipDone(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "SetCSSkipDone");

	Params::EventSystemManager_SetCSSkipDone Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.SetCSSkipVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSystemManager::SetCSSkipVisible(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "SetCSSkipVisible");

	Params::EventSystemManager_SetCSSkipVisible Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.SetPlayEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Play                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventSystemManager::SetPlayEvent(bool Play)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "SetPlayEvent");

	Params::EventSystemManager_SetPlayEvent Parms{};

	Parms.Play = Play;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.EventSystemManager.GetEventDataBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEventDataBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDataBase* UEventSystemManager::GetEventDataBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetEventDataBase");

	Params::EventSystemManager_GetEventDataBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetEventLoader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEventLoader*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventLoader* UEventSystemManager::GetEventLoader() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetEventLoader");

	Params::EventSystemManager_GetEventLoader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetGameProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameProgress*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameProgress* UEventSystemManager::GetGameProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetGameProgress");

	Params::EventSystemManager_GetGameProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetPCChangeBeforeTalkEventData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UEventSystemManager::GetPCChangeBeforeTalkEventData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetPCChangeBeforeTalkEventData");

	Params::EventSystemManager_GetPCChangeBeforeTalkEventData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetPCChangeTalkEventData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UEventSystemManager::GetPCChangeTalkEventData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetPCChangeTalkEventData");

	Params::EventSystemManager_GetPCChangeTalkEventData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.GetTalkEventSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTalkEventSystem*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTalkEventSystem* UEventSystemManager::GetTalkEventSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "GetTalkEventSystem");

	Params::EventSystemManager_GetTalkEventSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.IsCSSkipDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventSystemManager::IsCSSkipDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "IsCSSkipDone");

	Params::EventSystemManager_IsCSSkipDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.IsCSSkipVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventSystemManager::IsCSSkipVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "IsCSSkipVisible");

	Params::EventSystemManager_IsCSSkipVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.EventSystemManager.IsPlayEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventSystemManager::IsPlayEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventSystemManager", "IsPlayEvent");

	Params::EventSystemManager_IsPlayEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIShot_WinStatus.GetListIndexFunc
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   OutCategoryIndex                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutGroupIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_WinStatus::GetListIndexFunc(int32* OutCategoryIndex, int32* OutGroupIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "GetListIndexFunc");

	Params::UIShot_WinStatus_GetListIndexFunc Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCategoryIndex != nullptr)
		*OutCategoryIndex = Parms.OutCategoryIndex;

	if (OutGroupIndex != nullptr)
		*OutGroupIndex = Parms.OutGroupIndex;
}


// Function DarwinGame.UIShot_WinStatus.InitSlingShotListFunc
// (Final, Native, Protected, BlueprintCallable)

void UUIShot_WinStatus::InitSlingShotListFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "InitSlingShotListFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.OpenBulletsSelect
// (Final, Native, Public, BlueprintCallable)

void UUIShot_WinStatus::OpenBulletsSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "OpenBulletsSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.SetDataFunc
// (Final, Native, Protected, BlueprintCallable)

void UUIShot_WinStatus::SetDataFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "SetDataFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.SetNameFunc
// (Final, Native, Protected, BlueprintCallable)

void UUIShot_WinStatus::SetNameFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "SetNameFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.SetSelectIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_WinStatus::SetSelectIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "SetSelectIndex");

	Params::UIShot_WinStatus_SetSelectIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.SetSelectModeFunc
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInIsSelectMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_WinStatus::SetSelectModeFunc(bool bInIsSelectMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "SetSelectModeFunc");

	Params::UIShot_WinStatus_SetSelectModeFunc Parms{};

	Parms.bInIsSelectMode = bInIsSelectMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.UpdateClipFunc
// (Final, Native, Protected, BlueprintCallable)

void UUIShot_WinStatus::UpdateClipFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "UpdateClipFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.UpdateDataFunc
// (Final, Native, Protected, BlueprintCallable)

void UUIShot_WinStatus::UpdateDataFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "UpdateDataFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.UpdateDestinationArrowFunc
// (Final, Native, Protected, BlueprintCallable)

void UUIShot_WinStatus::UpdateDestinationArrowFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "UpdateDestinationArrowFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_WinStatus.GetSelectIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UUIShot_WinStatus::GetSelectIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "GetSelectIndex");

	Params::UIShot_WinStatus_GetSelectIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIShot_WinStatus.GetSelectMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UUIShot_WinStatus::GetSelectMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_WinStatus", "GetSelectMode");

	Params::UIShot_WinStatus_GetSelectMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FastTravelComponent.OnMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFastTravelComponent::OnMove(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FastTravelComponent", "OnMove");

	Params::FastTravelComponent_OnMove Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FastTravelPoint.RegisterForDataTable
// (Final, Native, Protected, BlueprintCallable)

void AFastTravelPoint::RegisterForDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FastTravelPoint", "RegisterForDataTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FeatureDataTable.CheckEffectValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   outputValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureDataTable::CheckEffectValue(class FName ID, int32 Level, float* outputValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "CheckEffectValue");

	Params::FeatureDataTable_CheckEffectValue Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outputValue != nullptr)
		*outputValue = Parms.outputValue;

	return Parms.ReturnValue;
}


// Function DarwinGame.FeatureDataTable.GetEffectPositionType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFeaturePositionType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFeaturePositionType UFeatureDataTable::GetEffectPositionType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetEffectPositionType");

	Params::FeatureDataTable_GetEffectPositionType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FeatureDataTable.GetEffectStatusParamType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusParamType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusParamType UFeatureDataTable::GetEffectStatusParamType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetEffectStatusParamType");

	Params::FeatureDataTable_GetEffectStatusParamType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FeatureDataTable.GetEffectValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFeatureDataTable::GetEffectValue(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetEffectValue");

	Params::FeatureDataTable_GetEffectValue Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FeatureDataTable.GetFeatureCondition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Condition                    Condition                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UFeatureDataTable::GetFeatureCondition(class FName ID, struct FST_Condition* Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetFeatureCondition");

	Params::FeatureDataTable_GetFeatureCondition Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Condition != nullptr)
		*Condition = std::move(Parms.Condition);
}


// Function DarwinGame.FeatureDataTable.GetFeatureEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_FeatureEffect                Output                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFeatureDataTable::GetFeatureEffect(class FName ID, struct FST_FeatureEffect* Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetFeatureEffect");

	Params::FeatureDataTable_GetFeatureEffect Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Output != nullptr)
		*Output = std::move(Parms.Output);

	return Parms.ReturnValue;
}


// Function DarwinGame.FeatureDataTable.GetFeatureEffectType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFeatureEffectType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFeatureEffectType UFeatureDataTable::GetFeatureEffectType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetFeatureEffectType");

	Params::FeatureDataTable_GetFeatureEffectType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FeatureDataTable.GetFeatureSystemType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFeatureSystemType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFeatureSystemType UFeatureDataTable::GetFeatureSystemType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FeatureDataTable", "GetFeatureSystemType");

	Params::FeatureDataTable_GetFeatureSystemType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UITitle_Select_Set_Base.PlayWaitAnim
// (Final, Native, Protected)

void UUITitle_Select_Set_Base::PlayWaitAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITitle_Select_Set_Base", "PlayWaitAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldBlueprintFunctionLibrary.AddHISMComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHierarchicalInstancedStaticMeshComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHierarchicalInstancedStaticMeshComponent* UFieldBlueprintFunctionLibrary::AddHISMComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldBlueprintFunctionLibrary", "AddHISMComponent");

	Params::FieldBlueprintFunctionLibrary_AddHISMComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldBlueprintFunctionLibrary.GetLevelNameWithActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isGet                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UFieldBlueprintFunctionLibrary::GetLevelNameWithActor(class AActor* TargetActor, bool* isGet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldBlueprintFunctionLibrary", "GetLevelNameWithActor");

	Params::FieldBlueprintFunctionLibrary_GetLevelNameWithActor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (isGet != nullptr)
		*isGet = Parms.isGet;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldBlueprintFunctionLibrary.GetViewportLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFieldBlueprintFunctionLibrary::GetViewportLocation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldBlueprintFunctionLibrary", "GetViewportLocation");

	Params::FieldBlueprintFunctionLibrary_GetViewportLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldBlueprintFunctionLibrary.OnFieldReset
// (Final, Native, Static, Public, BlueprintCallable)

void UFieldBlueprintFunctionLibrary::OnFieldReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldBlueprintFunctionLibrary", "OnFieldReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldBlueprintFunctionLibrary.OnFieldResetWhenTimeZoneChanges
// (Final, Native, Static, Public, BlueprintCallable)

void UFieldBlueprintFunctionLibrary::OnFieldResetWhenTimeZoneChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldBlueprintFunctionLibrary", "OnFieldResetWhenTimeZoneChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldComment.UpdateText
// (Event, Public, BlueprintEvent)

void AFieldComment::UpdateText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldComment", "UpdateText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.UISign_IconMiss.PlayOneshotMiss
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUISign_IconMiss::PlayOneshotMiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconMiss", "PlayOneshotMiss");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.UIField_IconQuestLine.ClearQuest
// (Final, Native, Public, BlueprintCallable)

void UUIField_IconQuestLine::ClearQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "ClearQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.EndClearAnimExec
// (Final, Native, Protected, BlueprintCallable)

void UUIField_IconQuestLine::EndClearAnimExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "EndClearAnimExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.PauseClearAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_IconQuestLine::PauseClearAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "PauseClearAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.PlayClearAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_IconQuestLine::PlayClearAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "PlayClearAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.PlayClearAnimFirstHalf
// (Final, Native, Private)

void UUIField_IconQuestLine::PlayClearAnimFirstHalf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "PlayClearAnimFirstHalf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.PlayClearStampAnim
// (Final, Native, Private)

void UUIField_IconQuestLine::PlayClearStampAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "PlayClearStampAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InQuestName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InQuestTypeName                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIField_IconQuestLine::SetData(const class FText& InQuestName, const class FText& InQuestTypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "SetData");

	Params::UIField_IconQuestLine_SetData Parms{};

	Parms.InQuestName = std::move(InQuestName);
	Parms.InQuestTypeName = std::move(InQuestTypeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.SetQuestID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InQuestID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconQuestLine::SetQuestID(class FName InQuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "SetQuestID");

	Params::UIField_IconQuestLine_SetQuestID Parms{};

	Parms.InQuestID = InQuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconQuestLine.StartQuest
// (Final, Native, Public, BlueprintCallable)

void UUIField_IconQuestLine::StartQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconQuestLine", "StartQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageComposite.SetBelongType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Belong                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageComposite::SetBelongType(const struct FGameplayTag& Belong)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageComposite", "SetBelongType");

	Params::UISign_IconDamageComposite_SetBelongType Parms{};

	Parms.Belong = std::move(Belong);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageComposite.SetCriticalType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageCriticalType                     CriticalType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageComposite::SetCriticalType(EDamageCriticalType CriticalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageComposite", "SetCriticalType");

	Params::UISign_IconDamageComposite_SetCriticalType Parms{};

	Parms.CriticalType = CriticalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageComposite.SetDamageValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageComposite::SetDamageValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageComposite", "SetDamageValue");

	Params::UISign_IconDamageComposite_SetDamageValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageComposite.SetData
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Belong                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageCriticalType                     CriticalType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageSizeType                         SizeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageComposite::SetData(float Value, const struct FGameplayTag& Belong, const struct FVector& TargetLocation, EDamageCriticalType CriticalType, EDamageSizeType SizeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageComposite", "SetData");

	Params::UISign_IconDamageComposite_SetData Parms{};

	Parms.Value = Value;
	Parms.Belong = std::move(Belong);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.CriticalType = CriticalType;
	Parms.SizeType = SizeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageComposite.SetSizeType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDamageSizeType                         SizeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageComposite::SetSizeType(EDamageSizeType SizeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageComposite", "SetSizeType");

	Params::UISign_IconDamageComposite_SetSizeType Parms{};

	Parms.SizeType = SizeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectBlueprintFunctionLibrary.CalcDropLaunchVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   min_dis                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   max_dis                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   min_height                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   max_height                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         base_rotator                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFieldObjectBlueprintFunctionLibrary::CalcDropLaunchVelocity(int32 min_dis, int32 max_dis, int32 min_height, int32 max_height, int32 Range, const struct FRotator& base_rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldObjectBlueprintFunctionLibrary", "CalcDropLaunchVelocity");

	Params::FieldObjectBlueprintFunctionLibrary_CalcDropLaunchVelocity Parms{};

	Parms.min_dis = min_dis;
	Parms.max_dis = max_dis;
	Parms.min_height = min_height;
	Parms.max_height = max_height;
	Parms.Range = Range;
	Parms.base_rotator = std::move(base_rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectBlueprintFunctionLibrary.CalcDropLaunchVelocityFromAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Azimuth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AzimuthRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Elevation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElevationRange                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UFieldObjectBlueprintFunctionLibrary::CalcDropLaunchVelocityFromAngle(float Strength, float Azimuth, float AzimuthRange, float Elevation, float ElevationRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldObjectBlueprintFunctionLibrary", "CalcDropLaunchVelocityFromAngle");

	Params::FieldObjectBlueprintFunctionLibrary_CalcDropLaunchVelocityFromAngle Parms{};

	Parms.Strength = Strength;
	Parms.Azimuth = Azimuth;
	Parms.AzimuthRange = AzimuthRange;
	Parms.Elevation = Elevation;
	Parms.ElevationRange = ElevationRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectBlueprintFunctionLibrary.CheckEventClearFromEventID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             EventID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsCheckOR                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFieldObjectBlueprintFunctionLibrary::CheckEventClearFromEventID(const class FName& EventID, bool IsCheckOR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FieldObjectBlueprintFunctionLibrary", "CheckEventClearFromEventID");

	Params::FieldObjectBlueprintFunctionLibrary_CheckEventClearFromEventID Parms{};

	Parms.EventID = EventID;
	Parms.IsCheckOR = IsCheckOR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropCoinFromCoinParamAttachActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::DropCoinFromCoinParamAttachActor(const struct FST_CoinParam& CoinData, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropCoinFromCoinParamAttachActor");

	Params::FieldObjectManager_DropCoinFromCoinParamAttachActor Parms{};

	Parms.CoinData = std::move(CoinData);
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropCoinFromCoinParamAttachComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::DropCoinFromCoinParamAttachComponent(const struct FST_CoinParam& CoinData, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropCoinFromCoinParamAttachComponent");

	Params::FieldObjectManager_DropCoinFromCoinParamAttachComponent Parms{};

	Parms.CoinData = std::move(CoinData);
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropCoinFromMonsterInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::DropCoinFromMonsterInfo(int32 Level, int32 KindId, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropCoinFromMonsterInfo");

	Params::FieldObjectManager_DropCoinFromMonsterInfo Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropCoinFromMonsterInfoAttachActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::DropCoinFromMonsterInfoAttachActor(int32 Level, int32 KindId, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropCoinFromMonsterInfoAttachActor");

	Params::FieldObjectManager_DropCoinFromMonsterInfoAttachActor Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropCoinFromMonsterInfoAttachComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::DropCoinFromMonsterInfoAttachComponent(int32 Level, int32 KindId, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropCoinFromMonsterInfoAttachComponent");

	Params::FieldObjectManager_DropCoinFromMonsterInfoAttachComponent Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropItem
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADropItemObject*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADropItemObject* UFieldObjectManager::DropItem(const class FName ItemId, const int32 ItemCount, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropItem");

	Params::FieldObjectManager_DropItem Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropItemAttachActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADropItemObject*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADropItemObject* UFieldObjectManager::DropItemAttachActor(const class FName ItemId, const int32 ItemCount, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropItemAttachActor");

	Params::FieldObjectManager_DropItemAttachActor Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropItemAttachComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADropItemObject*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADropItemObject* UFieldObjectManager::DropItemAttachComponent(const class FName ItemId, const int32 ItemCount, const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropItemAttachComponent");

	Params::FieldObjectManager_DropItemAttachComponent Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropTreasureMap
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATreasureMapObjectBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATreasureMapObjectBase* UFieldObjectManager::DropTreasureMap(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropTreasureMap");

	Params::FieldObjectManager_DropTreasureMap Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropTreasureMapAttachActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATreasureMapObjectBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATreasureMapObjectBase* UFieldObjectManager::DropTreasureMapAttachActor(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropTreasureMapAttachActor");

	Params::FieldObjectManager_DropTreasureMapAttachActor Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.DropTreasureMapAttachComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATreasureMapObjectBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATreasureMapObjectBase* UFieldObjectManager::DropTreasureMapAttachComponent(const struct FVector& LaunchVelocity, const TArray<class AActor*>& IgnoreActors, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "DropTreasureMapAttachComponent");

	Params::FieldObjectManager_DropTreasureMapAttachComponent Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.GetActorClass
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// ESpawnFieldObjectID                     ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UFieldObjectManager::GetActorClass(const ESpawnFieldObjectID ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "GetActorClass");

	Params::FieldObjectManager_GetActorClass Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.GetSpawnArtifactList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AArtifactObjectBase*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AArtifactObjectBase*> UFieldObjectManager::GetSpawnArtifactList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "GetSpawnArtifactList");

	Params::FieldObjectManager_GetSpawnArtifactList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.GetTrainObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATrainBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATrainBase* UFieldObjectManager::GetTrainObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "GetTrainObject");

	Params::FieldObjectManager_GetTrainObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.HideAllItemObject
// (Final, Native, Public, BlueprintCallable)

void UFieldObjectManager::HideAllItemObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "HideAllItemObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectManager.ReflectionReleaseStatus
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRelease                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOtherSkip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldObjectManager::ReflectionReleaseStatus(const class FName& ID, bool IsRelease, bool IsSkip, bool IsOtherSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "ReflectionReleaseStatus");

	Params::FieldObjectManager_ReflectionReleaseStatus Parms{};

	Parms.ID = ID;
	Parms.IsRelease = IsRelease;
	Parms.IsSkip = IsSkip;
	Parms.IsOtherSkip = IsOtherSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectManager.ShowAllItemObject
// (Final, Native, Public, BlueprintCallable)

void UFieldObjectManager::ShowAllItemObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "ShowAllItemObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldObjectManager.SpawnAttachActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ESpawnFieldObjectID                     ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFieldObjectBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFieldObjectBase* UFieldObjectManager::SpawnAttachActor(const ESpawnFieldObjectID ID, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnAttachActor");

	Params::FieldObjectManager_SpawnAttachActor Parms{};

	Parms.ID = ID;
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnAttachComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ESpawnFieldObjectID                     ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFieldObjectBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFieldObjectBase* UFieldObjectManager::SpawnAttachComponent(const ESpawnFieldObjectID ID, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnAttachComponent");

	Params::FieldObjectManager_SpawnAttachComponent Parms{};

	Parms.ID = ID;
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnCoinFromCoinParam
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::SpawnCoinFromCoinParam(const struct FST_CoinParam& CoinData, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnCoinFromCoinParam");

	Params::FieldObjectManager_SpawnCoinFromCoinParam Parms{};

	Parms.CoinData = std::move(CoinData);
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnCoinFromCoinParamAttachActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::SpawnCoinFromCoinParamAttachActor(const struct FST_CoinParam& CoinData, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnCoinFromCoinParamAttachActor");

	Params::FieldObjectManager_SpawnCoinFromCoinParamAttachActor Parms{};

	Parms.CoinData = std::move(CoinData);
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnCoinFromCoinParamAttachComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::SpawnCoinFromCoinParamAttachComponent(const struct FST_CoinParam& CoinData, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnCoinFromCoinParamAttachComponent");

	Params::FieldObjectManager_SpawnCoinFromCoinParamAttachComponent Parms{};

	Parms.CoinData = std::move(CoinData);
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnCoinFromMonsterInfo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::SpawnCoinFromMonsterInfo(int32 Level, int32 KindId, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnCoinFromMonsterInfo");

	Params::FieldObjectManager_SpawnCoinFromMonsterInfo Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnCoinFromMonsterInfoAttachActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::SpawnCoinFromMonsterInfoAttachActor(int32 Level, int32 KindId, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnCoinFromMonsterInfoAttachActor");

	Params::FieldObjectManager_SpawnCoinFromMonsterInfoAttachActor Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnCoinFromMonsterInfoAttachComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACoinObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACoinObjectBase* UFieldObjectManager::SpawnCoinFromMonsterInfoAttachComponent(int32 Level, int32 KindId, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnCoinFromMonsterInfoAttachComponent");

	Params::FieldObjectManager_SpawnCoinFromMonsterInfoAttachComponent Parms{};

	Parms.Level = Level;
	Parms.KindId = KindId;
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnFieldObject
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ESpawnFieldObjectID                     ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFieldObjectBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFieldObjectBase* UFieldObjectManager::SpawnFieldObject(const ESpawnFieldObjectID ID, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnFieldObject");

	Params::FieldObjectManager_SpawnFieldObject Parms{};

	Parms.ID = ID;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnItem
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemObjectBase* UFieldObjectManager::SpawnItem(const class FName ItemId, const int32 ItemCount, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnItem");

	Params::FieldObjectManager_SpawnItem Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnItemAttachActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemObjectBase* UFieldObjectManager::SpawnItemAttachActor(const class FName ItemId, const int32 ItemCount, class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnItemAttachActor");

	Params::FieldObjectManager_SpawnItemAttachActor Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;
	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnItemAttachComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemObjectBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemObjectBase* UFieldObjectManager::SpawnItemAttachComponent(const class FName ItemId, const int32 ItemCount, class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnItemAttachComponent");

	Params::FieldObjectManager_SpawnItemAttachComponent Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;
	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnPushWave
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplitNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APushWaveBase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APushWaveBase* UFieldObjectManager::SpawnPushWave(const struct FVector& Size, int32 SplitNum, float Speed, float Distance, const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnPushWave");

	Params::FieldObjectManager_SpawnPushWave Parms{};

	Parms.Size = std::move(Size);
	Parms.SplitNum = SplitNum;
	Parms.Speed = Speed;
	Parms.Distance = Distance;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnTreasureMap
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         WorldRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          WorldScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATreasureMapObjectBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATreasureMapObjectBase* UFieldObjectManager::SpawnTreasureMap(const struct FVector& WorldLocation, const struct FRotator& WorldRotation, const struct FVector& WorldScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnTreasureMap");

	Params::FieldObjectManager_SpawnTreasureMap Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldRotation = std::move(WorldRotation);
	Parms.WorldScale = std::move(WorldScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnTreasureMapAttachActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATreasureMapObjectBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATreasureMapObjectBase* UFieldObjectManager::SpawnTreasureMapAttachActor(class AActor* Parent, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnTreasureMapAttachActor");

	Params::FieldObjectManager_SpawnTreasureMapAttachActor Parms{};

	Parms.Parent = Parent;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.SpawnTreasureMapAttachComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Componnet                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         LocalRotation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// struct FVector                          LocalScale                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATreasureMapObjectBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATreasureMapObjectBase* UFieldObjectManager::SpawnTreasureMapAttachComponent(class USceneComponent* Componnet, const class FName socket, const struct FVector& LocalLocation, const struct FRotator& LocalRotation, const struct FVector& LocalScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "SpawnTreasureMapAttachComponent");

	Params::FieldObjectManager_SpawnTreasureMapAttachComponent Parms{};

	Parms.Componnet = Componnet;
	Parms.socket = socket;
	Parms.LocalLocation = std::move(LocalLocation);
	Parms.LocalRotation = std::move(LocalRotation);
	Parms.LocalScale = std::move(LocalScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldObjectManager.FindObject
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFieldObjectBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFieldObjectBase* UFieldObjectManager::FindObject(const class FName& ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldObjectManager", "FindObject");

	Params::FieldObjectManager_FindObject Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldStuntInterface.IsAllowClimbing
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFieldStuntInterface::IsAllowClimbing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldStuntInterface", "IsAllowClimbing");

	Params::FieldStuntInterface_IsAllowClimbing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldStuntInterface.IsAllowParkour
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFieldStuntInterface::IsAllowParkour() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldStuntInterface", "IsAllowParkour");

	Params::FieldStuntInterface_IsAllowParkour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldTerrainInterface.OnReceiveHitByTerrain
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IFieldTerrainInterface::OnReceiveHitByTerrain(class AActor* OtherActor, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTerrainInterface", "OnReceiveHitByTerrain");

	Params::FieldTerrainInterface_OnReceiveHitByTerrain Parms{};

	Parms.OtherActor = OtherActor;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldTerrainInterface.SetForceSpeed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFieldTerrainInterface::SetForceSpeed(float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTerrainInterface", "SetForceSpeed");

	Params::FieldTerrainInterface_SetForceSpeed Parms{};

	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldTerrainInterface.SetWorking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFieldTerrainInterface::SetWorking(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTerrainInterface", "SetWorking");

	Params::FieldTerrainInterface_SetWorking Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FieldTerrainInterface.GetTerrainType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EFieldTerrainType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFieldTerrainType IFieldTerrainInterface::GetTerrainType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTerrainInterface", "GetTerrainType");

	Params::FieldTerrainInterface_GetTerrainType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FieldTerrainInterface.IsWorking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFieldTerrainInterface::IsWorking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldTerrainInterface", "IsWorking");

	Params::FieldTerrainInterface_IsWorking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FlagMaterialDataAsset.Build
// (Final, Native, Protected, BlueprintCallable)

void UFlagMaterialDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlagMaterialDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.PlayBackOpen
// (Final, Native, Public, BlueprintCallable)

void UFlexibleDoorOpenAnimInstance::PlayBackOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "PlayBackOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.PlayClose
// (Final, Native, Public, BlueprintCallable)

void UFlexibleDoorOpenAnimInstance::PlayClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "PlayClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.PlayFrontOpen
// (Final, Native, Public, BlueprintCallable)

void UFlexibleDoorOpenAnimInstance::PlayFrontOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "PlayFrontOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.SetBackOpen
// (Final, Native, Public, BlueprintCallable)

void UFlexibleDoorOpenAnimInstance::SetBackOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "SetBackOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.SetClose
// (Final, Native, Public, BlueprintCallable)

void UFlexibleDoorOpenAnimInstance::SetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "SetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.SetFrontOpen
// (Final, Native, Public, BlueprintCallable)

void UFlexibleDoorOpenAnimInstance::SetFrontOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "SetFrontOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.IsBackOpenAndPlayAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlexibleDoorOpenAnimInstance::IsBackOpenAndPlayAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "IsBackOpenAndPlayAnimation");

	Params::FlexibleDoorOpenAnimInstance_IsBackOpenAndPlayAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.IsBackOpenAndSkipAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlexibleDoorOpenAnimInstance::IsBackOpenAndSkipAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "IsBackOpenAndSkipAnimation");

	Params::FlexibleDoorOpenAnimInstance_IsBackOpenAndSkipAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.IsCloseAndPlayAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlexibleDoorOpenAnimInstance::IsCloseAndPlayAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "IsCloseAndPlayAnimation");

	Params::FlexibleDoorOpenAnimInstance_IsCloseAndPlayAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.IsCloseAndSkipAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlexibleDoorOpenAnimInstance::IsCloseAndSkipAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "IsCloseAndSkipAnimation");

	Params::FlexibleDoorOpenAnimInstance_IsCloseAndSkipAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.IsFrontOpenAndPlayAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlexibleDoorOpenAnimInstance::IsFrontOpenAndPlayAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "IsFrontOpenAndPlayAnimation");

	Params::FlexibleDoorOpenAnimInstance_IsFrontOpenAndPlayAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FlexibleDoorOpenAnimInstance.IsFrontOpenAndSkipAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlexibleDoorOpenAnimInstance::IsFrontOpenAndSkipAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlexibleDoorOpenAnimInstance", "IsFrontOpenAndSkipAnimation");

	Params::FlexibleDoorOpenAnimInstance_IsFrontOpenAndSkipAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ForcedBattleAreaDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UForcedBattleAreaDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedBattleAreaDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ForcedBattleAreaManager.RemoveAll
// (Final, Native, Public, BlueprintCallable)

void UForcedBattleAreaManager::RemoveAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedBattleAreaManager", "RemoveAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ForcedBattleAreaManager.Spawn
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AForcedBattleAreaBase*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AForcedBattleAreaBase* UForcedBattleAreaManager::Spawn(class FName ID, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForcedBattleAreaManager", "Spawn");

	Params::ForcedBattleAreaManager_Spawn Parms{};

	Parms.ID = ID;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UICorrection_00.BonusInFunction
// (Final, Native, Protected, BlueprintCallable)

void UUICorrection_00::BonusInFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICorrection_00", "BonusInFunction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICorrection_00.InAnimEnd
// (Final, Native, Protected)

void UUICorrection_00::InAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICorrection_00", "InAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStation_ContentWin.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EAreaType                               InFocusArea                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           PartyUids                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIStation_ContentWin::SetData(EAreaType InFocusArea, const TArray<int32>& PartyUids)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStation_ContentWin", "SetData");

	Params::UIStation_ContentWin_SetData Parms{};

	Parms.InFocusArea = InFocusArea;
	Parms.PartyUids = std::move(PartyUids);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinStatus.ChoiceSetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FChoiceWindowData                Data                                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    DirectMessage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITalk_WinStatus::ChoiceSetData(const struct FChoiceWindowData& Data, bool DirectMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinStatus", "ChoiceSetData");

	Params::UITalk_WinStatus_ChoiceSetData Parms{};

	Parms.Data = std::move(Data);
	Parms.DirectMessage = DirectMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinStatus.SetSystemTextDataFromBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           messageText                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InputReset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITalk_WinStatus::SetSystemTextDataFromBP(const class FString& messageText, bool InputReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinStatus", "SetSystemTextDataFromBP");

	Params::UITalk_WinStatus_SetSystemTextDataFromBP Parms{};

	Parms.messageText = std::move(messageText);
	Parms.InputReset = InputReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinStatus.VisibleChoiceWindow
// (Final, Native, Public, BlueprintCallable)

void UUITalk_WinStatus::VisibleChoiceWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinStatus", "VisibleChoiceWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinStatus.WriteSentence
// (Final, Native, Public, BlueprintCallable)

void UUITalk_WinStatus::WriteSentence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinStatus", "WriteSentence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FrameRateUtils.AdjustValueBasedOnFPS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateUtils::AdjustValueBasedOnFPS(float Value, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FrameRateUtils", "AdjustValueBasedOnFPS");

	Params::FrameRateUtils_AdjustValueBasedOnFPS Parms{};

	Parms.Value = Value;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.FrameRateUtils.GetFrameCountMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFrameRateUtils::GetFrameCountMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FrameRateUtils", "GetFrameCountMultiplier");

	Params::FrameRateUtils_GetFrameCountMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UISwapMenu_List.OnChangeFocusFunc
// (Final, Native, Protected)

void UUISwapMenu_List::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISwapMenu_List", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.FriendPositionManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFriendPositionManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFriendPositionManager* UFriendPositionManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FriendPositionManager", "GetInstance");

	Params::FriendPositionManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIPCChange.Start
// (Final, Native, Public, BlueprintCallable)

void UUIPCChange::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPCChange", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsItem.AddItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsForceOpenItemGetUI                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsItem::AddItem(const class FName& ItemId, int32 Num, bool bIsForceOpenItemGetUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "AddItem");

	Params::GameBelongingsItem_AddItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Num = Num;
	Parms.bIsForceOpenItemGetUI = bIsForceOpenItemGetUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsItem.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameBelongingsItem*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameBelongingsItem* UGameBelongingsItem::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "Clone");

	Params::GameBelongingsItem_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsItem.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameBelongingsItem*              game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsItem::Overwrite(class UGameBelongingsItem* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "Overwrite");

	Params::GameBelongingsItem_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsItem.RemoveItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBelongingsItem::RemoveItem(const class FName& ItemId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "RemoveItem");

	Params::GameBelongingsItem_RemoveItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameBelongingsItem.GetCapacity
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameBelongingsItem::GetCapacity(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "GetCapacity");

	Params::GameBelongingsItem_GetCapacity Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsItem.GetItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameBelongingsItem::GetItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "GetItem");

	Params::GameBelongingsItem_GetItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsItem.GetItemAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, struct FGameDataItem>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<class FName, struct FGameDataItem> UGameBelongingsItem::GetItemAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "GetItemAll");

	Params::GameBelongingsItem_GetItemAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsItem.GetLimit
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameBelongingsItem::GetLimit(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "GetLimit");

	Params::GameBelongingsItem_GetLimit Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameBelongingsItem.IsCollectedItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameBelongingsItem::IsCollectedItem(const class FName& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBelongingsItem", "IsCollectedItem");

	Params::GameBelongingsItem_IsCollectedItem Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetWindowName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ETextWindow                             Window                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextWidget::GetWindowName(const ETextWindow& Window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TextWidget", "GetWindowName");

	Params::TextWidget_GetWindowName Parms{};

	Parms.Window = Window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.AddTextBlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ETextWindow                             InWindow                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvasPanel*                     InCanvasPanel                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMainBlock                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTextFontData                    InMainFontData                                         (Parm, NativeAccessSpecifierPublic)
// int32                                   InRubyBlock                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTextFontData                    InRubyFontData                                         (Parm, NativeAccessSpecifierPublic)

void UTextWidget::AddTextBlock(const ETextWindow& InWindow, class UCanvasPanel* InCanvasPanel, int32 InMainBlock, const struct FTextFontData& InMainFontData, int32 InRubyBlock, const struct FTextFontData& InRubyFontData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "AddTextBlock");

	Params::TextWidget_AddTextBlock Parms{};

	Parms.InWindow = InWindow;
	Parms.InCanvasPanel = InCanvasPanel;
	Parms.InMainBlock = InMainBlock;
	Parms.InMainFontData = std::move(InMainFontData);
	Parms.InRubyBlock = InRubyBlock;
	Parms.InRubyFontData = std::move(InRubyFontData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.ForcedUpdate
// (Final, Native, Public, BlueprintCallable)

void UTextWidget::ForcedUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "ForcedUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.InitChoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InItemNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::InitChoice(int32 InItemNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "InitChoice");

	Params::TextWidget_InitChoice Parms{};

	Parms.InItemNum = InItemNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.LoadIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTextWidget::LoadIcon(const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "LoadIcon");

	Params::TextWidget_LoadIcon Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.RollOut
// (Final, Native, Public, BlueprintCallable)

void UTextWidget::RollOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "RollOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetChoiceWindowData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FChoiceWindowData                InChoiceWindowData                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UTextWidget::SetChoiceWindowData(struct FChoiceWindowData* InChoiceWindowData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetChoiceWindowData");

	Params::TextWidget_SetChoiceWindowData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InChoiceWindowData != nullptr)
		*InChoiceWindowData = std::move(Parms.InChoiceWindowData);
}


// Function DarwinGame.TextWidget.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextWidgetData*                  InTextEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetData(class UTextWidgetData* InTextEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetData");

	Params::TextWidget_SetData Parms{};

	Parms.InTextEvent = InTextEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetIndent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InputIndent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetIndent(float InputIndent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetIndent");

	Params::TextWidget_SetIndent Parms{};

	Parms.InputIndent = InputIndent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetMainFontColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetMainFontColor(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetMainFontColor");

	Params::TextWidget_SetMainFontColor Parms{};

	Parms.InLinearColor = std::move(InLinearColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetMainShadowColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetMainShadowColor(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetMainShadowColor");

	Params::TextWidget_SetMainShadowColor Parms{};

	Parms.InLinearColor = std::move(InLinearColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetMainShadowOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetMainShadowOffset(const struct FVector2D& InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetMainShadowOffset");

	Params::TextWidget_SetMainShadowOffset Parms{};

	Parms.InOffset = std::move(InOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetOutlineColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetOutlineColor(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetOutlineColor");

	Params::TextWidget_SetOutlineColor Parms{};

	Parms.InLinearColor = std::move(InLinearColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetOutlineSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetOutlineSize(int32 InSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetOutlineSize");

	Params::TextWidget_SetOutlineSize Parms{};

	Parms.InSize = InSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetPause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetPause(bool InPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetPause");

	Params::TextWidget_SetPause Parms{};

	Parms.InPause = InPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.SetRubyFontColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::SetRubyFontColor(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "SetRubyFontColor");

	Params::TextWidget_SetRubyFontColor Parms{};

	Parms.InLinearColor = std::move(InLinearColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.StopVoice
// (Final, Native, Public, BlueprintCallable)

void UTextWidget::StopVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "StopVoice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.Update
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextWidget::Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "Update");

	Params::TextWidget_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.WriteSentence
// (Final, Native, Public, BlueprintCallable)

void UTextWidget::WriteSentence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "WriteSentence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TextWidget.CheckChoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextWidget::CheckChoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "CheckChoice");

	Params::TextWidget_CheckChoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.CheckUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextWidget::CheckUse(const class FName InName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "CheckUse");

	Params::TextWidget_CheckUse Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetChoiceWindowData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FChoiceWindowData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FChoiceWindowData UTextWidget::GetChoiceWindowData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetChoiceWindowData");

	Params::TextWidget_GetChoiceWindowData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetIconTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTextWidget::GetIconTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetIconTexture");

	Params::TextWidget_GetIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetIsSystemMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextWidget::GetIsSystemMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetIsSystemMessage");

	Params::TextWidget_GetIsSystemMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetMainFontInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSlateFontInfo             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FSlateFontInfo UTextWidget::GetMainFontInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetMainFontInfo");

	Params::TextWidget_GetMainFontInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetMainShadowOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector2D                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector2D UTextWidget::GetMainShadowOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetMainShadowOffset");

	Params::TextWidget_GetMainShadowOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetRubyFontSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UTextWidget::GetRubyFontSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetRubyFontSize");

	Params::TextWidget_GetRubyFontSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetTalkerID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UTextWidget::GetTalkerID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetTalkerID");

	Params::TextWidget_GetTalkerID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.GetUsedTextAreaSize
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETextWindow                             InWindow                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTextWidget::GetUsedTextAreaSize(const ETextWindow& InWindow) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "GetUsedTextAreaSize");

	Params::TextWidget_GetUsedTextAreaSize Parms{};

	Parms.InWindow = InWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.IsEndRollOut
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextWidget::IsEndRollOut() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "IsEndRollOut");

	Params::TextWidget_IsEndRollOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.IsLastPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextWidget::IsLastPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "IsLastPage");

	Params::TextWidget_IsLastPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TextWidget.IsTextEventCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTextWidget::IsTextEventCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextWidget", "IsTextEventCompleted");

	Params::TextWidget_IsTextEventCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataAddOnContent.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataAddOnContent*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataAddOnContent* UGameDataAddOnContent::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataAddOnContent", "Clone");

	Params::GameDataAddOnContent_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataAddOnContent.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataAddOnContent*            game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataAddOnContent::Overwrite(class UGameDataAddOnContent* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataAddOnContent", "Overwrite");

	Params::GameDataAddOnContent_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TimerReportManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTimerReportManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimerReportManager* UTimerReportManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TimerReportManager", "GetInstance");

	Params::TimerReportManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.AddReleaseArea
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::AddReleaseArea(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "AddReleaseArea");

	Params::GameDataArea_AddReleaseArea Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.AddVisitArea
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::AddVisitArea(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "AddVisitArea");

	Params::GameDataArea_AddVisitArea Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataArea*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataArea* UGameDataArea::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "Clone");

	Params::GameDataArea_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataArea*                    GameData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::Overwrite(class UGameDataArea* GameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "Overwrite");

	Params::GameDataArea_Overwrite Parms{};

	Parms.GameData = GameData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetAreaType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAreaType                               Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetAreaType(const EAreaType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetAreaType");

	Params::GameDataArea_SetAreaType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetDistrictID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetDistrictID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetDistrictID");

	Params::GameDataArea_SetDistrictID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetEnvironmentID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetEnvironmentID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetEnvironmentID");

	Params::GameDataArea_SetEnvironmentID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetPointID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetPointID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetPointID");

	Params::GameDataArea_SetPointID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetPrevDistrictID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetPrevDistrictID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetPrevDistrictID");

	Params::GameDataArea_SetPrevDistrictID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetPrevPointID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetPrevPointID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetPrevPointID");

	Params::GameDataArea_SetPrevPointID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetPrevRegionID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetPrevRegionID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetPrevRegionID");

	Params::GameDataArea_SetPrevRegionID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetPrevSectionID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetPrevSectionID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetPrevSectionID");

	Params::GameDataArea_SetPrevSectionID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetPrevZoneID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetPrevZoneID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetPrevZoneID");

	Params::GameDataArea_SetPrevZoneID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetRegionID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetRegionID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetRegionID");

	Params::GameDataArea_SetRegionID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetSectionID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetSectionID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetSectionID");

	Params::GameDataArea_SetSectionID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.SetZoneID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArea::SetZoneID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "SetZoneID");

	Params::GameDataArea_SetZoneID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArea.GetAreaState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_AreaState                    State                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataArea::GetAreaState(const class FName& ID, struct FST_AreaState* State) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetAreaState");

	Params::GameDataArea_GetAreaState Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (State != nullptr)
		*State = std::move(Parms.State);

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetAreaType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAreaType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAreaType UGameDataArea::GetAreaType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetAreaType");

	Params::GameDataArea_GetAreaType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetDistrictID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetDistrictID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetDistrictID");

	Params::GameDataArea_GetDistrictID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetEnvironmentID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGameDataArea::GetEnvironmentID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetEnvironmentID");

	Params::GameDataArea_GetEnvironmentID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetIndoorData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FST_IndoorData             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FST_IndoorData UGameDataArea::GetIndoorData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetIndoorData");

	Params::GameDataArea_GetIndoorData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetPointID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetPointID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetPointID");

	Params::GameDataArea_GetPointID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetPrevDistrictID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetPrevDistrictID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetPrevDistrictID");

	Params::GameDataArea_GetPrevDistrictID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetPrevPointID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetPrevPointID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetPrevPointID");

	Params::GameDataArea_GetPrevPointID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetPrevRegionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetPrevRegionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetPrevRegionID");

	Params::GameDataArea_GetPrevRegionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetPrevSectionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetPrevSectionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetPrevSectionID");

	Params::GameDataArea_GetPrevSectionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetPrevZoneID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetPrevZoneID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetPrevZoneID");

	Params::GameDataArea_GetPrevZoneID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetRegionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetRegionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetRegionID");

	Params::GameDataArea_GetRegionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetSectionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetSectionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetSectionID");

	Params::GameDataArea_GetSectionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetStarScarID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetStarScarID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetStarScarID");

	Params::GameDataArea_GetStarScarID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArea.GetZoneID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataArea::GetZoneID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArea", "GetZoneID");

	Params::GameDataArea_GetZoneID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArtifact.AddBelongingsArtifact
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ArtifactID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArtifact::AddBelongingsArtifact(int32 ArtifactID, int32 Num, int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArtifact", "AddBelongingsArtifact");

	Params::GameDataArtifact_AddBelongingsArtifact Parms{};

	Parms.ArtifactID = ArtifactID;
	Parms.Num = Num;
	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArtifact.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataArtifact*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataArtifact* UGameDataArtifact::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArtifact", "Clone");

	Params::GameDataArtifact_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArtifact.GetBelongingsArtifactEstimatedValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ArtifactID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UGameDataArtifact::GetBelongingsArtifactEstimatedValue(int32 ArtifactID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArtifact", "GetBelongingsArtifactEstimatedValue");

	Params::GameDataArtifact_GetBelongingsArtifactEstimatedValue Parms{};

	Parms.ArtifactID = ArtifactID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArtifact.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataArtifact*                game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArtifact::Overwrite(class UGameDataArtifact* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArtifact", "Overwrite");

	Params::GameDataArtifact_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataArtifactPoint.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataArtifactPoint*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataArtifactPoint* UGameDataArtifactPoint::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArtifactPoint", "Clone");

	Params::GameDataArtifactPoint_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataArtifactPoint.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataArtifactPoint*           game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataArtifactPoint::Overwrite(class UGameDataArtifactPoint* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataArtifactPoint", "Overwrite");

	Params::GameDataArtifactPoint_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDatabase.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDatabase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDatabase* UGameDatabase::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "Clone");

	Params::GameDatabase_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetAchievement
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataAchievement*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataAchievement* UGameDatabase::GetAchievement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetAchievement");

	Params::GameDatabase_GetAchievement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetAOC
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataAddOnContent*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataAddOnContent* UGameDatabase::GetAOC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetAOC");

	Params::GameDatabase_GetAOC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataArea*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataArea* UGameDatabase::GetArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetArea");

	Params::GameDatabase_GetArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetArtifact
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataArtifact*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataArtifact* UGameDatabase::GetArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetArtifact");

	Params::GameDatabase_GetArtifact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetArtifactPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataArtifactPoint*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataArtifactPoint* UGameDatabase::GetArtifactPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetArtifactPoint");

	Params::GameDatabase_GetArtifactPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetBelongingsCoin
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameBelongingsCoin*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameBelongingsCoin* UGameDatabase::GetBelongingsCoin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetBelongingsCoin");

	Params::GameDatabase_GetBelongingsCoin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetBelongingsItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameBelongingsItem*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameBelongingsItem* UGameDatabase::GetBelongingsItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetBelongingsItem");

	Params::GameDatabase_GetBelongingsItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetBonfire
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataBonfire*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataBonfire* UGameDatabase::GetBonfire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetBonfire");

	Params::GameDatabase_GetBonfire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetBreakObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataBreakObject*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataBreakObject* UGameDatabase::GetBreakObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetBreakObject");

	Params::GameDatabase_GetBreakObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetCollectionPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataCollectionPoint*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataCollectionPoint* UGameDatabase::GetCollectionPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetCollectionPoint");

	Params::GameDatabase_GetCollectionPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetDefeatedMonster
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDefeatedMonster*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDefeatedMonster* UGameDatabase::GetDefeatedMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetDefeatedMonster");

	Params::GameDatabase_GetDefeatedMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetDict
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDict*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDict* UGameDatabase::GetDict()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetDict");

	Params::GameDatabase_GetDict Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetDispatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDispatch*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDispatch* UGameDatabase::GetDispatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetDispatch");

	Params::GameDatabase_GetDispatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetDungeon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDungeon*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDungeon* UGameDatabase::GetDungeon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetDungeon");

	Params::GameDatabase_GetDungeon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetField
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataField*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataField* UGameDatabase::GetField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetField");

	Params::GameDatabase_GetField Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetFixTreasureBox
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataFixTreasureBox*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataFixTreasureBox* UGameDatabase::GetFixTreasureBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetFixTreasureBox");

	Params::GameDatabase_GetFixTreasureBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetGameDataFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataFlag*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataFlag* UGameDatabase::GetGameDataFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetGameDataFlag");

	Params::GameDatabase_GetGameDataFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetGuest
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataGuest*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataGuest* UGameDatabase::GetGuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetGuest");

	Params::GameDatabase_GetGuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetHeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataHeader*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataHeader* UGameDatabase::GetHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetHeader");

	Params::GameDatabase_GetHeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataHistory*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataHistory* UGameDatabase::GetHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetHistory");

	Params::GameDatabase_GetHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetMyTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataMyTeam*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataMyTeam* UGameDatabase::GetMyTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetMyTeam");

	Params::GameDatabase_GetMyTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetNetwork
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataNetwork*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataNetwork* UGameDatabase::GetNetwork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetNetwork");

	Params::GameDatabase_GetNetwork Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetNPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataNPC*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataNPC* UGameDatabase::GetNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetNPC");

	Params::GameDatabase_GetNPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataOption*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataOption* UGameDatabase::GetOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetOption");

	Params::GameDatabase_GetOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataParty*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataParty* UGameDatabase::GetParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetParty");

	Params::GameDatabase_GetParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetPlayerData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataPlayer*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataPlayer* UGameDatabase::GetPlayerData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetPlayerData");

	Params::GameDatabase_GetPlayerData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetQuest
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataQuest*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataQuest* UGameDatabase::GetQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetQuest");

	Params::GameDatabase_GetQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetSavePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataSavePoint*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataSavePoint* UGameDatabase::GetSavePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetSavePoint");

	Params::GameDatabase_GetSavePoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetScenarioProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataScenarioProgress*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataScenarioProgress* UGameDatabase::GetScenarioProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetScenarioProgress");

	Params::GameDatabase_GetScenarioProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetShop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataShop*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataShop* UGameDatabase::GetShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetShop");

	Params::GameDatabase_GetShop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetStation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataStation*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataStation* UGameDatabase::GetStation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetStation");

	Params::GameDatabase_GetStation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetStockMonster
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataStockMonster*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataStockMonster* UGameDatabase::GetStockMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetStockMonster");

	Params::GameDatabase_GetStockMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetTargetObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataTargetObject*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataTargetObject* UGameDatabase::GetTargetObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetTargetObject");

	Params::GameDatabase_GetTargetObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetTips
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataTips*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataTips* UGameDatabase::GetTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetTips");

	Params::GameDatabase_GetTips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.GetUIMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataUIMap*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataUIMap* UGameDatabase::GetUIMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "GetUIMap");

	Params::GameDatabase_GetUIMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDatabase.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDatabase*                    game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDatabase::Overwrite(class UGameDatabase* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDatabase", "Overwrite");

	Params::GameDatabase_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataBonfire.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataBonfire*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataBonfire* UGameDataBonfire::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataBonfire", "Clone");

	Params::GameDataBonfire_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataBonfire.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataBonfire*                 game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataBonfire::Overwrite(class UGameDataBonfire* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataBonfire", "Overwrite");

	Params::GameDataBonfire_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataBreakObject.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataBreakObject*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataBreakObject* UGameDataBreakObject::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataBreakObject", "Clone");

	Params::GameDataBreakObject_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataBreakObject.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataBreakObject*             GameData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataBreakObject::Overwrite(class UGameDataBreakObject* GameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataBreakObject", "Overwrite");

	Params::GameDataBreakObject_Overwrite Parms{};

	Parms.GameData = GameData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataCollectionPoint.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataCollectionPoint*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataCollectionPoint* UGameDataCollectionPoint::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataCollectionPoint", "Clone");

	Params::GameDataCollectionPoint_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataCollectionPoint.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataCollectionPoint*         game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataCollectionPoint::Overwrite(class UGameDataCollectionPoint* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataCollectionPoint", "Overwrite");

	Params::GameDataCollectionPoint_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataDefeatedMonster.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDefeatedMonster*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDefeatedMonster* UGameDataDefeatedMonster::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDefeatedMonster", "Clone");

	Params::GameDataDefeatedMonster_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataDefeatedMonster.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataDefeatedMonster*         game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataDefeatedMonster::Overwrite(class UGameDataDefeatedMonster* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDefeatedMonster", "Overwrite");

	Params::GameDataDefeatedMonster_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataDict.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDict*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDict* UGameDataDict::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDict", "Clone");

	Params::GameDataDict_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataDict.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataDict*                    game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataDict::Overwrite(class UGameDataDict* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDict", "Overwrite");

	Params::GameDataDict_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataDict.UpdateKnowledgeDictReleaseInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KnowledgeId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataDict::UpdateKnowledgeDictReleaseInfo(const class FName& KnowledgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDict", "UpdateKnowledgeDictReleaseInfo");

	Params::GameDataDict_UpdateKnowledgeDictReleaseInfo Parms{};

	Parms.KnowledgeId = KnowledgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataDict.UpdateQuestOverviewDictReleaseInfo
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KnowledgeId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataDict::UpdateQuestOverviewDictReleaseInfo(const class FName& KnowledgeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDict", "UpdateQuestOverviewDictReleaseInfo");

	Params::GameDataDict_UpdateQuestOverviewDictReleaseInfo Parms{};

	Parms.KnowledgeId = KnowledgeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataDispatch.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDispatch*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDispatch* UGameDataDispatch::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDispatch", "Clone");

	Params::GameDataDispatch_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataDispatch.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataDispatch*                game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataDispatch::Overwrite(class UGameDataDispatch* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDispatch", "Overwrite");

	Params::GameDataDispatch_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataDungeon.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataDungeon*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataDungeon* UGameDataDungeon::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDungeon", "Clone");

	Params::GameDataDungeon_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataDungeon.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataDungeon*                 game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataDungeon::Overwrite(class UGameDataDungeon* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataDungeon", "Overwrite");

	Params::GameDataDungeon_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataField.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataField*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataField* UGameDataField::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataField", "Clone");

	Params::GameDataField_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataField.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataField*                   GameData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataField::Overwrite(class UGameDataField* GameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataField", "Overwrite");

	Params::GameDataField_Overwrite Parms{};

	Parms.GameData = GameData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataField.SetTrainStopStationID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataField::SetTrainStopStationID(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataField", "SetTrainStopStationID");

	Params::GameDataField_SetTrainStopStationID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataField.GetTrainStopStationID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UGameDataField::GetTrainStopStationID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataField", "GetTrainStopStationID");

	Params::GameDataField_GetTrainStopStationID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFixTreasureBox.AddTreasureBoxState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             FiledObjectID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOpen_0                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataFixTreasureBox::AddTreasureBoxState(const class FName& FiledObjectID, const bool IsOpen_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFixTreasureBox", "AddTreasureBoxState");

	Params::GameDataFixTreasureBox_AddTreasureBoxState Parms{};

	Parms.FiledObjectID = FiledObjectID;
	Parms.IsOpen_0 = IsOpen_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataFixTreasureBox.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataFixTreasureBox*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataFixTreasureBox* UGameDataFixTreasureBox::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFixTreasureBox", "Clone");

	Params::GameDataFixTreasureBox_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFixTreasureBox.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataFixTreasureBox*          GameData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataFixTreasureBox::Overwrite(class UGameDataFixTreasureBox* GameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFixTreasureBox", "Overwrite");

	Params::GameDataFixTreasureBox_Overwrite Parms{};

	Parms.GameData = GameData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataFixTreasureBox.IsExistData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             FiledObjectID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataFixTreasureBox::IsExistData(const class FName& FiledObjectID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFixTreasureBox", "IsExistData");

	Params::GameDataFixTreasureBox_IsExistData Parms{};

	Parms.FiledObjectID = FiledObjectID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFixTreasureBox.IsOpen
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             FiledObjectID                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataFixTreasureBox::IsOpen(const class FName& FiledObjectID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFixTreasureBox", "IsOpen");

	Params::GameDataFixTreasureBox_IsOpen Parms{};

	Parms.FiledObjectID = FiledObjectID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFlag.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataFlag*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataFlag* UGameDataFlag::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFlag", "Clone");

	Params::GameDataFlag_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFlag.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataFlag*                    game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataFlag::Overwrite(class UGameDataFlag* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFlag", "Overwrite");

	Params::GameDataFlag_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataFlag.SetFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             FlagName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetFlag_0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataFlag::SetFlag(const class FName& FlagName, bool SetFlag_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFlag", "SetFlag");

	Params::GameDataFlag_SetFlag Parms{};

	Parms.FlagName = FlagName;
	Parms.SetFlag_0 = SetFlag_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataFlag.GetFlag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             FlagName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataFlag::GetFlag(const class FName& FlagName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataFlag", "GetFlag");

	Params::GameDataFlag_GetFlag Parms{};

	Parms.FlagName = FlagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFunctionLibrary.CheckFlagDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             FlagName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataFunctionLibrary::CheckFlagDefinition(const class FName& FlagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataFunctionLibrary", "CheckFlagDefinition");

	Params::GameDataFunctionLibrary_CheckFlagDefinition Parms{};

	Parms.FlagName = FlagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFunctionLibrary.CheckFlagDefinitions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     FlagNames                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    or_check                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataFunctionLibrary::CheckFlagDefinitions(const TArray<class FName>& FlagNames, bool or_check)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataFunctionLibrary", "CheckFlagDefinitions");

	Params::GameDataFunctionLibrary_CheckFlagDefinitions Parms{};

	Parms.FlagNames = std::move(FlagNames);
	Parms.or_check = or_check;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataFunctionLibrary.CheckFlagMatch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FName, bool>                 FlagNames                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataFunctionLibrary::CheckFlagMatch(const TMap<class FName, bool>& FlagNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataFunctionLibrary", "CheckFlagMatch");

	Params::GameDataFunctionLibrary_CheckFlagMatch Parms{};

	Parms.FlagNames = std::move(FlagNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataGuest*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataGuest* UGameDataGuest::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "Clone");

	Params::GameDataGuest_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetConstValue_GuestMonsterLoopRange
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EGuestType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   first                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   last                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataGuest::GetConstValue_GuestMonsterLoopRange(EGuestType Type, int32* first, int32* last)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetConstValue_GuestMonsterLoopRange");

	Params::GameDataGuest_GetConstValue_GuestMonsterLoopRange Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (first != nullptr)
		*first = Parms.first;

	if (last != nullptr)
		*last = Parms.last;
}


// Function DarwinGame.GameDataGuest.GetGuestMonsterHp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetGuestMonsterHp(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetGuestMonsterHp");

	Params::GameDataGuest_GetGuestMonsterHp Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetGuestMonsterKindId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetGuestMonsterKindId(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetGuestMonsterKindId");

	Params::GameDataGuest_GetGuestMonsterKindId Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetGuestMonsterLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetGuestMonsterLevel(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetGuestMonsterLevel");

	Params::GameDataGuest_GetGuestMonsterLevel Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetGuestMonsterMp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetGuestMonsterMp(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetGuestMonsterMp");

	Params::GameDataGuest_GetGuestMonsterMp Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetGuestMonsterNickName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UGameDataGuest::GetGuestMonsterNickName(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetGuestMonsterNickName");

	Params::GameDataGuest_GetGuestMonsterNickName Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.IsMainGuestMonsterIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataGuest::IsMainGuestMonsterIndex(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "IsMainGuestMonsterIndex");

	Params::GameDataGuest_IsMainGuestMonsterIndex Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataGuest*                   game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataGuest::Overwrite(class UGameDataGuest* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "Overwrite");

	Params::GameDataGuest_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataGuest.Remove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::Remove(int32 globalGuestIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "Remove");

	Params::GameDataGuest_Remove Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.SetGuestMonsterHp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataGuest::SetGuestMonsterHp(int32 globalGuestIndex, int32 HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "SetGuestMonsterHp");

	Params::GameDataGuest_SetGuestMonsterHp Parms{};

	Parms.globalGuestIndex = globalGuestIndex;
	Parms.HP = HP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataGuest.SetGuestMonsterKindId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataGuest::SetGuestMonsterKindId(int32 globalGuestIndex, int32 KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "SetGuestMonsterKindId");

	Params::GameDataGuest_SetGuestMonsterKindId Parms{};

	Parms.globalGuestIndex = globalGuestIndex;
	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataGuest.SetGuestMonsterLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataGuest::SetGuestMonsterLevel(int32 globalGuestIndex, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "SetGuestMonsterLevel");

	Params::GameDataGuest_SetGuestMonsterLevel Parms{};

	Parms.globalGuestIndex = globalGuestIndex;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataGuest.SetGuestMonsterMp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataGuest::SetGuestMonsterMp(int32 globalGuestIndex, int32 MP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "SetGuestMonsterMp");

	Params::GameDataGuest_SetGuestMonsterMp Parms{};

	Parms.globalGuestIndex = globalGuestIndex;
	Parms.MP = MP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataGuest.SetGuestMonsterNickName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             NickName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameDataGuest::SetGuestMonsterNickName(int32 globalGuestIndex, const class FText& NickName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "SetGuestMonsterNickName");

	Params::GameDataGuest_SetGuestMonsterNickName Parms{};

	Parms.globalGuestIndex = globalGuestIndex;
	Parms.NickName = std::move(NickName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataGuest.GetMainGuestMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetMainGuestMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetMainGuestMax");

	Params::GameDataGuest_GetMainGuestMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetMax");

	Params::GameDataGuest_GetMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.GetNumKind
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGuestType                              guestType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataGuest::GetNumKind(int32 KindId, EGuestType guestType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "GetNumKind");

	Params::GameDataGuest_GetNumKind Parms{};

	Parms.KindId = KindId;
	Parms.guestType = guestType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.IsEmptySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   globalGuestIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataGuest::IsEmptySlot(int32 globalGuestIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "IsEmptySlot");

	Params::GameDataGuest_IsEmptySlot Parms{};

	Parms.globalGuestIndex = globalGuestIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataGuest.IsMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGuestType                              guestType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataGuest::IsMax(EGuestType guestType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGuest", "IsMax");

	Params::GameDataGuest_IsMax Parms{};

	Parms.guestType = guestType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHeader.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataHeader*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataHeader* UGameDataHeader::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHeader", "Clone");

	Params::GameDataHeader_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataHeader.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataHeader*                  game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataHeader::Overwrite(class UGameDataHeader* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataHeader", "Overwrite");

	Params::GameDataHeader_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataManager* UGameDataManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameDataManager", "GetInstance");

	Params::GameDataManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataManager.GetGameDatabase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDatabase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDatabase* UGameDataManager::GetGameDatabase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataManager", "GetGameDatabase");

	Params::GameDataManager_GetGameDatabase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ProjectHttpManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UProjectHttpManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProjectHttpManager* UProjectHttpManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectHttpManager", "GetInstance");

	Params::ProjectHttpManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ProjectHttpManager.IsTermsAccepted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectHttpManager::IsTermsAccepted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectHttpManager", "IsTermsAccepted");

	Params::ProjectHttpManager_IsTermsAccepted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ProjectHttpManager.IsTermsFirstLook
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectHttpManager::IsTermsFirstLook() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectHttpManager", "IsTermsFirstLook");

	Params::ProjectHttpManager_IsTermsFirstLook Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ProjectHttpManager.IsTermsLooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectHttpManager::IsTermsLooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectHttpManager", "IsTermsLooked");

	Params::ProjectHttpManager_IsTermsLooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataMyTeam.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataMyTeam*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataMyTeam* UGameDataMyTeam::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataMyTeam", "Clone");

	Params::GameDataMyTeam_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataMyTeam.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataMyTeam*                  game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataMyTeam::Overwrite(class UGameDataMyTeam* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataMyTeam", "Overwrite");

	Params::GameDataMyTeam_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataMyTeam.SetTeamFlagID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FlagId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataMyTeam::SetTeamFlagID(int32 FlagId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataMyTeam", "SetTeamFlagID");

	Params::GameDataMyTeam_SetTeamFlagID Parms{};

	Parms.FlagId = FlagId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataNetwork.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataNetwork*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataNetwork* UGameDataNetwork::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataNetwork", "Clone");

	Params::GameDataNetwork_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataNetwork.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataNetwork*                 game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataNetwork::Overwrite(class UGameDataNetwork* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataNetwork", "Overwrite");

	Params::GameDataNetwork_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataOption*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataOption* UGameDataOption::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "Clone");

	Params::GameDataOption_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataOption*                  game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::Overwrite(class UGameDataOption* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "Overwrite");

	Params::GameDataOption_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetAmbientValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionAmbient                          InAmbientValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetAmbientValue(const EOptionAmbient InAmbientValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetAmbientValue");

	Params::GameDataOption_SetAmbientValue Parms{};

	Parms.InAmbientValue = InAmbientValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetAntialiasingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionAntialiasing                     InAntialiasingValue                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetAntialiasingValue(const EOptionAntialiasing InAntialiasingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetAntialiasingValue");

	Params::GameDataOption_SetAntialiasingValue Parms{};

	Parms.InAntialiasingValue = InAntialiasingValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetBGMVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionSoundVolume                      InBGMVolume                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetBGMVolume(const EOptionSoundVolume InBGMVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetBGMVolume");

	Params::GameDataOption_SetBGMVolume Parms{};

	Parms.InBGMVolume = InBGMVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetBloomValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionBloom                            InBloomValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetBloomValue(const EOptionBloom InBloomValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetBloomValue");

	Params::GameDataOption_SetBloomValue Parms{};

	Parms.InBloomValue = InBloomValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetBrightnessVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionBrightness                       InBrightnesVolum                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetBrightnessVolume(const EOptionBrightness InBrightnesVolum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetBrightnessVolume");

	Params::GameDataOption_SetBrightnessVolume Parms{};

	Parms.InBrightnesVolum = InBrightnesVolum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetCameraLeftRightIsNormal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InCameraLeftRightIsNormal                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetCameraLeftRightIsNormal(const bool InCameraLeftRightIsNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetCameraLeftRightIsNormal");

	Params::GameDataOption_SetCameraLeftRightIsNormal Parms{};

	Parms.InCameraLeftRightIsNormal = InCameraLeftRightIsNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetCameraLeftRightSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraYawRotateSpeedRatePolicy         InCameraLeftRightSpeed                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetCameraLeftRightSpeed(const ECameraYawRotateSpeedRatePolicy InCameraLeftRightSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetCameraLeftRightSpeed");

	Params::GameDataOption_SetCameraLeftRightSpeed Parms{};

	Parms.InCameraLeftRightSpeed = InCameraLeftRightSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetCameraUpDownIsNormal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InCameraUpDownIsNormal                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetCameraUpDownIsNormal(const bool InCameraUpDownIsNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetCameraUpDownIsNormal");

	Params::GameDataOption_SetCameraUpDownIsNormal Parms{};

	Parms.InCameraUpDownIsNormal = InCameraUpDownIsNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetCameraUpDownSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraPitchRotateSpeedRatePolicy       InCameraUpDownSpeed                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetCameraUpDownSpeed(const ECameraPitchRotateSpeedRatePolicy InCameraUpDownSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetCameraUpDownSpeed");

	Params::GameDataOption_SetCameraUpDownSpeed Parms{};

	Parms.InCameraUpDownSpeed = InCameraUpDownSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetControllerLayout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELayoutController                       InControllerLayout                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetControllerLayout(const ELayoutController InControllerLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetControllerLayout");

	Params::GameDataOption_SetControllerLayout Parms{};

	Parms.InControllerLayout = InControllerLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetDensityValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionDensity                          InDensityValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetDensityValue(const EOptionDensity InDensityValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetDensityValue");

	Params::GameDataOption_SetDensityValue Parms{};

	Parms.InDensityValue = InDensityValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetFpsValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFpsValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetFpsValue(const float InFpsValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetFpsValue");

	Params::GameDataOption_SetFpsValue Parms{};

	Parms.InFpsValue = InFpsValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetIsMouseAttackMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsMouseAttackMode                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetIsMouseAttackMode(const bool IsMouseAttackMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetIsMouseAttackMode");

	Params::GameDataOption_SetIsMouseAttackMode Parms{};

	Parms.IsMouseAttackMode = IsMouseAttackMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetIsUsingAController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsUsingAController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetIsUsingAController(const bool IsUsingAController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetIsUsingAController");

	Params::GameDataOption_SetIsUsingAController Parms{};

	Parms.IsUsingAController = IsUsingAController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetKeyboardLayout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELayoutKeyboard                         InKeyboardLayout                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetKeyboardLayout(const ELayoutKeyboard InKeyboardLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetKeyboardLayout");

	Params::GameDataOption_SetKeyboardLayout Parms{};

	Parms.InKeyboardLayout = InKeyboardLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetLanguageVoiceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELanguageVoiceType                      InLanguageVoiceType                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetLanguageVoiceType(const ELanguageVoiceType InLanguageVoiceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetLanguageVoiceType");

	Params::GameDataOption_SetLanguageVoiceType Parms{};

	Parms.InLanguageVoiceType = InLanguageVoiceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetLODValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionLOD                              InLODValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetLODValue(const EOptionLOD InLODValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetLODValue");

	Params::GameDataOption_SetLODValue Parms{};

	Parms.InLODValue = InLODValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetPresetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionPreset                           InPresetValue                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetPresetValue(const EOptionPreset InPresetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetPresetValue");

	Params::GameDataOption_SetPresetValue Parms{};

	Parms.InPresetValue = InPresetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetReflectionValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionReflection                       InReflectionValue                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetReflectionValue(const EOptionReflection InReflectionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetReflectionValue");

	Params::GameDataOption_SetReflectionValue Parms{};

	Parms.InReflectionValue = InReflectionValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetResolutionIndexValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionResolutionIndex                  InResolutionIndexValue                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetResolutionIndexValue(const EOptionResolutionIndex InResolutionIndexValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetResolutionIndexValue");

	Params::GameDataOption_SetResolutionIndexValue Parms{};

	Parms.InResolutionIndexValue = InResolutionIndexValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetSEVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionSoundVolume                      InSEVolume                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetSEVolume(const EOptionSoundVolume InSEVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetSEVolume");

	Params::GameDataOption_SetSEVolume Parms{};

	Parms.InSEVolume = InSEVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetShadowValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionShadow                           InShadowValue                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetShadowValue(const EOptionShadow InShadowValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetShadowValue");

	Params::GameDataOption_SetShadowValue Parms{};

	Parms.InShadowValue = InShadowValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetSubtitlesIsVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InSubtitlesIsVisible                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetSubtitlesIsVisible(const bool InSubtitlesIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetSubtitlesIsVisible");

	Params::GameDataOption_SetSubtitlesIsVisible Parms{};

	Parms.InSubtitlesIsVisible = InSubtitlesIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetTextureDetailValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionGraphicsQuality                  InTextureDetailValue                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetTextureDetailValue(const EOptionGraphicsQuality InTextureDetailValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetTextureDetailValue");

	Params::GameDataOption_SetTextureDetailValue Parms{};

	Parms.InTextureDetailValue = InTextureDetailValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetTextureFilterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionGraphicsQuality                  InTextureFilterValue                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetTextureFilterValue(const EOptionGraphicsQuality InTextureFilterValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetTextureFilterValue");

	Params::GameDataOption_SetTextureFilterValue Parms{};

	Parms.InTextureFilterValue = InTextureFilterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetVoiceVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionSoundVolume                      InVoiceVolum                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetVoiceVolume(const EOptionSoundVolume InVoiceVolum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetVoiceVolume");

	Params::GameDataOption_SetVoiceVolume Parms{};

	Parms.InVoiceVolum = InVoiceVolum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetVsyncIsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVysncIsEnabled                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetVsyncIsEnabled(const bool InVysncIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetVsyncIsEnabled");

	Params::GameDataOption_SetVsyncIsEnabled Parms{};

	Parms.InVysncIsEnabled = InVysncIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.SetWindowModeValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionWindowMode                       InWindowModeValue                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataOption::SetWindowModeValue(const EOptionWindowMode InWindowModeValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "SetWindowModeValue");

	Params::GameDataOption_SetWindowModeValue Parms{};

	Parms.InWindowModeValue = InWindowModeValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataOption.GetAmbientValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionAmbient                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionAmbient UGameDataOption::GetAmbientValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetAmbientValue");

	Params::GameDataOption_GetAmbientValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetAntialiasingValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionAntialiasing                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionAntialiasing UGameDataOption::GetAntialiasingValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetAntialiasingValue");

	Params::GameDataOption_GetAntialiasingValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetBGMVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionSoundVolume                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionSoundVolume UGameDataOption::GetBGMVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetBGMVolume");

	Params::GameDataOption_GetBGMVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetBGMVolumeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameDataOption::GetBGMVolumeRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetBGMVolumeRate");

	Params::GameDataOption_GetBGMVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetBloomValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionBloom                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionBloom UGameDataOption::GetBloomValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetBloomValue");

	Params::GameDataOption_GetBloomValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetBrightnessVolumeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionBrightness                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionBrightness UGameDataOption::GetBrightnessVolumeRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetBrightnessVolumeRate");

	Params::GameDataOption_GetBrightnessVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetCameraLeftRightIsNormal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataOption::GetCameraLeftRightIsNormal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetCameraLeftRightIsNormal");

	Params::GameDataOption_GetCameraLeftRightIsNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetCameraLeftRightSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECameraYawRotateSpeedRatePolicy         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECameraYawRotateSpeedRatePolicy UGameDataOption::GetCameraLeftRightSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetCameraLeftRightSpeed");

	Params::GameDataOption_GetCameraLeftRightSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetCameraUpDownIsNormal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataOption::GetCameraUpDownIsNormal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetCameraUpDownIsNormal");

	Params::GameDataOption_GetCameraUpDownIsNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetCameraUpDownSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECameraPitchRotateSpeedRatePolicy       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECameraPitchRotateSpeedRatePolicy UGameDataOption::GetCameraUpDownSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetCameraUpDownSpeed");

	Params::GameDataOption_GetCameraUpDownSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetControllerLayout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELayoutController                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELayoutController UGameDataOption::GetControllerLayout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetControllerLayout");

	Params::GameDataOption_GetControllerLayout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetDensityValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionDensity                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionDensity UGameDataOption::GetDensityValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetDensityValue");

	Params::GameDataOption_GetDensityValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetFpsValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameDataOption::GetFpsValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetFpsValue");

	Params::GameDataOption_GetFpsValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetIsMouseAttackMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataOption::GetIsMouseAttackMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetIsMouseAttackMode");

	Params::GameDataOption_GetIsMouseAttackMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetIsUsingAController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataOption::GetIsUsingAController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetIsUsingAController");

	Params::GameDataOption_GetIsUsingAController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetKeyboardLayout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELayoutKeyboard                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELayoutKeyboard UGameDataOption::GetKeyboardLayout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetKeyboardLayout");

	Params::GameDataOption_GetKeyboardLayout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetLanguageVoiceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELanguageVoiceType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELanguageVoiceType UGameDataOption::GetLanguageVoiceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetLanguageVoiceType");

	Params::GameDataOption_GetLanguageVoiceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetLODValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionLOD                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionLOD UGameDataOption::GetLODValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetLODValue");

	Params::GameDataOption_GetLODValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetPresetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionPreset                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionPreset UGameDataOption::GetPresetValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetPresetValue");

	Params::GameDataOption_GetPresetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetReflectionValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionReflection                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionReflection UGameDataOption::GetReflectionValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetReflectionValue");

	Params::GameDataOption_GetReflectionValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetResolutionIndexValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionResolutionIndex                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionResolutionIndex UGameDataOption::GetResolutionIndexValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetResolutionIndexValue");

	Params::GameDataOption_GetResolutionIndexValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetSEVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionSoundVolume                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionSoundVolume UGameDataOption::GetSEVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetSEVolume");

	Params::GameDataOption_GetSEVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetSEVolumeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameDataOption::GetSEVolumeRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetSEVolumeRate");

	Params::GameDataOption_GetSEVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetShadowValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionShadow                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionShadow UGameDataOption::GetShadowValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetShadowValue");

	Params::GameDataOption_GetShadowValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetSubtitlesIsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataOption::GetSubtitlesIsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetSubtitlesIsVisible");

	Params::GameDataOption_GetSubtitlesIsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetTextureDetailValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionGraphicsQuality                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionGraphicsQuality UGameDataOption::GetTextureDetailValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetTextureDetailValue");

	Params::GameDataOption_GetTextureDetailValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetTextureFilterValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionGraphicsQuality                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionGraphicsQuality UGameDataOption::GetTextureFilterValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetTextureFilterValue");

	Params::GameDataOption_GetTextureFilterValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetVoiceVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionSoundVolume                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionSoundVolume UGameDataOption::GetVoiceVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetVoiceVolume");

	Params::GameDataOption_GetVoiceVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetVoiceVolumeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameDataOption::GetVoiceVolumeRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetVoiceVolumeRate");

	Params::GameDataOption_GetVoiceVolumeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetVsyncIsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataOption::GetVsyncIsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetVsyncIsEnabled");

	Params::GameDataOption_GetVsyncIsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataOption.GetWindowModeValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOptionWindowMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionWindowMode UGameDataOption::GetWindowModeValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataOption", "GetWindowModeValue");

	Params::GameDataOption_GetWindowModeValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataParty*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataParty* UGameDataParty::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "Clone");

	Params::GameDataParty_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetClearPartyMonsterUIds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<int32> UGameDataParty::GetClearPartyMonsterUIds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetClearPartyMonsterUIds");

	Params::GameDataParty_GetClearPartyMonsterUIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetConstValue_PartyMonsterLoopRange
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EPartyType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   first                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   last                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::GetConstValue_PartyMonsterLoopRange(EPartyType Type, int32* first, int32* last)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetConstValue_PartyMonsterLoopRange");

	Params::GameDataParty_GetConstValue_PartyMonsterLoopRange Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (first != nullptr)
		*first = Parms.first;

	if (last != nullptr)
		*last = Parms.last;
}


// Function DarwinGame.GameDataParty.GetPartyMonsterHp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetPartyMonsterHp(int32 globalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetPartyMonsterHp");

	Params::GameDataParty_GetPartyMonsterHp Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetPartyMonsterKindId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetPartyMonsterKindId(int32 globalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetPartyMonsterKindId");

	Params::GameDataParty_GetPartyMonsterKindId Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetPartyMonsterLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetPartyMonsterLevel(int32 globalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetPartyMonsterLevel");

	Params::GameDataParty_GetPartyMonsterLevel Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetPartyMonsterMp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetPartyMonsterMp(int32 globalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetPartyMonsterMp");

	Params::GameDataParty_GetPartyMonsterMp Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetPartyMonsterNickName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UGameDataParty::GetPartyMonsterNickName(int32 globalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetPartyMonsterNickName");

	Params::GameDataParty_GetPartyMonsterNickName Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataParty*                   game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::Overwrite(class UGameDataParty* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "Overwrite");

	Params::GameDataParty_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.Remove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::Remove(int32 globalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "Remove");

	Params::GameDataParty_Remove Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.SetClearPartyMonsterUIds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           clearPartyMonsterUids                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::SetClearPartyMonsterUIds(const TArray<int32>& clearPartyMonsterUids)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "SetClearPartyMonsterUIds");

	Params::GameDataParty_SetClearPartyMonsterUIds Parms{};

	Parms.clearPartyMonsterUids = std::move(clearPartyMonsterUids);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.SetPartyMonsterHp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::SetPartyMonsterHp(int32 globalPartyIndex, int32 HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "SetPartyMonsterHp");

	Params::GameDataParty_SetPartyMonsterHp Parms{};

	Parms.globalPartyIndex = globalPartyIndex;
	Parms.HP = HP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.SetPartyMonsterKindId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::SetPartyMonsterKindId(int32 globalPartyIndex, int32 KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "SetPartyMonsterKindId");

	Params::GameDataParty_SetPartyMonsterKindId Parms{};

	Parms.globalPartyIndex = globalPartyIndex;
	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.SetPartyMonsterLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::SetPartyMonsterLevel(int32 globalPartyIndex, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "SetPartyMonsterLevel");

	Params::GameDataParty_SetPartyMonsterLevel Parms{};

	Parms.globalPartyIndex = globalPartyIndex;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.SetPartyMonsterMp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::SetPartyMonsterMp(int32 globalPartyIndex, int32 MP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "SetPartyMonsterMp");

	Params::GameDataParty_SetPartyMonsterMp Parms{};

	Parms.globalPartyIndex = globalPartyIndex;
	Parms.MP = MP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.SetPartyMonsterNickName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             NickName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameDataParty::SetPartyMonsterNickName(int32 globalPartyIndex, const class FText& NickName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "SetPartyMonsterNickName");

	Params::GameDataParty_SetPartyMonsterNickName Parms{};

	Parms.globalPartyIndex = globalPartyIndex;
	Parms.NickName = std::move(NickName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.Swap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   firstGlobalPartyIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   secoundGlobalPartyIndex                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataParty::Swap(int32 firstGlobalPartyIndex, int32 secoundGlobalPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "Swap");

	Params::GameDataParty_Swap Parms{};

	Parms.firstGlobalPartyIndex = firstGlobalPartyIndex;
	Parms.secoundGlobalPartyIndex = secoundGlobalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataParty.GetMainPartyMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetMainPartyMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetMainPartyMax");

	Params::GameDataParty_GetMainPartyMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetMatchArtifactMonsterList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<int32>                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TArray<int32> UGameDataParty::GetMatchArtifactMonsterList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetMatchArtifactMonsterList");

	Params::GameDataParty_GetMatchArtifactMonsterList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetMax");

	Params::GameDataParty_GetMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.GetNumKind
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPartyType                              partyType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataParty::GetNumKind(int32 KindId, EPartyType partyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "GetNumKind");

	Params::GameDataParty_GetNumKind Parms{};

	Parms.KindId = KindId;
	Parms.partyType = partyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.IsEmptySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataParty::IsEmptySlot(int32 globalPartyIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "IsEmptySlot");

	Params::GameDataParty_IsEmptySlot Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.IsMainPartyMonsterIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   globalPartyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataParty::IsMainPartyMonsterIndex(int32 globalPartyIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "IsMainPartyMonsterIndex");

	Params::GameDataParty_IsMainPartyMonsterIndex Parms{};

	Parms.globalPartyIndex = globalPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataParty.IsMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPartyType                              partyType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataParty::IsMax(EPartyType partyType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataParty", "IsMax");

	Params::GameDataParty_IsMax Parms{};

	Parms.partyType = partyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationElevator.ChangeBottomElevatorState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EElevatorState                          State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationElevator::ChangeBottomElevatorState(EElevatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "ChangeBottomElevatorState");

	Params::StationElevator_ChangeBottomElevatorState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.ChangeTopElevatorState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EElevatorState                          State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationElevator::ChangeTopElevatorState(EElevatorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "ChangeTopElevatorState");

	Params::StationElevator_ChangeTopElevatorState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.GetIsOpenDoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStationElevator::GetIsOpenDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "GetIsOpenDoor");

	Params::StationElevator_GetIsOpenDoor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationElevator.PlayCloseDoor
// (Final, Native, Public, BlueprintCallable)

void AStationElevator::PlayCloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "PlayCloseDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.PlayElevatorArrivalEventStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartOffset                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationElevator::PlayElevatorArrivalEventStart(const float StartOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "PlayElevatorArrivalEventStart");

	Params::StationElevator_PlayElevatorArrivalEventStart Parms{};

	Parms.StartOffset = StartOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.PlayElevatorMoveEventStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bToTop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationElevator::PlayElevatorMoveEventStart(bool bToTop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "PlayElevatorMoveEventStart");

	Params::StationElevator_PlayElevatorMoveEventStart Parms{};

	Parms.bToTop = bToTop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.PlayOpenDoor
// (Final, Native, Public, BlueprintCallable)

void AStationElevator::PlayOpenDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "PlayOpenDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.SetBottom
// (Final, Native, Public, BlueprintCallable)

void AStationElevator::SetBottom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "SetBottom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.SetTop
// (Final, Native, Public, BlueprintCallable)

void AStationElevator::SetTop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "SetTop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationElevator.getBottomPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AStationElevator::getBottomPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "getBottomPosition");

	Params::StationElevator_getBottomPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationElevator.getTopPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AStationElevator::getTopPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "getTopPosition");

	Params::StationElevator_getTopPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationElevator.IsBottom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStationElevator::IsBottom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "IsBottom");

	Params::StationElevator_IsBottom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationElevator.IsEndedEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStationElevator::IsEndedEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "IsEndedEvent");

	Params::StationElevator_IsEndedEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationElevator.IsTop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStationElevator::IsTop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationElevator", "IsTop");

	Params::StationElevator_IsTop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataSavePoint.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataSavePoint*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataSavePoint* UGameDataSavePoint::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "Clone");

	Params::GameDataSavePoint_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataSavePoint.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataSavePoint*               game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataSavePoint::Overwrite(class UGameDataSavePoint* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "Overwrite");

	Params::GameDataSavePoint_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataSavePoint.SetSavePointLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          save_location                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataSavePoint::SetSavePointLocation(const struct FVector& save_location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "SetSavePointLocation");

	Params::GameDataSavePoint_SetSavePointLocation Parms{};

	Parms.save_location = std::move(save_location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataSavePoint.SetSavePointPersistentId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPersistentLevelID                      persistent_id                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataSavePoint::SetSavePointPersistentId(EPersistentLevelID persistent_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "SetSavePointPersistentId");

	Params::GameDataSavePoint_SetSavePointPersistentId Parms{};

	Parms.persistent_id = persistent_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataSavePoint.SetSavePointRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         save_rotation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGameDataSavePoint::SetSavePointRotation(const struct FRotator& save_rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "SetSavePointRotation");

	Params::GameDataSavePoint_SetSavePointRotation Parms{};

	Parms.save_rotation = std::move(save_rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataSavePoint.GetSavePointLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UGameDataSavePoint::GetSavePointLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "GetSavePointLocation");

	Params::GameDataSavePoint_GetSavePointLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataSavePoint.GetSavePointPersistentId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPersistentLevelID                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPersistentLevelID UGameDataSavePoint::GetSavePointPersistentId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "GetSavePointPersistentId");

	Params::GameDataSavePoint_GetSavePointPersistentId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataSavePoint.GetSavePointRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator UGameDataSavePoint::GetSavePointRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataSavePoint", "GetSavePointRotation");

	Params::GameDataSavePoint_GetSavePointRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataScenarioProgress.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataScenarioProgress*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataScenarioProgress* UGameDataScenarioProgress::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataScenarioProgress", "Clone");

	Params::GameDataScenarioProgress_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataScenarioProgress.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataScenarioProgress*        game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataScenarioProgress::Overwrite(class UGameDataScenarioProgress* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataScenarioProgress", "Overwrite");

	Params::GameDataScenarioProgress_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetArrowComponent.SetTargetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetArrowComponent::SetTargetRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetArrowComponent", "SetTargetRadius");

	Params::TargetArrowComponent_SetTargetRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetArrowComponent.TargetChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetArrowComponent::TargetChange(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetArrowComponent", "TargetChange");

	Params::TargetArrowComponent_TargetChange Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetArrowComponent.TargetEnd
// (Final, Native, Public, BlueprintCallable)

void UTargetArrowComponent::TargetEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetArrowComponent", "TargetEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetArrowComponent.TargetStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetArrowComponent::TargetStart(class AActor* Start, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetArrowComponent", "TargetStart");

	Params::TargetArrowComponent_TargetStart Parms{};

	Parms.Start = Start;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetArrowComponent.TargetStartCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetArrowComponent::TargetStartCount(class AActor* Start, class AActor* Target, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetArrowComponent", "TargetStartCount");

	Params::TargetArrowComponent_TargetStartCount Parms{};

	Parms.Start = Start;
	Parms.Target = Target;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetArrowComponent.IsFinish
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTargetArrowComponent::IsFinish() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetArrowComponent", "IsFinish");

	Params::TargetArrowComponent_IsFinish Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStockMonster.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataStockMonster*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataStockMonster* UGameDataStockMonster::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStockMonster", "Clone");

	Params::GameDataStockMonster_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStockMonster.GetStockMonsterKindNum
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataStockMonster::GetStockMonsterKindNum(const class FName& KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStockMonster", "GetStockMonsterKindNum");

	Params::GameDataStockMonster_GetStockMonsterKindNum Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataStockMonster.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataStockMonster*            game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataStockMonster::Overwrite(class UGameDataStockMonster* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStockMonster", "Overwrite");

	Params::GameDataStockMonster_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataStockMonster.CanAddStockMonster
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataStockMonster::CanAddStockMonster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataStockMonster", "CanAddStockMonster");

	Params::GameDataStockMonster_CanAddStockMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataTargetObject.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataTargetObject*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataTargetObject* UGameDataTargetObject::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTargetObject", "Clone");

	Params::GameDataTargetObject_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataTargetObject.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataTargetObject*            game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataTargetObject::Overwrite(class UGameDataTargetObject* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataTargetObject", "Overwrite");

	Params::GameDataTargetObject_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconRange.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_SlingShotCategory            Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIShot_IconRange::SetData(const struct FST_SlingShotCategory& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconRange", "SetData");

	Params::UIShot_IconRange_SetData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.AddSignData
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EMapSymbolType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FloorNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::AddSignData(EMapSymbolType Type, int32 FloorNum, class FName AreaID, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "AddSignData");

	Params::GameDataUIMap_AddSignData Parms{};

	Parms.Type = Type;
	Parms.FloorNum = FloorNum;
	Parms.AreaID = AreaID;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.Clone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameDataUIMap*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameDataUIMap* UGameDataUIMap::Clone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "Clone");

	Params::GameDataUIMap_Clone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.CreateEnterAreaData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ArraySize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::CreateEnterAreaData(int32 ArraySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "CreateEnterAreaData");

	Params::GameDataUIMap_CreateEnterAreaData Parms{};

	Parms.ArraySize = ArraySize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.CreateEnterFloorAreaData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ArraySize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::CreateEnterFloorAreaData(int32 ArraySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "CreateEnterFloorAreaData");

	Params::GameDataUIMap_CreateEnterFloorAreaData Parms{};

	Parms.ArraySize = ArraySize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.GetEnterAreaMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UGameDataUIMap::GetEnterAreaMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetEnterAreaMask");

	Params::GameDataUIMap_GetEnterAreaMask Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.GetEnterFloorAreaMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UGameDataUIMap::GetEnterFloorAreaMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetEnterFloorAreaMask");

	Params::GameDataUIMap_GetEnterFloorAreaMask Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.GetIsFirstOpenAllMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataUIMap::GetIsFirstOpenAllMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetIsFirstOpenAllMap");

	Params::GameDataUIMap_GetIsFirstOpenAllMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.GetIsFirstOpenFaskullMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataUIMap::GetIsFirstOpenFaskullMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetIsFirstOpenFaskullMap");

	Params::GameDataUIMap_GetIsFirstOpenFaskullMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.GetZoomScaleIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataUIMap::GetZoomScaleIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetZoomScaleIndex");

	Params::GameDataUIMap_GetZoomScaleIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.Overwrite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataUIMap*                   game_data                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::Overwrite(class UGameDataUIMap* game_data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "Overwrite");

	Params::GameDataUIMap_Overwrite Parms{};

	Parms.game_data = game_data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.RemoveSignData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMapSymbolType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::RemoveSignData(EMapSymbolType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "RemoveSignData");

	Params::GameDataUIMap_RemoveSignData Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetEnterArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EnterAreaIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetEnterArea(int32 EnterAreaIndex, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetEnterArea");

	Params::GameDataUIMap_SetEnterArea Parms{};

	Parms.EnterAreaIndex = EnterAreaIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetEnterAreaMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       MaskData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetEnterAreaMask(class UTexture2D* MaskData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetEnterAreaMask");

	Params::GameDataUIMap_SetEnterAreaMask Parms{};

	Parms.MaskData = MaskData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetEnterFloorArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EnterFloorAreaIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetEnterFloorArea(int32 EnterFloorAreaIndex, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetEnterFloorArea");

	Params::GameDataUIMap_SetEnterFloorArea Parms{};

	Parms.EnterFloorAreaIndex = EnterFloorAreaIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetEnterFloorAreaMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       MaskData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetEnterFloorAreaMask(class UTexture2D* MaskData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetEnterFloorAreaMask");

	Params::GameDataUIMap_SetEnterFloorAreaMask Parms{};

	Parms.MaskData = MaskData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetIsFirstOpenAllMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetIsFirstOpenAllMap(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetIsFirstOpenAllMap");

	Params::GameDataUIMap_SetIsFirstOpenAllMap Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetIsFirstOpenFaskullMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetIsFirstOpenFaskullMap(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetIsFirstOpenFaskullMap");

	Params::GameDataUIMap_SetIsFirstOpenFaskullMap Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.SetZoomScaleIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameDataUIMap::SetZoomScaleIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "SetZoomScaleIndex");

	Params::GameDataUIMap_SetZoomScaleIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameDataUIMap.GetEnterAreaValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EnterAreaIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataUIMap::GetEnterAreaValue(int32 EnterAreaIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetEnterAreaValue");

	Params::GameDataUIMap_GetEnterAreaValue Parms{};

	Parms.EnterAreaIndex = EnterAreaIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.GetEnterFloorAreaValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EnterFloorAreaIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameDataUIMap::GetEnterFloorAreaValue(int32 EnterFloorAreaIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "GetEnterFloorAreaValue");

	Params::GameDataUIMap_GetEnterFloorAreaValue Parms{};

	Parms.EnterFloorAreaIndex = EnterFloorAreaIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.IsContainSignData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMapSymbolType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataUIMap::IsContainSignData(EMapSymbolType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "IsContainSignData");

	Params::GameDataUIMap_IsContainSignData Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.IsEmptyArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataUIMap::IsEmptyArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "IsEmptyArea");

	Params::GameDataUIMap_IsEmptyArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameDataUIMap.IsEmptyFloorArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameDataUIMap::IsEmptyFloorArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataUIMap", "IsEmptyFloorArea");

	Params::GameDataUIMap_IsEmptyFloorArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameFunctionLibrary.IsClassDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameFunctionLibrary::IsClassDefaultObject(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary", "IsClassDefaultObject");

	Params::GameFunctionLibrary_IsClassDefaultObject Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameFunctionLibrary.IsDebug
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameFunctionLibrary::IsDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary", "IsDebug");

	Params::GameFunctionLibrary_IsDebug Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameFunctionLibrary.IsEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameFunctionLibrary::IsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary", "IsEditor");

	Params::GameFunctionLibrary_IsEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameFunctionLibrary.IsNotPlayInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameFunctionLibrary::IsNotPlayInEditor(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary", "IsNotPlayInEditor");

	Params::GameFunctionLibrary_IsNotPlayInEditor Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameFunctionLibrary.IsPlayInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameFunctionLibrary::IsPlayInEditor(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary", "IsPlayInEditor");

	Params::GameFunctionLibrary_IsPlayInEditor Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameFunctionLibrary.IsRelease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameFunctionLibrary::IsRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary", "IsRelease");

	Params::GameFunctionLibrary_IsRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameplayEffectDataTable.GetEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayEffect> UGameplayEffectDataTable::GetEffect(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayEffectDataTable", "GetEffect");

	Params::GameplayEffectDataTable_GetEffect Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameProgress.GetEpisodeProgressMaxNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEpisodeType                            episode_type                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameProgress::GetEpisodeProgressMaxNum(EEpisodeType episode_type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "GetEpisodeProgressMaxNum");

	Params::GameProgress_GetEpisodeProgressMaxNum Parms{};

	Parms.episode_type = episode_type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameProgress.UpdateChapter
// (Final, Native, Public, BlueprintCallable)

void UGameProgress::UpdateChapter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "UpdateChapter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameProgress.UpdateEpisodeProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEpisodeType                            update_episode_type                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameProgress::UpdateEpisodeProgress(EEpisodeType update_episode_type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "UpdateEpisodeProgress");

	Params::GameProgress_UpdateEpisodeProgress Parms{};

	Parms.update_episode_type = update_episode_type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameProgress.UpdateEpisodeProgressAll
// (Final, Native, Public, BlueprintCallable)

void UGameProgress::UpdateEpisodeProgressAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "UpdateEpisodeProgressAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameProgress.GetChapterNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameProgress::GetChapterNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "GetChapterNum");

	Params::GameProgress_GetChapterNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameProgress.GetCurrentEpisodeProgressID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEpisodeType                            episode_type                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGameProgress::GetCurrentEpisodeProgressID(EEpisodeType episode_type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "GetCurrentEpisodeProgressID");

	Params::GameProgress_GetCurrentEpisodeProgressID Parms{};

	Parms.episode_type = episode_type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameProgress.GetEpisodeProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEpisodeType                            episode_type                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameProgress::GetEpisodeProgress(EEpisodeType episode_type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgress", "GetEpisodeProgress");

	Params::GameProgress_GetEpisodeProgress Parms{};

	Parms.episode_type = episode_type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameScriptDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UGameScriptDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.AddExceptNpcList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameScriptManager::AddExceptNpcList(const class FName& NpcID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "AddExceptNpcList");

	Params::GameScriptManager_AddExceptNpcList Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.ContainsExceptNpcList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameScriptManager::ContainsExceptNpcList(const class FName& NpcID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "ContainsExceptNpcList");

	Params::GameScriptManager_ContainsExceptNpcList Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameScriptManager.ExecuteGameScriptAll
// (Final, Native, Public, BlueprintCallable)

void UGameScriptManager::ExecuteGameScriptAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "ExecuteGameScriptAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.RemoveExceptNpcList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameScriptManager::RemoveExceptNpcList(const class FName& NpcID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "RemoveExceptNpcList");

	Params::GameScriptManager_RemoveExceptNpcList Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.RemoveSpawnFriendMonsterNPC
// (Final, Native, Public, BlueprintCallable)

void UGameScriptManager::RemoveSpawnFriendMonsterNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "RemoveSpawnFriendMonsterNPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.RemoveSpawnObjectAll
// (Final, Native, Public, BlueprintCallable)

void UGameScriptManager::RemoveSpawnObjectAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "RemoveSpawnObjectAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.ResetExceptNpcList
// (Final, Native, Public, BlueprintCallable)

void UGameScriptManager::ResetExceptNpcList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "ResetExceptNpcList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameScriptManager.GetAllGameScript
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AGameScriptBase*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AGameScriptBase*> UGameScriptManager::GetAllGameScript() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameScriptManager", "GetAllGameScript");

	Params::GameScriptManager_GetAllGameScript Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameSequenceFunctionLibrary.StartEventSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             event_id                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestState                             quest_state                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             fast_travel_id                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    debug_play                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    is_reopen_quest_ui                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    is_keep_hide_ui                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    is_keep_disable_input                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSequenceFunctionLibrary::StartEventSequence(const class FName& event_id, EQuestState quest_state, class FName fast_travel_id, bool debug_play, bool is_reopen_quest_ui, bool is_keep_hide_ui, bool is_keep_disable_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSequenceFunctionLibrary", "StartEventSequence");

	Params::GameSequenceFunctionLibrary_StartEventSequence Parms{};

	Parms.event_id = event_id;
	Parms.quest_state = quest_state;
	Parms.fast_travel_id = fast_travel_id;
	Parms.debug_play = debug_play;
	Parms.is_reopen_quest_ui = is_reopen_quest_ui;
	Parms.is_keep_hide_ui = is_keep_hide_ui;
	Parms.is_keep_disable_input = is_keep_disable_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSequenceFunctionLibrary.StartFastTravelSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             fast_travel_id                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFastTravelWarpCategory                 warp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFastTravelLoadingShowType              loading_show_type                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    is_arrival_event_skip                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSequenceFunctionLibrary::StartFastTravelSequence(const class FName& fast_travel_id, EFastTravelWarpCategory warp, EFastTravelLoadingShowType loading_show_type, bool is_arrival_event_skip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSequenceFunctionLibrary", "StartFastTravelSequence");

	Params::GameSequenceFunctionLibrary_StartFastTravelSequence Parms{};

	Parms.fast_travel_id = fast_travel_id;
	Parms.warp = warp;
	Parms.loading_show_type = loading_show_type;
	Parms.is_arrival_event_skip = is_arrival_event_skip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSequenceFunctionLibrary.StartNewItemGetSequence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsSkipTeamRankUpSequecne                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSequenceFunctionLibrary::StartNewItemGetSequence(bool bIsSkipTeamRankUpSequecne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSequenceFunctionLibrary", "StartNewItemGetSequence");

	Params::GameSequenceFunctionLibrary_StartNewItemGetSequence Parms{};

	Parms.bIsSkipTeamRankUpSequecne = bIsSkipTeamRankUpSequecne;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSequenceFunctionLibrary.StartOpenLevelSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             fast_travel_id                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSequenceFunctionLibrary::StartOpenLevelSequence(const class FName& fast_travel_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSequenceFunctionLibrary", "StartOpenLevelSequence");

	Params::GameSequenceFunctionLibrary_StartOpenLevelSequence Parms{};

	Parms.fast_travel_id = fast_travel_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSequenceFunctionLibrary.StartTeamRankUpSequence
// (Final, Native, Static, Public, BlueprintCallable)

void UGameSequenceFunctionLibrary::StartTeamRankUpSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSequenceFunctionLibrary", "StartTeamRankUpSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.ApplyDisplaySettings
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::ApplyDisplaySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "ApplyDisplaySettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.ApplyGraphicSettings
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::ApplyGraphicSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "ApplyGraphicSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.GetPCResolutionIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    AllowUnsetValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionResolutionIndex                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionResolutionIndex UGameSetting::GetPCResolutionIndex(bool AllowUnsetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "GetPCResolutionIndex");

	Params::GameSetting_GetPCResolutionIndex Parms{};

	Parms.AllowUnsetValue = AllowUnsetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameSetting.GetPCWindowMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionWindowMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOptionWindowMode UGameSetting::GetPCWindowMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "GetPCWindowMode");

	Params::GameSetting_GetPCWindowMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GameSetting.HandleResolutionChanges
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::HandleResolutionChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "HandleResolutionChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.Initialize
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.LoadStartupResolution
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::LoadStartupResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "LoadStartupResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.ReflectDisplaySettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataOption*                  GameDataOption                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::ReflectDisplaySettings(const class UGameDataOption* GameDataOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "ReflectDisplaySettings");

	Params::GameSetting_ReflectDisplaySettings Parms{};

	Parms.GameDataOption = GameDataOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.ReflectGraphicSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameDataOption*                  GameDataOption                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::ReflectGraphicSettings(const class UGameDataOption* GameDataOption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "ReflectGraphicSettings");

	Params::GameSetting_ReflectGraphicSettings Parms{};

	Parms.GameDataOption = GameDataOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.ReflectSavedResolution
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::ReflectSavedResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "ReflectSavedResolution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.RestoreDepthOfFieldQuality
// (Final, Native, Public, BlueprintCallable)

void UGameSetting::RestoreDepthOfFieldQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "RestoreDepthOfFieldQuality");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetAmbient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionAmbient                          InAmbientValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetAmbient(EOptionAmbient InAmbientValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetAmbient");

	Params::GameSetting_SetAmbient Parms{};

	Parms.InAmbientValue = InAmbientValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetAntialiasing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionAntialiasing                     InAntialiasing                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetAntialiasing(EOptionAntialiasing InAntialiasing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetAntialiasing");

	Params::GameSetting_SetAntialiasing Parms{};

	Parms.InAntialiasing = InAntialiasing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetBloom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionBloom                            InBloom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetBloom(EOptionBloom InBloom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetBloom");

	Params::GameSetting_SetBloom Parms{};

	Parms.InBloom = InBloom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetBrightness(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetBrightness");

	Params::GameSetting_SetBrightness Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionDensity                          InDensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetDensity(EOptionDensity InDensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetDensity");

	Params::GameSetting_SetDensity Parms{};

	Parms.InDensity = InDensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetDepthOfFieldQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetDepthOfFieldQuality(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetDepthOfFieldQuality");

	Params::GameSetting_SetDepthOfFieldQuality Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetDisplayData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionBrightness                       InBrightnessVolume                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFpsValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InVysncIsEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetDisplayData(EOptionBrightness InBrightnessVolume, float InFpsValue, bool InVysncIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetDisplayData");

	Params::GameSetting_SetDisplayData Parms{};

	Parms.InBrightnessVolume = InBrightnessVolume;
	Parms.InFpsValue = InFpsValue;
	Parms.InVysncIsEnabled = InVysncIsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetGraphicData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionAntialiasing                     InAntialiasingValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionAmbient                          InAmbientValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionShadow                           InShadowValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionGraphicsQuality                  InTextureFilterValue                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionGraphicsQuality                  InTextureDetailValue                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionDensity                          InDensityValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionLOD                              InLODValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionReflection                       InReflectionValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionBloom                            InBloomValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetGraphicData(EOptionAntialiasing InAntialiasingValue, EOptionAmbient InAmbientValue, EOptionShadow InShadowValue, EOptionGraphicsQuality InTextureFilterValue, EOptionGraphicsQuality InTextureDetailValue, EOptionDensity InDensityValue, EOptionLOD InLODValue, EOptionReflection InReflectionValue, EOptionBloom InBloomValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetGraphicData");

	Params::GameSetting_SetGraphicData Parms{};

	Parms.InAntialiasingValue = InAntialiasingValue;
	Parms.InAmbientValue = InAmbientValue;
	Parms.InShadowValue = InShadowValue;
	Parms.InTextureFilterValue = InTextureFilterValue;
	Parms.InTextureDetailValue = InTextureDetailValue;
	Parms.InDensityValue = InDensityValue;
	Parms.InLODValue = InLODValue;
	Parms.InReflectionValue = InReflectionValue;
	Parms.InBloomValue = InBloomValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionLOD                              InLOD                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetLOD(EOptionLOD InLOD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetLOD");

	Params::GameSetting_SetLOD Parms{};

	Parms.InLOD = InLOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetPCFps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetPCFps(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetPCFps");

	Params::GameSetting_SetPCFps Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetPCResolution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionResolutionIndex                  InResolutionIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetPCResolution(EOptionResolutionIndex InResolutionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetPCResolution");

	Params::GameSetting_SetPCResolution Parms{};

	Parms.InResolutionIndex = InResolutionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetPCVsync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetPCVsync(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetPCVsync");

	Params::GameSetting_SetPCVsync Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetPCWindowMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionWindowMode                       InWindowMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetPCWindowMode(EOptionWindowMode InWindowMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetPCWindowMode");

	Params::GameSetting_SetPCWindowMode Parms{};

	Parms.InWindowMode = InWindowMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetReflection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionReflection                       InReflection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetReflection(EOptionReflection InReflection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetReflection");

	Params::GameSetting_SetReflection Parms{};

	Parms.InReflection = InReflection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetRendering
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetRendering(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetRendering");

	Params::GameSetting_SetRendering Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetResolutionData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionResolutionIndex                  InResolutionIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOptionWindowMode                       InWindowMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetResolutionData(EOptionResolutionIndex InResolutionIndex, EOptionWindowMode InWindowMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetResolutionData");

	Params::GameSetting_SetResolutionData Parms{};

	Parms.InResolutionIndex = InResolutionIndex;
	Parms.InWindowMode = InWindowMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionShadow                           InShadow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetShadow(EOptionShadow InShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetShadow");

	Params::GameSetting_SetShadow Parms{};

	Parms.InShadow = InShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetTextureDetail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionGraphicsQuality                  InTextureDetail                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetTextureDetail(EOptionGraphicsQuality InTextureDetail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetTextureDetail");

	Params::GameSetting_SetTextureDetail Parms{};

	Parms.InTextureDetail = InTextureDetail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.SetTextureFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOptionGraphicsQuality                  InTextureFilter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSetting::SetTextureFilter(EOptionGraphicsQuality InTextureFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "SetTextureFilter");

	Params::GameSetting_SetTextureFilter Parms{};

	Parms.InTextureFilter = InTextureFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GameSetting.GetWindowsDesktopResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameSetting::GetWindowsDesktopResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSetting", "GetWindowsDesktopResolution");

	Params::GameSetting_GetWindowsDesktopResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GenSoundBaseComponent.OnSoundActiveRangeBeginOverlap
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGenSoundBaseComponent::OnSoundActiveRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenSoundBaseComponent", "OnSoundActiveRangeBeginOverlap");

	Params::GenSoundBaseComponent_OnSoundActiveRangeBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GenSoundBaseComponent.OnSoundActiveRangeEndOverlap
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenSoundBaseComponent::OnSoundActiveRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenSoundBaseComponent", "OnSoundActiveRangeEndOverlap");

	Params::GenSoundBaseComponent_OnSoundActiveRangeEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GiraMagicBase.StopPillarOfFier
// (Final, Native, Protected)
// Parameters:
// class AEffectBase*                      Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGiraMagicBase::StopPillarOfFier(class AEffectBase* Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GiraMagicBase", "StopPillarOfFier");

	Params::GiraMagicBase_StopPillarOfFier Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GrenadeMagicBase.OnHit
// (Final, Native, Public, BlueprintCallable)

void AGrenadeMagicBase::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrenadeMagicBase", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GrenadeSlingShotBullet.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AGrenadeSlingShotBullet::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GrenadeSlingShotBullet", "OnOverlapBegin");

	Params::GrenadeSlingShotBullet_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GroundStateLand.SetInputEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroundStateLand::SetInputEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundStateLand", "SetInputEnabled");

	Params::GroundStateLand_SetInputEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GroundStateLand.SetJumpEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroundStateLand::SetJumpEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundStateLand", "SetJumpEnabled");

	Params::GroundStateLand_SetJumpEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAbilityBase.InitWidget
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UImage*                           abilityIcon                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                       nameWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                       noteWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUICoinRankIcon*                  rankIcon                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIUpDownIcon*                    upDownIcon                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidgetAnimation*>         panelAnmAry                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIAbilityBase::InitWidget(class UImage* abilityIcon, class UTextBlock* nameWidget, class UTextBlock* noteWidget, class UUICoinRankIcon* rankIcon, class UUIUpDownIcon* upDownIcon, const TArray<class UWidgetAnimation*>& panelAnmAry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAbilityBase", "InitWidget");

	Params::UIAbilityBase_InitWidget Parms{};

	Parms.abilityIcon = abilityIcon;
	Parms.nameWidget = nameWidget;
	Parms.noteWidget = noteWidget;
	Parms.rankIcon = rankIcon;
	Parms.upDownIcon = upDownIcon;
	Parms.panelAnmAry = std::move(panelAnmAry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAbilityBase.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinFeature                  InParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUIAbilityBase::SetData(const struct FST_CoinFeature& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAbilityBase", "SetData");

	Params::UIAbilityBase_SetData Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GuestEditLibrary.K2_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   stockUid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuestEditOption                 Option                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGuestEditLibrary::K2_Add(int32 stockUid, const struct FGuestEditOption& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GuestEditLibrary", "K2_Add");

	Params::GuestEditLibrary_K2_Add Parms{};

	Parms.stockUid = stockUid;
	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.GuestEditLibrary.K2_MemberChange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           stockUids                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuestEditOption                 Option                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGuestEditLibrary::K2_MemberChange(const TArray<int32>& stockUids, const struct FGuestEditOption& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GuestEditLibrary", "K2_MemberChange");

	Params::GuestEditLibrary_K2_MemberChange Parms{};

	Parms.stockUids = std::move(stockUids);
	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.GuestEditLibrary.K2_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuestEditOption                 Option                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGuestEditLibrary::K2_Remove(int32 partyIndex, const struct FGuestEditOption& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GuestEditLibrary", "K2_Remove");

	Params::GuestEditLibrary_K2_Remove Parms{};

	Parms.partyIndex = partyIndex;
	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RectTriggerBase.OnComponentBeginOverlapForBind
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARectTriggerBase::OnComponentBeginOverlapForBind(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RectTriggerBase", "OnComponentBeginOverlapForBind");

	Params::RectTriggerBase_OnComponentBeginOverlapForBind Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RectTriggerBase.OnComponentEndOverlapForBind
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARectTriggerBase::OnComponentEndOverlapForBind(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RectTriggerBase", "OnComponentEndOverlapForBind");

	Params::RectTriggerBase_OnComponentEndOverlapForBind Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RectTriggerBase.OnEnterTrigger
// (Native, Protected)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARectTriggerBase::OnEnterTrigger(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RectTriggerBase", "OnEnterTrigger");

	Params::RectTriggerBase_OnEnterTrigger Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RectTriggerBase.OnExitTrigger
// (Native, Protected)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARectTriggerBase::OnExitTrigger(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RectTriggerBase", "OnExitTrigger");

	Params::RectTriggerBase_OnExitTrigger Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.ControlBSComp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESoundControlType                       ControlType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCompCategory                       CompCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolume                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAtomCue*                    Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::ControlBSComp(ESoundControlType ControlType, EAtomCompCategory CompCategory, float FadeTime, float FadeVolume, class USoundAtomCue* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "ControlBSComp");

	Params::SoundUtility_ControlBSComp Parms{};

	Parms.ControlType = ControlType;
	Parms.CompCategory = CompCategory;
	Parms.FadeTime = FadeTime;
	Parms.FadeVolume = FadeVolume;
	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.DebugDisplayESound
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::DebugDisplayESound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "DebugDisplayESound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.FadeByACVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAtomComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESoundFadeType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolume                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESFadeOutEndState                       FOState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::FadeByACVolume(class UAtomComponent* Component, ESoundFadeType Type, float FadeTime, float FadeVolume, ESFadeOutEndState FOState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "FadeByACVolume");

	Params::SoundUtility_FadeByACVolume Parms{};

	Parms.Component = Component;
	Parms.Type = Type;
	Parms.FadeTime = FadeTime;
	Parms.FadeVolume = FadeVolume;
	Parms.FOState = FOState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.FadeByCSGroupTableVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             GroupID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::FadeByCSGroupTableVolume(class FName GroupID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "FadeByCSGroupTableVolume");

	Params::SoundUtility_FadeByCSGroupTableVolume Parms{};

	Parms.GroupID = GroupID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.FadeByEventStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::FadeByEventStatus(class FName Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "FadeByEventStatus");

	Params::SoundUtility_FadeByEventStatus Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.GetBSComp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAtomCompCategory                       CompCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::GetBSComp(EAtomCompCategory CompCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetBSComp");

	Params::SoundUtility_GetBSComp Parms{};

	Parms.CompCategory = CompCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetCueByCueSheetTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAtomCue*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundAtomCue* USoundUtility::GetCueByCueSheetTable(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetCueByCueSheetTable");

	Params::SoundUtility_GetCueByCueSheetTable Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetESoundList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UESoundBase*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UESoundBase*> USoundUtility::GetESoundList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetESoundList");

	Params::SoundUtility_GetESoundList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetGenCreatureList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UGenSoundBaseComponent*>   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UGenSoundBaseComponent*> USoundUtility::GetGenCreatureList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetGenCreatureList");

	Params::SoundUtility_GetGenCreatureList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetGenNatureList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UGenSoundBaseComponent*>   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UGenSoundBaseComponent*> USoundUtility::GetGenNatureList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetGenNatureList");

	Params::SoundUtility_GetGenNatureList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetLoadSoundStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::GetLoadSoundStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetLoadSoundStatus");

	Params::SoundUtility_GetLoadSoundStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetParameterByTextSoundTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ETextSoundTableCategory                 Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ID                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ID_Me                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::GetParameterByTextSoundTable(ETextSoundTableCategory Category, class FName RowName, class FName* SheetName, class FString* ID, class FString* ID_Me)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetParameterByTextSoundTable");

	Params::SoundUtility_GetParameterByTextSoundTable Parms{};

	Parms.Category = Category;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SheetName != nullptr)
		*SheetName = Parms.SheetName;

	if (ID != nullptr)
		*ID = std::move(Parms.ID);

	if (ID_Me != nullptr)
		*ID_Me = std::move(Parms.ID_Me);
}


// Function DarwinGame.SoundUtility.GetSoundDataTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESoundTableCategory                     STCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* USoundUtility::GetSoundDataTable(ESoundTableCategory STCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetSoundDataTable");

	Params::SoundUtility_GetSoundDataTable Parms{};

	Parms.STCategory = STCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.GetUpdateSoundStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::GetUpdateSoundStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "GetUpdateSoundStatus");

	Params::SoundUtility_GetUpdateSoundStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsChangeBgmBossBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsChangeBgmBossBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsChangeBgmBossBattle");

	Params::SoundUtility_IsChangeBgmBossBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsEnableBgmChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsEnableBgmChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsEnableBgmChange");

	Params::SoundUtility_IsEnableBgmChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsLoadedCueSheetEnvAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsLoadedCueSheetEnvAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsLoadedCueSheetEnvAll");

	Params::SoundUtility_IsLoadedCueSheetEnvAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsPlayingBgmName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsPlayingBgmName(const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsPlayingBgmName");

	Params::SoundUtility_IsPlayingBgmName Parms{};

	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsPlayingMe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsPlayingMe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsPlayingMe");

	Params::SoundUtility_IsPlayingMe Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsStopBgmBossFinish
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsStopBgmBossFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsStopBgmBossFinish");

	Params::SoundUtility_IsStopBgmBossFinish Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.IsWaitStartBgmBaseAreaBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundUtility::IsWaitStartBgmBaseAreaBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "IsWaitStartBgmBaseAreaBattle");

	Params::SoundUtility_IsWaitStartBgmBaseAreaBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.LoadCueSheetByCueSheetTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAtomCueSheet*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundAtomCueSheet* USoundUtility::LoadCueSheetByCueSheetTable(ECueSheetTableCategory Category, class FName SheetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "LoadCueSheetByCueSheetTable");

	Params::SoundUtility_LoadCueSheetByCueSheetTable Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.LoadCueSheetEnvAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAreaType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::LoadCueSheetEnvAll(EAreaType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "LoadCueSheetEnvAll");

	Params::SoundUtility_LoadCueSheetEnvAll Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.LoadCueSheetTravellerVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsAutoTraveller                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::LoadCueSheetTravellerVoice(bool IsAutoTraveller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "LoadCueSheetTravellerVoice");

	Params::SoundUtility_LoadCueSheetTravellerVoice Parms{};

	Parms.IsAutoTraveller = IsAutoTraveller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.LoadPointEnvSound
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::LoadPointEnvSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "LoadPointEnvSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PauseBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAtomCompCategory                       Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolume                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PauseBgm(EAtomCompCategory Category, float FadeTime, float FadeVolume, float Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PauseBgm");

	Params::SoundUtility_PauseBgm Parms{};

	Parms.Category = Category;
	Parms.FadeTime = FadeTime;
	Parms.FadeVolume = FadeVolume;
	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.Play2DLoopSoundByCueName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::Play2DLoopSoundByCueName(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "Play2DLoopSoundByCueName");

	Params::SoundUtility_Play2DLoopSoundByCueName Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.Play2DSoundByCueName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::Play2DSoundByCueName(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "Play2DSoundByCueName");

	Params::SoundUtility_Play2DSoundByCueName Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.Play3DSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESoundInsulationType                    SIType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::Play3DSound(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName, class USceneComponent* Component, ESoundInsulationType SIType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "Play3DSound");

	Params::SoundUtility_Play3DSound Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);
	Parms.Component = Component;
	Parms.SIType = SIType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayBaseEnv
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::PlayBaseEnv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayBaseEnv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAtomCompCategory                       Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsForce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayBgm(EAtomCompCategory Category, const class FString& CueName, bool IsForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayBgm");

	Params::SoundUtility_PlayBgm Parms{};

	Parms.Category = Category;
	Parms.CueName = std::move(CueName);
	Parms.IsForce = IsForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayBgmByAfterBonfire
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::PlayBgmByAfterBonfire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayBgmByAfterBonfire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayBgmByBaseArea
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::PlayBgmByBaseArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayBgmByBaseArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayBoardVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTiming                            Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayBoardVoice(EVoiceTiming Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayBoardVoice");

	Params::SoundUtility_PlayBoardVoice Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayBossMonsterVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingBoss                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayBossMonsterVoice(EVoiceTimingBoss Timing, class AMonsterBase* Monster, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayBossMonsterVoice");

	Params::SoundUtility_PlayBossMonsterVoice Parms{};

	Parms.Timing = Timing;
	Parms.Monster = Monster;
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayEventSeByActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayEventSeByActor(class AActor* Actor, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayEventSeByActor");

	Params::SoundUtility_PlayEventSeByActor Parms{};

	Parms.Actor = Actor;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayEventSeByPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayEventSeByPlayer(class AActor* Actor, bool IsPlayer, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayEventSeByPlayer");

	Params::SoundUtility_PlayEventSeByPlayer Parms{};

	Parms.Actor = Actor;
	Parms.IsPlayer = IsPlayer;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayFlagPulloutSuccessSe
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::PlayFlagPulloutSuccessSe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayFlagPulloutSuccessSe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayFukidashiVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::PlayFukidashiVoice(class FName RowName, class FName NpcID, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayFukidashiVoice");

	Params::SoundUtility_PlayFukidashiVoice Parms{};

	Parms.RowName = RowName;
	Parms.NpcID = NpcID;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.PlayGuidePartVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PartVoiceID                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayGuidePartVoice(const class FString& PartVoiceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayGuidePartVoice");

	Params::SoundUtility_PlayGuidePartVoice Parms{};

	Parms.PartVoiceID = std::move(PartVoiceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayGuideVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingGuide                       Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayGuideVoice(EVoiceTimingGuide Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayGuideVoice");

	Params::SoundUtility_PlayGuideVoice Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayInstructorVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingInstructor                  Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayInstructorVoice(EVoiceTimingInstructor Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayInstructorVoice");

	Params::SoundUtility_PlayInstructorVoice Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayItemGetSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayItemGetSound(class FName ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayItemGetSound");

	Params::SoundUtility_PlayItemGetSound Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayMe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayMe(const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayMe");

	Params::SoundUtility_PlayMe Parms{};

	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayMeByLevelUp
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::PlayMeByLevelUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayMeByLevelUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayMonsterVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTiming                            Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayMonsterVoice(EVoiceTiming Timing, class AMonsterBase* Monster, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayMonsterVoice");

	Params::SoundUtility_PlayMonsterVoice Parms{};

	Parms.Timing = Timing;
	Parms.Monster = Monster;
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayNPCVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PartVoiceID                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::PlayNPCVoice(const class FString& PartVoiceID, class FName NpcID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayNPCVoice");

	Params::SoundUtility_PlayNPCVoice Parms{};

	Parms.PartVoiceID = std::move(PartVoiceID);
	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.PlayNPCVoiceCallPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::PlayNPCVoiceCallPC(class FName NpcID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayNPCVoiceCallPC");

	Params::SoundUtility_PlayNPCVoiceCallPC Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.PlayObjectSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EObjectSoundCategory                    Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::PlayObjectSound(EObjectSoundCategory Category, class FName RowName, class USceneComponent* AttachComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayObjectSound");

	Params::SoundUtility_PlayObjectSound Parms{};

	Parms.Category = Category;
	Parms.RowName = RowName;
	Parms.AttachComp = AttachComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.PlayPCPartVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PartVoiceID                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayPCPartVoice(const class FString& PartVoiceID, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayPCPartVoice");

	Params::SoundUtility_PlayPCPartVoice Parms{};

	Parms.PartVoiceID = std::move(PartVoiceID);
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayPCPartVoiceReverse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           PartVoiceID                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayPCPartVoiceReverse(const class FString& PartVoiceID, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayPCPartVoiceReverse");

	Params::SoundUtility_PlayPCPartVoiceReverse Parms{};

	Parms.PartVoiceID = std::move(PartVoiceID);
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayPCVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingPC                          Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayPCVoice(EVoiceTimingPC Timing, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayPCVoice");

	Params::SoundUtility_PlayPCVoice Parms{};

	Parms.Timing = Timing;
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayPCVoiceReverse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingPC                          Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayPCVoiceReverse(EVoiceTimingPC Timing, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayPCVoiceReverse");

	Params::SoundUtility_PlayPCVoiceReverse Parms{};

	Parms.Timing = Timing;
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayPCVoiceSpecify
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsP000                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoiceTimingPC                          Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Is3DPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayPCVoiceSpecify(bool IsP000, EVoiceTimingPC Timing, bool Is3DPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayPCVoiceSpecify");

	Params::SoundUtility_PlayPCVoiceSpecify Parms{};

	Parms.IsP000 = IsP000;
	Parms.Timing = Timing;
	Parms.Is3DPosition = Is3DPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayReceptionVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingReception                   Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayReceptionVoice(EVoiceTimingReception Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayReceptionVoice");

	Params::SoundUtility_PlayReceptionVoice Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayStationStaffVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EVoiceTimingStationStaff                Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayStationStaffVoice(EVoiceTimingStationStaff Timing, class FName NpcID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayStationStaffVoice");

	Params::SoundUtility_PlayStationStaffVoice Parms{};

	Parms.Timing = Timing;
	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayTableSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SoundID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESoundInsulationType                    SIType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayTableSound(class UDataTable* Table, class FName SoundID, ESoundInsulationType SIType, class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayTableSound");

	Params::SoundUtility_PlayTableSound Parms{};

	Parms.Table = Table;
	Parms.SoundID = SoundID;
	Parms.SIType = SIType;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.PlayTravellerVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NickNameID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoiceDataType                          VoiceType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELanguageVoiceType                      LanguageType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::PlayTravellerVoice(int32 KindId, class FName NickNameID, EVoiceDataType VoiceType, ELanguageVoiceType LanguageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "PlayTravellerVoice");

	Params::SoundUtility_PlayTravellerVoice Parms{};

	Parms.KindId = KindId;
	Parms.NickNameID = NickNameID;
	Parms.VoiceType = VoiceType;
	Parms.LanguageType = LanguageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.ReleaseCueSheetByCueSheetTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::ReleaseCueSheetByCueSheetTable(ECueSheetTableCategory Category, class FName SheetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "ReleaseCueSheetByCueSheetTable");

	Params::SoundUtility_ReleaseCueSheetByCueSheetTable Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.ReleaseCueSheetEnvAll
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::ReleaseCueSheetEnvAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "ReleaseCueSheetEnvAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.ReleaseCueSheetTravellerVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    IsAutoTraveller                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::ReleaseCueSheetTravellerVoice(bool IsAutoTraveller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "ReleaseCueSheetTravellerVoice");

	Params::SoundUtility_ReleaseCueSheetTravellerVoice Parms{};

	Parms.IsAutoTraveller = IsAutoTraveller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.ReleasePointEnvSound
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::ReleasePointEnvSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "ReleasePointEnvSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.ResumeBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAtomCompCategory                       Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolume                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::ResumeBgm(EAtomCompCategory Category, float FadeTime, float FadeVolume, float Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "ResumeBgm");

	Params::SoundUtility_ResumeBgm Parms{};

	Parms.Category = Category;
	Parms.FadeTime = FadeTime;
	Parms.FadeVolume = FadeVolume;
	Parms.Timer = Timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetChangeBgmBossBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetChangeBgmBossBattle(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetChangeBgmBossBattle");

	Params::SoundUtility_SetChangeBgmBossBattle Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetEventExceptionSoundControl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetEventExceptionSoundControl(bool isEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetEventExceptionSoundControl");

	Params::SoundUtility_SetEventExceptionSoundControl Parms{};

	Parms.isEnable = isEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetIsPlayMeBaseAreaBattleNotify
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetIsPlayMeBaseAreaBattleNotify(bool isEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetIsPlayMeBaseAreaBattleNotify");

	Params::SoundUtility_SetIsPlayMeBaseAreaBattleNotify Parms{};

	Parms.isEnable = isEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetMeAfterResumeBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetMeAfterResumeBgm(bool isEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetMeAfterResumeBgm");

	Params::SoundUtility_SetMeAfterResumeBgm Parms{};

	Parms.isEnable = isEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetSEVSoundStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESoundTriggerTiming                     Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetSEVSoundStatus(ESoundTriggerTiming Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetSEVSoundStatus");

	Params::SoundUtility_SetSEVSoundStatus Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetStopBgmBossFinish
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetStopBgmBossFinish(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetStopBgmBossFinish");

	Params::SoundUtility_SetStopBgmBossFinish Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetUpdateAreaBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetUpdateAreaBgm(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetUpdateAreaBgm");

	Params::SoundUtility_SetUpdateAreaBgm Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetUpdateAreaBgmNight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetUpdateAreaBgmNight(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetUpdateAreaBgmNight");

	Params::SoundUtility_SetUpdateAreaBgmNight Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetUpdateSoundStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetUpdateSoundStatus(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetUpdateSoundStatus");

	Params::SoundUtility_SetUpdateSoundStatus Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetVolcanoBattleBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetVolcanoBattleBgm(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetVolcanoBattleBgm");

	Params::SoundUtility_SetVolcanoBattleBgm Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.SetWaitStartBgmBaseAreaBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::SetWaitStartBgmBaseAreaBattle(bool bIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "SetWaitStartBgmBaseAreaBattle");

	Params::SoundUtility_SetWaitStartBgmBaseAreaBattle Parms{};

	Parms.bIsEnable = bIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.Spawn2DSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::Spawn2DSound(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "Spawn2DSound");

	Params::SoundUtility_Spawn2DSound Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.Spawn2DSoundCalcReverb
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECueSheetTableCategory                  Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SheetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomComponent* USoundUtility::Spawn2DSoundCalcReverb(ECueSheetTableCategory Category, class FName SheetName, const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "Spawn2DSoundCalcReverb");

	Params::SoundUtility_Spawn2DSoundCalcReverb Parms{};

	Parms.Category = Category;
	Parms.SheetName = SheetName;
	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SoundUtility.Stop2DLoopSoundByCueName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CueName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::Stop2DLoopSoundByCueName(const class FString& CueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "Stop2DLoopSoundByCueName");

	Params::SoundUtility_Stop2DLoopSoundByCueName Parms{};

	Parms.CueName = std::move(CueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.StopBaseEnv
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::StopBaseEnv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "StopBaseEnv");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.StopBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAtomCompCategory                       Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSpecify                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::StopBgm(EAtomCompCategory Category, float FadeTime, bool IsSpecify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "StopBgm");

	Params::SoundUtility_StopBgm Parms{};

	Parms.Category = Category;
	Parms.FadeTime = FadeTime;
	Parms.IsSpecify = IsSpecify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.StopBgmAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundUtility::StopBgmAll(float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "StopBgmAll");

	Params::SoundUtility_StopBgmAll Parms{};

	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SoundUtility.StopEventCategorySound
// (Final, Native, Static, Public, BlueprintCallable)

void USoundUtility::StopEventCategorySound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundUtility", "StopEventCategorySound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.IcicleMagicBase.OnHit
// (Final, Native, Public, BlueprintCallable)

void AIcicleMagicBase::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IcicleMagicBase", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.InitialPositionDoor.ReceiveSetClose
// (Event, Protected, BlueprintEvent)

void AInitialPositionDoor::ReceiveSetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InitialPositionDoor", "ReceiveSetClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.InitialPositionDoor.ReceiveSetOpen
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInitialPositionDoor::ReceiveSetOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InitialPositionDoor", "ReceiveSetOpen");

	Params::InitialPositionDoor_ReceiveSetOpen Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.InitialPositionDoor.SetClose
// (Final, Native, Public, BlueprintCallable)

void AInitialPositionDoor::SetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InitialPositionDoor", "SetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.InitialPositionDoor.SetOpen
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInitialPositionDoor::SetOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InitialPositionDoor", "SetOpen");

	Params::InitialPositionDoor_SetOpen Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAreaNameDisplayer.InAreaExec
// (Final, Native, Static, Public, BlueprintCallable)

void UUIAreaNameDisplayer::InAreaExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIAreaNameDisplayer", "InAreaExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAreaNameDisplayer.OutAreaExec
// (Final, Native, Static, Public, BlueprintCallable)

void UUIAreaNameDisplayer::OutAreaExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIAreaNameDisplayer", "OutAreaExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ItemDataTable.ConvertItemID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ItemId                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemDataTable::ConvertItemID(int32 Index_0, class FString* ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemDataTable", "ConvertItemID");

	Params::ItemDataTable_ConvertItemID Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemId != nullptr)
		*ItemId = std::move(Parms.ItemId);
}


// Function DarwinGame.ItemDataTable.GetItemInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_ItemInfoData                 itemInfo                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemDataTable::GetItemInfo(const class FName& ItemId, struct FST_ItemInfoData* itemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemDataTable", "GetItemInfo");

	Params::ItemDataTable_GetItemInfo Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (itemInfo != nullptr)
		*itemInfo = std::move(Parms.itemInfo);
}


// Function DarwinGame.ItemDataTable.GetItemKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UItemDataTable::GetItemKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemDataTable", "GetItemKeys");

	Params::ItemDataTable_GetItemKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ItemDataTable.GetItemKeysOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EItemDataType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FName> UItemDataTable::GetItemKeysOf(EItemDataType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemDataTable", "GetItemKeysOf");

	Params::ItemDataTable_GetItemKeysOf Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ItemDataTable.GetItemName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             itemNameString                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UItemDataTable::GetItemName(const class FName& ItemId, class FText* itemNameString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemDataTable", "GetItemName");

	Params::ItemDataTable_GetItemName Parms{};

	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (itemNameString != nullptr)
		*itemNameString = std::move(Parms.itemNameString);
}


// Function DarwinGame.ItemInterface.Aim
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HandLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IItemInterface::Aim(const struct FVector& HandLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInterface", "Aim");

	Params::ItemInterface_Aim Parms{};

	Parms.HandLocation = std::move(HandLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ItemInterface.Hold
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IItemInterface::Hold(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInterface", "Hold");

	Params::ItemInterface_Hold Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ItemInterface.SetVisible
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IItemInterface::SetVisible(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInterface", "SetVisible");

	Params::ItemInterface_SetVisible Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ItemInterface.Use
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IItemInterface::Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInterface", "Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.KeyInputFunctionLibrary.GetAfterSecond
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKeyInputFunctionLibrary::GetAfterSecond(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "GetAfterSecond");

	Params::KeyInputFunctionLibrary_GetAfterSecond Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.GetInputType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputType UKeyInputFunctionLibrary::GetInputType(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "GetInputType");

	Params::KeyInputFunctionLibrary_GetInputType Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.GetValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKeyInputFunctionLibrary::GetValue(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "GetValue");

	Params::KeyInputFunctionLibrary_GetValue Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.IsJustPressed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeyInputFunctionLibrary::IsJustPressed(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "IsJustPressed");

	Params::KeyInputFunctionLibrary_IsJustPressed Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.IsJustReleased
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeyInputFunctionLibrary::IsJustReleased(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "IsJustReleased");

	Params::KeyInputFunctionLibrary_IsJustReleased Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.IsPressed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeyInputFunctionLibrary::IsPressed(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "IsPressed");

	Params::KeyInputFunctionLibrary_IsPressed Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.IsRepeatPressed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKeyInputFunctionLibrary::IsRepeatPressed(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "IsRepeatPressed");

	Params::KeyInputFunctionLibrary_IsRepeatPressed Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.Reset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKeyInput                        KeyInput                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EAxisMappingType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKeyInput                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKeyInput UKeyInputFunctionLibrary::Reset(const struct FKeyInput& KeyInput, EAxisMappingType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "Reset");

	Params::KeyInputFunctionLibrary_Reset Parms{};

	Parms.KeyInput = std::move(KeyInput);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KeyInputFunctionLibrary.ResetAll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyInput                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKeyInput UKeyInputFunctionLibrary::ResetAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KeyInputFunctionLibrary", "ResetAll");

	Params::KeyInputFunctionLibrary_ResetAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetActionCycleEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKindDataTable::GetActionCycleEnemy(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetActionCycleEnemy");

	Params::KindDataTable_GetActionCycleEnemy Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetActionCycleFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKindDataTable::GetActionCycleFriend(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetActionCycleFriend");

	Params::KindDataTable_GetActionCycleFriend Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetArtifactCarryingCapacity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetArtifactCarryingCapacity(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetArtifactCarryingCapacity");

	Params::KindDataTable_GetArtifactCarryingCapacity Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetArtifactDropOffRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetArtifactDropOffRate(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetArtifactDropOffRate");

	Params::KindDataTable_GetArtifactDropOffRate Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetAttackAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetAttackAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetAttackAccordingToLevel");

	Params::KindDataTable_GetAttackAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetBattleArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetBattleArea(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetBattleArea");

	Params::KindDataTable_GetBattleArea Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetCoreHearing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetCoreHearing(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetCoreHearing");

	Params::KindDataTable_GetCoreHearing Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetCustomPartsLotteryRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomPartsLotteryRate          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCustomPartsLotteryRate UKindDataTable::GetCustomPartsLotteryRate(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetCustomPartsLotteryRate");

	Params::KindDataTable_GetCustomPartsLotteryRate Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetDefenceAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetDefenceAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetDefenceAccordingToLevel");

	Params::KindDataTable_GetDefenceAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetDexterityAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetDexterityAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetDexterityAccordingToLevel");

	Params::KindDataTable_GetDexterityAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetDropItemInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_DropItemInfo>         DropItemInfos                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKindDataTable::GetDropItemInfo(class FName KindId, TArray<struct FST_DropItemInfo>* DropItemInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetDropItemInfo");

	Params::KindDataTable_GetDropItemInfo Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DropItemInfos != nullptr)
		*DropItemInfos = std::move(Parms.DropItemInfos);
}


// Function DarwinGame.KindDataTable.GetEcologicalArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetEcologicalArea(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetEcologicalArea");

	Params::KindDataTable_GetEcologicalArea Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetEffectSizeID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEffectSizeID                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEffectSizeID UKindDataTable::GetEffectSizeID(class FName KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetEffectSizeID");

	Params::KindDataTable_GetEffectSizeID Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetEscapeCountMax
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetEscapeCountMax(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetEscapeCountMax");

	Params::KindDataTable_GetEscapeCountMax Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetEscapeProbability
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetEscapeProbability(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetEscapeProbability");

	Params::KindDataTable_GetEscapeProbability Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetExpGrowthType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetExpGrowthType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetExpGrowthType");

	Params::KindDataTable_GetExpGrowthType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetFeatureInfos
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_CharacterFeatureInfo> FeatureInfos                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKindDataTable::GetFeatureInfos(class FName ID, TArray<struct FST_CharacterFeatureInfo>* FeatureInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetFeatureInfos");

	Params::KindDataTable_GetFeatureInfos Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FeatureInfos != nullptr)
		*FeatureInfos = std::move(Parms.FeatureInfos);
}


// Function DarwinGame.KindDataTable.GetFormationSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetFormationSize(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetFormationSize");

	Params::KindDataTable_GetFormationSize Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetGazeTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKindDataTable::GetGazeTime(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetGazeTime");

	Params::KindDataTable_GetGazeTime Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetHPAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetHPAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetHPAccordingToLevel");

	Params::KindDataTable_GetHPAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetIsFlyType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKindDataTable::GetIsFlyType(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetIsFlyType");

	Params::KindDataTable_GetIsFlyType Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetLineageCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELineageCategory                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELineageCategory UKindDataTable::GetLineageCategory(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetLineageCategory");

	Params::KindDataTable_GetLineageCategory Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetLinkData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_LinkData                     LinkData                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UKindDataTable::GetLinkData(class FName KindId, ELinkType Type, struct FST_LinkData* LinkData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetLinkData");

	Params::KindDataTable_GetLinkData Parms{};

	Parms.KindId = KindId;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LinkData != nullptr)
		*LinkData = std::move(Parms.LinkData);
}


// Function DarwinGame.KindDataTable.GetMagicAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetMagicAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetMagicAccordingToLevel");

	Params::KindDataTable_GetMagicAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetMonsterSenseLotteryWeightByArrayIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ArrayIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetMonsterSenseLotteryWeightByArrayIndex(class FName ID, int32 ArrayIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetMonsterSenseLotteryWeightByArrayIndex");

	Params::KindDataTable_GetMonsterSenseLotteryWeightByArrayIndex Parms{};

	Parms.ID = ID;
	Parms.ArrayIndex = ArrayIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetMonsterSenseTotalWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetMonsterSenseTotalWeight(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetMonsterSenseTotalWeight");

	Params::KindDataTable_GetMonsterSenseTotalWeight Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetMPAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetMPAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetMPAccordingToLevel");

	Params::KindDataTable_GetMPAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetNightSight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetNightSight(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetNightSight");

	Params::KindDataTable_GetNightSight Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetNormalHearing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetNormalHearing(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetNormalHearing");

	Params::KindDataTable_GetNormalHearing Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetNormalSight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetNormalSight(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetNormalSight");

	Params::KindDataTable_GetNormalSight Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetOriginKindID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKindDataTable::GetOriginKindID(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetOriginKindID");

	Params::KindDataTable_GetOriginKindID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetResistCalcType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EResistanceType                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetResistCalcType(class FName ID, EResistanceType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetResistCalcType");

	Params::KindDataTable_GetResistCalcType Parms{};

	Parms.ID = ID;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetStatusAccordingToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_Status                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_Status UKindDataTable::GetStatusAccordingToLevel(class FName ID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetStatusAccordingToLevel");

	Params::KindDataTable_GetStatusAccordingToLevel Parms{};

	Parms.ID = ID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetSurprisePopRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKindDataTable::GetSurprisePopRange(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetSurprisePopRange");

	Params::KindDataTable_GetSurprisePopRange Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.GetTribalName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKindDataTable::GetTribalName(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "GetTribalName");

	Params::KindDataTable_GetTribalName Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.HasSuperArmor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKindDataTable::HasSuperArmor(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "HasSuperArmor");

	Params::KindDataTable_HasSuperArmor Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.KindDataTable.IsResistToBlown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKindDataTable::IsResistToBlown(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KindDataTable", "IsResistToBlown");

	Params::KindDataTable_IsResistToBlown Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LevelManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULevelManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelManager* ULevelManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelManager", "GetInstance");

	Params::LevelManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LevelManager.LoadPersistent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             level_path                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelManager::LoadPersistent(const class FName level_path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "LoadPersistent");

	Params::LevelManager_LoadPersistent Parms{};

	Parms.level_path = level_path;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LevelManager.SetAmbientVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelManager::SetAmbientVisible(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "SetAmbientVisible");

	Params::LevelManager_SetAmbientVisible Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LevelManager.IsFinishLoadLevelOnPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    is_narrow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelManager::IsFinishLoadLevelOnPlayer(bool is_narrow) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "IsFinishLoadLevelOnPlayer");

	Params::LevelManager_IsFinishLoadLevelOnPlayer Parms{};

	Parms.is_narrow = is_narrow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LevelManager.IsFinishLoadLevelOnPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelManager::IsFinishLoadLevelOnPosition(const struct FVector& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "IsFinishLoadLevelOnPosition");

	Params::LevelManager_IsFinishLoadLevelOnPosition Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LevelManager.IsFinishLoadPersistent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelManager::IsFinishLoadPersistent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "IsFinishLoadPersistent");

	Params::LevelManager_IsFinishLoadPersistent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LevelManager.IsFinishVisibleLevelOnPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    is_narrow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelManager::IsFinishVisibleLevelOnPlayer(bool is_narrow) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "IsFinishVisibleLevelOnPlayer");

	Params::LevelManager_IsFinishVisibleLevelOnPlayer Parms{};

	Parms.is_narrow = is_narrow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LevelManager.IsFinishVisibleLevelOnPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelManager::IsFinishVisibleLevelOnPosition(const struct FVector& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelManager", "IsFinishVisibleLevelOnPosition");

	Params::LevelManager_IsFinishVisibleLevelOnPosition Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LiftDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void ULiftDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiftDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LightningStrikeMagicBase.OnHit
// (Final, Native, Public, BlueprintCallable)

void ALightningStrikeMagicBase::OnHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightningStrikeMagicBase", "OnHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCCSLookTargetActor.Init
// (Final, Native, Public, BlueprintCallable)

void ANPCCSLookTargetActor::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCCSLookTargetActor", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULinkSystemComponent::Close(ELinkType Type, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "Close");

	Params::LinkSystemComponent_Close Parms{};

	Parms.Type = Type;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.ExecuteLinkAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULinkSystemComponent::ExecuteLinkAction(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "ExecuteLinkAction");

	Params::LinkSystemComponent_ExecuteLinkAction Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.IsMenuOpend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULinkSystemComponent::IsMenuOpend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "IsMenuOpend");

	Params::LinkSystemComponent_IsMenuOpend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LinkSystemComponent.LinkCancel
// (Final, Native, Public, BlueprintCallable)

void ULinkSystemComponent::LinkCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "LinkCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.OnUseAnimationEnd
// (Final, Native, Private)

void ULinkSystemComponent::OnUseAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "OnUseAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.open
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULinkSystemComponent::open(ELinkType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "open");

	Params::LinkSystemComponent_open Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.StartGlideElapsedTimer
// (Final, Native, Private)

void ULinkSystemComponent::StartGlideElapsedTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "StartGlideElapsedTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.StartReacstTimer
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    LinkTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULinkSystemComponent::StartReacstTimer(class AGPACharacter* LinkTarget, ELinkType Type, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "StartReacstTimer");

	Params::LinkSystemComponent_StartReacstTimer Parms{};

	Parms.LinkTarget = LinkTarget;
	Parms.Type = Type;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.LinkSystemComponent.GetLinkWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIField_IconLink*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_IconLink* ULinkSystemComponent::GetLinkWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LinkSystemComponent", "GetLinkWidget");

	Params::LinkSystemComponent_GetLinkWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LinkSystemLibrary.GetHighJumpHeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULinkSystemLibrary::GetHighJumpHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LinkSystemLibrary", "GetHighJumpHeight");

	Params::LinkSystemLibrary_GetHighJumpHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LocTextUtility.AddNoBreakSpace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           srcStr                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpaceInsertLocale                      spaceInsertlocale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULocTextUtility::AddNoBreakSpace(const class FString& srcStr, ESpaceInsertLocale spaceInsertlocale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocTextUtility", "AddNoBreakSpace");

	Params::LocTextUtility_AddNoBreakSpace Parms{};

	Parms.srcStr = std::move(srcStr);
	Parms.spaceInsertlocale = spaceInsertlocale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LocTextUtility.AlignNewLines
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DisplayText                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UComputeTextBlock*                TextBlock                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULocTextUtility::AlignNewLines(const class FString& DisplayText, class UComputeTextBlock* TextBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocTextUtility", "AlignNewLines");

	Params::LocTextUtility_AlignNewLines Parms{};

	Parms.DisplayText = std::move(DisplayText);
	Parms.TextBlock = TextBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LocTextUtility.IsCurrenLanguageJapanese
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocTextUtility::IsCurrenLanguageJapanese()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocTextUtility", "IsCurrenLanguageJapanese");

	Params::LocTextUtility_IsCurrenLanguageJapanese Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LocTextUtility.IsCurrenLanguageKorean
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocTextUtility::IsCurrenLanguageKorean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocTextUtility", "IsCurrenLanguageKorean");

	Params::LocTextUtility_IsCurrenLanguageKorean Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LocTextUtility.IsCurrenLanguageZhHant
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocTextUtility::IsCurrenLanguageZhHant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocTextUtility", "IsCurrenLanguageZhHant");

	Params::LocTextUtility_IsCurrenLanguageZhHant Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.LocTextUtility.IsCurrentLanguageZhHans
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocTextUtility::IsCurrentLanguageZhHans()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocTextUtility", "IsCurrentLanguageZhHans");

	Params::LocTextUtility_IsCurrentLanguageZhHans Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RectangleAreaOfEffect.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARectangleAreaOfEffect::SetSize(const struct FVector2D& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RectangleAreaOfEffect", "SetSize");

	Params::RectangleAreaOfEffect_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.M026.SetHideBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AM026::SetHideBone(class FName BoneName, bool hide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("M026", "SetHideBone");

	Params::M026_SetHideBone Parms{};

	Parms.BoneName = BoneName;
	Parms.hide = hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.AddIgnoreActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::AddIgnoreActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "AddIgnoreActor");

	Params::MonsterBoss_AddIgnoreActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.AddIgnoreActorInRush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::AddIgnoreActorInRush(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "AddIgnoreActorInRush");

	Params::MonsterBoss_AddIgnoreActorInRush Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.BehaviorDecision
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::BehaviorDecision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "BehaviorDecision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.BindOnTargetPerceptionUpdated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AMonsterBoss::BindOnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "BindOnTargetPerceptionUpdated");

	Params::MonsterBoss_BindOnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.BoostTick
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::BoostTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "BoostTick");

	Params::MonsterBoss_BoostTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.BossBoostingCheckBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMonsterBoss::BossBoostingCheckBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "BossBoostingCheckBegin");

	Params::MonsterBoss_BossBoostingCheckBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.BossRotateInsightTargetBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMonsterBoss::BossRotateInsightTargetBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "BossRotateInsightTargetBegin");

	Params::MonsterBoss_BossRotateInsightTargetBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.CheckWeaknesses
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::CheckWeaknesses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "CheckWeaknesses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.ClearBossFainting
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::ClearBossFainting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "ClearBossFainting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.ClearFrontHit
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::ClearFrontHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "ClearFrontHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.FinishQte
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::FinishQte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "FinishQte");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.GetBattleAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMonsterBossBattleAI*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterBossBattleAI* AMonsterBoss::GetBattleAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBattleAI");

	Params::MonsterBoss_GetBattleAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBodyRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBoss::GetBodyRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBodyRange");

	Params::MonsterBoss_GetBodyRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossObjectSightType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBossSightType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossSightType AMonsterBoss::GetBossObjectSightType(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossObjectSightType");

	Params::MonsterBoss_GetBossObjectSightType Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossSightType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBossSightType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossSightType AMonsterBoss::GetBossSightType(class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossSightType");

	Params::MonsterBoss_GetBossSightType Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetGimmickActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AMonsterBoss::GetGimmickActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetGimmickActor");

	Params::MonsterBoss_GetGimmickActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetSummonID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMonsterBoss::GetSummonID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetSummonID");

	Params::MonsterBoss_GetSummonID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.HitCheckCircleImpactFront
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBossSightType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossSightType AMonsterBoss::HitCheckCircleImpactFront(const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "HitCheckCircleImpactFront");

	Params::MonsterBoss_HitCheckCircleImpactFront Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.HitCheckCircleImpactFrontAng
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBoss::HitCheckCircleImpactFrontAng(const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "HitCheckCircleImpactFrontAng");

	Params::MonsterBoss_HitCheckCircleImpactFrontAng Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.HitCheckSphereImpactFront
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBossSightType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossSightType AMonsterBoss::HitCheckSphereImpactFront(const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "HitCheckSphereImpactFront");

	Params::MonsterBoss_HitCheckSphereImpactFront Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IncBossGimmick
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::IncBossGimmick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IncBossGimmick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.IncBossGimmickBreak
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::IncBossGimmickBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IncBossGimmickBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.IncContCnt
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::IncContCnt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IncContCnt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.InitBattleTimer
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::InitBattleTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "InitBattleTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.IsMaxSummon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsMaxSummon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsMaxSummon");

	Params::MonsterBoss_IsMaxSummon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsNoneSummon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsNoneSummon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsNoneSummon");

	Params::MonsterBoss_IsNoneSummon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsOnBarrier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsOnBarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsOnBarrier");

	Params::MonsterBoss_IsOnBarrier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.OnChangedRedEyeStep
// (Event, Public, BlueprintEvent)

void AMonsterBoss::OnChangedRedEyeStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "OnChangedRedEyeStep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.MonsterBoss.PushBackAvoidBody
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::PushBackAvoidBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "PushBackAvoidBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.PushBackBarrier
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::PushBackBarrier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "PushBackBarrier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.PushBackCircleImpactFront
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::PushBackCircleImpactFront(const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "PushBackCircleImpactFront");

	Params::MonsterBoss_PushBackCircleImpactFront Parms{};

	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.RemoveAttackLocationUser
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::RemoveAttackLocationUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "RemoveAttackLocationUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.RequestQte
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::RequestQte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "RequestQte");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SequenceRollBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Back                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SequenceRollBack(int32 Back)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SequenceRollBack");

	Params::MonsterBoss_SequenceRollBack Parms{};

	Parms.Back = Back;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetAttackCont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetAttackCont(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetAttackCont");

	Params::MonsterBoss_SetAttackCont Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBarrier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBarrier(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBarrier");

	Params::MonsterBoss_SetBarrier Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBarrierAppend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossBarrierAppend               step                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBarrierAppend(EMonsterBossBarrierAppend step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBarrierAppend");

	Params::MonsterBoss_SetBarrierAppend Parms{};

	Parms.step = step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBarrierStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossBarrierStep                 step                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBarrierStep(EMonsterBossBarrierStep step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBarrierStep");

	Params::MonsterBoss_SetBarrierStep Parms{};

	Parms.step = step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossBarrierBreak
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::SetBossBarrierBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossBarrierBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossBoostingCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_BossBoostingCheck            fst                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossBoostingCheck(const struct FST_BossBoostingCheck& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossBoostingCheck");

	Params::MonsterBoss_SetBossBoostingCheck Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossFainting
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::SetBossFainting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossFainting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossForceChargeBreak
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::SetBossForceChargeBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossForceChargeBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossGimmickBreak
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossGimmickBreak(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossGimmickBreak");

	Params::MonsterBoss_SetBossGimmickBreak Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossHidden(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossHidden");

	Params::MonsterBoss_SetBossHidden Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossPhase                       phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossPhase(EMonsterBossPhase phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossPhase");

	Params::MonsterBoss_SetBossPhase Parms{};

	Parms.phase = phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossRotateInsightTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_BossRotateInsightTarget      cnt                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossRotateInsightTarget(const struct FST_BossRotateInsightTarget& cnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossRotateInsightTarget");

	Params::MonsterBoss_SetBossRotateInsightTarget Parms{};

	Parms.cnt = std::move(cnt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossSerialPeriod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Period                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossSerialPeriod(int32 Period)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossSerialPeriod");

	Params::MonsterBoss_SetBossSerialPeriod Parms{};

	Parms.Period = Period;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossTargetInRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_BossTargetInRange            cnt                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossTargetInRange(const struct FST_BossTargetInRange& cnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossTargetInRange");

	Params::MonsterBoss_SetBossTargetInRange Parms{};

	Parms.cnt = std::move(cnt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetBossType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetBossType(EMonsterBossType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetBossType");

	Params::MonsterBoss_SetBossType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCamEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCamEnd(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCamEnd");

	Params::MonsterBoss_SetCamEnd Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCameraControll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossCameraControllType          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCameraControll(EMonsterBossCameraControllType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCameraControll");

	Params::MonsterBoss_SetCameraControll Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCameraType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossCameraType                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCameraType(EMonsterBossCameraType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCameraType");

	Params::MonsterBoss_SetCameraType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCollisionRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sensor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   impact                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   barrier                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCollisionRadius(float sensor, float impact, float barrier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCollisionRadius");

	Params::MonsterBoss_SetCollisionRadius Parms{};

	Parms.sensor = sensor;
	Parms.impact = impact;
	Parms.barrier = barrier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCollisonLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          sensorleft                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          sensorright                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          impact                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          sensorleft2                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          sensorright2                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          impact2                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          barrier                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCollisonLocation(const struct FVector& sensorleft, const struct FVector& sensorright, const struct FVector& impact, const struct FVector& sensorleft2, const struct FVector& sensorright2, const struct FVector& impact2, const struct FVector& barrier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCollisonLocation");

	Params::MonsterBoss_SetCollisonLocation Parms{};

	Parms.sensorleft = std::move(sensorleft);
	Parms.sensorright = std::move(sensorright);
	Parms.impact = std::move(impact);
	Parms.sensorleft2 = std::move(sensorleft2);
	Parms.sensorright2 = std::move(sensorright2);
	Parms.impact2 = std::move(impact2);
	Parms.barrier = std::move(barrier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCombatDuring
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossCombatDuring                during                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCombatDuring(EMonsterBossCombatDuring during)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCombatDuring");

	Params::MonsterBoss_SetCombatDuring Parms{};

	Parms.during = during;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetContCnt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   cnt                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetContCnt(int32 cnt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetContCnt");

	Params::MonsterBoss_SetContCnt Parms{};

	Parms.cnt = cnt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCursedStatue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           statue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCursedStatue(class AActor* statue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCursedStatue");

	Params::MonsterBoss_SetCursedStatue Parms{};

	Parms.statue = statue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetCursedStatueLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    exitui                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetCursedStatueLocation(const struct FVector& Location, bool exitui)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetCursedStatueLocation");

	Params::MonsterBoss_SetCursedStatueLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.exitui = exitui;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetEndQuickSand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetEndQuickSand(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetEndQuickSand");

	Params::MonsterBoss_SetEndQuickSand Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetFirstWaitPos
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          vec                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetFirstWaitPos(const struct FVector& vec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetFirstWaitPos");

	Params::MonsterBoss_SetFirstWaitPos Parms{};

	Parms.vec = std::move(vec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetGimmickActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetGimmickActor(class AActor* Actor, const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetGimmickActor");

	Params::MonsterBoss_SetGimmickActor Parms{};

	Parms.Actor = Actor;
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetGimmickFixedPos
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  fixedpos                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetGimmickFixedPos(const TArray<struct FVector>& fixedpos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetGimmickFixedPos");

	Params::MonsterBoss_SetGimmickFixedPos Parms{};

	Parms.fixedpos = std::move(fixedpos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetHitWeaknesses
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetHitWeaknesses(const bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetHitWeaknesses");

	Params::MonsterBoss_SetHitWeaknesses Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetIsInVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetIsInVisible(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetIsInVisible");

	Params::MonsterBoss_SetIsInVisible Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetLastBossEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterLastBossEffect                  eff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetLastBossEffect(EMonsterLastBossEffect eff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetLastBossEffect");

	Params::MonsterBoss_SetLastBossEffect Parms{};

	Parms.eff = eff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetLeftFrontHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetLeftFrontHit(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetLeftFrontHit");

	Params::MonsterBoss_SetLeftFrontHit Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetLeftFrontOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetLeftFrontOverlap(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetLeftFrontOverlap");

	Params::MonsterBoss_SetLeftFrontOverlap Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetNextSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetNextSection(class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetNextSection");

	Params::MonsterBoss_SetNextSection Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetNohitRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   nohit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetNohitRadius(float nohit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetNohitRadius");

	Params::MonsterBoss_SetNohitRadius Parms{};

	Parms.nohit = nohit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetPossessedID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Summon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetPossessedID(class FName Summon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetPossessedID");

	Params::MonsterBoss_SetPossessedID Parms{};

	Parms.Summon = Summon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetQuickSandBreaking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetQuickSandBreaking(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetQuickSandBreaking");

	Params::MonsterBoss_SetQuickSandBreaking Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetQuickSandWait
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetQuickSandWait(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetQuickSandWait");

	Params::MonsterBoss_SetQuickSandWait Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetRedeyeStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossRedeyeStep                  step                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetRedeyeStep(EMonsterBossRedeyeStep step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetRedeyeStep");

	Params::MonsterBoss_SetRedeyeStep Parms{};

	Parms.step = step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetReplacement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetReplacement(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetReplacement");

	Params::MonsterBoss_SetReplacement Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetReplacementBody
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossBodyType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetReplacementBody(EMonsterBossBodyType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetReplacementBody");

	Params::MonsterBoss_SetReplacementBody Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetRestraintChargeBreak
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::SetRestraintChargeBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetRestraintChargeBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetRightFrontHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetRightFrontHit(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetRightFrontHit");

	Params::MonsterBoss_SetRightFrontHit Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetRightFrontOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetRightFrontOverlap(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetRightFrontOverlap");

	Params::MonsterBoss_SetRightFrontOverlap Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetStartCameraShake
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetStartCameraShake(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetStartCameraShake");

	Params::MonsterBoss_SetStartCameraShake Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetStartQuickSand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetStartQuickSand(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetStartQuickSand");

	Params::MonsterBoss_SetStartQuickSand Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetSummonID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Summon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetSummonID(class FName Summon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetSummonID");

	Params::MonsterBoss_SetSummonID Parms{};

	Parms.Summon = Summon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetSummonPossessedID
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::SetSummonPossessedID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetSummonPossessedID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetVolcanoCollided
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetVolcanoCollided(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetVolcanoCollided");

	Params::MonsterBoss_SetVolcanoCollided Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.SetVolcanoGimmickAllDestroyed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterBoss::SetVolcanoGimmickAllDestroyed(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "SetVolcanoGimmickAllDestroyed");

	Params::MonsterBoss_SetVolcanoGimmickAllDestroyed Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.StopQuickSand
// (Final, Native, Public, BlueprintCallable)

void AMonsterBoss::StopQuickSand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "StopQuickSand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBoss.GetAttackCont
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetAttackCont() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetAttackCont");

	Params::MonsterBoss_GetAttackCont Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBarrierAppend
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossBarrierAppend               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossBarrierAppend AMonsterBoss::GetBarrierAppend() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBarrierAppend");

	Params::MonsterBoss_GetBarrierAppend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossBoostingCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_BossBoostingCheck            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_BossBoostingCheck AMonsterBoss::GetBossBoostingCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossBoostingCheck");

	Params::MonsterBoss_GetBossBoostingCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossDerived
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossDerived                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossDerived AMonsterBoss::GetBossDerived() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossDerived");

	Params::MonsterBoss_GetBossDerived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossForceChargeBreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetBossForceChargeBreak() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossForceChargeBreak");

	Params::MonsterBoss_GetBossForceChargeBreak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossForm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossForm                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossForm AMonsterBoss::GetBossForm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossForm");

	Params::MonsterBoss_GetBossForm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossGimmickBreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetBossGimmickBreak() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossGimmickBreak");

	Params::MonsterBoss_GetBossGimmickBreak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetBossHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossHidden");

	Params::MonsterBoss_GetBossHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossPhase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossPhase                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossPhase AMonsterBoss::GetBossPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossPhase");

	Params::MonsterBoss_GetBossPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossRotateInsightTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_BossRotateInsightTarget      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_BossRotateInsightTarget AMonsterBoss::GetBossRotateInsightTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossRotateInsightTarget");

	Params::MonsterBoss_GetBossRotateInsightTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossSerialPeriod
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterBoss::GetBossSerialPeriod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossSerialPeriod");

	Params::MonsterBoss_GetBossSerialPeriod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossStage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterBoss::GetBossStage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossStage");

	Params::MonsterBoss_GetBossStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossTargetInRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_BossTargetInRange            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_BossTargetInRange AMonsterBoss::GetBossTargetInRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossTargetInRange");

	Params::MonsterBoss_GetBossTargetInRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetBossType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossType AMonsterBoss::GetBossType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetBossType");

	Params::MonsterBoss_GetBossType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetCamEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetCamEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetCamEnd");

	Params::MonsterBoss_GetCamEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetCameraControll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossCameraControllType          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossCameraControllType AMonsterBoss::GetCameraControll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetCameraControll");

	Params::MonsterBoss_GetCameraControll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetCameraType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossCameraType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossCameraType AMonsterBoss::GetCameraType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetCameraType");

	Params::MonsterBoss_GetCameraType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetChargeBreakingStun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetChargeBreakingStun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetChargeBreakingStun");

	Params::MonsterBoss_GetChargeBreakingStun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetCombatDuring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossCombatDuring                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossCombatDuring AMonsterBoss::GetCombatDuring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetCombatDuring");

	Params::MonsterBoss_GetCombatDuring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetContCnt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMonsterBoss::GetContCnt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetContCnt");

	Params::MonsterBoss_GetContCnt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetEndQuickSand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetEndQuickSand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetEndQuickSand");

	Params::MonsterBoss_GetEndQuickSand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetExposeWeaknesses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetExposeWeaknesses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetExposeWeaknesses");

	Params::MonsterBoss_GetExposeWeaknesses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetHitWeaknesses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetHitWeaknesses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetHitWeaknesses");

	Params::MonsterBoss_GetHitWeaknesses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetImpactCollisionFrontEnd
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMonsterBoss::GetImpactCollisionFrontEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetImpactCollisionFrontEnd");

	Params::MonsterBoss_GetImpactCollisionFrontEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetImpactCollisionRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBoss::GetImpactCollisionRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetImpactCollisionRadius");

	Params::MonsterBoss_GetImpactCollisionRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetImpactCollisionRearEnd
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMonsterBoss::GetImpactCollisionRearEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetImpactCollisionRearEnd");

	Params::MonsterBoss_GetImpactCollisionRearEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetIsInVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetIsInVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetIsInVisible");

	Params::MonsterBoss_GetIsInVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetLeftFrontHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetLeftFrontHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetLeftFrontHit");

	Params::MonsterBoss_GetLeftFrontHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetLeftFrontOverlap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetLeftFrontOverlap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetLeftFrontOverlap");

	Params::MonsterBoss_GetLeftFrontOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetNextSection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMonsterBoss::GetNextSection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetNextSection");

	Params::MonsterBoss_GetNextSection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetNohitRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMonsterBoss::GetNohitRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetNohitRadius");

	Params::MonsterBoss_GetNohitRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetPossessedID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMonsterBoss::GetPossessedID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetPossessedID");

	Params::MonsterBoss_GetPossessedID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetQuickSand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AFieldObjectBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFieldObjectBase* AMonsterBoss::GetQuickSand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetQuickSand");

	Params::MonsterBoss_GetQuickSand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetQuickSandBreaking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetQuickSandBreaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetQuickSandBreaking");

	Params::MonsterBoss_GetQuickSandBreaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetQuickSandWait
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetQuickSandWait() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetQuickSandWait");

	Params::MonsterBoss_GetQuickSandWait Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetRedeyeStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMonsterBossRedeyeStep                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossRedeyeStep AMonsterBoss::GetRedeyeStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetRedeyeStep");

	Params::MonsterBoss_GetRedeyeStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetReplacement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetReplacement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetReplacement");

	Params::MonsterBoss_GetReplacement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetRestraintChargeBreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetRestraintChargeBreak() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetRestraintChargeBreak");

	Params::MonsterBoss_GetRestraintChargeBreak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetRightFrontHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetRightFrontHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetRightFrontHit");

	Params::MonsterBoss_GetRightFrontHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetRightFrontOverlap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetRightFrontOverlap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetRightFrontOverlap");

	Params::MonsterBoss_GetRightFrontOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetStartCameraShake
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetStartCameraShake() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetStartCameraShake");

	Params::MonsterBoss_GetStartCameraShake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetStartQuickSand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetStartQuickSand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetStartQuickSand");

	Params::MonsterBoss_GetStartQuickSand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.GetVolcanoCollided
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::GetVolcanoCollided() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "GetVolcanoCollided");

	Params::MonsterBoss_GetVolcanoCollided Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsBossBoost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsBossBoost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsBossBoost");

	Params::MonsterBoss_IsBossBoost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsBossDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsBossDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsBossDead");

	Params::MonsterBoss_IsBossDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsBossDeathblow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsBossDeathblow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsBossDeathblow");

	Params::MonsterBoss_IsBossDeathblow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsBossFainting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsBossFainting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsBossFainting");

	Params::MonsterBoss_IsBossFainting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsChangeRedeyeStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsChangeRedeyeStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsChangeRedeyeStep");

	Params::MonsterBoss_IsChangeRedeyeStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBoss.IsGimmickFirstBreak
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMonsterBoss::IsGimmickFirstBreak() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBoss", "IsGimmickFirstBreak");

	Params::MonsterBoss_IsGimmickFirstBreak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIQuest_Order_List.ClearOutFinishedFunction
// (Final, Native, Protected)

void UUIQuest_Order_List::ClearOutFinishedFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQuest_Order_List", "ClearOutFinishedFunction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuest_Order_List.DeleteNewCallback
// (Final, Native, Protected)

void UUIQuest_Order_List::DeleteNewCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQuest_Order_List", "DeleteNewCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Panel_01.EffectEnd
// (Final, Native, Protected)

void UUIAppraise_Panel_01::EffectEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Panel_01", "EffectEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Panel_01.ExpansionEnd
// (Final, Native, Protected)

void UUIAppraise_Panel_01::ExpansionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Panel_01", "ExpansionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MemoryTestGameMode.CreateAndAddTestObject
// (Final, Native, Public, BlueprintCallable)

void AMemoryTestGameMode::CreateAndAddTestObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MemoryTestGameMode", "CreateAndAddTestObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MemoryTestGameMode.GetTestObjects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMemoryTestObject*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class UMemoryTestObject*> AMemoryTestGameMode::GetTestObjects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MemoryTestGameMode", "GetTestObjects");

	Params::MemoryTestGameMode_GetTestObjects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.adjustIEMessageId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           SrcID                                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DstID                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::adjustIEMessageId(const class FString& SrcID, class FString* DstID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "adjustIEMessageId");

	Params::MessageUtils_adjustIEMessageId Parms{};

	Parms.SrcID = std::move(SrcID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DstID != nullptr)
		*DstID = std::move(Parms.DstID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.adjustIEMessageId_Branch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::adjustIEMessageId_Branch(const class FString& Src, class FString* NextID, const int32 Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "adjustIEMessageId_Branch");

	Params::MessageUtils_adjustIEMessageId_Branch Parms{};

	Parms.Src = std::move(Src);
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextID != nullptr)
		*NextID = std::move(Parms.NextID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.adjustIEMessageId_Jouken
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextJoukenType                         JoukenType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::adjustIEMessageId_Jouken(const class FString& Src, class FString* NextID, ETextJoukenType JoukenType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "adjustIEMessageId_Jouken");

	Params::MessageUtils_adjustIEMessageId_Jouken Parms{};

	Parms.Src = std::move(Src);
	Parms.JoukenType = JoukenType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextID != nullptr)
		*NextID = std::move(Parms.NextID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.adjustIEMessageId_PCType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextPCType                             NewPcType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::adjustIEMessageId_PCType(const class FString& Src, class FString* NextID, ETextPCType NewPcType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "adjustIEMessageId_PCType");

	Params::MessageUtils_adjustIEMessageId_PCType Parms{};

	Parms.Src = std::move(Src);
	Parms.NewPcType = NewPcType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextID != nullptr)
		*NextID = std::move(Parms.NextID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.adjustIEMessageId_TalkNum
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestState                             QuestState                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::adjustIEMessageId_TalkNum(const class FString& Src, class FString* NextID, const EQuestState QuestState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "adjustIEMessageId_TalkNum");

	Params::MessageUtils_adjustIEMessageId_TalkNum Parms{};

	Parms.Src = std::move(Src);
	Parms.QuestState = QuestState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextID != nullptr)
		*NextID = std::move(Parms.NextID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.adjustIEMessageId_Time
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hour                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::adjustIEMessageId_Time(const class FString& Src, class FString* NextID, const int32 Hour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "adjustIEMessageId_Time");

	Params::MessageUtils_adjustIEMessageId_Time Parms{};

	Parms.Src = std::move(Src);
	Parms.Hour = Hour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextID != nullptr)
		*NextID = std::move(Parms.NextID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.AdjustIEQuestTalkID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TalkId                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEventType                              EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestState                             QuestState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewTalkId                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::AdjustIEQuestTalkID(const class FString& TalkId, EEventType EventType, EQuestState QuestState, class FString* NewTalkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "AdjustIEQuestTalkID");

	Params::MessageUtils_AdjustIEQuestTalkID Parms{};

	Parms.TalkId = std::move(TalkId);
	Parms.EventType = EventType;
	Parms.QuestState = QuestState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTalkId != nullptr)
		*NewTalkId = std::move(Parms.NewTalkId);
}


// Function DarwinGame.MessageUtils.CheckColorTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsColor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckColorTag(const class FString& Src, bool* IsColor, float* R, float* G, float* B, float* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckColorTag");

	Params::MessageUtils_CheckColorTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsColor != nullptr)
		*IsColor = Parms.IsColor;

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (B != nullptr)
		*B = Parms.B;

	if (A != nullptr)
		*A = Parms.A;
}


// Function DarwinGame.MessageUtils.CheckDelegateTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::CheckDelegateTag(const class FString& Src, class FString* OutString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckDelegateTag");

	Params::MessageUtils_CheckDelegateTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.CheckEmojiChangeColorTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsColor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckEmojiChangeColorTag(const class FString& Src, bool* IsColor, float* R, float* G, float* B, float* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckEmojiChangeColorTag");

	Params::MessageUtils_CheckEmojiChangeColorTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsColor != nullptr)
		*IsColor = Parms.IsColor;

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (B != nullptr)
		*B = Parms.B;

	if (A != nullptr)
		*A = Parms.A;
}


// Function DarwinGame.MessageUtils.CheckEmojiTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsStamp                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TypeID                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckEmojiTag(const class FString& Src, bool* IsStamp, int32* TypeID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckEmojiTag");

	Params::MessageUtils_CheckEmojiTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsStamp != nullptr)
		*IsStamp = Parms.IsStamp;

	if (TypeID != nullptr)
		*TypeID = Parms.TypeID;
}


// Function DarwinGame.MessageUtils.CheckEmotionEffectTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsemotionEffect                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmotionEffectID                        EmotionEffectID                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckEmotionEffectTag(const class FString& Src, bool* IsemotionEffect, EEmotionEffectID* EmotionEffectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckEmotionEffectTag");

	Params::MessageUtils_CheckEmotionEffectTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsemotionEffect != nullptr)
		*IsemotionEffect = Parms.IsemotionEffect;

	if (EmotionEffectID != nullptr)
		*EmotionEffectID = Parms.EmotionEffectID;
}


// Function DarwinGame.MessageUtils.CheckFlagCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TextID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMessageUtils::CheckFlagCommand(const class FString& TextID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckFlagCommand");

	Params::MessageUtils_CheckFlagCommand Parms{};

	Parms.TextID = std::move(TextID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.CheckFukidashiStamp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Serifu                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStampIconType                          StampType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::CheckFukidashiStamp(const class FString& Serifu, EStampIconType* StampType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckFukidashiStamp");

	Params::MessageUtils_CheckFukidashiStamp Parms{};

	Parms.Serifu = std::move(Serifu);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StampType != nullptr)
		*StampType = Parms.StampType;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.CheckOutLineColorTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsColor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckOutLineColorTag(const class FString& Src, bool* IsColor, float* R, float* G, float* B, float* A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckOutLineColorTag");

	Params::MessageUtils_CheckOutLineColorTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsColor != nullptr)
		*IsColor = Parms.IsColor;

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (B != nullptr)
		*B = Parms.B;

	if (A != nullptr)
		*A = Parms.A;
}


// Function DarwinGame.MessageUtils.CheckPartVoiceTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPartVoice                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TalkTypeName                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckPartVoiceTag(const class FString& Src, bool* IsPartVoice, class FString* TalkTypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckPartVoiceTag");

	Params::MessageUtils_CheckPartVoiceTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsPartVoice != nullptr)
		*IsPartVoice = Parms.IsPartVoice;

	if (TalkTypeName != nullptr)
		*TalkTypeName = std::move(Parms.TalkTypeName);
}


// Function DarwinGame.MessageUtils.CheckSoundTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsSound                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCueSheetCategory                   SoundType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SoundNo                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckSoundTag(const class FString& Src, bool* IsSound, EAtomCueSheetCategory* SoundType, int32* SoundNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckSoundTag");

	Params::MessageUtils_CheckSoundTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsSound != nullptr)
		*IsSound = Parms.IsSound;

	if (SoundType != nullptr)
		*SoundType = Parms.SoundType;

	if (SoundNo != nullptr)
		*SoundNo = Parms.SoundNo;
}


// Function DarwinGame.MessageUtils.CheckStampTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsStamp                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStampIconType                          StampType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEmoteType                              emoteType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Option                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopNum                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckStampTag(const class FString& Src, bool* IsStamp, EStampIconType* StampType, EEmoteType* emoteType, class FString* Option, int32* LoopNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckStampTag");

	Params::MessageUtils_CheckStampTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsStamp != nullptr)
		*IsStamp = Parms.IsStamp;

	if (StampType != nullptr)
		*StampType = Parms.StampType;

	if (emoteType != nullptr)
		*emoteType = Parms.emoteType;

	if (Option != nullptr)
		*Option = std::move(Parms.Option);

	if (LoopNum != nullptr)
		*LoopNum = Parms.LoopNum;
}


// Function DarwinGame.MessageUtils.CheckTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::CheckTag(const class FString& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckTag");

	Params::MessageUtils_CheckTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.CheckTipsTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTips                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TipsID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::CheckTipsTag(const class FString& Src, bool* IsTips, class FString* TipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "CheckTipsTag");

	Params::MessageUtils_CheckTipsTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsTips != nullptr)
		*IsTips = Parms.IsTips;

	if (TipsID != nullptr)
		*TipsID = std::move(Parms.TipsID);
}


// Function DarwinGame.MessageUtils.Command_Check_Chart
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Str                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextTalkChart                          ChartID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsChartOnly                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::Command_Check_Chart(const class FString& Str, ETextTalkChart* ChartID, bool* IsChartOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "Command_Check_Chart");

	Params::MessageUtils_Command_Check_Chart Parms{};

	Parms.Str = std::move(Str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ChartID != nullptr)
		*ChartID = Parms.ChartID;

	if (IsChartOnly != nullptr)
		*IsChartOnly = Parms.IsChartOnly;
}


// Function DarwinGame.MessageUtils.Command_Check_Icon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Str                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextTalkIcon                           Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::Command_Check_Icon(const class FString& Str, ETextTalkIcon* Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "Command_Check_Icon");

	Params::MessageUtils_Command_Check_Icon Parms{};

	Parms.Str = std::move(Str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function DarwinGame.MessageUtils.Command_Check_LipSync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Str                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLipSync                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::Command_Check_LipSync(const class FString& Str, bool* IsLipSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "Command_Check_LipSync");

	Params::MessageUtils_Command_Check_LipSync Parms{};

	Parms.Str = std::move(Str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsLipSync != nullptr)
		*IsLipSync = Parms.IsLipSync;
}


// Function DarwinGame.MessageUtils.Command_Check_TurnPC
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Str                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTurn                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsWait                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsReturn                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::Command_Check_TurnPC(const class FString& Str, bool* IsTurn, bool* IsWait, bool* IsReturn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "Command_Check_TurnPC");

	Params::MessageUtils_Command_Check_TurnPC Parms{};

	Parms.Str = std::move(Str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsTurn != nullptr)
		*IsTurn = Parms.IsTurn;

	if (IsWait != nullptr)
		*IsWait = Parms.IsWait;

	if (IsReturn != nullptr)
		*IsReturn = Parms.IsReturn;
}


// Function DarwinGame.MessageUtils.createIEMessageID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMessageIdInfo                   Info                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::createIEMessageID(const struct FMessageIdInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "createIEMessageID");

	Params::MessageUtils_createIEMessageID Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.createIEMessageID_Old
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FMessageIdInfo                   Info                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::createIEMessageID_Old(const struct FMessageIdInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "createIEMessageID_Old");

	Params::MessageUtils_createIEMessageID_Old Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.GetEmojiStr
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   emojiId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SysytemType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Str                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::GetEmojiStr(int32 emojiId, int32 SysytemType, class FString* Str)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetEmojiStr");

	Params::MessageUtils_GetEmojiStr Parms{};

	Parms.emojiId = emojiId;
	Parms.SysytemType = SysytemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Str != nullptr)
		*Str = std::move(Parms.Str);
}


// Function DarwinGame.MessageUtils.GetEventTalkData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_EventTalkData                EventTalkData                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::GetEventTalkData(const class FName& TextID, struct FST_EventTalkData* EventTalkData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetEventTalkData");

	Params::MessageUtils_GetEventTalkData Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EventTalkData != nullptr)
		*EventTalkData = std::move(Parms.EventTalkData);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.GetFukidashiID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SrcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SubFlag                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UMessageUtils::GetFukidashiID(const class FName SrcID, int32 Hour, const bool SubFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetFukidashiID");

	Params::MessageUtils_GetFukidashiID Parms{};

	Parms.SrcID = SrcID;
	Parms.Hour = Hour;
	Parms.SubFlag = SubFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.GetFukidashiIDList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SrcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TArray<class FName> UMessageUtils::GetFukidashiIDList(const class FName SrcID, int32 Hour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetFukidashiIDList");

	Params::MessageUtils_GetFukidashiIDList Parms{};

	Parms.SrcID = SrcID;
	Parms.Hour = Hour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.getNextCSMessageId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           SrcID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NextID                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::getNextCSMessageId(const class FString& SrcID, const class FString& Src, class FString* NextID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "getNextCSMessageId");

	Params::MessageUtils_getNextCSMessageId Parms{};

	Parms.SrcID = std::move(SrcID);
	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NextID != nullptr)
		*NextID = std::move(Parms.NextID);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.GetNextTextID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TextID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndType                                EndType                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMessageUtils::GetNextTextID(const class FString& TextID, const EEndType EndType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetNextTextID");

	Params::MessageUtils_GetNextTextID Parms{};

	Parms.TextID = std::move(TextID);
	Parms.EndType = EndType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.GetSerifuDataDirect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::GetSerifuDataDirect(const class FName& TextID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetSerifuDataDirect");

	Params::MessageUtils_GetSerifuDataDirect Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.GetStampID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMessageUtils::GetStampID(const class FString& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "GetStampID");

	Params::MessageUtils_GetStampID Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.InsertSpaceToTop
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Dst                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMessageUtils::InsertSpaceToTop(const class FString& Src, class FString* Dst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "InsertSpaceToTop");

	Params::MessageUtils_InsertSpaceToTop Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Dst != nullptr)
		*Dst = std::move(Parms.Dst);
}


// Function DarwinGame.MessageUtils.IsEmojiChangeSizeTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::IsEmojiChangeSizeTag(const class FString& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "IsEmojiChangeSizeTag");

	Params::MessageUtils_IsEmojiChangeSizeTag Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.IsFukidashiID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TextID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::IsFukidashiID(const class FName TextID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "IsFukidashiID");

	Params::MessageUtils_IsFukidashiID Parms{};

	Parms.TextID = TextID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.IsJapanese
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::IsJapanese()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "IsJapanese");

	Params::MessageUtils_IsJapanese Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.IsValidMessageID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::IsValidMessageID(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "IsValidMessageID");

	Params::MessageUtils_IsValidMessageID Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.procIEMessageID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Src                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMessageIdInfo                   IdInfo                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::procIEMessageID(const class FString& Src, struct FMessageIdInfo* IdInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "procIEMessageID");

	Params::MessageUtils_procIEMessageID Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IdInfo != nullptr)
		*IdInfo = std::move(Parms.IdInfo);

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.ProcSerifuText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::ProcSerifuText(const class FString& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "ProcSerifuText");

	Params::MessageUtils_ProcSerifuText Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.RemoveSquareBrackets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::RemoveSquareBrackets(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "RemoveSquareBrackets");

	Params::MessageUtils_RemoveSquareBrackets Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.ShapeFukidashiText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Serifu                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMessageUtils::ShapeFukidashiText(const class FString& Serifu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MessageUtils", "ShapeFukidashiText");

	Params::MessageUtils_ShapeFukidashiText Parms{};

	Parms.Serifu = std::move(Serifu);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MessageUtils.SerifuToFukidashi
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Serifu                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Fukidashi                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Length                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMessageUtils::SerifuToFukidashi(const class FString& Serifu, class FString* Fukidashi, const int32 Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MessageUtils", "SerifuToFukidashi");

	Params::MessageUtils_SerifuToFukidashi Parms{};

	Parms.Serifu = std::move(Serifu);
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Fukidashi != nullptr)
		*Fukidashi = std::move(Parms.Fukidashi);

	return Parms.ReturnValue;
}


// Function DarwinGame.MissileLaunchPadMagicBase.AddMissile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMissileMagicBase*                missile                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMissileLaunchPadMagicBase::AddMissile(class AMissileMagicBase* missile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileLaunchPadMagicBase", "AddMissile");

	Params::MissileLaunchPadMagicBase_AddMissile Parms{};

	Parms.missile = missile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MissileLaunchPadMagicBase.BulletsLoad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<ESocket>                         Sockets                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ActionDetailIDs                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMissileLaunchPadMagicBase::BulletsLoad(const TArray<ESocket>& Sockets, const TArray<class FName>& ActionDetailIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileLaunchPadMagicBase", "BulletsLoad");

	Params::MissileLaunchPadMagicBase_BulletsLoad Parms{};

	Parms.Sockets = std::move(Sockets);
	Parms.ActionDetailIDs = std::move(ActionDetailIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MissileLaunchPadMagicBase.GetBulletActionDetailID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AMissileLaunchPadMagicBase::GetBulletActionDetailID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileLaunchPadMagicBase", "GetBulletActionDetailID");

	Params::MissileLaunchPadMagicBase_GetBulletActionDetailID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MissileLaunchPadMagicBase.GetEffectContainerSpec
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FActionGameplayEffectContainerSpecReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FActionGameplayEffectContainerSpec AMissileLaunchPadMagicBase::GetEffectContainerSpec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileLaunchPadMagicBase", "GetEffectContainerSpec");

	Params::MissileLaunchPadMagicBase_GetEffectContainerSpec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MissileLaunchPadMagicBase.Launch
// (Final, Native, Public, BlueprintCallable)

void AMissileLaunchPadMagicBase::Launch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileLaunchPadMagicBase", "Launch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MissileLaunchPadMagicBase.LaunchStart
// (Final, Native, Public, BlueprintCallable)

void AMissileLaunchPadMagicBase::LaunchStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissileLaunchPadMagicBase", "LaunchStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraiseSequence.DestroyFlashEffect
// (Final, Native, Public, BlueprintCallable)

void UUIAppraiseSequence::DestroyFlashEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "DestroyFlashEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraiseSequence.EndFlashSequencer
// (Final, Native, Public, BlueprintCallable)

void UUIAppraiseSequence::EndFlashSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "EndFlashSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraiseSequence.FadeOut
// (Final, Native, Public, BlueprintCallable)

void UUIAppraiseSequence::FadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "FadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraiseSequence.GetCaptureComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneCaptureComponent2D* UUIAppraiseSequence::GetCaptureComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "GetCaptureComponent");

	Params::UIAppraiseSequence_GetCaptureComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIAppraiseSequence.IsFlash
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIAppraiseSequence::IsFlash(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "IsFlash");

	Params::UIAppraiseSequence_IsFlash Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIAppraiseSequence.IsFly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIAppraiseSequence::IsFly(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "IsFly");

	Params::UIAppraiseSequence_IsFly Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIAppraiseSequence.QualityUpPopUp
// (Final, Native, Public, BlueprintCallable)

void UUIAppraiseSequence::QualityUpPopUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "QualityUpPopUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraiseSequence.SetDefaultMaterial
// (Final, Native, Public, BlueprintCallable)

void UUIAppraiseSequence::SetDefaultMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "SetDefaultMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraiseSequence.SpawnFlashEffect
// (Final, Native, Public, BlueprintCallable)

void UUIAppraiseSequence::SpawnFlashEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraiseSequence", "SpawnFlashEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossBoostingCheck.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossBoostingCheck::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossBoostingCheck", "NotifyBegin");

	Params::MonsNotifyState_BossBoostingCheck_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossBoostingCheck.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossBoostingCheck::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossBoostingCheck", "NotifyEnd");

	Params::MonsNotifyState_BossBoostingCheck_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossBoostingCheck.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossBoostingCheck::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossBoostingCheck", "NotifyTick");

	Params::MonsNotifyState_BossBoostingCheck_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossCombatDuring.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossCombatDuring::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossCombatDuring", "NotifyBegin");

	Params::MonsNotifyState_BossCombatDuring_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossCombatDuring.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossCombatDuring::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossCombatDuring", "NotifyEnd");

	Params::MonsNotifyState_BossCombatDuring_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossCombatDuring.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossCombatDuring::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossCombatDuring", "NotifyTick");

	Params::MonsNotifyState_BossCombatDuring_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossExposeWeaknesses.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossExposeWeaknesses::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossExposeWeaknesses", "NotifyBegin");

	Params::MonsNotifyState_BossExposeWeaknesses_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossExposeWeaknesses.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossExposeWeaknesses::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossExposeWeaknesses", "NotifyEnd");

	Params::MonsNotifyState_BossExposeWeaknesses_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossExposeWeaknesses.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossExposeWeaknesses::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossExposeWeaknesses", "NotifyTick");

	Params::MonsNotifyState_BossExposeWeaknesses_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NavLinkProxyEx.SmartLinkReached
// (Final, Native, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          destPoint                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavLinkProxyEx::SmartLinkReached(class AActor* Actor, const struct FVector& destPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkProxyEx", "SmartLinkReached");

	Params::NavLinkProxyEx_SmartLinkReached Parms{};

	Parms.Actor = Actor;
	Parms.destPoint = std::move(destPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossPossessed.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossPossessed::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossPossessed", "NotifyBegin");

	Params::MonsNotifyState_BossPossessed_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossPossessed.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossPossessed::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossPossessed", "NotifyEnd");

	Params::MonsNotifyState_BossPossessed_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossPossessed.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossPossessed::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossPossessed", "NotifyTick");

	Params::MonsNotifyState_BossPossessed_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossPossessFlying.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossPossessFlying::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossPossessFlying", "NotifyBegin");

	Params::MonsNotifyState_BossPossessFlying_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossPossessFlying.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossPossessFlying::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossPossessFlying", "NotifyEnd");

	Params::MonsNotifyState_BossPossessFlying_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossPossessFlying.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossPossessFlying::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossPossessFlying", "NotifyTick");

	Params::MonsNotifyState_BossPossessFlying_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossRetarget.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossRetarget::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossRetarget", "NotifyBegin");

	Params::MonsNotifyState_BossRetarget_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossRetarget.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossRetarget::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossRetarget", "NotifyEnd");

	Params::MonsNotifyState_BossRetarget_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossRetarget.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossRetarget::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossRetarget", "NotifyTick");

	Params::MonsNotifyState_BossRetarget_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossRotateInsightTarget.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossRotateInsightTarget::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossRotateInsightTarget", "NotifyBegin");

	Params::MonsNotifyState_BossRotateInsightTarget_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossRotateInsightTarget.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossRotateInsightTarget::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossRotateInsightTarget", "NotifyEnd");

	Params::MonsNotifyState_BossRotateInsightTarget_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossRotateInsightTarget.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossRotateInsightTarget::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossRotateInsightTarget", "NotifyTick");

	Params::MonsNotifyState_BossRotateInsightTarget_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossSelfhalm.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossSelfhalm::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossSelfhalm", "NotifyBegin");

	Params::MonsNotifyState_BossSelfhalm_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossSelfhalm.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossSelfhalm::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossSelfhalm", "NotifyEnd");

	Params::MonsNotifyState_BossSelfhalm_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossSelfhalm.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossSelfhalm::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossSelfhalm", "NotifyTick");

	Params::MonsNotifyState_BossSelfhalm_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossStatueDeadWait.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossStatueDeadWait::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossStatueDeadWait", "NotifyBegin");

	Params::MonsNotifyState_BossStatueDeadWait_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossStatueDeadWait.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossStatueDeadWait::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossStatueDeadWait", "NotifyEnd");

	Params::MonsNotifyState_BossStatueDeadWait_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossStatueDeadWait.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossStatueDeadWait::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossStatueDeadWait", "NotifyTick");

	Params::MonsNotifyState_BossStatueDeadWait_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossStatueDestroy.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossStatueDestroy::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossStatueDestroy", "NotifyBegin");

	Params::MonsNotifyState_BossStatueDestroy_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossStatueDestroy.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossStatueDestroy::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossStatueDestroy", "NotifyEnd");

	Params::MonsNotifyState_BossStatueDestroy_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossStatueDestroy.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossStatueDestroy::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossStatueDestroy", "NotifyTick");

	Params::MonsNotifyState_BossStatueDestroy_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossTargetInRange.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossTargetInRange::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossTargetInRange", "NotifyBegin");

	Params::MonsNotifyState_BossTargetInRange_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossTargetInRange.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossTargetInRange::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossTargetInRange", "NotifyEnd");

	Params::MonsNotifyState_BossTargetInRange_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossTargetInRange.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossTargetInRange::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossTargetInRange", "NotifyTick");

	Params::MonsNotifyState_BossTargetInRange_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkTravellerEvent.ConnectNetworkTravelIine
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bRandamTraverller                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkTravellerEvent::ConnectNetworkTravelIine(bool bRandamTraverller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "ConnectNetworkTravelIine");

	Params::NetworkTravellerEvent_ConnectNetworkTravelIine Parms{};

	Parms.bRandamTraverller = bRandamTraverller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkTravellerEvent.FadeIn
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkTravellerEvent::FadeIn(int32 NextSectionNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "FadeIn");

	Params::NetworkTravellerEvent_FadeIn Parms{};

	Parms.NextSectionNum = NextSectionNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkTravellerEvent.IsPlayNotArtifactReplicaReaction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsAutoTraveller                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANetworkTravellerEvent::IsPlayNotArtifactReplicaReaction(bool IsAutoTraveller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "IsPlayNotArtifactReplicaReaction");

	Params::NetworkTravellerEvent_IsPlayNotArtifactReplicaReaction Parms{};

	Parms.IsAutoTraveller = IsAutoTraveller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NetworkTravellerEvent.OpenAboutReplicaDialog
// (Final, Native, Protected, BlueprintCallable)

void ANetworkTravellerEvent::OpenAboutReplicaDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "OpenAboutReplicaDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkTravellerEvent.OpenNetoworkTravellerUI
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NextSectionNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandamTraverller                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkTravellerEvent::OpenNetoworkTravellerUI(int32 NextSectionNum, bool bRandamTraverller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "OpenNetoworkTravellerUI");

	Params::NetworkTravellerEvent_OpenNetoworkTravellerUI Parms{};

	Parms.NextSectionNum = NextSectionNum;
	Parms.bRandamTraverller = bRandamTraverller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkTravellerEvent.PlayMonsterVoice
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsAutoTraveller                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANetworkTravellerEvent::PlayMonsterVoice(bool IsAutoTraveller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "PlayMonsterVoice");

	Params::NetworkTravellerEvent_PlayMonsterVoice Parms{};

	Parms.IsAutoTraveller = IsAutoTraveller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NetworkTravellerEvent.PlaySoundLeaveTravellerMsgWindowOpen
// (Final, Native, Protected, BlueprintCallable)

void ANetworkTravellerEvent::PlaySoundLeaveTravellerMsgWindowOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NetworkTravellerEvent", "PlaySoundLeaveTravellerMsgWindowOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossUIRestart.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossUIRestart::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossUIRestart", "NotifyBegin");

	Params::MonsNotifyState_BossUIRestart_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossUIRestart.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossUIRestart::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossUIRestart", "NotifyEnd");

	Params::MonsNotifyState_BossUIRestart_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_BossUIRestart.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_BossUIRestart::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_BossUIRestart", "NotifyTick");

	Params::MonsNotifyState_BossUIRestart_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_GuideSysLog.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_GuideSysLog::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_GuideSysLog", "NotifyBegin");

	Params::MonsNotifyState_GuideSysLog_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_GuideSysLog.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_GuideSysLog::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_GuideSysLog", "NotifyEnd");

	Params::MonsNotifyState_GuideSysLog_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_GuideSysLog.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_GuideSysLog::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_GuideSysLog", "NotifyTick");

	Params::MonsNotifyState_GuideSysLog_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_IgnoreCollision.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_IgnoreCollision::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_IgnoreCollision", "NotifyBegin");

	Params::MonsNotifyState_IgnoreCollision_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_IgnoreCollision.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_IgnoreCollision::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_IgnoreCollision", "NotifyEnd");

	Params::MonsNotifyState_IgnoreCollision_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_IgnoreCollision.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_IgnoreCollision::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_IgnoreCollision", "NotifyTick");

	Params::MonsNotifyState_IgnoreCollision_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterCheckFloorChangeSection.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterCheckFloorChangeSection::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterCheckFloorChangeSection", "NotifyBegin");

	Params::MonsNotifyState_MonsterCheckFloorChangeSection_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterCheckFloorChangeSection.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterCheckFloorChangeSection::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterCheckFloorChangeSection", "NotifyEnd");

	Params::MonsNotifyState_MonsterCheckFloorChangeSection_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterCheckFloorChangeSection.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterCheckFloorChangeSection::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterCheckFloorChangeSection", "NotifyTick");

	Params::MonsNotifyState_MonsterCheckFloorChangeSection_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.GetAttackTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* ANPCAIController::GetAttackTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetAttackTarget");

	Params::NPCAIController_GetAttackTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.GetFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANPCAIController::GetFloat(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetFloat");

	Params::NPCAIController_GetFloat Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.GetInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANPCAIController::GetInt(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetInt");

	Params::NPCAIController_GetInt Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.GetNPCAiType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCAiType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCAiType ANPCAIController::GetNPCAiType(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetNPCAiType");

	Params::NPCAIController_GetNPCAiType Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.GetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANPCAIController::GetRotator(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetRotator");

	Params::NPCAIController_GetRotator Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.GetTraceTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* ANPCAIController::GetTraceTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetTraceTarget");

	Params::NPCAIController_GetTraceTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.GetVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANPCAIController::GetVector(class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetVector");

	Params::NPCAIController_GetVector Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCAIController.NPCAiInit
// (Event, Public, BlueprintEvent)
// Parameters:
// class ACharacter*                       NPCActor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::NPCAiInit(const class ACharacter* NPCActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "NPCAiInit");

	Params::NPCAIController_NPCAiInit Parms{};

	Parms.NPCActor = NPCActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.NPCAIController.SetAttackTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetAttackTarget(class APawn* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetAttackTarget");

	Params::NPCAIController_SetAttackTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetFloat(class FName Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetFloat");

	Params::NPCAIController_SetFloat Parms{};

	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetInt(class FName Key, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetInt");

	Params::NPCAIController_SetInt Parms{};

	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetNPCAiType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENPCAiType                              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetNPCAiType(class FName Key, ENPCAiType Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetNPCAiType");

	Params::NPCAIController_SetNPCAiType Parms{};

	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANPCAIController::SetRotator(class FName Key, const struct FRotator& Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetRotator");

	Params::NPCAIController_SetRotator Parms{};

	Parms.Key = Key;
	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetTarget(class FName Key, class APawn* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetTarget");

	Params::NPCAIController_SetTarget Parms{};

	Parms.Key = Key;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetTraceTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetTraceTarget(class APawn* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetTraceTarget");

	Params::NPCAIController_SetTraceTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.SetVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCAIController::SetVector(class FName Key, const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "SetVector");

	Params::NPCAIController_SetVector Parms{};

	Parms.Key = Key;
	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCAIController.GetTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ANPCAIController::GetTarget(class FName Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCAIController", "GetTarget");

	Params::NPCAIController_GetTarget Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsNotifyState_MonsterRotateInsightTarget.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterRotateInsightTarget::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterRotateInsightTarget", "NotifyBegin");

	Params::MonsNotifyState_MonsterRotateInsightTarget_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterRotateInsightTarget.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterRotateInsightTarget::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterRotateInsightTarget", "NotifyEnd");

	Params::MonsNotifyState_MonsterRotateInsightTarget_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterRotateInsightTarget.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterRotateInsightTarget::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterRotateInsightTarget", "NotifyTick");

	Params::MonsNotifyState_MonsterRotateInsightTarget_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_TargetInRangeFin.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_TargetInRangeFin::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_TargetInRangeFin", "NotifyBegin");

	Params::MonsNotifyState_TargetInRangeFin_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_TargetInRangeFin.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_TargetInRangeFin::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_TargetInRangeFin", "NotifyTick");

	Params::MonsNotifyState_TargetInRangeFin_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterTimeCheckAttack.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterTimeCheckAttack::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterTimeCheckAttack", "NotifyBegin");

	Params::MonsNotifyState_MonsterTimeCheckAttack_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterTimeCheckAttack.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterTimeCheckAttack::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterTimeCheckAttack", "NotifyEnd");

	Params::MonsNotifyState_MonsterTimeCheckAttack_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_MonsterTimeCheckAttack.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_MonsterTimeCheckAttack::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_MonsterTimeCheckAttack", "NotifyTick");

	Params::MonsNotifyState_MonsterTimeCheckAttack_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_RotateToTargetWithLocationOffset.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_RotateToTargetWithLocationOffset::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_RotateToTargetWithLocationOffset", "NotifyBegin");

	Params::MonsNotifyState_RotateToTargetWithLocationOffset_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_RotateToTargetWithLocationOffset.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_RotateToTargetWithLocationOffset::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_RotateToTargetWithLocationOffset", "NotifyTick");

	Params::MonsNotifyState_RotateToTargetWithLocationOffset_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_TimeCheckMultipleAttack.NotifyBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBegin                  fst                                                    (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_TimeCheckMultipleAttack::NotifyBegin(const struct FST_NotifyBegin& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_TimeCheckMultipleAttack", "NotifyBegin");

	Params::MonsNotifyState_TimeCheckMultipleAttack_NotifyBegin Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_TimeCheckMultipleAttack.NotifyEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_TimeCheckMultipleAttack::NotifyEnd(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_TimeCheckMultipleAttack", "NotifyEnd");

	Params::MonsNotifyState_TimeCheckMultipleAttack_NotifyEnd Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsNotifyState_TimeCheckMultipleAttack.NotifyTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NotifyBase                   fst                                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMonsNotifyState_TimeCheckMultipleAttack::NotifyTick(const struct FST_NotifyBase& fst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsNotifyState_TimeCheckMultipleAttack", "NotifyTick");

	Params::MonsNotifyState_TimeCheckMultipleAttack_NotifyTick Parms{};

	Parms.fst = std::move(fst);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PointEnvSound.OnSoundActiveRangeBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPointEnvSound::OnSoundActiveRangeBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointEnvSound", "OnSoundActiveRangeBeginOverlap");

	Params::PointEnvSound_OnSoundActiveRangeBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PointEnvSound.OnSoundActiveRangeEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointEnvSound::OnSoundActiveRangeEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PointEnvSound", "OnSoundActiveRangeEndOverlap");

	Params::PointEnvSound_OnSoundActiveRangeEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterAIController.GetAttackTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* AMonsterAIController::GetAttackTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterAIController", "GetAttackTarget");

	Params::MonsterAIController_GetAttackTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterAIController.GetTraceTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* AMonsterAIController::GetTraceTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterAIController", "GetTraceTarget");

	Params::MonsterAIController_GetTraceTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterAIController.SetAttackTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterAIController::SetAttackTarget(class APawn* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterAIController", "SetAttackTarget");

	Params::MonsterAIController_SetAttackTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterAIController.SetTraceTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMonsterAIController::SetTraceTarget(class APawn* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterAIController", "SetTraceTarget");

	Params::MonsterAIController_SetTraceTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAI.DeriVateActionDecision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAI::DeriVateActionDecision(class AMonster* Monster, class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAI", "DeriVateActionDecision");

	Params::MonsterBattleAI_DeriVateActionDecision Parms{};

	Parms.Monster = Monster;
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBattleAI.LeaveRequest
// (Final, Native, Public)
// Parameters:
// class AMonster*                         Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBattleAI::LeaveRequest(class AMonster* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBattleAI", "LeaveRequest");

	Params::MonsterBattleAI_LeaveRequest Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.QuestDestinationRectBase.OnOverlapEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AQuestDestinationRectBase::OnOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestDestinationRectBase", "OnOverlapEvent");

	Params::QuestDestinationRectBase_OnOverlapEvent Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TagTextRubyDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UTagTextRubyDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TagTextRubyDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.ActionCancel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blendOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::ActionCancel(class AMonsterBase* Monster, float blendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "ActionCancel");

	Params::MonsterBlueprintFunctionLibrary_ActionCancel Parms{};

	Parms.Monster = Monster;
	Parms.blendOut = blendOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.ActionCancelAndSetLocationAndRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::ActionCancelAndSetLocationAndRotation(class AMonsterBase* Monster, const struct FVector& Location, const struct FRotator& Rotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "ActionCancelAndSetLocationAndRotation");

	Params::MonsterBlueprintFunctionLibrary_ActionCancelAndSetLocationAndRotation Parms{};

	Parms.Monster = Monster;
	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.ActionOneShotMotion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAir                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::ActionOneShotMotion(class AGPACharacter* Character, bool isAir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "ActionOneShotMotion");

	Params::MonsterBlueprintFunctionLibrary_ActionOneShotMotion Parms{};

	Parms.Character = Character;
	Parms.isAir = isAir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.AddHateDirect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   hateValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::AddHateDirect(class AMonsterBase* Monster, class AGPACharacter* Target, float hateValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "AddHateDirect");

	Params::MonsterBlueprintFunctionLibrary_AddHateDirect Parms{};

	Parms.Monster = Monster;
	Parms.Target = Target;
	Parms.hateValue = hateValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetAcquiredDragonStones
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<bool>                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<bool> UMonsterBlueprintFunctionLibrary::GetAcquiredDragonStones()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetAcquiredDragonStones");

	Params::MonsterBlueprintFunctionLibrary_GetAcquiredDragonStones Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetAngleToRotatorAndIsLeft
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    isLeft                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         object_rot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMonsterBlueprintFunctionLibrary::GetAngleToRotatorAndIsLeft(bool* isLeft, const struct FRotator& object_rot, class AGPACharacter* Observer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetAngleToRotatorAndIsLeft");

	Params::MonsterBlueprintFunctionLibrary_GetAngleToRotatorAndIsLeft Parms{};

	Parms.object_rot = std::move(object_rot);
	Parms.Observer = Observer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (isLeft != nullptr)
		*isLeft = Parms.isLeft;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetAngleToTargetLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          object_vec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMonsterBlueprintFunctionLibrary::GetAngleToTargetLocation(const struct FVector& object_vec, class AGPACharacter* Observer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetAngleToTargetLocation");

	Params::MonsterBlueprintFunctionLibrary_GetAngleToTargetLocation Parms{};

	Parms.object_vec = std::move(object_vec);
	Parms.Observer = Observer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetAngleToTargetLocationAndIsLeft
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    isLeft                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          object_vec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Observer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMonsterBlueprintFunctionLibrary::GetAngleToTargetLocationAndIsLeft(bool* isLeft, const struct FVector& object_vec, class AGPACharacter* Observer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetAngleToTargetLocationAndIsLeft");

	Params::MonsterBlueprintFunctionLibrary_GetAngleToTargetLocationAndIsLeft Parms{};

	Parms.object_vec = std::move(object_vec);
	Parms.Observer = Observer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (isLeft != nullptr)
		*isLeft = Parms.isLeft;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetBossFormFromType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterBossType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBossForm                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossForm UMonsterBlueprintFunctionLibrary::GetBossFormFromType(EMonsterBossType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetBossFormFromType");

	Params::MonsterBlueprintFunctionLibrary_GetBossFormFromType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetBossName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMonsterBlueprintFunctionLibrary::GetBossName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetBossName");

	Params::MonsterBlueprintFunctionLibrary_GetBossName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetBossType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMonsterBossType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossType UMonsterBlueprintFunctionLibrary::GetBossType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetBossType");

	Params::MonsterBlueprintFunctionLibrary_GetBossType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetBossTypeFromDungeon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMonsterBossType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossType UMonsterBlueprintFunctionLibrary::GetBossTypeFromDungeon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetBossTypeFromDungeon");

	Params::MonsterBlueprintFunctionLibrary_GetBossTypeFromDungeon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetCamOwner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMonsterBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterBase* UMonsterBlueprintFunctionLibrary::GetCamOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetCamOwner");

	Params::MonsterBlueprintFunctionLibrary_GetCamOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetCurrentPersistentLevelID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPersistentLevelID                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPersistentLevelID UMonsterBlueprintFunctionLibrary::GetCurrentPersistentLevelID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetCurrentPersistentLevelID");

	Params::MonsterBlueprintFunctionLibrary_GetCurrentPersistentLevelID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetDir
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          object_vec                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          observer_vec                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMonsterBlueprintFunctionLibrary::GetDir(const struct FVector& object_vec, const struct FVector& observer_vec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetDir");

	Params::MonsterBlueprintFunctionLibrary_GetDir Parms{};

	Parms.object_vec = std::move(object_vec);
	Parms.observer_vec = std::move(observer_vec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetFootLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::GetFootLocation(struct FVector* Out, const class AGPACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetFootLocation");

	Params::MonsterBlueprintFunctionLibrary_GetFootLocation Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetGuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterBase* UMonsterBlueprintFunctionLibrary::GetGuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetGuest");

	Params::MonsterBlueprintFunctionLibrary_GetGuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetGuestID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMonsterBlueprintFunctionLibrary::GetGuestID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetGuestID");

	Params::MonsterBlueprintFunctionLibrary_GetGuestID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetIsDungeon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::GetIsDungeon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetIsDungeon");

	Params::MonsterBlueprintFunctionLibrary_GetIsDungeon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetMonster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonster*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonster* UMonsterBlueprintFunctionLibrary::GetMonster(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetMonster");

	Params::MonsterBlueprintFunctionLibrary_GetMonster Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetMonsterBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonsterBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterBase* UMonsterBlueprintFunctionLibrary::GetMonsterBase(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetMonsterBase");

	Params::MonsterBlueprintFunctionLibrary_GetMonsterBase Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetMonsterBoss
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonsterBoss*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterBoss* UMonsterBlueprintFunctionLibrary::GetMonsterBoss(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetMonsterBoss");

	Params::MonsterBlueprintFunctionLibrary_GetMonsterBoss Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetMonsterTargettingMe
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AMonsterBase*>             Array                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonsterBase*                     own                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::GetMonsterTargettingMe(TArray<class AMonsterBase*>* Array, EMonsterRegisterType Type, class FName Key, const class AMonsterBase* own)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetMonsterTargettingMe");

	Params::MonsterBlueprintFunctionLibrary_GetMonsterTargettingMe Parms{};

	Parms.Type = Type;
	Parms.Key = Key;
	Parms.own = own;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Array != nullptr)
		*Array = std::move(Parms.Array);
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetPartyMonster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonster*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonster* UMonsterBlueprintFunctionLibrary::GetPartyMonster(int32 partyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetPartyMonster");

	Params::MonsterBlueprintFunctionLibrary_GetPartyMonster Parms{};

	Parms.partyIndex = partyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetPartyMonsterUID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMonsterBlueprintFunctionLibrary::GetPartyMonsterUID(int32 partyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetPartyMonsterUID");

	Params::MonsterBlueprintFunctionLibrary_GetPartyMonsterUID Parms{};

	Parms.partyIndex = partyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetRandomPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   division                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::GetRandomPoint(struct FVector* Out, const struct FVector& Center, float Radius, int32 division)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetRandomPoint");

	Params::MonsterBlueprintFunctionLibrary_GetRandomPoint Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.division = division;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetRandomWalkRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMonsterBlueprintFunctionLibrary::GetRandomWalkRange(const class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetRandomWalkRange");

	Params::MonsterBlueprintFunctionLibrary_GetRandomWalkRange Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetSpawnLasboss
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::GetSpawnLasboss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetSpawnLasboss");

	Params::MonsterBlueprintFunctionLibrary_GetSpawnLasboss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterStatus                          Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* UMonsterBlueprintFunctionLibrary::GetTarget(EMonsterRegisterType Type, const class AGPACharacter* Character, EMonsterStatus Status, float Distance, bool Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetTarget");

	Params::MonsterBlueprintFunctionLibrary_GetTarget Parms{};

	Parms.Type = Type;
	Parms.Character = Character;
	Parms.Status = Status;
	Parms.Distance = Distance;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetTargetInSight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterStatus                          Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* UMonsterBlueprintFunctionLibrary::GetTargetInSight(EMonsterRegisterType Type, const class AGPACharacter* Character, EMonsterStatus Status, float Distance, float Angle, bool Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetTargetInSight");

	Params::MonsterBlueprintFunctionLibrary_GetTargetInSight Parms{};

	Parms.Type = Type;
	Parms.Character = Character;
	Parms.Status = Status;
	Parms.Distance = Distance;
	Parms.Angle = Angle;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetTerraceWallNum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMonsterBlueprintFunctionLibrary::GetTerraceWallNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetTerraceWallNum");

	Params::MonsterBlueprintFunctionLibrary_GetTerraceWallNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetTerraceWallOpen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::GetTerraceWallOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetTerraceWallOpen");

	Params::MonsterBlueprintFunctionLibrary_GetTerraceWallOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GetTraceTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGPACharacter* UMonsterBlueprintFunctionLibrary::GetTraceTarget(int32 partyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GetTraceTarget");

	Params::MonsterBlueprintFunctionLibrary_GetTraceTarget Parms{};

	Parms.partyIndex = partyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.GuestLeaveRequest
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterBlueprintFunctionLibrary::GuestLeaveRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "GuestLeaveRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsBossDead
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsBossDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsBossDead");

	Params::MonsterBlueprintFunctionLibrary_IsBossDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsBossReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsBossReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsBossReady");

	Params::MonsterBlueprintFunctionLibrary_IsBossReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsCloseEnough
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsCloseEnough(const struct FVector& Center, const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsCloseEnough");

	Params::MonsterBlueprintFunctionLibrary_IsCloseEnough Parms{};

	Parms.Center = std::move(Center);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsEnableMakeRandomWalkPointThirdCheck
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsEnableMakeRandomWalkPointThirdCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsEnableMakeRandomWalkPointThirdCheck");

	Params::MonsterBlueprintFunctionLibrary_IsEnableMakeRandomWalkPointThirdCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsFarEnough
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsFarEnough(const struct FVector& Center, const struct FVector& Location, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsFarEnough");

	Params::MonsterBlueprintFunctionLibrary_IsFarEnough Parms{};

	Parms.Center = std::move(Center);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsForceBattlePlaying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsForceBattlePlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsForceBattlePlaying");

	Params::MonsterBlueprintFunctionLibrary_IsForceBattlePlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsLastBossReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsLastBossReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsLastBossReady");

	Params::MonsterBlueprintFunctionLibrary_IsLastBossReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsLocationHeightTolerance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGPACharacter*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsLocationHeightTolerance(class AMonsterBase* Owner, class AGPACharacter* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsLocationHeightTolerance");

	Params::MonsterBlueprintFunctionLibrary_IsLocationHeightTolerance Parms{};

	Parms.Owner = Owner;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsReleaseFlag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             KeyName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsReleaseFlag(class FName KeyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsReleaseFlag");

	Params::MonsterBlueprintFunctionLibrary_IsReleaseFlag Parms{};

	Parms.KeyName = KeyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.IsSpecialAbility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::IsSpecialAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "IsSpecialAbility");

	Params::MonsterBlueprintFunctionLibrary_IsSpecialAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.Preload
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::Preload(const class FName& KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "Preload");

	Params::MonsterBlueprintFunctionLibrary_Preload Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.Relocation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBlueprintFunctionLibrary::Relocation(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "Relocation");

	Params::MonsterBlueprintFunctionLibrary_Relocation Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.RequestLeaveBySpawnID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SpawnPointID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::RequestLeaveBySpawnID(class FName SpawnPointID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "RequestLeaveBySpawnID");

	Params::MonsterBlueprintFunctionLibrary_RequestLeaveBySpawnID Parms{};

	Parms.SpawnPointID = SpawnPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.RequestLeaveBySpawnPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEnemySpawnGeneratorBase*         spawnPoint                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::RequestLeaveBySpawnPoint(class UEnemySpawnGeneratorBase* spawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "RequestLeaveBySpawnPoint");

	Params::MonsterBlueprintFunctionLibrary_RequestLeaveBySpawnPoint Parms{};

	Parms.spawnPoint = spawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetAcquiredDragonStones
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<bool>                            arr                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetAcquiredDragonStones(const TArray<bool>& arr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetAcquiredDragonStones");

	Params::MonsterBlueprintFunctionLibrary_SetAcquiredDragonStones Parms{};

	Parms.arr = std::move(arr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetBossBattleStartWaiting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetBossBattleStartWaiting(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetBossBattleStartWaiting");

	Params::MonsterBlueprintFunctionLibrary_SetBossBattleStartWaiting Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetBossPause
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Pause                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetBossPause(bool Pause, bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetBossPause");

	Params::MonsterBlueprintFunctionLibrary_SetBossPause Parms{};

	Parms.Pause = Pause;
	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetBossType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterBossType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetBossType(EMonsterBossType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetBossType");

	Params::MonsterBlueprintFunctionLibrary_SetBossType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetBossTypeToDungeon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterBossType                        BossType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetBossTypeToDungeon(EMonsterBossType BossType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetBossTypeToDungeon");

	Params::MonsterBlueprintFunctionLibrary_SetBossTypeToDungeon Parms{};

	Parms.BossType = BossType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetBossVisible
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetBossVisible(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetBossVisible");

	Params::MonsterBlueprintFunctionLibrary_SetBossVisible Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetCamOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetCamOwner(class AMonsterBase* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetCamOwner");

	Params::MonsterBlueprintFunctionLibrary_SetCamOwner Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetFriendMonsterLocationPlayerAround
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterBlueprintFunctionLibrary::SetFriendMonsterLocationPlayerAround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetFriendMonsterLocationPlayerAround");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetHideEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetHideEffect(bool hide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetHideEffect");

	Params::MonsterBlueprintFunctionLibrary_SetHideEffect Parms{};

	Parms.hide = hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetHideEffectToEffectAndMonsterType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterHideEffect                      Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    MonsterType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetHideEffectToEffectAndMonsterType(bool hide, EMonsterHideEffect Effect, EMonsterRegisterType MonsterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetHideEffectToEffectAndMonsterType");

	Params::MonsterBlueprintFunctionLibrary_SetHideEffectToEffectAndMonsterType Parms{};

	Parms.hide = hide;
	Parms.Effect = Effect;
	Parms.MonsterType = MonsterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetHideEffectToMonsterType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    MonsterType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetHideEffectToMonsterType(bool hide, EMonsterRegisterType MonsterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetHideEffectToMonsterType");

	Params::MonsterBlueprintFunctionLibrary_SetHideEffectToMonsterType Parms{};

	Parms.hide = hide;
	Parms.MonsterType = MonsterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetHideEffectToType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterHideEffect                      Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetHideEffectToType(bool hide, EMonsterHideEffect Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetHideEffectToType");

	Params::MonsterBlueprintFunctionLibrary_SetHideEffectToType Parms{};

	Parms.hide = hide;
	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetIsDungeon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetIsDungeon(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetIsDungeon");

	Params::MonsterBlueprintFunctionLibrary_SetIsDungeon Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetLastBossBattleStartWaiting
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetLastBossBattleStartWaiting(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetLastBossBattleStartWaiting");

	Params::MonsterBlueprintFunctionLibrary_SetLastBossBattleStartWaiting Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetMoveAwayQueryParams
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetMoveAwayQueryParams(const class AMonsterBase* Monster, float Radius, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetMoveAwayQueryParams");

	Params::MonsterBlueprintFunctionLibrary_SetMoveAwayQueryParams Parms{};

	Parms.Monster = Monster;
	Parms.Radius = Radius;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetSpawnLasboss
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetSpawnLasboss(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetSpawnLasboss");

	Params::MonsterBlueprintFunctionLibrary_SetSpawnLasboss Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SetWaitTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SetWaitTime(const class AMonsterBase* Monster, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SetWaitTime");

	Params::MonsterBlueprintFunctionLibrary_SetWaitTime Parms{};

	Parms.Monster = Monster;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBlueprintFunctionLibrary.SpawnGuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             guestid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBlueprintFunctionLibrary::SpawnGuest(class FName guestid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterBlueprintFunctionLibrary", "SpawnGuest");

	Params::MonsterBlueprintFunctionLibrary_SpawnGuest Parms{};

	Parms.guestid = guestid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBTTaskExecuter.AvortTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBTTask                          Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBTTaskExecuter::AvortTask(class AMonsterBase* Monster, EMonsterBTTask Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBTTaskExecuter", "AvortTask");

	Params::MonsterBTTaskExecuter_AvortTask Parms{};

	Parms.Monster = Monster;
	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBTTaskExecuter.ExecuteTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBTTask                          Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterBTTaskExecuter::ExecuteTask(class AMonsterBase* Monster, EMonsterBTTask Task, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBTTaskExecuter", "ExecuteTask");

	Params::MonsterBTTaskExecuter_ExecuteTask Parms{};

	Parms.Monster = Monster;
	Parms.Task = Task;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterBTTaskExecuter.FinishTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBTTask                          Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBTTaskExecuter::FinishTask(class AMonsterBase* Monster, EMonsterBTTask Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBTTaskExecuter", "FinishTask");

	Params::MonsterBTTaskExecuter_FinishTask Parms{};

	Parms.Monster = Monster;
	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterBTTaskExecuter.InitTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterBTTask                          Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterBTTaskExecuter::InitTask(class AMonsterBase* Monster, EMonsterBTTask Task)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterBTTaskExecuter", "InitTask");

	Params::MonsterBTTaskExecuter_InitTask Parms{};

	Parms.Monster = Monster;
	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetSystemComponent.Aim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetSystemComponent::Aim(bool End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetSystemComponent", "Aim");

	Params::TargetSystemComponent_Aim Parms{};

	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetSystemComponent.NextTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AddValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetSystemComponent::NextTarget(int32 AddValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetSystemComponent", "NextTarget");

	Params::TargetSystemComponent_NextTarget Parms{};

	Parms.AddValue = AddValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetSystemComponent.ReleaseAimAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStateEnd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTargetSystemComponent::ReleaseAimAssist(bool bStateEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetSystemComponent", "ReleaseAimAssist");

	Params::TargetSystemComponent_ReleaseAimAssist Parms{};

	Parms.bStateEnd = bStateEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetSystemComponent.CanChangeTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTargetSystemComponent::CanChangeTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetSystemComponent", "CanChangeTarget");

	Params::TargetSystemComponent_CanChangeTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TargetSystemComponent.GetTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UTargetSystemComponent::GetTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetSystemComponent", "GetTarget");

	Params::TargetSystemComponent_GetTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterCustomMaterialDataTable.GetCustomMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UMaterialInstance>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UMaterialInstance>> UMonsterCustomMaterialDataTable::GetCustomMaterial(class FName KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterCustomMaterialDataTable", "GetCustomMaterial");

	Params::MonsterCustomMaterialDataTable_GetCustomMaterial Parms{};

	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RiverBase.OnBeginOverlapCollision
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARiverBase::OnBeginOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverBase", "OnBeginOverlapCollision");

	Params::RiverBase_OnBeginOverlapCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RiverBase.OnEndOverlapCollision
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARiverBase::OnEndOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiverBase", "OnEndOverlapCollision");

	Params::RiverBase_OnEndOverlapCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterInterface.DeactivationService
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMonsterInterface::DeactivationService()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterInterface", "DeactivationService");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterInterface.UpdateService
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMonsterInterface::UpdateService()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterInterface", "UpdateService");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMonsterManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMonsterManager* UMonsterManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterManager", "GetInstance");

	Params::MonsterManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.AddMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::AddMonster(const class AMonsterBase* Monster, EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "AddMonster");

	Params::MonsterManager_AddMonster Parms{};

	Parms.Monster = Monster;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ChangeBelong
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::ChangeBelong(const class AMonster* Monster, EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ChangeBelong");

	Params::MonsterManager_ChangeBelong Parms{};

	Parms.Monster = Monster;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ClearFastTravel
// (Final, Native, Public, BlueprintCallable)

void UMonsterManager::ClearFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ClearFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ClearMonsterOfProvocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::ClearMonsterOfProvocation(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ClearMonsterOfProvocation");

	Params::MonsterManager_ClearMonsterOfProvocation Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.DestroyMonsterByBattleID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BattleID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::DestroyMonsterByBattleID(class FName BattleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "DestroyMonsterByBattleID");

	Params::MonsterManager_DestroyMonsterByBattleID Parms{};

	Parms.BattleID = BattleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.DestroyMonsterByThoughtType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterThoughtType                     ThoughtType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::DestroyMonsterByThoughtType(EMonsterThoughtType ThoughtType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "DestroyMonsterByThoughtType");

	Params::MonsterManager_DestroyMonsterByThoughtType Parms{};

	Parms.ThoughtType = ThoughtType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.EnqueueRequestSpawnParam
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCommonSpawnParam                spawnParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMonsterManager::EnqueueRequestSpawnParam(class FName KindId, const struct FCommonSpawnParam& spawnParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "EnqueueRequestSpawnParam");

	Params::MonsterManager_EnqueueRequestSpawnParam Parms{};

	Parms.KindId = KindId;
	Parms.spawnParam = std::move(spawnParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.GetBossDerived
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMonsterBossType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossType UMonsterManager::GetBossDerived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetBossDerived");

	Params::MonsterManager_GetBossDerived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetBossType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EMonsterBossType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMonsterBossType UMonsterManager::GetBossType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetBossType");

	Params::MonsterManager_GetBossType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetFastTravel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMonsterManager::GetFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetFastTravel");

	Params::MonsterManager_GetFastTravel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetMonsterOfProvocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMonsterBase*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMonsterBase* UMonsterManager::GetMonsterOfProvocation(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetMonsterOfProvocation");

	Params::MonsterManager_GetMonsterOfProvocation Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetMonsters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMonsterBase*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AMonsterBase*> UMonsterManager::GetMonsters(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetMonsters");

	Params::MonsterManager_GetMonsters Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetMonstersWithList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<EMonsterRegisterType>            TypeList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMonsterBase*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AMonsterBase*> UMonsterManager::GetMonstersWithList(const TArray<EMonsterRegisterType>& TypeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetMonstersWithList");

	Params::MonsterManager_GetMonstersWithList Parms{};

	Parms.TypeList = std::move(TypeList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetPauseFlag
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterManager::GetPauseFlag(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetPauseFlag");

	Params::MonsterManager_GetPauseFlag Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.GetPushBackType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMonsterManager::GetPushBackType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetPushBackType");

	Params::MonsterManager_GetPushBackType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.HiddenDeadIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::HiddenDeadIcon(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "HiddenDeadIcon");

	Params::MonsterManager_HiddenDeadIcon Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.IsBoss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterManager::IsBoss(const class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "IsBoss");

	Params::MonsterManager_IsBoss Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.IsEnemy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterManager::IsEnemy(const class AMonster* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "IsEnemy");

	Params::MonsterManager_IsEnemy Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.IsEnemyBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterManager::IsEnemyBase(const class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "IsEnemyBase");

	Params::MonsterManager_IsEnemyBase Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.IsSpecialAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterManager::IsSpecialAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "IsSpecialAbility");

	Params::MonsterManager_IsSpecialAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.NoticeEndRevengeBattle
// (Final, Native, Public, BlueprintCallable)

void UMonsterManager::NoticeEndRevengeBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "NoticeEndRevengeBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.NoticeStartRevengeBattle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          FlagLocaton                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BattleID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Subtract                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class AMonsterBase* spawned)>begin_func                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class AMonsterBase* deaded)>end_func                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UMonsterManager::NoticeStartRevengeBattle(const struct FVector& FlagLocaton, class FName BattleID, int32 Subtract, TDelegate<void(class AMonsterBase* spawned)> begin_func, TDelegate<void(class AMonsterBase* deaded)> end_func)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "NoticeStartRevengeBattle");

	Params::MonsterManager_NoticeStartRevengeBattle Parms{};

	Parms.FlagLocaton = std::move(FlagLocaton);
	Parms.BattleID = BattleID;
	Parms.Subtract = Subtract;
	Parms.begin_func = begin_func;
	Parms.end_func = end_func;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.PauseAttributeWithoutBoss
// (Final, Native, Public, BlueprintCallable)

void UMonsterManager::PauseAttributeWithoutBoss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "PauseAttributeWithoutBoss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.PauseMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::PauseMonster(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "PauseMonster");

	Params::MonsterManager_PauseMonster Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.PauseMonsterWithoutBoss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Logic                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::PauseMonsterWithoutBoss(bool Logic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "PauseMonsterWithoutBoss");

	Params::MonsterManager_PauseMonsterWithoutBoss Parms{};

	Parms.Logic = Logic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.Remove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::Remove(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "Remove");

	Params::MonsterManager_Remove Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.RemoveAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::RemoveAll(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "RemoveAll");

	Params::MonsterManager_RemoveAll Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.RemoveFromSpawnID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             spawn_point_id                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::RemoveFromSpawnID(class FName spawn_point_id, EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "RemoveFromSpawnID");

	Params::MonsterManager_RemoveFromSpawnID Parms{};

	Parms.spawn_point_id = spawn_point_id;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.RequestSpawnParameterID
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   MonsterParameterId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlaceType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EcologicalAiType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             spawn_point_id                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         rot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EEnemySpawnGeneratorType                parentType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHighAltitude                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::RequestSpawnParameterID(int32 MonsterParameterId, int32 PlaceType, class FName EcologicalAiType, EMonsterRegisterType Type, const struct FVector& Pos, class FName spawn_point_id, const struct FRotator& rot, EEnemySpawnGeneratorType parentType, int32 SpawnPriority, bool IsHighAltitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "RequestSpawnParameterID");

	Params::MonsterManager_RequestSpawnParameterID Parms{};

	Parms.MonsterParameterId = MonsterParameterId;
	Parms.PlaceType = PlaceType;
	Parms.EcologicalAiType = EcologicalAiType;
	Parms.Type = Type;
	Parms.Pos = std::move(Pos);
	Parms.spawn_point_id = spawn_point_id;
	Parms.rot = std::move(rot);
	Parms.parentType = parentType;
	Parms.SpawnPriority = SpawnPriority;
	Parms.IsHighAltitude = IsHighAltitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ResetTimeScale
// (Final, Native, Public, BlueprintCallable)

void UMonsterManager::ResetTimeScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ResetTimeScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ResumeAttributeWithoutBoss
// (Final, Native, Public, BlueprintCallable)

void UMonsterManager::ResumeAttributeWithoutBoss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ResumeAttributeWithoutBoss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ResumeMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::ResumeMonster(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ResumeMonster");

	Params::MonsterManager_ResumeMonster Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.ResumeMonsterWithoutBoss
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Logic                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::ResumeMonsterWithoutBoss(bool Logic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "ResumeMonsterWithoutBoss");

	Params::MonsterManager_ResumeMonsterWithoutBoss Parms{};

	Parms.Logic = Logic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetBossDerived
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   derived                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetBossDerived(int32 derived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetBossDerived");

	Params::MonsterManager_SetBossDerived Parms{};

	Parms.derived = derived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetBossType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMonsterBossType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetBossType(EMonsterBossType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetBossType");

	Params::MonsterManager_SetBossType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetDistanceCheckSkip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    skipFlag                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetDistanceCheckSkip(const bool skipFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetDistanceCheckSkip");

	Params::MonsterManager_SetDistanceCheckSkip Parms{};

	Parms.skipFlag = skipFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetFastTravel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetFastTravel(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetFastTravel");

	Params::MonsterManager_SetFastTravel Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetIsStopUpdateMonsters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetIsStopUpdateMonsters(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetIsStopUpdateMonsters");

	Params::MonsterManager_SetIsStopUpdateMonsters Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetPlayerAccessingArtifact
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AArtifactObjectBase*              Artifact                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetPlayerAccessingArtifact(class AArtifactObjectBase* Artifact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetPlayerAccessingArtifact");

	Params::MonsterManager_SetPlayerAccessingArtifact Parms{};

	Parms.Artifact = Artifact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetPushBackType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetPushBackType(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetPushBackType");

	Params::MonsterManager_SetPushBackType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.SetTimeScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterManager::SetTimeScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "SetTimeScale");

	Params::MonsterManager_SetTimeScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.Spawn
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCommonSpawnParam                spawnParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMonsterManager::Spawn(class FName KindId, const struct FCommonSpawnParam& spawnParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "Spawn");

	Params::MonsterManager_Spawn Parms{};

	Parms.KindId = KindId;
	Parms.spawnParam = std::move(spawnParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterManager.GetPlayerAccessingArtifact
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AArtifactObjectBase*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AArtifactObjectBase* UMonsterManager::GetPlayerAccessingArtifact() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "GetPlayerAccessingArtifact");

	Params::MonsterManager_GetPlayerAccessingArtifact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterManager.IsDistanceCheckSkip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterManager::IsDistanceCheckSkip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterManager", "IsDistanceCheckSkip");

	Params::MonsterManager_IsDistanceCheckSkip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RuinsDoor.PlayClose
// (Final, Native, Public, BlueprintCallable)

void ARuinsDoor::PlayClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "PlayClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RuinsDoor.PlayOpen
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuinsDoor::PlayOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "PlayOpen");

	Params::RuinsDoor_PlayOpen Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RuinsDoor.ReceivePlayClose
// (Event, Protected, BlueprintEvent)

void ARuinsDoor::ReceivePlayClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "ReceivePlayClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.RuinsDoor.ReceivePlayOpen
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuinsDoor::ReceivePlayOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "ReceivePlayOpen");

	Params::RuinsDoor_ReceivePlayOpen Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.RuinsDoor.ReceiveSetClose
// (Event, Protected, BlueprintEvent)

void ARuinsDoor::ReceiveSetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "ReceiveSetClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.RuinsDoor.ReceiveSetOpen
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuinsDoor::ReceiveSetOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "ReceiveSetOpen");

	Params::RuinsDoor_ReceiveSetOpen Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.RuinsDoor.SetClose
// (Final, Native, Public, BlueprintCallable)

void ARuinsDoor::SetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "SetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RuinsDoor.SetOpen
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARuinsDoor::SetOpen(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RuinsDoor", "SetOpen");

	Params::RuinsDoor_SetOpen Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterParameterDataTable.GetDropItemInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MonsterParamID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_DropItemInfo>         DropItemInfos                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterParameterDataTable::GetDropItemInfo(class FName MonsterParamID, TArray<struct FST_DropItemInfo>* DropItemInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterParameterDataTable", "GetDropItemInfo");

	Params::MonsterParameterDataTable_GetDropItemInfo Parms{};

	Parms.MonsterParamID = MonsterParamID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DropItemInfos != nullptr)
		*DropItemInfos = std::move(Parms.DropItemInfos);
}


// Function DarwinGame.MonsterParameterDataTable.GetExpGain
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MonsterId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMonsterParameterDataTable::GetExpGain(class FName MonsterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterParameterDataTable", "GetExpGain");

	Params::MonsterParameterDataTable_GetExpGain Parms{};

	Parms.MonsterId = MonsterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterParameterDataTable.GetKindID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MonsterId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMonsterParameterDataTable::GetKindID(class FName MonsterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterParameterDataTable", "GetKindID");

	Params::MonsterParameterDataTable_GetKindID Parms{};

	Parms.MonsterId = MonsterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterParameterDataTable.GetLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MonsterId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMonsterParameterDataTable::GetLevel(class FName MonsterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterParameterDataTable", "GetLevel");

	Params::MonsterParameterDataTable_GetLevel Parms{};

	Parms.MonsterId = MonsterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterRelocationBlueprintFunctionLibrary.Main
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterRelocationBlueprintFunctionLibrary::Main(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterRelocationBlueprintFunctionLibrary", "Main");

	Params::MonsterRelocationBlueprintFunctionLibrary_Main Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterRingComponent.GetRingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AStaticMeshActor*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AStaticMeshActor* UMonsterRingComponent::GetRingActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterRingComponent", "GetRingActor");

	Params::MonsterRingComponent_GetRingActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterRivalTeamLotteryWeight.RandomSelectRivalTeamForce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ERivalTeamForce                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERivalTeamForce UMonsterRivalTeamLotteryWeight::RandomSelectRivalTeamForce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterRivalTeamLotteryWeight", "RandomSelectRivalTeamForce");

	Params::MonsterRivalTeamLotteryWeight_RandomSelectRivalTeamForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SectorAreaOfEffect.SetAngleType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESectorAoEAngle                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASectorAreaOfEffect::SetAngleType(ESectorAoEAngle Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SectorAreaOfEffect", "SetAngleType");

	Params::SectorAreaOfEffect_SetAngleType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SectorAreaOfEffect.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rad                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASectorAreaOfEffect::SetRadius(float Rad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SectorAreaOfEffect", "SetRadius");

	Params::SectorAreaOfEffect_SetRadius Parms{};

	Parms.Rad = Rad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.CancelActionState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    registerType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::CancelActionState(EMonsterRegisterType registerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "CancelActionState");

	Params::MonsterSpecialAbilityFunctionLibrary_CancelActionState Parms{};

	Parms.registerType = registerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.CloseAbilityName
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterSpecialAbilityFunctionLibrary::CloseAbilityName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "CloseAbilityName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.CloseScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterSpecialAbilityFunctionLibrary::CloseScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "CloseScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.DisableInvincibleSingle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::DisableInvincibleSingle(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "DisableInvincibleSingle");

	Params::MonsterSpecialAbilityFunctionLibrary_DisableInvincibleSingle Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.IsCancel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterSpecialAbilityFunctionLibrary::IsCancel(class AMonsterBase* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "IsCancel");

	Params::MonsterSpecialAbilityFunctionLibrary_IsCancel Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.LoadAbilityCueSheet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::LoadAbilityCueSheet(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "LoadAbilityCueSheet");

	Params::MonsterSpecialAbilityFunctionLibrary_LoadAbilityCueSheet Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.OpenAbilityName
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterSpecialAbilityFunctionLibrary::OpenAbilityName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "OpenAbilityName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.OpenScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterSpecialAbilityFunctionLibrary::OpenScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "OpenScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.ReleaseAbilityCueSheet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::ReleaseAbilityCueSheet(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "ReleaseAbilityCueSheet");

	Params::MonsterSpecialAbilityFunctionLibrary_ReleaseAbilityCueSheet Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.SetEnvironmentEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::SetEnvironmentEnable(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "SetEnvironmentEnable");

	Params::MonsterSpecialAbilityFunctionLibrary_SetEnvironmentEnable Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.SetMonsterTimerPause
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isPause                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::SetMonsterTimerPause(class AMonsterBase* Monster, bool isPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "SetMonsterTimerPause");

	Params::MonsterSpecialAbilityFunctionLibrary_SetMonsterTimerPause Parms{};

	Parms.Monster = Monster;
	Parms.isPause = isPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.SetPlayerInputEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::SetPlayerInputEnable(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "SetPlayerInputEnable");

	Params::MonsterSpecialAbilityFunctionLibrary_SetPlayerInputEnable Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.SetupAbilityName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::SetupAbilityName(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "SetupAbilityName");

	Params::MonsterSpecialAbilityFunctionLibrary_SetupAbilityName Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.StopMonstersWithoutOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonster*                         Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::StopMonstersWithoutOwner(class AMonster* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "StopMonstersWithoutOwner");

	Params::MonsterSpecialAbilityFunctionLibrary_StopMonstersWithoutOwner Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilityFunctionLibrary.UnRegisterFieldTerrainInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AGPACharacter*                    Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterSpecialAbilityFunctionLibrary::UnRegisterFieldTerrainInfo(class AGPACharacter* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterSpecialAbilityFunctionLibrary", "UnRegisterFieldTerrainInfo");

	Params::MonsterSpecialAbilityFunctionLibrary_UnRegisterFieldTerrainInfo Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterSpecialAbilitySequenceDelegater.Execute
// (Final, Native, Public)

void UMonsterSpecialAbilitySequenceDelegater::Execute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpecialAbilitySequenceDelegater", "Execute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILoadContent.ExecLoad
// (Final, Native, Protected)

void UUILoadContent::ExecLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILoadContent", "ExecLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILoadContent.FadeOutEnd
// (Final, Native, Protected)

void UUILoadContent::FadeOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILoadContent", "FadeOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILoadContent.LoadDialogCallback
// (Final, Native, Protected)
// Parameters:
// bool                                    IsYes                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUILoadContent::LoadDialogCallback(bool IsYes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILoadContent", "LoadDialogCallback");

	Params::UILoadContent_LoadDialogCallback Parms{};

	Parms.IsYes = IsYes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.ApplyAttributeToMonsters
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::ApplyAttributeToMonsters(EMonsterRegisterType Type, class FName AttributeID, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "ApplyAttributeToMonsters");

	Params::MonsterStateBlueprintFunctionLibrary_ApplyAttributeToMonsters Parms{};

	Parms.Type = Type;
	Parms.AttributeID = AttributeID;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.GetMonstersHidden
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterStateBlueprintFunctionLibrary::GetMonstersHidden(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "GetMonstersHidden");

	Params::MonsterStateBlueprintFunctionLibrary_GetMonstersHidden Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.GetMonstersStopLogic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterStateBlueprintFunctionLibrary::GetMonstersStopLogic(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "GetMonstersStopLogic");

	Params::MonsterStateBlueprintFunctionLibrary_GetMonstersStopLogic Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.HasMonster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterStateBlueprintFunctionLibrary::HasMonster(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "HasMonster");

	Params::MonsterStateBlueprintFunctionLibrary_HasMonster Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.IsBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterStateBlueprintFunctionLibrary::IsBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "IsBattle");

	Params::MonsterStateBlueprintFunctionLibrary_IsBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.PauseAllMonsters
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterStateBlueprintFunctionLibrary::PauseAllMonsters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "PauseAllMonsters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.PauseEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::PauseEnemy(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "PauseEnemy");

	Params::MonsterStateBlueprintFunctionLibrary_PauseEnemy Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.PauseToType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::PauseToType(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "PauseToType");

	Params::MonsterStateBlueprintFunctionLibrary_PauseToType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.PlayCharacterCommonEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterCommonEffectID                EffectId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::PlayCharacterCommonEffect(EMonsterRegisterType Type, ECharacterCommonEffectID EffectId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "PlayCharacterCommonEffect");

	Params::MonsterStateBlueprintFunctionLibrary_PlayCharacterCommonEffect Parms{};

	Parms.Type = Type;
	Parms.EffectId = EffectId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.ReleaseAttributeFromMonsters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMonsterBase*>             ignores                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::ReleaseAttributeFromMonsters(EMonsterRegisterType Type, class FName AttributeID, TArray<class AMonsterBase*>* ignores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "ReleaseAttributeFromMonsters");

	Params::MonsterStateBlueprintFunctionLibrary_ReleaseAttributeFromMonsters Parms{};

	Parms.Type = Type;
	Parms.AttributeID = AttributeID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ignores != nullptr)
		*ignores = std::move(Parms.ignores);
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.ResumeAllMonsters
// (Final, Native, Static, Public, BlueprintCallable)

void UMonsterStateBlueprintFunctionLibrary::ResumeAllMonsters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "ResumeAllMonsters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.ResumeEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::ResumeEnemy(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "ResumeEnemy");

	Params::MonsterStateBlueprintFunctionLibrary_ResumeEnemy Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.ResumeToType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::ResumeToType(EMonsterRegisterType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "ResumeToType");

	Params::MonsterStateBlueprintFunctionLibrary_ResumeToType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.RivalTeamIsBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterStateBlueprintFunctionLibrary::RivalTeamIsBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "RivalTeamIsBattle");

	Params::MonsterStateBlueprintFunctionLibrary_RivalTeamIsBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetHide
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetHide(class AMonsterBase* Monster, bool IsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetHide");

	Params::MonsterStateBlueprintFunctionLibrary_SetHide Parms{};

	Parms.Monster = Monster;
	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetHideFriendsWithoutSpecifiedFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetHideFriendsWithoutSpecifiedFriend(class AMonsterBase* Monster, bool IsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetHideFriendsWithoutSpecifiedFriend");

	Params::MonsterStateBlueprintFunctionLibrary_SetHideFriendsWithoutSpecifiedFriend Parms{};

	Parms.Monster = Monster;
	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetHideToList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AMonsterBase*>             MonsterList                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHide                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetHideToList(TArray<class AMonsterBase*>* MonsterList, const bool IsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetHideToList");

	Params::MonsterStateBlueprintFunctionLibrary_SetHideToList Parms{};

	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MonsterList != nullptr)
		*MonsterList = std::move(Parms.MonsterList);
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetHideToListReturnList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AMonsterBase*>             MonsterList                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHide                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMonsterBase*>             OutMonsterList                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetHideToListReturnList(TArray<class AMonsterBase*>* MonsterList, const bool IsHide, TArray<class AMonsterBase*>* OutMonsterList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetHideToListReturnList");

	Params::MonsterStateBlueprintFunctionLibrary_SetHideToListReturnList Parms{};

	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MonsterList != nullptr)
		*MonsterList = std::move(Parms.MonsterList);

	if (OutMonsterList != nullptr)
		*OutMonsterList = std::move(Parms.OutMonsterList);
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetHideToType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetHideToType(EMonsterRegisterType Type, bool IsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetHideToType");

	Params::MonsterStateBlueprintFunctionLibrary_SetHideToType Parms{};

	Parms.Type = Type;
	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetHideToTypeReturnList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMonsterBase*>             OutMonsterList                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetHideToTypeReturnList(EMonsterRegisterType Type, bool IsHide, TArray<class AMonsterBase*>* OutMonsterList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetHideToTypeReturnList");

	Params::MonsterStateBlueprintFunctionLibrary_SetHideToTypeReturnList Parms{};

	Parms.Type = Type;
	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMonsterList != nullptr)
		*OutMonsterList = std::move(Parms.OutMonsterList);
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetMonstersTickEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetMonstersTickEnabled(EMonsterRegisterType Type, bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetMonstersTickEnabled");

	Params::MonsterStateBlueprintFunctionLibrary_SetMonstersTickEnabled Parms{};

	Parms.Type = Type;
	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MonsterStateBlueprintFunctionLibrary.SetPauseMonstersActiveGameplayEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EMonsterRegisterType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Pause                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AMonsterBase*>             ignores                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMonsterStateBlueprintFunctionLibrary::SetPauseMonstersActiveGameplayEffect(EMonsterRegisterType Type, bool Pause, TArray<class AMonsterBase*>* ignores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MonsterStateBlueprintFunctionLibrary", "SetPauseMonstersActiveGameplayEffect");

	Params::MonsterStateBlueprintFunctionLibrary_SetPauseMonstersActiveGameplayEffect Parms{};

	Parms.Type = Type;
	Parms.Pause = Pause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ignores != nullptr)
		*ignores = std::move(Parms.ignores);
}


// Function DarwinGame.MonsterTableComponent.FindEcologicalMotionData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AMonster*                         Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MotionID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterTableComponent::FindEcologicalMotionData(class AMonster* Monster, class FName MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterTableComponent", "FindEcologicalMotionData");

	Params::MonsterTableComponent_FindEcologicalMotionData Parms{};

	Parms.Monster = Monster;
	Parms.MotionID = MotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MonsterTableComponent.GetEcologicalMotionData
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FST_EcologicalMotionData         Out                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// class AMonster*                         Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MotionID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMonsterTableComponent::GetEcologicalMotionData(struct FST_EcologicalMotionData* Out, class AMonster* Monster, class FName MotionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterTableComponent", "GetEcologicalMotionData");

	Params::MonsterTableComponent_GetEcologicalMotionData Parms{};

	Parms.Monster = Monster;
	Parms.MotionID = MotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);

	return Parms.ReturnValue;
}


// Function DarwinGame.UICircleGaugeBase.PlaySuccessAnim
// (Native, Public, BlueprintCallable)

void UUICircleGaugeBase::PlaySuccessAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICircleGaugeBase", "PlaySuccessAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICircleGaugeBase.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICircleGaugeBase::SetPercent(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICircleGaugeBase", "SetPercent");

	Params::UICircleGaugeBase_SetPercent Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICircleGaugeBase.SuccessAnimEnd
// (Final, Native, Private)

void UUICircleGaugeBase::SuccessAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICircleGaugeBase", "SuccessAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerControllerInterface.PossessCamera
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADarwinCamera*                    Camera                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPlayerControllerInterface::PossessCamera(class ADarwinCamera* Camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerInterface", "PossessCamera");

	Params::PlayerControllerInterface_PossessCamera Parms{};

	Parms.Camera = Camera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerControllerInterface.GetControlledCamera
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ADarwinCamera*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADarwinCamera* IPlayerControllerInterface::GetControlledCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerInterface", "GetControlledCamera");

	Params::PlayerControllerInterface_GetControlledCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MyTeamFunctionLibrary.AddTeamArtifactValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   UpArtifactValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMyTeamFunctionLibrary::AddTeamArtifactValue(int64 UpArtifactValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MyTeamFunctionLibrary", "AddTeamArtifactValue");

	Params::MyTeamFunctionLibrary_AddTeamArtifactValue Parms{};

	Parms.UpArtifactValue = UpArtifactValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.MyTeamFunctionLibrary.GetTeamFlagID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMyTeamFunctionLibrary::GetTeamFlagID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MyTeamFunctionLibrary", "GetTeamFlagID");

	Params::MyTeamFunctionLibrary_GetTeamFlagID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MyTeamFunctionLibrary.IsTeamLevelUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMyTeamFunctionLibrary::IsTeamLevelUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MyTeamFunctionLibrary", "IsTeamLevelUp");

	Params::MyTeamFunctionLibrary_IsTeamLevelUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.MyTeamLevelDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UMyTeamLevelDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MyTeamLevelDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.GetSocketNameFromESoket
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// ESocket                                 socket                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ANPCBase::GetSocketNameFromESoket(const ESocket socket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NPCBase", "GetSocketNameFromESoket");

	Params::NPCBase_GetSocketNameFromESoket Parms{};

	Parms.socket = socket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.AiTick
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::AiTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "AiTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ChangeEmoteList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENPCEmotePart                           PartID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EmoteID                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::ChangeEmoteList(const ENPCEmotePart PartID, const int32 EmoteID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ChangeEmoteList");

	Params::NPCBase_ChangeEmoteList Parms{};

	Parms.PartID = PartID;
	Parms.EmoteID = EmoteID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ChangeNPCAiTypeToNormal
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::ChangeNPCAiTypeToNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ChangeNPCAiTypeToNormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.CheckAndPlayPartVoice
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           Src                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::CheckAndPlayPartVoice(const class FString& Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "CheckAndPlayPartVoice");

	Params::NPCBase_CheckAndPlayPartVoice Parms{};

	Parms.Src = std::move(Src);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.CloseFukidashiWithoutStamp
// (Event, Public, BlueprintEvent)

void ANPCBase::CloseFukidashiWithoutStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "CloseFukidashiWithoutStamp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.CloseIcon
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ANPCBase::CloseIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "CloseIcon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.CloseNearUI
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::CloseNearUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "CloseNearUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.CompLoad
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FName                             AppearanceID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::CompLoad(class FName AppearanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "CompLoad");

	Params::NPCBase_CompLoad Parms{};

	Parms.AppearanceID = AppearanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.DisableMoveCapsule
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::DisableMoveCapsule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "DisableMoveCapsule");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.EnableMoveCapsule
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::EnableMoveCapsule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "EnableMoveCapsule");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.EndEvent
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::EndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "EndEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.EndNPCAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::EndNPCAnimState(const struct FGameplayTag& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "EndNPCAnimState");

	Params::NPCBase_EndNPCAnimState Parms{};

	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.GetAcceptableRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANPCBase::GetAcceptableRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAcceptableRadius");

	Params::NPCBase_GetAcceptableRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetAiEventMoveParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FST_NPCEventAiMovePoints   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FST_NPCEventAiMovePoints ANPCBase::GetAiEventMoveParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAiEventMoveParam");

	Params::NPCBase_GetAiEventMoveParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetAIIsWalkFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetAIIsWalkFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAIIsWalkFlag");

	Params::NPCBase_GetAIIsWalkFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetAIPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     Points                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::GetAIPoints(TArray<class FName>* Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAIPoints");

	Params::NPCBase_GetAIPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Points != nullptr)
		*Points = std::move(Parms.Points);
}


// Function DarwinGame.NPCBase.GetCurrentEventID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ANPCBase::GetCurrentEventID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetCurrentEventID");

	Params::NPCBase_GetCurrentEventID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetCurrentLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Length                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Loop                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Locate                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::GetCurrentLocationAndRotation(const float Length, const bool Loop, struct FVector* Locate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetCurrentLocationAndRotation");

	Params::NPCBase_GetCurrentLocationAndRotation Parms{};

	Parms.Length = Length;
	Parms.Loop = Loop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locate != nullptr)
		*Locate = std::move(Parms.Locate);
}


// Function DarwinGame.NPCBase.GetEaseTurnRotation
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Current                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANPCBase::GetEaseTurnRotation(const struct FRotator& Current, const struct FRotator& Target, float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetEaseTurnRotation");

	Params::NPCBase_GetEaseTurnRotation Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.Speed = Speed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetFukidashiOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANPCBase::GetFukidashiOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetFukidashiOffset");

	Params::NPCBase_GetFukidashiOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetIsPlayEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetIsPlayEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetIsPlayEvent");

	Params::NPCBase_GetIsPlayEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetIsTalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetIsTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetIsTalking");

	Params::NPCBase_GetIsTalking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetIsTalkingTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetIsTalkingTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetIsTalkingTurn");

	Params::NPCBase_GetIsTalkingTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetLookAtRotationToLocation
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANPCBase::GetLookAtRotationToLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetLookAtRotationToLocation");

	Params::NPCBase_GetLookAtRotationToLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetLookAtRotationToPlayer
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANPCBase::GetLookAtRotationToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetLookAtRotationToPlayer");

	Params::NPCBase_GetLookAtRotationToPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetMoveAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetMoveAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetMoveAnimation");

	Params::NPCBase_GetMoveAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetNPCAiParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FST_NPCDataAIParam               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FST_NPCDataAIParam ANPCBase::GetNPCAiParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetNPCAiParam");

	Params::NPCBase_GetNPCAiParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetNPCAiType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENPCAiType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENPCAiType ANPCBase::GetNPCAiType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetNPCAiType");

	Params::NPCBase_GetNPCAiType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetOpenFukidashiType
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EFukidashiEnum                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFukidashiEnum ANPCBase::GetOpenFukidashiType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetOpenFukidashiType");

	Params::NPCBase_GetOpenFukidashiType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetSplineAreaLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<float> ANPCBase::GetSplineAreaLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetSplineAreaLength");

	Params::NPCBase_GetSplineAreaLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetSplineComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* ANPCBase::GetSplineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetSplineComponent");

	Params::NPCBase_GetSplineComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetSplinePosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANPCBase::GetSplinePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetSplinePosition");

	Params::NPCBase_GetSplinePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetStampOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANPCBase::GetStampOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetStampOffset");

	Params::NPCBase_GetStampOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.HitFukidashiCollision
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::HitFukidashiCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "HitFukidashiCollision");

	Params::NPCBase_HitFukidashiCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IncrementTalkNum
// (Final, Native, Private, BlueprintCallable)

void ANPCBase::IncrementTalkNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IncrementTalkNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.Init
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.IsExtraTalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsExtraTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsExtraTalk");

	Params::NPCBase_IsExtraTalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsOpenLocalizeStamp
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsOpenLocalizeStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsOpenLocalizeStamp");

	Params::NPCBase_IsOpenLocalizeStamp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsOpenNetworkTravelerFukidashi
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsOpenNetworkTravelerFukidashi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsOpenNetworkTravelerFukidashi");

	Params::NPCBase_IsOpenNetworkTravelerFukidashi Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsOpenNewDispatch
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsOpenNewDispatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsOpenNewDispatch");

	Params::NPCBase_IsOpenNewDispatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsOpenNewHubReception
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsOpenNewHubReception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsOpenNewHubReception");

	Params::NPCBase_IsOpenNewHubReception Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.NPCInitMovement
// (Final, Native, Protected, BlueprintCallable)

void ANPCBase::NPCInitMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "NPCInitMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.NPCOpenFukidasiUI
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IconVisibility                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::NPCOpenFukidasiUI(const bool IconVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "NPCOpenFukidasiUI");

	Params::NPCBase_NPCOpenFukidasiUI Parms{};

	Parms.IconVisibility = IconVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.NPCBase.NPCStopMovement
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::NPCStopMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "NPCStopMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.OpenIcon
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBalloonIconType                        IconType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::OpenIcon(EBalloonIconType IconType, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "OpenIcon");

	Params::NPCBase_OpenIcon Parms{};

	Parms.IconType = IconType;
	Parms.Offset = std::move(Offset);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.NPCBase.OpenNearUI
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::OpenNearUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "OpenNearUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.PlayQuestEvent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::PlayQuestEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "PlayQuestEvent");

	Params::NPCBase_PlayQuestEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.ProcHideWorkEnd
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::ProcHideWorkEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ProcHideWorkEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ProcHideWorkLoop
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::ProcHideWorkLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ProcHideWorkLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ProcNPCLookAtBody
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::ProcNPCLookAtBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ProcNPCLookAtBody");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ResetFukidashiParam
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::ResetFukidashiParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ResetFukidashiParam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ResetFukidashiVisible
// (Final, Native, Private, BlueprintCallable)

void ANPCBase::ResetFukidashiVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ResetFukidashiVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.ResetNPCEmoteDisplCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANPCBase::ResetNPCEmoteDisplCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ResetNPCEmoteDisplCount");

	Params::NPCBase_ResetNPCEmoteDisplCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.ResetTalkNum
// (Final, Native, Private, BlueprintCallable)

void ANPCBase::ResetTalkNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "ResetTalkNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAcceptableRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetAcceptableRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAcceptableRadius");

	Params::NPCBase_SetAcceptableRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAiEventMoveParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FST_NPCEventAiMovePoints         Data                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)

void ANPCBase::SetAiEventMoveParam(const struct FST_NPCEventAiMovePoints& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAiEventMoveParam");

	Params::NPCBase_SetAiEventMoveParam Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAIIsWalkFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetAIIsWalkFlag(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAIIsWalkFlag");

	Params::NPCBase_SetAIIsWalkFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAIWorkIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetAIWorkIndex(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAIWorkIndex");

	Params::NPCBase_SetAIWorkIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAIWorkTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetAIWorkTargetLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAIWorkTargetLocation");

	Params::NPCBase_SetAIWorkTargetLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAIWorkTargetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANPCBase::SetAIWorkTargetRotator(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAIWorkTargetRotator");

	Params::NPCBase_SetAIWorkTargetRotator Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetAppearance
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::SetAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetAppearance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.SetCapsuleVerocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Verocity                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetCapsuleVerocity(const struct FVector& Verocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetCapsuleVerocity");

	Params::NPCBase_SetCapsuleVerocity Parms{};

	Parms.Verocity = std::move(Verocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetCustomEquipmentsState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NPCListID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetCustomEquipmentsState(const class FName NPCListID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetCustomEquipmentsState");

	Params::NPCBase_SetCustomEquipmentsState Parms{};

	Parms.NPCListID = NPCListID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetFukidashiDrawCollisonRadious
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Radious                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetFukidashiDrawCollisonRadious(const float Radious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetFukidashiDrawCollisonRadious");

	Params::NPCBase_SetFukidashiDrawCollisonRadious Parms{};

	Parms.Radious = Radious;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.NPCBase.SetFukidashiRequest
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::SetFukidashiRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetFukidashiRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetHideWorkReady
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::SetHideWorkReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetHideWorkReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetIsLookAtBodyPlaying
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetIsLookAtBodyPlaying(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetIsLookAtBodyPlaying");

	Params::NPCBase_SetIsLookAtBodyPlaying Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetMoveAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetMoveAnimation(bool Animation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetMoveAnimation");

	Params::NPCBase_SetMoveAnimation Parms{};

	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCAiType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENPCAiType                              AIType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCAiType(const ENPCAiType AIType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCAiType");

	Params::NPCBase_SetNPCAiType Parms{};

	Parms.AIType = AIType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCCapsule
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_NPCAppearance                NPCAppearanceData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UCapsuleComponent*                MoveCapsuleComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCapsuleComponent*                TalkEndCapsuleComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCCapsule(const struct FST_NPCAppearance& NPCAppearanceData, class UCapsuleComponent* MoveCapsuleComponent, class UCapsuleComponent* TalkEndCapsuleComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCCapsule");

	Params::NPCBase_SetNPCCapsule Parms{};

	Parms.NPCAppearanceData = std::move(NPCAppearanceData);
	Parms.MoveCapsuleComponent = MoveCapsuleComponent;
	Parms.TalkEndCapsuleComponent = TalkEndCapsuleComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCCapsuleDefaultSize
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_NPCAppearance                NPCAppearanceData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UCapsuleComponent*                MoveCapsuleComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCapsuleComponent*                TalkEndCapsuleComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCCapsuleDefaultSize(const struct FST_NPCAppearance& NPCAppearanceData, class UCapsuleComponent* MoveCapsuleComponent, class UCapsuleComponent* TalkEndCapsuleComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCCapsuleDefaultSize");

	Params::NPCBase_SetNPCCapsuleDefaultSize Parms{};

	Parms.NPCAppearanceData = std::move(NPCAppearanceData);
	Parms.MoveCapsuleComponent = MoveCapsuleComponent;
	Parms.TalkEndCapsuleComponent = TalkEndCapsuleComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ChangeNPCID                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOverwrite                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::SetNPCData(const class FName ChangeNPCID, const bool IsOverwrite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCData");

	Params::NPCBase_SetNPCData Parms{};

	Parms.ChangeNPCID = ChangeNPCID;
	Parms.IsOverwrite = IsOverwrite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.SetNPCEmoteSetting
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NPCAppearanceID                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCEmoteSetting(const class FName& NPCAppearanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCEmoteSetting");

	Params::NPCBase_SetNPCEmoteSetting Parms{};

	Parms.NPCAppearanceID = NPCAppearanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCMaterial
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_NPCAppearance                NPCAppearanceData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCMaterial(const struct FST_NPCAppearance& NPCAppearanceData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCMaterial");

	Params::NPCBase_SetNPCMaterial Parms{};

	Parms.NPCAppearanceData = std::move(NPCAppearanceData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCRelativeLocation
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FST_NPCAppearance                NPCAppearanceData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ENPCAiType                              NPCAiType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsuleOffset                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCRelativeLocation(const struct FST_NPCAppearance& NPCAppearanceData, const ENPCAiType NPCAiType, const struct FVector& CapsuleOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCRelativeLocation");

	Params::NPCBase_SetNPCRelativeLocation Parms{};

	Parms.NPCAppearanceData = std::move(NPCAppearanceData);
	Parms.NPCAiType = NPCAiType;
	Parms.CapsuleOffset = std::move(CapsuleOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetNPCSkeletalMesh
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_NPCAppearance                NPCAppearanceData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ANPCBase::SetNPCSkeletalMesh(const struct FST_NPCAppearance& NPCAppearanceData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetNPCSkeletalMesh");

	Params::NPCBase_SetNPCSkeletalMesh Parms{};

	Parms.NPCAppearanceData = std::move(NPCAppearanceData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetOriginRotat
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         rot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ANPCBase::SetOriginRotat(const struct FRotator& rot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetOriginRotat");

	Params::NPCBase_SetOriginRotat Parms{};

	Parms.rot = std::move(rot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetRestartAI
// (Final, Native, Protected, BlueprintCallable)

void ANPCBase::SetRestartAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetRestartAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetSearchTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetSearchTurn(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetSearchTurn");

	Params::NPCBase_SetSearchTurn Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetSplinePosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetSplinePosition(float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetSplinePosition");

	Params::NPCBase_SetSplinePosition Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetTalkEndTurnBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetTalkEndTurnBack(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetTalkEndTurnBack");

	Params::NPCBase_SetTalkEndTurnBack Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetTalking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetTalking(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetTalking");

	Params::NPCBase_SetTalking Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetTalkingTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetTalkingTurn(bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetTalkingTurn");

	Params::NPCBase_SetTalkingTurn Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetTalkLookAtEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetTalkLookAtEnable(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetTalkLookAtEnable");

	Params::NPCBase_SetTalkLookAtEnable Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SetTalkStartState
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ANPCBase::SetTalkStartState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetTalkStartState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.NPCBase.SetTalkStartTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SetTalkStartTurn(const bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SetTalkStartTurn");

	Params::NPCBase_SetTalkStartTurn Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.SoundRequest
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EAtomCueSheetCategory                   SoundType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SoundNo                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::SoundRequest(const EAtomCueSheetCategory SoundType, const int32 SoundNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "SoundRequest");

	Params::NPCBase_SoundRequest Parms{};

	Parms.SoundType = SoundType;
	Parms.SoundNo = SoundNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.StartLookAt
// (Final, Native, Private, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::StartLookAt(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "StartLookAt");

	Params::NPCBase_StartLookAt Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.StartLookAtPlayer
// (Final, Native, Private, BlueprintCallable)

void ANPCBase::StartLookAtPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "StartLookAtPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.StartNPCAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AnimState                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     State                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::StartNPCAnimState(const struct FGameplayTag& AnimState, const struct FGameplayTag& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "StartNPCAnimState");

	Params::NPCBase_StartNPCAnimState Parms{};

	Parms.AnimState = std::move(AnimState);
	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.StopAIActive
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::StopAIActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "StopAIActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.StopLookAt
// (Final, Native, Private, BlueprintCallable)

void ANPCBase::StopLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "StopLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.UpdateBrancheEventID
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::UpdateBrancheEventID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "UpdateBrancheEventID");

	Params::NPCBase_UpdateBrancheEventID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.UpdateFukidashiList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    IsUpdate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NextFukidashiTextID                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVisible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::UpdateFukidashiList(bool* IsUpdate, class FName* NextFukidashiTextID, bool* IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "UpdateFukidashiList");

	Params::NPCBase_UpdateFukidashiList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsUpdate != nullptr)
		*IsUpdate = Parms.IsUpdate;

	if (NextFukidashiTextID != nullptr)
		*NextFukidashiTextID = Parms.NextFukidashiTextID;

	if (IsVisible != nullptr)
		*IsVisible = Parms.IsVisible;
}


// Function DarwinGame.NPCBase.UpdateLookAt_Implementation
// (Final, Native, Private, BlueprintCallable)

void ANPCBase::UpdateLookAt_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "UpdateLookAt_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.UpdateMoveParam
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::UpdateMoveParam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "UpdateMoveParam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.UpdateNavigateAiState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsUpdateIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCBase::UpdateNavigateAiState(const bool IsUpdateIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "UpdateNavigateAiState");

	Params::NPCBase_UpdateNavigateAiState Parms{};

	Parms.IsUpdateIndex = IsUpdateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.UpdateNavigateFukidashi
// (Final, Native, Public, BlueprintCallable)

void ANPCBase::UpdateNavigateFukidashi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "UpdateNavigateFukidashi");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCBase.GetAIWorkIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANPCBase::GetAIWorkIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAIWorkIndex");

	Params::NPCBase_GetAIWorkIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetAIWorkTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ANPCBase::GetAIWorkTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAIWorkTargetLocation");

	Params::NPCBase_GetAIWorkTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetAIWorkTargetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ANPCBase::GetAIWorkTargetRotator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetAIWorkTargetRotator");

	Params::NPCBase_GetAIWorkTargetRotator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetCurrentEmoteType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEmoteType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEmoteType ANPCBase::GetCurrentEmoteType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetCurrentEmoteType");

	Params::NPCBase_GetCurrentEmoteType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetIdleEmoteListNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANPCBase::GetIdleEmoteListNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetIdleEmoteListNum");

	Params::NPCBase_GetIdleEmoteListNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetLookAtBodyParams
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_EventNPCLookAt               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_EventNPCLookAt ANPCBase::GetLookAtBodyParams() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetLookAtBodyParams");

	Params::NPCBase_GetLookAtBodyParams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetLookAtParams
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FST_EventNPCLookAt               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FST_EventNPCLookAt ANPCBase::GetLookAtParams() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetLookAtParams");

	Params::NPCBase_GetLookAtParams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetNPCID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ANPCBase::GetNPCID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetNPCID");

	Params::NPCBase_GetNPCID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetNPCListID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ANPCBase::GetNPCListID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetNPCListID");

	Params::NPCBase_GetNPCListID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetOriginRotat
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FRotator                   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FRotator ANPCBase::GetOriginRotat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetOriginRotat");

	Params::NPCBase_GetOriginRotat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetQuestStateNPC
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EQuestState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EQuestState ANPCBase::GetQuestStateNPC() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetQuestStateNPC");

	Params::NPCBase_GetQuestStateNPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetSearchTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool ANPCBase::GetSearchTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetSearchTurn");

	Params::NPCBase_GetSearchTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetTalkEndTurnBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetTalkEndTurnBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetTalkEndTurnBack");

	Params::NPCBase_GetTalkEndTurnBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetTalkLookAtEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::GetTalkLookAtEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetTalkLookAtEnable");

	Params::NPCBase_GetTalkLookAtEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetTalkNum
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ANPCBase::GetTalkNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetTalkNum");

	Params::NPCBase_GetTalkNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.GetTalkStartTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool ANPCBase::GetTalkStartTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "GetTalkStartTurn");

	Params::NPCBase_GetTalkStartTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.HasAIWorkIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::HasAIWorkIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "HasAIWorkIndex");

	Params::NPCBase_HasAIWorkIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.HasQuest
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::HasQuest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "HasQuest");

	Params::NPCBase_HasQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsDebugFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsDebugFlag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsDebugFlag");

	Params::NPCBase_IsDebugFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsOverWriteSpawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsOverWriteSpawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsOverWriteSpawn");

	Params::NPCBase_IsOverWriteSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsQuestClearAll
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsQuestClearAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsQuestClearAll");

	Params::NPCBase_IsQuestClearAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsValidNPCData
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsValidNPCData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsValidNPCData");

	Params::NPCBase_IsValidNPCData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCBase.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCBase::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCBase", "IsVisible");

	Params::NPCBase_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.AddToList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANPCBase*                         NPC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::AddToList(class ANPCBase* NPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "AddToList");

	Params::NPCManager_AddToList Parms{};

	Parms.NPC = NPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.ChangeNPCData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NextNPCID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::ChangeNPCData(class FName NextNPCID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "ChangeNPCData");

	Params::NPCManager_ChangeNPCData Parms{};

	Parms.NextNPCID = NextNPCID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.CheckFukidashi
// (Final, Native, Public, BlueprintCallable)

void UNPCManager::CheckFukidashi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "CheckFukidashi");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.GetAllActiveNPCLocations
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FVector> UNPCManager::GetAllActiveNPCLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetAllActiveNPCLocations");

	Params::NPCManager_GetAllActiveNPCLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetAllNPCActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ANPCBase*>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class ANPCBase*> UNPCManager::GetAllNPCActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetAllNPCActor");

	Params::NPCManager_GetAllNPCActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCAppearanceData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NPCAppearanceID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_NPCAppearance                DataInfo                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UNPCManager::GetNPCAppearanceData(class FName NPCAppearanceID, bool* Result, struct FST_NPCAppearance* DataInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCAppearanceData");

	Params::NPCManager_GetNPCAppearanceData Parms{};

	Parms.NPCAppearanceID = NPCAppearanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (DataInfo != nullptr)
		*DataInfo = std::move(Parms.DataInfo);
}


// Function DarwinGame.NPCManager.GetNPCDataFromTable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_NPCData                      NPCData                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UNPCManager::GetNPCDataFromTable(const class FName NpcID, bool* Result, struct FST_NPCData* NPCData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCDataFromTable");

	Params::NPCManager_GetNPCDataFromTable Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (NPCData != nullptr)
		*NPCData = std::move(Parms.NPCData);
}


// Function DarwinGame.NPCManager.GetNPCLocations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     NPCIDs                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<struct FVector> UNPCManager::GetNPCLocations(const TArray<class FName>& NPCIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCLocations");

	Params::NPCManager_GetNPCLocations Parms{};

	Parms.NPCIDs = std::move(NPCIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCMovePointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PointID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_NPCMovePoints                DataInfo                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UNPCManager::GetNPCMovePointData(class FName PointID, bool* Result, struct FST_NPCMovePoints* DataInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCMovePointData");

	Params::NPCManager_GetNPCMovePointData Parms{};

	Parms.PointID = PointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (DataInfo != nullptr)
		*DataInfo = std::move(Parms.DataInfo);
}


// Function DarwinGame.NPCManager.GetNPCNaviPointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PointID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_NPCEventAiMovePoints         DataInfo                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UNPCManager::GetNPCNaviPointData(class FName PointID, bool* Result, struct FST_NPCEventAiMovePoints* DataInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCNaviPointData");

	Params::NPCManager_GetNPCNaviPointData Parms{};

	Parms.PointID = PointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (DataInfo != nullptr)
		*DataInfo = std::move(Parms.DataInfo);
}


// Function DarwinGame.NPCManager.GetNPCParticleEffectList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FST_NPCParticleEffectData>ParticleEffectList                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::GetNPCParticleEffectList(const class FName ID, TArray<struct FST_NPCParticleEffectData>* ParticleEffectList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCParticleEffectList");

	Params::NPCManager_GetNPCParticleEffectList Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ParticleEffectList != nullptr)
		*ParticleEffectList = std::move(Parms.ParticleEffectList);

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCPointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_PointDataTable               DataInfo                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UNPCManager::GetNPCPointData(class FName NpcID, bool* Result, struct FST_PointDataTable* DataInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCPointData");

	Params::NPCManager_GetNPCPointData Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (DataInfo != nullptr)
		*DataInfo = std::move(Parms.DataInfo);
}


// Function DarwinGame.NPCManager.GetNPCSplineNaviPointData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PointID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_NPCEventAiMovePoints         DataInfo                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void UNPCManager::GetNPCSplineNaviPointData(class FName PointID, bool* Result, struct FST_NPCEventAiMovePoints* DataInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCSplineNaviPointData");

	Params::NPCManager_GetNPCSplineNaviPointData Parms{};

	Parms.PointID = PointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (DataInfo != nullptr)
		*DataInfo = std::move(Parms.DataInfo);
}


// Function DarwinGame.NPCManager.InitializeFriendNPCData
// (Final, Native, Public, BlueprintCallable)

void UNPCManager::InitializeFriendNPCData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "InitializeFriendNPCData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.Remove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RemoveNPCId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::Remove(class FName RemoveNPCId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "Remove");

	Params::NPCManager_Remove Parms{};

	Parms.RemoveNPCId = RemoveNPCId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.SetIsNPCAiSkip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    flg                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::SetIsNPCAiSkip(const bool flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "SetIsNPCAiSkip");

	Params::NPCManager_SetIsNPCAiSkip Parms{};

	Parms.flg = flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.SetSplinePointActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::SetSplinePointActor(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "SetSplinePointActor");

	Params::NPCManager_SetSplinePointActor Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.SetUpdateEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable_flag                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::SetUpdateEnable(bool enable_flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "SetUpdateEnable");

	Params::NPCManager_SetUpdateEnable Parms{};

	Parms.enable_flag = enable_flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.SetVisibleNPCAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNPCManager::SetVisibleNPCAll(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "SetVisibleNPCAll");

	Params::NPCManager_SetVisibleNPCAll Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.Spawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::Spawn(const class FName NpcID, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "Spawn");

	Params::NPCManager_Spawn Parms{};

	Parms.NpcID = NpcID;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.UpdateNPCVisibility
// (Final, Native, Public, BlueprintCallable)

void UNPCManager::UpdateNPCVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "UpdateNPCVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.NPCManager.ContainsList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NPC_ID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::ContainsList(const class FName NPC_ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "ContainsList");

	Params::NPCManager_ContainsList Parms{};

	Parms.NPC_ID = NPC_ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.ConvertNPCID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NPCDataID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UNPCManager::ConvertNPCID(const class FName NPCDataID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "ConvertNPCID");

	Params::NPCManager_ConvertNPCID Parms{};

	Parms.NPCDataID = NPCDataID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetIsNPCAiSkip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::GetIsNPCAiSkip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetIsNPCAiSkip");

	Params::NPCManager_GetIsNPCAiSkip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPC
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANPCBase*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPCBase* UNPCManager::GetNPC(class FName NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPC");

	Params::NPCManager_GetNPC Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCAppearanceDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCAppearanceDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCAppearanceDataTable");

	Params::NPCManager_GetNPCAppearanceDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCDataTable");

	Params::NPCManager_GetNPCDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCEmoteDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCEmoteDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCEmoteDataTable");

	Params::NPCManager_GetNPCEmoteDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCMovePointDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCMovePointDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCMovePointDataTable");

	Params::NPCManager_GetNPCMovePointDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCNaviPointDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCNaviPointDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCNaviPointDataTable");

	Params::NPCManager_GetNPCNaviPointDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCOptionDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCOptionDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCOptionDataTable");

	Params::NPCManager_GetNPCOptionDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCParticleEffectDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCParticleEffectDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCParticleEffectDataTable");

	Params::NPCManager_GetNPCParticleEffectDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCPartVoiceDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCPartVoiceDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCPartVoiceDataTable");

	Params::NPCManager_GetNPCPartVoiceDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCPartVoiceID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           TalkTypeName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TalkerTypeNo                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNPCManager::GetNPCPartVoiceID(const class FString& TalkTypeName, const int32 TalkerTypeNo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCPartVoiceID");

	Params::NPCManager_GetNPCPartVoiceID Parms{};

	Parms.TalkTypeName = std::move(TalkTypeName);
	Parms.TalkerTypeNo = TalkerTypeNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCPartVoiceIDFromNpcID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           TalkType                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNPCManager::GetNPCPartVoiceIDFromNpcID(const class FString& TalkType, const class FName NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCPartVoiceIDFromNpcID");

	Params::NPCManager_GetNPCPartVoiceIDFromNpcID Parms{};

	Parms.TalkType = std::move(TalkType);
	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCPointDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCPointDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCPointDataTable");

	Params::NPCManager_GetNPCPointDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetNPCSplineNaviPointDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDataTable*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataTable* UNPCManager::GetNPCSplineNaviPointDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetNPCSplineNaviPointDataTable");

	Params::NPCManager_GetNPCSplineNaviPointDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.GetSplinePointActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UNPCManager::GetSplinePointActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "GetSplinePointActor");

	Params::NPCManager_GetSplinePointActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.IsAutoTravelerNPCId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::IsAutoTravelerNPCId(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "IsAutoTravelerNPCId");

	Params::NPCManager_IsAutoTravelerNPCId Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.IsFriendNPCId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::IsFriendNPCId(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "IsFriendNPCId");

	Params::NPCManager_IsFriendNPCId Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.IsInvitationTravelerNPCId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::IsInvitationTravelerNPCId(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "IsInvitationTravelerNPCId");

	Params::NPCManager_IsInvitationTravelerNPCId Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.IsManagerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::IsManagerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "IsManagerActive");

	Params::NPCManager_IsManagerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.NPCManager.IsVisibleNPCId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNPCManager::IsVisibleNPCId(const class FName& NpcID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCManager", "IsVisibleNPCId");

	Params::NPCManager_IsVisibleNPCId Parms{};

	Parms.NpcID = NpcID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenCoinMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenCoinMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenCoinMenu");

	Params::OpenCheckFunctionLibrary_CanOpenCoinMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenConfigMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenConfigMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenConfigMenu");

	Params::OpenCheckFunctionLibrary_CanOpenConfigMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenDictionaryMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenDictionaryMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenDictionaryMenu");

	Params::OpenCheckFunctionLibrary_CanOpenDictionaryMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenFieldLink
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenFieldLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenFieldLink");

	Params::OpenCheckFunctionLibrary_CanOpenFieldLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenItemMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenItemMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenItemMenu");

	Params::OpenCheckFunctionLibrary_CanOpenItemMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenMainMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenMainMenu");

	Params::OpenCheckFunctionLibrary_CanOpenMainMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenMapMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenMapMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenMapMenu");

	Params::OpenCheckFunctionLibrary_CanOpenMapMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenMiniMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenMiniMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenMiniMap");

	Params::OpenCheckFunctionLibrary_CanOpenMiniMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenPartyMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenPartyMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenPartyMenu");

	Params::OpenCheckFunctionLibrary_CanOpenPartyMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenQuestMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenQuestMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenQuestMenu");

	Params::OpenCheckFunctionLibrary_CanOpenQuestMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenQuestWindow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenQuestWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenQuestWindow");

	Params::OpenCheckFunctionLibrary_CanOpenQuestWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenSpStock
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenSpStock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenSpStock");

	Params::OpenCheckFunctionLibrary_CanOpenSpStock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenStatusWindow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenStatusWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenStatusWindow");

	Params::OpenCheckFunctionLibrary_CanOpenStatusWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanOpenTeamMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanOpenTeamMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanOpenTeamMenu");

	Params::OpenCheckFunctionLibrary_CanOpenTeamMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanShowBaseIsland
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanShowBaseIsland()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanShowBaseIsland");

	Params::OpenCheckFunctionLibrary_CanShowBaseIsland Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.OpenCheckFunctionLibrary.CanShowCategory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOpenCheckFunctionLibrary::CanShowCategory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OpenCheckFunctionLibrary", "CanShowCategory");

	Params::OpenCheckFunctionLibrary_CanShowCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIQuest_Order.Setup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     InQuestIdList                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsParentDisplay                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsNewOrderQuest                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsClearedDisplay                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsClosedPlayEvent                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIQuest_Order::Setup(const TArray<class FName>& InQuestIdList, const class FName& NpcID, bool bInIsParentDisplay, bool bInIsNewOrderQuest, bool bInIsClearedDisplay, bool bInIsClosedPlayEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQuest_Order", "Setup");

	Params::UIQuest_Order_Setup Parms{};

	Parms.InQuestIdList = std::move(InQuestIdList);
	Parms.NpcID = NpcID;
	Parms.bInIsParentDisplay = bInIsParentDisplay;
	Parms.bInIsNewOrderQuest = bInIsNewOrderQuest;
	Parms.bInIsClearedDisplay = bInIsClearedDisplay;
	Parms.bInIsClosedPlayEvent = bInIsClosedPlayEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ParkourAbility.AdjustRotation
// (Final, Native, Protected, BlueprintCallable)

void UParkourAbility::AdjustRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParkourAbility", "AdjustRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ParkourAbility.CalculateParkourValue
// (Final, Native, Protected, BlueprintCallable)

void UParkourAbility::CalculateParkourValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParkourAbility", "CalculateParkourValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ParkourAbility.SetCapsuleScale
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        CapsuleScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParkourAbility::SetCapsuleScale(const struct FVector2D& CapsuleScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParkourAbility", "SetCapsuleScale");

	Params::ParkourAbility_SetCapsuleScale Parms{};

	Parms.CapsuleScale = std::move(CapsuleScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ParkourAbility.GetParkourData
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FParkour                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FParkour UParkourAbility::GetParkourData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParkourAbility", "GetParkourData");

	Params::ParkourAbility_GetParkourData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ParkourAbility.GetTurnRotation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UParkourAbility::GetTurnRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParkourAbility", "GetTurnRotation");

	Params::ParkourAbility_GetTurnRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PartyEditLibrary.K2_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   stockUid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyEditOption                 Option                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPartyEditLibrary::K2_Add(int32 stockUid, const struct FPartyEditOption& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PartyEditLibrary", "K2_Add");

	Params::PartyEditLibrary_K2_Add Parms{};

	Parms.stockUid = stockUid;
	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PartyEditLibrary.K2_MemberChange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           stockUids                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyEditOption                 Option                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPartyEditLibrary::K2_MemberChange(const TArray<int32>& stockUids, const struct FPartyEditOption& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PartyEditLibrary", "K2_MemberChange");

	Params::PartyEditLibrary_K2_MemberChange Parms{};

	Parms.stockUids = std::move(stockUids);
	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PartyEditLibrary.K2_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   partyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyEditOption                 Option                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPartyEditLibrary::K2_Remove(int32 partyIndex, const struct FPartyEditOption& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PartyEditLibrary", "K2_Remove");

	Params::PartyEditLibrary_K2_Remove Parms{};

	Parms.partyIndex = partyIndex;
	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PersistentLevelDataAsset.Import
// (Final, Native, Public)

void UPersistentLevelDataAsset::Import()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentLevelDataAsset", "Import");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PersistentLevelDataAsset.GetLevelData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPersistentLevelID                      ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPersistentLevelRecord           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPersistentLevelRecord UPersistentLevelDataAsset::GetLevelData(EPersistentLevelID ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentLevelDataAsset", "GetLevelData");

	Params::PersistentLevelDataAsset_GetLevelData Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PersistentLevelDataAsset.GetLevelPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPersistentLevelID                      ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPersistentLevelDataAsset::GetLevelPath(EPersistentLevelID ID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentLevelDataAsset", "GetLevelPath");

	Params::PersistentLevelDataAsset_GetLevelPath Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PersistentLevelDataAsset.IsContainsLevelPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             level_path                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPersistentLevelDataAsset::IsContainsLevelPath(const class FName level_path) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersistentLevelDataAsset", "IsContainsLevelPath");

	Params::PersistentLevelDataAsset_IsContainsLevelPath Parms{};

	Parms.level_path = level_path;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.CancelProcessRunningOnHoldKeyPush
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::CancelProcessRunningOnHoldKeyPush()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CancelProcessRunningOnHoldKeyPush");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.ChangeStateCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NextTag                                                (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ChangeStateCamera(const struct FGameplayTag& NextTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ChangeStateCamera");

	Params::PlayerCharacter_ChangeStateCamera Parms{};

	Parms.NextTag = std::move(NextTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.ChangeToBeast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterapSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ChangeToBeast(bool End, float InterapSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ChangeToBeast");

	Params::PlayerCharacter_ChangeToBeast Parms{};

	Parms.End = End;
	Parms.InterapSpeed = InterapSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.DisableInvincible
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::DisableInvincible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DisableInvincible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.EnableInvincible
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::EnableInvincible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "EnableInvincible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.FindFieldActMotionData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             MotionID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FST_FieldAct                     FieldActData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::FindFieldActMotionData(class FName MotionID, struct FST_FieldAct* FieldActData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FindFieldActMotionData");

	Params::PlayerCharacter_FindFieldActMotionData Parms{};

	Parms.MotionID = MotionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FieldActData != nullptr)
		*FieldActData = std::move(Parms.FieldActData);

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.ForceMove
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ForceMove(const struct FVector& Direction, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ForceMove");

	Params::PlayerCharacter_ForceMove Parms{};

	Parms.Direction = std::move(Direction);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.GenerateEquipment
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::GenerateEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GenerateEquipment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.GetDarwinCamera
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADarwinCamera*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADarwinCamera* APlayerCharacter::GetDarwinCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetDarwinCamera");

	Params::PlayerCharacter_GetDarwinCamera Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.GetLMBGameplayTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag APlayerCharacter::GetLMBGameplayTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetLMBGameplayTag");

	Params::PlayerCharacter_GetLMBGameplayTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.GetRideMotion
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_RideMotionData               FoundData                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::GetRideMotion(struct FST_RideMotionData* FoundData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetRideMotion");

	Params::PlayerCharacter_GetRideMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FoundData != nullptr)
		*FoundData = std::move(Parms.FoundData);

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.HideMarker
// (Final, Native, Public)

void APlayerCharacter::HideMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "HideMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.InitInteraction
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::InitInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "InitInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.InteractWhenAlreadyPressed
// (Final, Native, Private)

void APlayerCharacter::InteractWhenAlreadyPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "InteractWhenAlreadyPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.IsLMBPressed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::IsLMBPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "IsLMBPressed");

	Params::PlayerCharacter_IsLMBPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.LoseSightOfInteractObject
// (Final, Native, Private)

void APlayerCharacter::LoseSightOfInteractObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LoseSightOfInteractObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.OnAimMarkerOnOwner
// (Final, Native, Public)
// Parameters:
// bool                                    bOverPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnAimMarkerOnOwner(bool bOverPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnAimMarkerOnOwner");

	Params::PlayerCharacter_OnAimMarkerOnOwner Parms{};

	Parms.bOverPlayer = bOverPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.OnAimTrigger
// (Final, Native, Public)
// Parameters:
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnAimTrigger(bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnAimTrigger");

	Params::PlayerCharacter_OnAimTrigger Parms{};

	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.OnChangeMP
// (Final, Native, Private, BlueprintCallable)

void APlayerCharacter::OnChangeMP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnChangeMP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.OnInputChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnInputChanged(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnInputChanged");

	Params::PlayerCharacter_OnInputChanged Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.OnSetEquipmentFlag
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChanged                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnSetEquipmentFlag(bool enable, bool isChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnSetEquipmentFlag");

	Params::PlayerCharacter_OnSetEquipmentFlag Parms{};

	Parms.enable = enable;
	Parms.isChanged = isChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.RegisterAbyssInfo
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::RegisterAbyssInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "RegisterAbyssInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.Restart
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerCharacter::Restart(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "Restart");

	Params::PlayerCharacter_Restart Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.Search
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::Search(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "Search");

	Params::PlayerCharacter_Search Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.SetActiveRegenMP
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetActiveRegenMP(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetActiveRegenMP");

	Params::PlayerCharacter_SetActiveRegenMP Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.ShowMarker
// (Final, Native, Public)

void APlayerCharacter::ShowMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShowMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.ShowTransformInfoForDebug
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ShowTransformInfoForDebug(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShowTransformInfoForDebug");

	Params::PlayerCharacter_ShowTransformInfoForDebug Parms{};

	Parms.IsShow = IsShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.PlayerCharacter.StartAbyssSequence
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::StartAbyssSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "StartAbyssSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.StartBattleTimer
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APlayerCharacter::StartBattleTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "StartBattleTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.PlayerCharacter.StartVision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::StartVision(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "StartVision");

	Params::PlayerCharacter_StartVision Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PlayerCharacter.GetFieldActionInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFieldActionEventStruct          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFieldActionEventStruct APlayerCharacter::GetFieldActionInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetFieldActionInfo");

	Params::PlayerCharacter_GetFieldActionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.IsBattleModeContinue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::IsBattleModeContinue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "IsBattleModeContinue");

	Params::PlayerCharacter_IsBattleModeContinue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.IsPlayingUseSwordAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::IsPlayingUseSwordAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "IsPlayingUseSwordAction");

	Params::PlayerCharacter_IsPlayingUseSwordAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PlayerCharacter.OnTheWater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::OnTheWater() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnTheWater");

	Params::PlayerCharacter_OnTheWater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.PushWaveBase.InitParam
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplitNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APushWaveBase::InitParam(const struct FVector& Size, int32 SplitNum, float Speed, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushWaveBase", "InitParam");

	Params::PushWaveBase_InitParam Parms{};

	Parms.Size = std::move(Size);
	Parms.SplitNum = SplitNum;
	Parms.Speed = Speed;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PushWaveBase.OnBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APushWaveBase::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushWaveBase", "OnBeginOverlap");

	Params::PushWaveBase_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.PushWaveBase.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APushWaveBase::OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PushWaveBase", "OnEndOverlap");

	Params::PushWaveBase_OnEndOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RailSplineComponent.GetClosestPointAndDistance
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URailSplineComponent::GetClosestPointAndDistance(const struct FVector& Location, float* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RailSplineComponent", "GetClosestPointAndDistance");

	Params::RailSplineComponent_GetClosestPointAndDistance Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	return Parms.ReturnValue;
}


// Function DarwinGame.RailSplineComponent.GetLocationAndRotationAtDistance
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URailSplineComponent::GetLocationAndRotationAtDistance(float Distance, struct FVector* Location, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RailSplineComponent", "GetLocationAndRotationAtDistance");

	Params::RailSplineComponent_GetLocationAndRotationAtDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function DarwinGame.RailSplineComponent.GetRailDirectionAtDistance
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URailSplineComponent::GetRailDirectionAtDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RailSplineComponent", "GetRailDirectionAtDistance");

	Params::RailSplineComponent_GetRailDirectionAtDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.ResistDataTable.GetResistValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CalcType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UResistDataTable::GetResistValue(class FName ID, int32 CalcType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ResistDataTable", "GetResistValue");

	Params::ResistDataTable_GetResistValue Parms{};

	Parms.ID = ID;
	Parms.CalcType = CalcType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.ExistAppearRivalTeamMonsterWithoutOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URivalTeamMonsterBlueprintFunctionLibrary::ExistAppearRivalTeamMonsterWithoutOwner(class AMonsterBase* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "ExistAppearRivalTeamMonsterWithoutOwner");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_ExistAppearRivalTeamMonsterWithoutOwner Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.GetFootpadMonsters
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AMonsterBase*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AMonsterBase*> URivalTeamMonsterBlueprintFunctionLibrary::GetFootpadMonsters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "GetFootpadMonsters");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_GetFootpadMonsters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.GetNearestArtifactObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADropItemObject*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADropItemObject* URivalTeamMonsterBlueprintFunctionLibrary::GetNearestArtifactObject(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "GetNearestArtifactObject");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_GetNearestArtifactObject Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.GetRivalTeamForceName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URivalTeamMonsterBlueprintFunctionLibrary::GetRivalTeamForceName(ERivalTeamForce RivalTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "GetRivalTeamForceName");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_GetRivalTeamForceName Parms{};

	Parms.RivalTeam = RivalTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.GetRivalTeamMonsters
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AMonsterBase*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AMonsterBase*> URivalTeamMonsterBlueprintFunctionLibrary::GetRivalTeamMonsters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "GetRivalTeamMonsters");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_GetRivalTeamMonsters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.GetRivalTeamMonstersHasArtifact
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AMonsterBase*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class AMonsterBase*> URivalTeamMonsterBlueprintFunctionLibrary::GetRivalTeamMonstersHasArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "GetRivalTeamMonstersHasArtifact");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_GetRivalTeamMonstersHasArtifact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.GetTravelRivalTeamForce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<ERivalTeamForce>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<ERivalTeamForce> URivalTeamMonsterBlueprintFunctionLibrary::GetTravelRivalTeamForce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "GetTravelRivalTeamForce");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_GetTravelRivalTeamForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.IsEventRivalTeamID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URivalTeamMonsterBlueprintFunctionLibrary::IsEventRivalTeamID(ERivalTeamForce RivalTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "IsEventRivalTeamID");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_IsEventRivalTeamID Parms{};

	Parms.RivalTeam = RivalTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.IsRivalTeamMonster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URivalTeamMonsterBlueprintFunctionLibrary::IsRivalTeamMonster(const class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "IsRivalTeamMonster");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_IsRivalTeamMonster Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.IsTravelRivalTeamForce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URivalTeamMonsterBlueprintFunctionLibrary::IsTravelRivalTeamForce(ERivalTeamForce RivalTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "IsTravelRivalTeamForce");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_IsTravelRivalTeamForce Parms{};

	Parms.RivalTeam = RivalTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.NoticeAccessArtifactByPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AArtifactObjectBase*              Artifact                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URivalTeamMonsterBlueprintFunctionLibrary::NoticeAccessArtifactByPlayer(class AArtifactObjectBase* Artifact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "NoticeAccessArtifactByPlayer");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_NoticeAccessArtifactByPlayer Parms{};

	Parms.Artifact = Artifact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.NoticeDropArtifact
// (Final, Native, Static, Public, BlueprintCallable)

void URivalTeamMonsterBlueprintFunctionLibrary::NoticeDropArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "NoticeDropArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.NoticeWithdrawalRivalTeamMonster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMonsterBase*                     Monster                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URivalTeamMonsterBlueprintFunctionLibrary::NoticeWithdrawalRivalTeamMonster(class AMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "NoticeWithdrawalRivalTeamMonster");

	Params::RivalTeamMonsterBlueprintFunctionLibrary_NoticeWithdrawalRivalTeamMonster Parms{};

	Parms.Monster = Monster;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RivalTeamMonsterBlueprintFunctionLibrary.WithdrawalRivalTeam
// (Final, Native, Static, Public, BlueprintCallable)

void URivalTeamMonsterBlueprintFunctionLibrary::WithdrawalRivalTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RivalTeamMonsterBlueprintFunctionLibrary", "WithdrawalRivalTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.DestroySmogEffect
// (Final, Native, Public, BlueprintCallable)

void ARouteMap::DestroySmogEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "DestroySmogEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.PlayGearAnim
// (Final, Native, Public, BlueprintCallable)

void ARouteMap::PlayGearAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "PlayGearAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.SetReflectionRelease
// (Final, Native, Public, BlueprintCallable)

void ARouteMap::SetReflectionRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "SetReflectionRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.SetReflectionSeal
// (Final, Native, Public, BlueprintCallable)

void ARouteMap::SetReflectionSeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "SetReflectionSeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.SpawnSmogEffect
// (Final, Native, Public, BlueprintCallable)

void ARouteMap::SpawnSmogEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "SpawnSmogEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.StopGearAnim
// (Final, Native, Public, BlueprintCallable)

void ARouteMap::StopGearAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "StopGearAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.SwitchLightGradually
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARouteMap::SwitchLightGradually(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "SwitchLightGradually");

	Params::RouteMap_SwitchLightGradually Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.SwitchPointLightGradually
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARouteMap::SwitchPointLightGradually(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "SwitchPointLightGradually");

	Params::RouteMap_SwitchPointLightGradually Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.RouteMap.GetStationID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ARouteMap::GetStationID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RouteMap", "GetStationID");

	Params::RouteMap_GetStationID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SaveManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USaveManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveManager* USaveManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveManager", "GetInstance");

	Params::SaveManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SequencerController.GetRebindOrders
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class FString, struct FST_SequencerRebindOrder>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, struct FST_SequencerRebindOrder> USequencerController::GetRebindOrders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerController", "GetRebindOrders");

	Params::SequencerController_GetRebindOrders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SequencerController.PlayLevelSequence
// (Event, Public, BlueprintCallable, BlueprintEvent)

void USequencerController::PlayLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerController", "PlayLevelSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.SequencerController.PlaySubLevelSequencer
// (Event, Public, BlueprintCallable, BlueprintEvent)

void USequencerController::PlaySubLevelSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerController", "PlaySubLevelSequencer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.SequencerController.SetPlayLevelSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              PlayMainLevelSequenceActor                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequencePlayer*             PlayMainLevelSequencePlayer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USequencerController::SetPlayLevelSequence(class ALevelSequenceActor* PlayMainLevelSequenceActor, class ULevelSequencePlayer* PlayMainLevelSequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SequencerController", "SetPlayLevelSequence");

	Params::SequencerController_SetPlayLevelSequence Parms{};

	Parms.PlayMainLevelSequenceActor = PlayMainLevelSequenceActor;
	Parms.PlayMainLevelSequencePlayer = PlayMainLevelSequencePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ShotgunMagicBase.EndOfLife
// (Final, Native, Private, BlueprintCallable)

void AShotgunMagicBase::EndOfLife()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShotgunMagicBase", "EndOfLife");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ShotgunMagicBase.GenerateShotgunAllCollisions
// (Final, Native, Private, BlueprintCallable)

void AShotgunMagicBase::GenerateShotgunAllCollisions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShotgunMagicBase", "GenerateShotgunAllCollisions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.ShotgunMagicBase.GenerateShotgunCollision
// (Final, Native, Private, BlueprintCallable)

void AShotgunMagicBase::GenerateShotgunCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShotgunMagicBase", "GenerateShotgunCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleModeAnimInstance.PlayMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EModeAnimMode                           Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USimpleModeAnimInstance::PlayMode(EModeAnimMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleModeAnimInstance", "PlayMode");

	Params::SimpleModeAnimInstance_PlayMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleModeAnimInstance.SetMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EModeAnimMode                           Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USimpleModeAnimInstance::SetMode(EModeAnimMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleModeAnimInstance", "SetMode");

	Params::SimpleModeAnimInstance_SetMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SimpleModeAnimInstance.IsModeAndPlayAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EModeAnimMode                           Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleModeAnimInstance::IsModeAndPlayAnimation(EModeAnimMode Mode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleModeAnimInstance", "IsModeAndPlayAnimation");

	Params::SimpleModeAnimInstance_IsModeAndPlayAnimation Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SimpleModeAnimInstance.IsModeAndSkipAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EModeAnimMode                           Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USimpleModeAnimInstance::IsModeAndSkipAnimation(EModeAnimMode Mode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleModeAnimInstance", "IsModeAndSkipAnimation");

	Params::SimpleModeAnimInstance_IsModeAndSkipAnimation Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SlingShot.Grab
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlingShot::Grab(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlingShot", "Grab");

	Params::SlingShot_Grab Parms{};

	Parms.Alpha = Alpha;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.SlingShot.SetHandSocketName
// (Event, Protected, BlueprintEvent)

void ASlingShot::SetHandSocketName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlingShot", "SetHandSocketName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.SlingShot.Shot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             actionDetailID                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActionGameplayEffectContainerSpecSpec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASlingShot::Shot(const class FName ItemId, const class FName actionDetailID, const struct FActionGameplayEffectContainerSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlingShot", "Shot");

	Params::SlingShot_Shot Parms{};

	Parms.ItemId = ItemId;
	Parms.actionDetailID = actionDetailID;
	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SofdecMoviePlayer.GetPlayer
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UManaComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UManaComponent* ASofdecMoviePlayer::GetPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SofdecMoviePlayer", "GetPlayer");

	Params::SofdecMoviePlayer_GetPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.SofdecMoviePlayer.IsEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASofdecMoviePlayer::IsEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SofdecMoviePlayer", "IsEnd");

	Params::SofdecMoviePlayer_IsEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.SofdecMoviePlayer.Play
// (Final, Native, Public, BlueprintCallable)

void ASofdecMoviePlayer::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SofdecMoviePlayer", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SofdecMoviePlayer.Prepare
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASofdecMoviePlayer::Prepare(const class FName& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SofdecMoviePlayer", "Prepare");

	Params::SofdecMoviePlayer_Prepare Parms{};

	Parms.Path = Path;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.SofdecMoviePlayer.SetPlayerTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bTickableWhenPaused                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASofdecMoviePlayer::SetPlayerTickableWhenPaused(bool bTickableWhenPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SofdecMoviePlayer", "SetPlayerTickableWhenPaused");

	Params::SofdecMoviePlayer_SetPlayerTickableWhenPaused Parms{};

	Parms.bTickableWhenPaused = bTickableWhenPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.ChangeReleaseFlag
// (Final, Native, Public, BlueprintCallable)

void AStationBase::ChangeReleaseFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "ChangeReleaseFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.EnableLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationBase::EnableLine(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "EnableLine");

	Params::StationBase_EnableLine Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.EnableTeamFlag
// (Final, Native, Public, BlueprintCallable)

void AStationBase::EnableTeamFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "EnableTeamFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.ForcePlacementTrain
// (Final, Native, Public, BlueprintCallable)

void AStationBase::ForcePlacementTrain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "ForcePlacementTrain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.PlaySmogEffect
// (Final, Native, Public, BlueprintCallable)

void AStationBase::PlaySmogEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "PlaySmogEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.StopSmogEffect
// (Final, Native, Public, BlueprintCallable)

void AStationBase::StopSmogEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "StopSmogEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.SwitchLightGradually
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationBase::SwitchLightGradually(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "SwitchLightGradually");

	Params::StationBase_SwitchLightGradually Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StationBase.GetTrainGuide
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutStopLocation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutInboundVector                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStationBase::GetTrainGuide(struct FVector* OutStopLocation, struct FVector* OutInboundVector) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "GetTrainGuide");

	Params::StationBase_GetTrainGuide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStopLocation != nullptr)
		*OutStopLocation = std::move(Parms.OutStopLocation);

	if (OutInboundVector != nullptr)
		*OutInboundVector = std::move(Parms.OutInboundVector);
}


// Function DarwinGame.StationBase.GetTrainGuideInboundVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AStationBase::GetTrainGuideInboundVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "GetTrainGuideInboundVector");

	Params::StationBase_GetTrainGuideInboundVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationBase.GetTrainGuideStopLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AStationBase::GetTrainGuideStopLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "GetTrainGuideStopLocation");

	Params::StationBase_GetTrainGuideStopLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StationBase.IsRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStationBase::IsRelease() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StationBase", "IsRelease");

	Params::StationBase_IsRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.StreamingLevelData.Build
// (Final, Native, Protected, BlueprintCallable)

void UStreamingLevelData::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamingLevelData", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.StreamingLevelData.
// (Final, Native, Protected, BlueprintCallable)

void UStreamingLevelData::m________________________________()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamingLevelData", "");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TargetObjectDataAsset.Build
// (Final, Native, Public, BlueprintCallable)

void UTargetObjectDataAsset::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetObjectDataAsset", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TimeScaleComponent.EndHitStop
// (Final, Native, Protected, BlueprintCallable)

void UTimeScaleComponent::EndHitStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeScaleComponent", "EndHitStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TimeScaleComponent.IsActivateHitStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             actionDetailID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExternalTrigger                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimeScaleComponent::IsActivateHitStop(class AActor* Attacker, class FName actionDetailID, bool ExternalTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeScaleComponent", "IsActivateHitStop");

	Params::TimeScaleComponent_IsActivateHitStop Parms{};

	Parms.Attacker = Attacker;
	Parms.actionDetailID = actionDetailID;
	Parms.ExternalTrigger = ExternalTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.TimeScaleComponent.ResetTimeScale
// (Final, Native, Public, BlueprintCallable)

void UTimeScaleComponent::ResetTimeScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeScaleComponent", "ResetTimeScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TimeScaleComponent.SetTimeScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeScaleComponent::SetTimeScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeScaleComponent", "SetTimeScale");

	Params::TimeScaleComponent_SetTimeScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TimeScaleComponent.StartHitStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   stopMsTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimeScaleComponent::StartHitStop(float stopMsTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeScaleComponent", "StartHitStop");

	Params::TimeScaleComponent_StartHitStop Parms{};

	Parms.stopMsTime = stopMsTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TimeScaleComponent.GetTimeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimeScaleComponent::GetTimeScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeScaleComponent", "GetTimeScale");

	Params::TimeScaleComponent_GetTimeScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UISign_IconAreaBase.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             AreaName                                               (Parm, NativeAccessSpecifierPublic)

void UUISign_IconAreaBase::SetData(const class FName& ID, const class FText& AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconAreaBase", "SetData");

	Params::UISign_IconAreaBase_SetData Parms{};

	Parms.ID = ID;
	Parms.AreaName = std::move(AreaName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TornadoMagicBase.HomingOff
// (Final, Native, Private, BlueprintCallable)

void ATornadoMagicBase::HomingOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TornadoMagicBase", "HomingOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.TrialFunctionLibrary.IsTrial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTrialFunctionLibrary::IsTrial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TrialFunctionLibrary", "IsTrial");

	Params::TrialFunctionLibrary_IsTrial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UISign_IconLvupStatus.BroadcastEndStatusUp
// (Final, Native, Protected, BlueprintCallable)

void UUISign_IconLvupStatus::BroadcastEndStatusUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvupStatus", "BroadcastEndStatusUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconLvupStatus.RequestStatusUp
// (Final, Native, Public, BlueprintCallable)

void UUISign_IconLvupStatus::RequestStatusUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvupStatus", "RequestStatusUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconLvupStatus.SetIsStatusIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconLvupStatus::SetIsStatusIcon(bool IsIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvupStatus", "SetIsStatusIcon");

	Params::UISign_IconLvupStatus_SetIsStatusIcon Parms{};

	Parms.IsIcon = IsIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconLvupStatus.SetStatusList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InBeforeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCharacterID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InUid                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconLvupStatus::SetStatusList(int32 InLevel, int32 InBeforeLevel, class FName InCharacterID, int32 InUid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvupStatus", "SetStatusList");

	Params::UISign_IconLvupStatus_SetStatusList Parms{};

	Parms.InLevel = InLevel;
	Parms.InBeforeLevel = InBeforeLevel;
	Parms.InCharacterID = InCharacterID;
	Parms.InUid = InUid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Menu.ButtonInEnd
// (Final, Native, Protected)

void UUIAppraise_Menu::ButtonInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Menu", "ButtonInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Menu.ButtonOutEnd
// (Final, Native, Protected)

void UUIAppraise_Menu::ButtonOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Menu", "ButtonOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Menu.FlavorTextInEnd
// (Final, Native, Protected)

void UUIAppraise_Menu::FlavorTextInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Menu", "FlavorTextInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Popup.InAnimEnd
// (Final, Native, Protected)

void UUIAppraise_Popup::InAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Popup", "InAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIAppraise_Popup.OutAnimEnd
// (Final, Native, Protected)

void UUIAppraise_Popup::OutAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAppraise_Popup", "OutAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.AddAllUnclaimedBenefits
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::AddAllUnclaimedBenefits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "AddAllUnclaimedBenefits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.AddPlayerGold
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AddGold                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::AddPlayerGold(int32 AddGold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "AddPlayerGold");

	Params::UIUtility_AddPlayerGold Parms{};

	Parms.AddGold = AddGold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CanGetUnclaimedBenefits
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::CanGetUnclaimedBenefits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CanGetUnclaimedBenefits");

	Params::UIUtility_CanGetUnclaimedBenefits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.CanUnlockFacilityDismiss
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::CanUnlockFacilityDismiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CanUnlockFacilityDismiss");

	Params::UIUtility_CanUnlockFacilityDismiss Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.ClearDelayedTipsSchedule
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ClearDelayedTipsSchedule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ClearDelayedTipsSchedule");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseBoard
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseBoard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseBoard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseBulletShop
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseBulletShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseBulletShop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseDispatch
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseDispatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseDispatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseFacility
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseFacility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseFacility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseFieldStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFieldStatusOpenType                    OpenType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::CloseFieldStatus(EFieldStatusOpenType OpenType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseFieldStatus");

	Params::UIUtility_CloseFieldStatus Parms{};

	Parms.OpenType = OpenType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.CloseFoodShop
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseFoodShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseFoodShop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseMyArtifact
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseMyArtifact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseMyArtifact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseNetworkTop
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseNetworkTop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseNetworkTop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseQuestConfirmation
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseQuestConfirmation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseQuestConfirmation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseShop
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseShop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.CloseSwap
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::CloseSwap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "CloseSwap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.DynamicCreateWidgetFromClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    DarwinUserWidgetClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::DynamicCreateWidgetFromClass(TSubclassOf<class UDarwinUserWidget> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "DynamicCreateWidgetFromClass");

	Params::UIUtility_DynamicCreateWidgetFromClass Parms{};

	Parms.DarwinUserWidgetClass = DarwinUserWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function DarwinGame.UIUtility.DynamicCreateWidgetFromSoftClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             DarwinUserWidgetClass                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::DynamicCreateWidgetFromSoftClass(TSoftClassPtr<class UClass> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "DynamicCreateWidgetFromSoftClass");

	Params::UIUtility_DynamicCreateWidgetFromSoftClass Parms{};

	Parms.DarwinUserWidgetClass = DarwinUserWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function DarwinGame.UIUtility.EventMaskContinuedOn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::EventMaskContinuedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "EventMaskContinuedOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ExitWidgetGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EManagedUIGroup                         Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::ExitWidgetGroup(EManagedUIGroup Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ExitWidgetGroup");

	Params::UIUtility_ExitWidgetGroup Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.FormatItemFlavorText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             ItemText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EAreaType>                       AreaTypeList                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIUtility::FormatItemFlavorText(const class FText& ItemText, const TArray<EAreaType>& AreaTypeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "FormatItemFlavorText");

	Params::UIUtility_FormatItemFlavorText Parms{};

	Parms.ItemText = std::move(ItemText);
	Parms.AreaTypeList = std::move(AreaTypeList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.GetArtifactTypeName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EArtifactType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIUtility::GetArtifactTypeName(EArtifactType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetArtifactTypeName");

	Params::UIUtility_GetArtifactTypeName Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.GetHasTipsSchedule
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::GetHasTipsSchedule()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetHasTipsSchedule");

	Params::UIUtility_GetHasTipsSchedule Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.GetHubReceptionQuestIDs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     OutIDs                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::GetHubReceptionQuestIDs(TArray<class FName>* OutIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetHubReceptionQuestIDs");

	Params::UIUtility_GetHubReceptionQuestIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIDs != nullptr)
		*OutIDs = std::move(Parms.OutIDs);
}


// Function DarwinGame.UIUtility.GetPlayerGold
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIUtility::GetPlayerGold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetPlayerGold");

	Params::UIUtility_GetPlayerGold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.GetPlayerLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UUIUtility::GetPlayerLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetPlayerLocation");

	Params::UIUtility_GetPlayerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.GetPlayerName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UUIUtility::GetPlayerName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetPlayerName");

	Params::UIUtility_GetPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.GetUnusedWidgetFromClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    DarwinUserWidgetClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::GetUnusedWidgetFromClass(TSubclassOf<class UDarwinUserWidget> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetUnusedWidgetFromClass");

	Params::UIUtility_GetUnusedWidgetFromClass Parms{};

	Parms.DarwinUserWidgetClass = DarwinUserWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function DarwinGame.UIUtility.GetUnusedWidgetFromSoftClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             DarwinUserWidgetClass                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::GetUnusedWidgetFromSoftClass(TSoftClassPtr<class UClass> DarwinUserWidgetClass, int32* OutIndex, class UDarwinUserWidget** OutWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetUnusedWidgetFromSoftClass");

	Params::UIUtility_GetUnusedWidgetFromSoftClass Parms{};

	Parms.DarwinUserWidgetClass = DarwinUserWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function DarwinGame.UIUtility.GetWidgetFromClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    DarwinUserWidgetClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::GetWidgetFromClass(TSubclassOf<class UDarwinUserWidget> DarwinUserWidgetClass, int32 Index_0, class UDarwinUserWidget** OutWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetWidgetFromClass");

	Params::UIUtility_GetWidgetFromClass Parms{};

	Parms.DarwinUserWidgetClass = DarwinUserWidgetClass;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function DarwinGame.UIUtility.GetWidgetFromSoftClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             DarwinUserWidgetClass                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::GetWidgetFromSoftClass(TSoftClassPtr<class UClass> DarwinUserWidgetClass, int32 Index_0, class UDarwinUserWidget** OutWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "GetWidgetFromSoftClass");

	Params::UIUtility_GetWidgetFromSoftClass Parms{};

	Parms.DarwinUserWidgetClass = DarwinUserWidgetClass;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;
}


// Function DarwinGame.UIUtility.IfLoadEndOpenFieldStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IfLoadEndOpenFieldStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IfLoadEndOpenFieldStatus");

	Params::UIUtility_IfLoadEndOpenFieldStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.InitWidgetGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EManagedUIGroup                         Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::InitWidgetGroup(EManagedUIGroup Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "InitWidgetGroup");

	Params::UIUtility_InitWidgetGroup Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.IsCloseBoard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsCloseBoard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsCloseBoard");

	Params::UIUtility_IsCloseBoard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsCloseDispatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsCloseDispatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsCloseDispatch");

	Params::UIUtility_IsCloseDispatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsCloseNetworkTop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsCloseNetworkTop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsCloseNetworkTop");

	Params::UIUtility_IsCloseNetworkTop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsInitWidgetGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EManagedUIGroup                         Group                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsInitWidgetGroup(EManagedUIGroup Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsInitWidgetGroup");

	Params::UIUtility_IsInitWidgetGroup Parms{};

	Parms.Group = Group;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsLargeSizeFlavorWindowByLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsLargeSizeFlavorWindowByLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsLargeSizeFlavorWindowByLanguage");

	Params::UIUtility_IsLargeSizeFlavorWindowByLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsNewDispatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsNewDispatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsNewDispatch");

	Params::UIUtility_IsNewDispatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsNewFacilityReception
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsNewFacilityReception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsNewFacilityReception");

	Params::UIUtility_IsNewFacilityReception Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsNewHubReception
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsNewHubReception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsNewHubReception");

	Params::UIUtility_IsNewHubReception Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsOpenQuestMenuDirectly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsOpenQuestMenuDirectly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsOpenQuestMenuDirectly");

	Params::UIUtility_IsOpenQuestMenuDirectly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsOpenTeamMenuConfirmation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsOpenTeamMenuConfirmation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsOpenTeamMenuConfirmation");

	Params::UIUtility_IsOpenTeamMenuConfirmation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsOpenTeamMenuDirectly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsOpenTeamMenuDirectly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsOpenTeamMenuDirectly");

	Params::UIUtility_IsOpenTeamMenuDirectly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsPlayLevelUpAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsPlayLevelUpAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsPlayLevelUpAnim");

	Params::UIUtility_IsPlayLevelUpAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsRewordTypeContainUnclaimedBenefits
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAddOnContentRewordType                 RewordType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsRewordTypeContainUnclaimedBenefits(EAddOnContentRewordType RewordType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsRewordTypeContainUnclaimedBenefits");

	Params::UIUtility_IsRewordTypeContainUnclaimedBenefits Parms{};

	Parms.RewordType = RewordType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.IsUnclaimedBenefits
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::IsUnclaimedBenefits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "IsUnclaimedBenefits");

	Params::UIUtility_IsUnclaimedBenefits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.LastBattleQTESevenStoneGetBackLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELastBtlQTELogType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::LastBattleQTESevenStoneGetBackLog(ELastBtlQTELogType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "LastBattleQTESevenStoneGetBackLog");

	Params::UIUtility_LastBattleQTESevenStoneGetBackLog Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.LoadTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UUIUtility::LoadTexture(class UObject* Outer_0, const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "LoadTexture");

	Params::UIUtility_LoadTexture Parms{};

	Parms.Outer_0 = Outer_0;
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.LoadTextureSoft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        SoftObjectReference                                    (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UUIUtility::LoadTextureSoft(class UObject* Outer_0, const TSoftObjectPtr<class UTexture2D>& SoftObjectReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "LoadTextureSoft");

	Params::UIUtility_LoadTextureSoft Parms{};

	Parms.Outer_0 = Outer_0;
	Parms.SoftObjectReference = SoftObjectReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.OpenBoard
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenBoard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenBoard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenBulletShop
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenBulletShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenBulletShop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenDelayedTips
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TipsID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::OpenDelayedTips(class FName TipsID, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenDelayedTips");

	Params::UIUtility_OpenDelayedTips Parms{};

	Parms.TipsID = TipsID;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenDispatch
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenDispatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenDispatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenFacility
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenFacility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenFacility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenFieldStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFieldStatusOpenType                    OpenType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::OpenFieldStatus(EFieldStatusOpenType OpenType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenFieldStatus");

	Params::UIUtility_OpenFieldStatus Parms{};

	Parms.OpenType = OpenType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.OpenFoodShop
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenFoodShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenFoodShop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenMyArtifact
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   PedestalIndex                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::OpenMyArtifact(const int32& PedestalIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenMyArtifact");

	Params::UIUtility_OpenMyArtifact Parms{};

	Parms.PedestalIndex = PedestalIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenNetworkTop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EOpenNetworkUIType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::OpenNetworkTop(EOpenNetworkUIType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenNetworkTop");

	Params::UIUtility_OpenNetworkTop Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenQuestMenuDirectly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQuestMenuOpenType                      InOpenType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::OpenQuestMenuDirectly(EQuestMenuOpenType InOpenType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenQuestMenuDirectly");

	Params::UIUtility_OpenQuestMenuDirectly Parms{};

	Parms.InOpenType = InOpenType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenQuestOrder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     QuestIdList                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NpcID                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsParentDisplay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsNewOrderQuest                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsClearedDisplay                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsClosedPlayEvent                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::OpenQuestOrder(const TArray<class FName>& QuestIdList, const class FName& NpcID, bool bIsParentDisplay, bool bInIsNewOrderQuest, bool bInIsClearedDisplay, bool bInIsClosedPlayEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenQuestOrder");

	Params::UIUtility_OpenQuestOrder Parms{};

	Parms.QuestIdList = std::move(QuestIdList);
	Parms.NpcID = NpcID;
	Parms.bIsParentDisplay = bIsParentDisplay;
	Parms.bInIsNewOrderQuest = bInIsNewOrderQuest;
	Parms.bInIsClearedDisplay = bInIsClearedDisplay;
	Parms.bInIsClosedPlayEvent = bInIsClosedPlayEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.OpenShop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETradePlace                             TradePlace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::OpenShop(ETradePlace TradePlace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenShop");

	Params::UIUtility_OpenShop Parms{};

	Parms.TradePlace = TradePlace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenSwap
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenSwap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenSwap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.OpenTeamMenuDirectly
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::OpenTeamMenuDirectly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "OpenTeamMenuDirectly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ReOpenQuestOrder
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIUtility::ReOpenQuestOrder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ReOpenQuestOrder");

	Params::UIUtility_ReOpenQuestOrder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIUtility.SetHubReceptionDelegateAtQuestOrder
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::SetHubReceptionDelegateAtQuestOrder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SetHubReceptionDelegateAtQuestOrder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SetSubtitlesText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::SetSubtitlesText(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SetSubtitlesText");

	Params::UIUtility_SetSubtitlesText Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SubtitlesMaskIn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   AnimationSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::SubtitlesMaskIn(float AnimationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SubtitlesMaskIn");

	Params::UIUtility_SubtitlesMaskIn Parms{};

	Parms.AnimationSeconds = AnimationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SubtitlesMaskOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   AnimationSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::SubtitlesMaskOut(float AnimationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SubtitlesMaskOut");

	Params::UIUtility_SubtitlesMaskOut Parms{};

	Parms.AnimationSeconds = AnimationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SubtitlesSkipIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::SubtitlesSkipIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SubtitlesSkipIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SubtitlesSkipOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::SubtitlesSkipOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SubtitlesSkipOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SubtitlesTextHidden
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::SubtitlesTextHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SubtitlesTextHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.SubtitlesTextVisible
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::SubtitlesTextVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "SubtitlesTextVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleComposerNameIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleComposerNameIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleComposerNameIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleComposerNameOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleComposerNameOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleComposerNameOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleDesignerNameIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleDesignerNameIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleDesignerNameIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleDesignerNameOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleDesignerNameOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleDesignerNameOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleDirectorNameIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleDirectorNameIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleDirectorNameIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleDirectorNameOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleDirectorNameOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleDirectorNameOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleMaskIn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   AnimationSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::ThreePeopleMaskIn(float AnimationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleMaskIn");

	Params::UIUtility_ThreePeopleMaskIn Parms{};

	Parms.AnimationSeconds = AnimationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleMaskOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   AnimationSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::ThreePeopleMaskOut(float AnimationSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleMaskOut");

	Params::UIUtility_ThreePeopleMaskOut Parms{};

	Parms.AnimationSeconds = AnimationSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleSkipIn
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleSkipIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleSkipIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.ThreePeopleSkipOut
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::ThreePeopleSkipOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "ThreePeopleSkipOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.UIMapDrawEnterArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EAreaType                               AreaType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUtility::UIMapDrawEnterArea(EAreaType AreaType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "UIMapDrawEnterArea");

	Params::UIUtility_UIMapDrawEnterArea Parms{};

	Parms.AreaType = AreaType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.UIMapDrawEnterCurrentArea
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::UIMapDrawEnterCurrentArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "UIMapDrawEnterCurrentArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUtility.UnlockFacilityDismiss
// (Final, Native, Static, Public, BlueprintCallable)

void UUIUtility::UnlockFacilityDismiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIUtility", "UnlockFacilityDismiss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBoardmenu.OnChangeFocusFunc
// (Final, Native, Protected)

void UUIBoardmenu::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBoardmenu", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEvent_Mask.OutAnimationFinished
// (Final, Native, Private)

void UUIEvent_Mask::OutAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEvent_Mask", "OutAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEvent_Mask.PlaySkipWaitAnimation
// (Final, Native, Private)

void UUIEvent_Mask::PlaySkipWaitAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEvent_Mask", "PlaySkipWaitAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEvent_Mask.PlayWaitAnimation
// (Final, Native, Private)

void UUIEvent_Mask::PlayWaitAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEvent_Mask", "PlayWaitAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBonus_Points_01.InEnd
// (Final, Native, Protected)

void UUIBonus_Points_01::InEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBonus_Points_01", "InEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIBonus_Points_02.FlashEnd
// (Final, Native, Protected)

void UUIBonus_Points_02::FlashEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIBonus_Points_02", "FlashEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQM_Panel_00.ClearOutAnimationFinished
// (Final, Native, Protected)

void UUIQM_Panel_00::ClearOutAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQM_Panel_00", "ClearOutAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICaution.CloseProcessing
// (Final, Native, Public)

void UUICaution::CloseProcessing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICaution", "CloseProcessing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICoinRankIcon.InitWidget
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UWidgetAnimation*>         rankAnmAry                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICoinRankIcon::InitWidget(const TArray<class UWidgetAnimation*>& rankAnmAry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoinRankIcon", "InitWidget");

	Params::UICoinRankIcon_InitWidget Parms{};

	Parms.rankAnmAry = std::move(rankAnmAry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICoinRankIcon.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICoinRankIcon::SetData(int32 InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICoinRankIcon", "SetData");

	Params::UICoinRankIcon_SetData Parms{};

	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICommonmenu_01.OnChangeFocusFunc
// (Final, Native, Protected)

void UUICommonmenu_01::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICommonmenu_01", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICommonmenu_02.OnChangeFocusFunc
// (Final, Native, Protected)

void UUICommonmenu_02::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICommonmenu_02", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UICommonmenu_03.OnChangeFocusFunc
// (Final, Native, Protected)

void UUICommonmenu_03::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICommonmenu_03", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.InputDisable
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconReticle::InputDisable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "InputDisable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.InputEnable
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconReticle::InputEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "InputEnable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.PlayHoldOnAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_IconReticle::PlayHoldOnAnimation(float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "PlayHoldOnAnimation");

	Params::UIShot_IconReticle_PlayHoldOnAnimation Parms{};

	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.PlayInputLAnimation
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconReticle::PlayInputLAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "PlayInputLAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.PlayInputRAnimation
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconReticle::PlayInputRAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "PlayInputRAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.PlayLockWaitAnimation
// (Final, Native, Public)

void UUIShot_IconReticle::PlayLockWaitAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "PlayLockWaitAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.PlayShotAnimation
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconReticle::PlayShotAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "PlayShotAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconReticle.SetAim
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsAim                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_IconReticle::SetAim(bool IsAim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "SetAim");

	Params::UIShot_IconReticle_SetAim Parms{};

	Parms.IsAim = IsAim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIShot_IconReticle.SetReticleVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_IconReticle::SetReticleVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "SetReticleVisibility");

	Params::UIShot_IconReticle_SetReticleVisibility Parms{};

	Parms.visible = visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIShot_IconReticle.SlingShot
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUIShot_IconReticle::SlingShot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "SlingShot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.UIShot_IconReticle.StopHoldOnAnimation
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconReticle::StopHoldOnAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconReticle", "StopHoldOnAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIDiscovery_00.SetGaugeData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNowDiscoveryPoint                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIDiscovery_00::SetGaugeData(float InNowDiscoveryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIDiscovery_00", "SetGaugeData");

	Params::UIDiscovery_00_SetGaugeData Parms{};

	Parms.InNowDiscoveryPoint = InNowDiscoveryPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIDiscovery_00.SetupData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxDiscoveryPoint                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InNowDiscoveryPoint                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIDiscovery_00::SetupData(class AActor* InTarget, float InMaxDiscoveryPoint, float InNowDiscoveryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIDiscovery_00", "SetupData");

	Params::UIDiscovery_00_SetupData Parms{};

	Parms.InTarget = InTarget;
	Parms.InMaxDiscoveryPoint = InMaxDiscoveryPoint;
	Parms.InNowDiscoveryPoint = InNowDiscoveryPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIDiscovery_Icon.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIDiscovery_Icon::SetData(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIDiscovery_Icon", "SetData");

	Params::UIDiscovery_Icon_SetData Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuestQueueSystem.SetQueueProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIQuestQueueProcessType                InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InQuestID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsDirecting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIQuestQueueSystem::SetQueueProcess(EUIQuestQueueProcessType InType, class FName InQuestID, bool bInIsDirecting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQuestQueueSystem", "SetQueueProcess");

	Params::UIQuestQueueSystem_SetQueueProcess Parms{};

	Parms.InType = InType;
	Parms.InQuestID = InQuestID;
	Parms.bInIsDirecting = bInIsDirecting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimate_ItemPanel_00.EndCsrFlashAnim
// (Final, Native, Protected)

void UUIEstimate_ItemPanel_00::EndCsrFlashAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_ItemPanel_00", "EndCsrFlashAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimate_ItemPanel_00.EndInAnim
// (Final, Native, Protected)

void UUIEstimate_ItemPanel_00::EndInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_ItemPanel_00", "EndInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimate_Thomasson_01.EndInAnim
// (Final, Native, Protected)

void UUIEstimate_Thomasson_01::EndInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_Thomasson_01", "EndInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIEstimate_ValuePanel_00.BonusFlashAnimEnd
// (Final, Native, Private)

void UUIEstimate_ValuePanel_00::BonusFlashAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIEstimate_ValuePanel_00", "BonusFlashAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFacilityMenu_Set.OnChangeFocusFunc
// (Final, Native, Protected)

void UUIFacilityMenu_Set::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFacilityMenu_Set", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFade.BroadCastFadeInDelegate
// (Final, Native, Protected, BlueprintCallable)

void UUIFade::BroadCastFadeInDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "BroadCastFadeInDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFade.BroadCastFadeOutDelegate
// (Final, Native, Protected, BlueprintCallable)

void UUIFade::BroadCastFadeOutDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "BroadCastFadeOutDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIFade.FadeInScreen
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFade::FadeInScreen(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "FadeInScreen");

	Params::UIFade_FadeInScreen Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIFade.FadeOutScreen
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFadeZOrderType                         ZorderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFade::FadeOutScreen(float Time, const struct FLinearColor& Color, EFadeZOrderType ZorderType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "FadeOutScreen");

	Params::UIFade_FadeOutScreen Parms{};

	Parms.Time = Time;
	Parms.Color = std::move(Color);
	Parms.ZorderType = ZorderType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIFade.FadeOutScreenKeepAlpha
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFadeZOrderType                         ZorderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFade::FadeOutScreenKeepAlpha(float Time, const struct FLinearColor& Color, EFadeZOrderType ZorderType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "FadeOutScreenKeepAlpha");

	Params::UIFade_FadeOutScreenKeepAlpha Parms{};

	Parms.Time = Time;
	Parms.Color = std::move(Color);
	Parms.ZorderType = ZorderType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIFade.IsFadeActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIFade::IsFadeActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "IsFadeActive");

	Params::UIFade_IsFadeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIFade.ReAddViewPort
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFadeZOrderType                         ZorderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIFade::ReAddViewPort(EFadeZOrderType ZorderType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "ReAddViewPort");

	Params::UIFade_ReAddViewPort Parms{};

	Parms.ZorderType = ZorderType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIFade.GetCurrentFrameRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIFade::GetCurrentFrameRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "GetCurrentFrameRate");

	Params::UIFade_GetCurrentFrameRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIFade.GetFadeType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUIFadeType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIFadeType UUIFade::GetFadeType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIFade", "GetFadeType");

	Params::UIFade_GetFadeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_IconLink.ResetButtonData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLink::ResetButtonData(EAxisMappingType Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLink", "ResetButtonData");

	Params::UIField_IconLink_ResetButtonData Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLink.SetCanUseButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxisMappingType                        Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanUse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsRecast                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLink::SetCanUseButton(ELinkType Type, EAxisMappingType Button, bool bCanUse, bool bIsRecast)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLink", "SetCanUseButton");

	Params::UIField_IconLink_SetCanUseButton Parms{};

	Parms.Type = Type;
	Parms.Button = Button;
	Parms.bCanUse = bCanUse;
	Parms.bIsRecast = bIsRecast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLink.SetLinkType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLink::SetLinkType(ELinkType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLink", "SetLinkType");

	Params::UIField_IconLink_SetLinkType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLink.SetMonsterIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLink::SetMonsterIcon(EAxisMappingType Button, class FName KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLink", "SetMonsterIcon");

	Params::UIField_IconLink_SetMonsterIcon Parms{};

	Parms.Button = Button;
	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_IconLink.SetRecastPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkType                               Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxisMappingType                        Button                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_IconLink::SetRecastPercent(ELinkType Type, EAxisMappingType Button, float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_IconLink", "SetRecastPercent");

	Params::UIField_IconLink_SetRecastPercent Parms{};

	Parms.Type = Type;
	Parms.Button = Button;
	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_SearchPoint.SetCanAccess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanAccess                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_SearchPoint::SetCanAccess(bool bCanAccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_SearchPoint", "SetCanAccess");

	Params::UIField_SearchPoint_SetCanAccess Parms{};

	Parms.bCanAccess = bCanAccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Status.GetArtifactIconList
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIArtifactList_Field*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIArtifactList_Field* UUIField_Status::GetArtifactIconList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetArtifactIconList");

	Params::UIField_Status_GetArtifactIconList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetBossStatus
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIField_WinBoss*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_WinBoss* UUIField_Status::GetBossStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetBossStatus");

	Params::UIField_Status_GetBossStatus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetBottomCautionAlert
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIAlert_01*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIAlert_01* UUIField_Status::GetBottomCautionAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetBottomCautionAlert");

	Params::UIField_Status_GetBottomCautionAlert Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetCaution
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUICaution*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUICaution* UUIField_Status::GetCaution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetCaution");

	Params::UIField_Status_GetCaution Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetFriendStatus
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIField_WinFStatus*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_WinFStatus* UUIField_Status::GetFriendStatus(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetFriendStatus");

	Params::UIField_Status_GetFriendStatus Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetLogWindow
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIField_WinLogbox*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_WinLogbox* UUIField_Status::GetLogWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetLogWindow");

	Params::UIField_Status_GetLogWindow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetMapStatus
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIMap_WinStatus*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIMap_WinStatus* UUIField_Status::GetMapStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetMapStatus");

	Params::UIField_Status_GetMapStatus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetMonsterVision
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIVision_Field*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIVision_Field* UUIField_Status::GetMonsterVision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetMonsterVision");

	Params::UIField_Status_GetMonsterVision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetPlayerStatus
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUIField_WinPStatus*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_WinPStatus* UUIField_Status::GetPlayerStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetPlayerStatus");

	Params::UIField_Status_GetPlayerStatus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetQuestConfirmation
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIField_QuestConfirmation*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_QuestConfirmation* UUIField_Status::GetQuestConfirmation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetQuestConfirmation");

	Params::UIField_Status_GetQuestConfirmation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetQuestWindow
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIField_WinQuest*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_WinQuest* UUIField_Status::GetQuestWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetQuestWindow");

	Params::UIField_Status_GetQuestWindow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetSkillChainWindow
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIField_WinSkillbox*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIField_WinSkillbox* UUIField_Status::GetSkillChainWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetSkillChainWindow");

	Params::UIField_Status_GetSkillChainWindow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetTopCautionAlert
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUIAlert_00*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIAlert_00* UUIField_Status::GetTopCautionAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetTopCautionAlert");

	Params::UIField_Status_GetTopCautionAlert Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_Status.GetUnusedFriendStatus
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUIField_WinFStatus*              OutWidget                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResultIndex                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_Status::GetUnusedFriendStatus(class UUIField_WinFStatus** OutWidget, int32* ResultIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "GetUnusedFriendStatus");

	Params::UIField_Status_GetUnusedFriendStatus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutWidget != nullptr)
		*OutWidget = Parms.OutWidget;

	if (ResultIndex != nullptr)
		*ResultIndex = Parms.ResultIndex;
}


// Function DarwinGame.UIField_Status.SetAllyShotHoldFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_Status::SetAllyShotHoldFlag(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "SetAllyShotHoldFlag");

	Params::UIField_Status_SetAllyShotHoldFlag Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Status.SetBattlingFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_Status::SetBattlingFlag(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "SetBattlingFlag");

	Params::UIField_Status_SetBattlingFlag Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Status.SetMoveingFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_Status::SetMoveingFlag(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "SetMoveingFlag");

	Params::UIField_Status_SetMoveingFlag Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Status.UpdateEventFlagVisible
// (Final, Native, Public, BlueprintCallable)

void UUIField_Status::UpdateEventFlagVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Status", "UpdateEventFlagVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Win_Message.InAnimEnd
// (Final, Native, Private)

void UUIField_Win_Message::InAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Win_Message", "InAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Win_Message.InButtonAnimEnd
// (Final, Native, Private)

void UUIField_Win_Message::InButtonAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Win_Message", "InButtonAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Win_Message.OutAnimEnd
// (Final, Native, Private)

void UUIField_Win_Message::OutAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Win_Message", "OutAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_Win_Message.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_Win_Message::SetData(class FName GroupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_Win_Message", "SetData");

	Params::UIField_Win_Message_SetData Parms{};

	Parms.GroupName = GroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinAction.PlayOneshotCautionAnim
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EInputGuideCaution                      CautionType                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinAction::PlayOneshotCautionAnim(const EInputGuideCaution& CautionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinAction", "PlayOneshotCautionAnim");

	Params::UIField_WinAction_PlayOneshotCautionAnim Parms{};

	Parms.CautionType = CautionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinAction.SetActionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputGuideType                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputGuideType                         LongActionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsGaugeMaxCloseType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinAction::SetActionType(EInputGuideType Type, EInputGuideType LongActionType, bool IsGaugeMaxCloseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinAction", "SetActionType");

	Params::UIField_WinAction_SetActionType Parms{};

	Parms.Type = Type;
	Parms.LongActionType = LongActionType;
	Parms.IsGaugeMaxCloseType = IsGaugeMaxCloseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinAction.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinAction::SetPercent(float Percent, bool HasInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinAction", "SetPercent");

	Params::UIField_WinAction_SetPercent Parms{};

	Parms.Percent = Percent;
	Parms.HasInput = HasInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.AddStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatusRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinBoss::AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "AddStatusIcon");

	Params::UIField_WinBoss_AddStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;
	Parms.StatusRank = StatusRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.ChangeStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FStateChangeIconData>     OrderList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinBoss::ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "ChangeStatusIcon");

	Params::UIField_WinBoss_ChangeStatusIcon Parms{};

	Parms.OrderList = std::move(OrderList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.DeleteAllStatusIcon
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinBoss::DeleteAllStatusIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "DeleteAllStatusIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.DeleteStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinBoss::DeleteStatusIcon(const class FName& StatusParameterID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "DeleteStatusIcon");

	Params::UIField_WinBoss_DeleteStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.GetSpiritGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUISpirit_Gauge*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUISpirit_Gauge* UUIField_WinBoss::GetSpiritGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "GetSpiritGauge");

	Params::UIField_WinBoss_GetSpiritGauge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_WinBoss.SetBossNameText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIField_WinBoss::SetBossNameText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "SetBossNameText");

	Params::UIField_WinBoss_SetBossNameText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.SetHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinBoss::SetHP(int32 InHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "SetHP");

	Params::UIField_WinBoss_SetHP Parms{};

	Parms.InHP = InHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinBoss::SetLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "SetLevel");

	Params::UIField_WinBoss_SetLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinBoss.SetMaxHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinBoss::SetMaxHP(int32 InMaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinBoss", "SetMaxHP");

	Params::UIField_WinBoss_SetMaxHP Parms{};

	Parms.InMaxHP = InMaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.AddStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatusRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "AddStatusIcon");

	Params::UIField_WinFriend_AddStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;
	Parms.StatusRank = StatusRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.ChangeStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FStateChangeIconData>     OrderList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "ChangeStatusIcon");

	Params::UIField_WinFriend_ChangeStatusIcon Parms{};

	Parms.OrderList = std::move(OrderList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.DeleteAllStatusIcon
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::DeleteAllStatusIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "DeleteAllStatusIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.DeleteStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::DeleteStatusIcon(const class FName& StatusParameterID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "DeleteStatusIcon");

	Params::UIField_WinFriend_DeleteStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.EndLink
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::EndLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "EndLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.ExecCarryingArtifacts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanDropOff                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::ExecCarryingArtifacts(bool bCanDropOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "ExecCarryingArtifacts");

	Params::UIField_WinFriend_ExecCarryingArtifacts Parms{};

	Parms.bCanDropOff = bCanDropOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.GetSpiritGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUISpirit_Gauge*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUISpirit_Gauge* UUIField_WinFriend::GetSpiritGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "GetSpiritGauge");

	Params::UIField_WinFriend_GetSpiritGauge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_WinFriend.HideMonster
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::HideMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "HideMonster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.InitData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InPartyIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::InitData(int32 InHP, int32 InMaxHP, int32 InLevel, const class FText& InName, int32 InPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "InitData");

	Params::UIField_WinFriend_InitData Parms{};

	Parms.InHP = InHP;
	Parms.InMaxHP = InMaxHP;
	Parms.InLevel = InLevel;
	Parms.InName = std::move(InName);
	Parms.InPartyIndex = InPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.PlayDangerStamp
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::PlayDangerStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "PlayDangerStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.PlayDeathStamp
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::PlayDeathStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "PlayDeathStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.PlayLeaveArtifactStamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArtifactType                           InArtifactType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPartyIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::PlayLeaveArtifactStamp(EArtifactType InArtifactType, int32 InPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "PlayLeaveArtifactStamp");

	Params::UIField_WinFriend_PlayLeaveArtifactStamp Parms{};

	Parms.InArtifactType = InArtifactType;
	Parms.InPartyIndex = InPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.PlayNearArtifactStamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArtifactType                           InArtifactType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPartyIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::PlayNearArtifactStamp(EArtifactType InArtifactType, int32 InPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "PlayNearArtifactStamp");

	Params::UIField_WinFriend_PlayNearArtifactStamp Parms{};

	Parms.InArtifactType = InArtifactType;
	Parms.InPartyIndex = InPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SetHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewHP                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::SetHP(int32 NewHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SetHP");

	Params::UIField_WinFriend_SetHP Parms{};

	Parms.NewHP = NewHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SetLevel");

	Params::UIField_WinFriend_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SetMaxHP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewMaxHP                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::SetMaxHP(int32 NewMaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SetMaxHP");

	Params::UIField_WinFriend_SetMaxHP Parms{};

	Parms.NewMaxHP = NewMaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SetName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             CharacterName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIField_WinFriend::SetName(const class FText& CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SetName");

	Params::UIField_WinFriend_SetName Parms{};

	Parms.CharacterName = std::move(CharacterName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SetPartyIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPartyIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::SetPartyIndex(int32 InPartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SetPartyIndex");

	Params::UIField_WinFriend_SetPartyIndex Parms{};

	Parms.InPartyIndex = InPartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SpiritGaugeCloseExec
// (Final, Native, Private)

void UUIField_WinFriend::SpiritGaugeCloseExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SpiritGaugeCloseExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.SpiritGaugeOpenExec
// (Final, Native, Private)

void UUIField_WinFriend::SpiritGaugeOpenExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "SpiritGaugeOpenExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.StartLink
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::StartLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "StartLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.StopDangerStamp
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::StopDangerStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "StopDangerStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.StopDeathStamp
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::StopDeathStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "StopDeathStamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.StopLeaveArtifactStamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArtifactType                           InArtifactType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::StopLeaveArtifactStamp(EArtifactType InArtifactType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "StopLeaveArtifactStamp");

	Params::UIField_WinFriend_StopLeaveArtifactStamp Parms{};

	Parms.InArtifactType = InArtifactType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.StopNearArtifactStamp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArtifactType                           InArtifactType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFriend::StopNearArtifactStamp(EArtifactType InArtifactType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "StopNearArtifactStamp");

	Params::UIField_WinFriend_StopNearArtifactStamp Parms{};

	Parms.InArtifactType = InArtifactType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.Targeted
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::Targeted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "Targeted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.UnTargeted
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::UnTargeted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "UnTargeted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFriend.VisibleMonster
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFriend::VisibleMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFriend", "VisibleMonster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.AddStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatusRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::AddStatusIcon(const class FName& StatusParameterID, int32 StatusRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "AddStatusIcon");

	Params::UIField_WinStatusBase_AddStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;
	Parms.StatusRank = StatusRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.ChangeStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FStateChangeIconData>     OrderList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::ChangeStatusIcon(const TArray<struct FStateChangeIconData>& OrderList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "ChangeStatusIcon");

	Params::UIField_WinStatusBase_ChangeStatusIcon Parms{};

	Parms.OrderList = std::move(OrderList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.DeleteAllStatusIcon
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinStatusBase::DeleteAllStatusIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "DeleteAllStatusIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.DeleteStatusIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             StatusParameterID                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::DeleteStatusIcon(const class FName& StatusParameterID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "DeleteStatusIcon");

	Params::UIField_WinStatusBase_DeleteStatusIcon Parms{};

	Parms.StatusParameterID = StatusParameterID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.SetHP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPlayAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::SetHP(int32 InHP, bool IsDamage, bool IsPlayAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "SetHP");

	Params::UIField_WinStatusBase_SetHP Parms{};

	Parms.InHP = InHP;
	Parms.IsDamage = IsDamage;
	Parms.IsPlayAnim = IsPlayAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.SetMaxHP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::SetMaxHP(int32 InMaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "SetMaxHP");

	Params::UIField_WinStatusBase_SetMaxHP Parms{};

	Parms.InMaxHP = InMaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.SetMaxMP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMaxMP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::SetMaxMP(int32 InMaxMP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "SetMaxMP");

	Params::UIField_WinStatusBase_SetMaxMP Parms{};

	Parms.InMaxMP = InMaxMP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.SetMP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinStatusBase::SetMP(int32 InMP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "SetMP");

	Params::UIField_WinStatusBase_SetMP Parms{};

	Parms.InMP = InMP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinStatusBase.UpdateMP
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinStatusBase::UpdateMP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinStatusBase", "UpdateMP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.BroadcastDamage
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinFStatus::BroadcastDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "BroadcastDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.BroadcastLvup
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinFStatus::BroadcastLvup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "BroadcastLvup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.DamageAnimEndExec
// (Final, Native, Private)

void UUIField_WinFStatus::DamageAnimEndExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "DamageAnimEndExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.EndLevelUpAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinFStatus::EndLevelUpAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "EndLevelUpAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.ExecLevelUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UpLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFStatus::ExecLevelUp(int32 UpLevel, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "ExecLevelUp");

	Params::UIField_WinFStatus_ExecLevelUp Parms{};

	Parms.UpLevel = UpLevel;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.HoldShotTarget
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFStatus::HoldShotTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "HoldShotTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.InitData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxMP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InKindID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomEquipmentType             InCustomEquipment                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERivalTeamForce                         InRivalTeam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsRivalTeamLeader                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InUid                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFStatus::InitData(int32 InHP, int32 InMaxHP, int32 InMP, int32 InMaxMP, const class FName& InKindID, const struct FCustomEquipmentType& InCustomEquipment, ERivalTeamForce InRivalTeam, bool bInIsRivalTeamLeader, int32 InLevel, const class FText& InName, int32 InUid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "InitData");

	Params::UIField_WinFStatus_InitData Parms{};

	Parms.InHP = InHP;
	Parms.InMaxHP = InMaxHP;
	Parms.InMP = InMP;
	Parms.InMaxMP = InMaxMP;
	Parms.InKindID = InKindID;
	Parms.InCustomEquipment = std::move(InCustomEquipment);
	Parms.InRivalTeam = InRivalTeam;
	Parms.bInIsRivalTeamLeader = bInIsRivalTeamLeader;
	Parms.InLevel = InLevel;
	Parms.InName = std::move(InName);
	Parms.InUid = InUid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.IsSetID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIField_WinFStatus::IsSetID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "IsSetID");

	Params::UIField_WinFStatus_IsSetID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_WinFStatus.OnEndLvupExec
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinFStatus::OnEndLvupExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "OnEndLvupExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.OnStartLvupExec
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinFStatus::OnStartLvupExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "OnStartLvupExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.PlayLevelUpAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinFStatus::PlayLevelUpAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "PlayLevelUpAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.ReleaseShotTarget
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinFStatus::ReleaseShotTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "ReleaseShotTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.ReviveAnimEndExec
// (Final, Native, Private)

void UUIField_WinFStatus::ReviveAnimEndExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "ReviveAnimEndExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.SetID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InKindID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomEquipmentType             InCustomEquipment                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERivalTeamForce                         InRivalTeam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsRivalTeamLeader                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFStatus::SetID(class FName InKindID, const struct FCustomEquipmentType& InCustomEquipment, ERivalTeamForce InRivalTeam, bool bInIsRivalTeamLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "SetID");

	Params::UIField_WinFStatus_SetID Parms{};

	Parms.InKindID = InKindID;
	Parms.InCustomEquipment = std::move(InCustomEquipment);
	Parms.InRivalTeam = InRivalTeam;
	Parms.bInIsRivalTeamLeader = bInIsRivalTeamLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.SetLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinFStatus::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "SetLevel");

	Params::UIField_WinFStatus_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinFStatus.SetName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUIField_WinFStatus::SetName(const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinFStatus", "SetName");

	Params::UIField_WinFStatus_SetName Parms{};

	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.BroadcastDamage
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinPStatus::BroadcastDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "BroadcastDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.BroadcastLvup
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinPStatus::BroadcastLvup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "BroadcastLvup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.EndRecovery
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinPStatus::EndRecovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "EndRecovery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.ExecLvup
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UpLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ComboUP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinPStatus::ExecLvup(int32 UpLevel, bool ComboUP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "ExecLvup");

	Params::UIField_WinPStatus_ExecLvup Parms{};

	Parms.UpLevel = UpLevel;
	Parms.ComboUP = ComboUP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIField_WinPStatus.GetID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UUIField_WinPStatus::GetID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "GetID");

	Params::UIField_WinPStatus_GetID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIField_WinPStatus.InitData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InHP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxHP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxMP                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinPStatus::InitData(int32 InHP, int32 InMaxHP, int32 InMP, int32 InMaxMP, int32 InLevel, const class FName& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "InitData");

	Params::UIField_WinPStatus_InitData Parms{};

	Parms.InHP = InHP;
	Parms.InMaxHP = InMaxHP;
	Parms.InMP = InMP;
	Parms.InMaxMP = InMaxMP;
	Parms.InLevel = InLevel;
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.OnEndLvupExec
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinPStatus::OnEndLvupExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "OnEndLvupExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.OnStartLvupExec
// (Final, Native, Protected, BlueprintCallable)

void UUIField_WinPStatus::OnStartLvupExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "OnStartLvupExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.SetID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InKindID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinPStatus::SetID(class FName InKindID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "SetID");

	Params::UIField_WinPStatus_SetID Parms{};

	Parms.InKindID = InKindID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.SetLevel
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinPStatus::SetLevel(int32 NewLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "SetLevel");

	Params::UIField_WinPStatus_SetLevel Parms{};

	Parms.NewLevel = NewLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIField_WinPStatus.SetName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InName                                                 (Parm, NativeAccessSpecifierPublic)

void UUIField_WinPStatus::SetName(const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "SetName");

	Params::UIField_WinPStatus_SetName Parms{};

	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.SetSpValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIField_WinPStatus::SetSpValue(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "SetSpValue");

	Params::UIField_WinPStatus_SetSpValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinPStatus.StartRecovery
// (Final, Native, Public, BlueprintCallable)

void UUIField_WinPStatus::StartRecovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinPStatus", "StartRecovery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinQuest.EndTaskProcess
// (Final, Native, Protected)

void UUIField_WinQuest::EndTaskProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinQuest", "EndTaskProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinQuest.InOutWindowProcess
// (Final, Native, Protected)

void UUIField_WinQuest::InOutWindowProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinQuest", "InOutWindowProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIField_WinSkillbox.AddChain
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bIsNewChain                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCustomEquipmentType             CustomEquipment                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERivalTeamForce                         RivalTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRivalTeamLeader                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EResistanceType                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ActionName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EResistanceType>                 NextChainTypes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIField_WinSkillbox::AddChain(bool bIsNewChain, class FName KindId, const struct FCustomEquipmentType& CustomEquipment, ERivalTeamForce RivalTeam, bool IsRivalTeamLeader, EResistanceType Type, const class FText& ActionName, const TArray<EResistanceType>& NextChainTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIField_WinSkillbox", "AddChain");

	Params::UIField_WinSkillbox_AddChain Parms{};

	Parms.bIsNewChain = bIsNewChain;
	Parms.KindId = KindId;
	Parms.CustomEquipment = std::move(CustomEquipment);
	Parms.RivalTeam = RivalTeam;
	Parms.IsRivalTeamLeader = IsRivalTeamLeader;
	Parms.Type = Type;
	Parms.ActionName = std::move(ActionName);
	Parms.NextChainTypes = std::move(NextChainTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIGaugeBase.InitWithParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxParam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGaugeBase::InitWithParam(float InParam, float InMaxParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGaugeBase", "InitWithParam");

	Params::UIGaugeBase_InitWithParam Parms{};

	Parms.InParam = InParam;
	Parms.InMaxParam = InMaxParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGaugeBase.InitWithPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGaugeBase::InitWithPercent(float InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGaugeBase", "InitWithPercent");

	Params::UIGaugeBase_InitWithPercent Parms{};

	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGaugeBase.SetMaxParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMaxParam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGaugeBase::SetMaxParam(float InMaxParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGaugeBase", "SetMaxParam");

	Params::UIGaugeBase_SetMaxParam Parms{};

	Parms.InMaxParam = InMaxParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGaugeBase.SetParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGaugeBase::SetParam(float InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGaugeBase", "SetParam");

	Params::UIGaugeBase_SetParam Parms{};

	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGaugeBase.SetShowParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InShowParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGaugeBase::SetShowParam(float InShowParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGaugeBase", "SetShowParam");

	Params::UIGaugeBase_SetShowParam Parms{};

	Parms.InShowParam = InShowParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGaugeBase.UpdateWithParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxParam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGaugeBase::UpdateWithParam(float InParam, float InMaxParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGaugeBase", "UpdateWithParam");

	Params::UIGaugeBase_UpdateWithParam Parms{};

	Parms.InParam = InParam;
	Parms.InMaxParam = InMaxParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGlut_IconFood.Clip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGlut_IconFood::Clip(float InX, float InY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_IconFood", "Clip");

	Params::UIGlut_IconFood_Clip Parms{};

	Parms.InX = InX;
	Parms.InY = InY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGlut_IconFood.IsFavoriteFood
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIGlut_IconFood::IsFavoriteFood()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_IconFood", "IsFavoriteFood");

	Params::UIGlut_IconFood_IsFavoriteFood Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIGlut_IconFood.SetDataUid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InItemId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InUid                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGlut_IconFood::SetDataUid(const class FName& InItemId, const int32& InUid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_IconFood", "SetDataUid");

	Params::UIGlut_IconFood_SetDataUid Parms{};

	Parms.InItemId = InItemId;
	Parms.InUid = InUid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGlut_IconFood.SetIsCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsCategory                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGlut_IconFood::SetIsCategory(bool bInIsCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_IconFood", "SetIsCategory");

	Params::UIGlut_IconFood_SetIsCategory Parms{};

	Parms.bInIsCategory = bInIsCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGlut_IconFood.UpdateData
// (Final, Native, Public, BlueprintCallable)

void UUIGlut_IconFood::UpdateData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_IconFood", "UpdateData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGlut_WinStatus.SetTargetUid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InUid                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIGlut_WinStatus::SetTargetUid(const int32 InUid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGlut_WinStatus", "SetTargetUid");

	Params::UIGlut_WinStatus_SetTargetUid Parms{};

	Parms.InUid = InUid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGood.HeartOutAnimEnd
// (Final, Native, Protected)

void UUIGood::HeartOutAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGood", "HeartOutAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGood.PlayHeartResultEffect
// (Final, Native, Public, BlueprintCallable)

void UUIGood::PlayHeartResultEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGood", "PlayHeartResultEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGood_Count.EndCountOnAnim
// (Final, Native, Protected)

void UUIGood_Count::EndCountOnAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGood_Count", "EndCountOnAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGood_Count.EndStopOnAnim
// (Final, Native, Protected)

void UUIGood_Count::EndStopOnAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGood_Count", "EndStopOnAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGood_Gauge.GaugeCloseAnimEnd
// (Final, Native, Protected)

void UUIGood_Gauge::GaugeCloseAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGood_Gauge", "GaugeCloseAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIGood_GoodIcon.EndAnimFunc
// (Final, Native, Private)

void UUIGood_GoodIcon::EndAnimFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIGood_GoodIcon", "EndAnimFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHub_Coin_02.PlayEndCoinFallAnimCallBack
// (Final, Native, Protected, BlueprintCallable)

void UUIHub_Coin_02::PlayEndCoinFallAnimCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHub_Coin_02", "PlayEndCoinFallAnimCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHub_CoinWindow.EffectMovieRequestDataExec
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UManaComponent*                   ManaComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIHub_CoinWindow::EffectMovieRequestDataExec(class UManaComponent* ManaComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHub_CoinWindow", "EffectMovieRequestDataExec");

	Params::UIHub_CoinWindow_EffectMovieRequestDataExec Parms{};

	Parms.ManaComponent = ManaComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHub_RankUp.EffectMovieChangeStateExec
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EManaComponentStatus                    Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UManaComponent*                   ManaComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIHub_RankUp::EffectMovieChangeStateExec(EManaComponentStatus Status, class UManaComponent* ManaComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHub_RankUp", "EffectMovieChangeStateExec");

	Params::UIHub_RankUp_EffectMovieChangeStateExec Parms{};

	Parms.Status = Status;
	Parms.ManaComponent = ManaComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHub_RankUp.EffectMovieRequestDataExec
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UManaComponent*                   ManaComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIHub_RankUp::EffectMovieRequestDataExec(class UManaComponent* ManaComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHub_RankUp", "EffectMovieRequestDataExec");

	Params::UIHub_RankUp_EffectMovieRequestDataExec Parms{};

	Parms.ManaComponent = ManaComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIHub_RankUp.PlayNewRankAnim
// (Final, Native, Protected, BlueprintCallable)

void UUIHub_RankUp::PlayNewRankAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIHub_RankUp", "PlayNewRankAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemget_NewItem.SetItemData
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InItemId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIItemget_NewItem::SetItemData(class FName InItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemget_NewItem", "SetItemData");

	Params::UIItemget_NewItem_SetItemData Parms{};

	Parms.InItemId = InItemId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIItemget_NewItem.SetItemTitleText
// (Final, Native, Protected, BlueprintCallable)

void UUIItemget_NewItem::SetItemTitleText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemget_NewItem", "SetItemTitleText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemget_NewItem.SetRecipeTitleText
// (Final, Native, Protected, BlueprintCallable)

void UUIItemget_NewItem::SetRecipeTitleText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemget_NewItem", "SetRecipeTitleText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemget_NewItem.IsDecideVisible
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIItemget_NewItem::IsDecideVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemget_NewItem", "IsDecideVisible");

	Params::UIItemget_NewItem_IsDecideVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UIItemmenu.ItemChangeFocusCallback
// (Final, Native, Protected)

void UUIItemmenu::ItemChangeFocusCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu", "ItemChangeFocusCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_02_03.GetFacilityType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacilityMenuType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFacilityMenuType UUIItemmenu_02_03::GetFacilityType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_02_03", "GetFacilityType");

	Params::UIItemmenu_02_03_GetFacilityType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIItemmenu_02_03.ItemChangeFocusCallback
// (Final, Native, Protected)

void UUIItemmenu_02_03::ItemChangeFocusCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_02_03", "ItemChangeFocusCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_02_03.SetFacilityType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacilityMenuType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIItemmenu_02_03::SetFacilityType(EFacilityMenuType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_02_03", "SetFacilityType");

	Params::UIItemmenu_02_03_SetFacilityType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.GetInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUIManager*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIManager* UUIManager::GetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIManager", "GetInstance");

	Params::UIManager_GetInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.DynamicCreateWidget
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinUserWidget* UUIManager::DynamicCreateWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "DynamicCreateWidget");

	Params::UIManager_DynamicCreateWidget Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetReUseWidget
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinUserWidget* UUIManager::GetReUseWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetReUseWidget");

	Params::UIManager_GetReUseWidget Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetUnusedWidget
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinUserWidget* UUIManager::GetUnusedWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetUnusedWidget");

	Params::UIManager_GetUnusedWidget Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDarwinUserWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinUserWidget* UUIManager::GetWidget(TSubclassOf<class UDarwinUserWidget> Class_0, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetWidget");

	Params::UIManager_GetWidget Parms{};

	Parms.Class_0 = Class_0;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetWidgetArray
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDarwinUserWidget>    Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidgetArray*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidgetArray* UUIManager::GetWidgetArray(TSubclassOf<class UDarwinUserWidget> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetWidgetArray");

	Params::UIManager_GetWidgetArray Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.LoadOneShot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             OneShotName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIManager::LoadOneShot(class FName OneShotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "LoadOneShot");

	Params::UIManager_LoadOneShot Parms{};

	Parms.OneShotName = OneShotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.PauseGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIManager::PauseGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "PauseGame");

	Params::UIManager_PauseGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.PlayOneShot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   OneShotId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WaitTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::PlayOneShot(int32 OneShotId, float WaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "PlayOneShot");

	Params::UIManager_PlayOneShot Parms{};

	Parms.OneShotId = OneShotId;
	Parms.WaitTime = WaitTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.ResetResidentWidgetViewPort
// (Final, Native, Public, BlueprintCallable)

void UUIManager::ResetResidentWidgetViewPort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "ResetResidentWidgetViewPort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetCanOpenMainMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanOpen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetCanOpenMainMenu(bool bCanOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetCanOpenMainMenu");

	Params::UIManager_SetCanOpenMainMenu Parms{};

	Parms.bCanOpen = bCanOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtDungeon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtDungeon(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtDungeon");

	Params::UIManager_SetHideFlagAtDungeon Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtEvent(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtEvent");

	Params::UIManager_SetHideFlagAtEvent Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtForcedBattle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtForcedBattle(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtForcedBattle");

	Params::UIManager_SetHideFlagAtForcedBattle Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtGeneralSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtGeneralSequence(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtGeneralSequence");

	Params::UIManager_SetHideFlagAtGeneralSequence Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtQuest(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtQuest");

	Params::UIManager_SetHideFlagAtQuest Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtQuestOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtQuestOrder(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtQuestOrder");

	Params::UIManager_SetHideFlagAtQuestOrder Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtRankUpSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtRankUpSequence(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtRankUpSequence");

	Params::UIManager_SetHideFlagAtRankUpSequence Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetHideFlagAtSpecialAbility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHide                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetHideFlagAtSpecialAbility(bool bIsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetHideFlagAtSpecialAbility");

	Params::UIManager_SetHideFlagAtSpecialAbility Parms{};

	Parms.bIsHide = bIsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetQueueSystemCanEnqueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanEnqueue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetQueueSystemCanEnqueue(bool bCanEnqueue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetQueueSystemCanEnqueue");

	Params::UIManager_SetQueueSystemCanEnqueue Parms{};

	Parms.bCanEnqueue = bCanEnqueue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.SetQueueSystemUpdateEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::SetQueueSystemUpdateEnable(bool bIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "SetQueueSystemUpdateEnable");

	Params::UIManager_SetQueueSystemUpdateEnable Parms{};

	Parms.bIsEnable = bIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.UnloadOneShot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   OneShotId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIManager::UnloadOneShot(int32 OneShotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "UnloadOneShot");

	Params::UIManager_UnloadOneShot Parms{};

	Parms.OneShotId = OneShotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIManager.UnPauseGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIManager::UnPauseGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "UnPauseGame");

	Params::UIManager_UnPauseGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.CanOpenMainMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIManager::CanOpenMainMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "CanOpenMainMenu");

	Params::UIManager_CanOpenMainMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetDarwinFrameCapture
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDarwinFrameCapture*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDarwinFrameCapture* UUIManager::GetDarwinFrameCapture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetDarwinFrameCapture");

	Params::UIManager_GetDarwinFrameCapture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetTipsOpenConditionsChecker
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTipsOpenConditionsChecker*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTipsOpenConditionsChecker* UUIManager::GetTipsOpenConditionsChecker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetTipsOpenConditionsChecker");

	Params::UIManager_GetTipsOpenConditionsChecker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetTipsOpener
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTipsOpener*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTipsOpener* UUIManager::GetTipsOpener() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetTipsOpener");

	Params::UIManager_GetTipsOpener Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetUIARMarkerSystem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIARMarkerSystem*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIARMarkerSystem* UUIManager::GetUIARMarkerSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetUIARMarkerSystem");

	Params::UIManager_GetUIARMarkerSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetUIArtifactGetSystem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIArtifactGetSystem*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIArtifactGetSystem* UUIManager::GetUIArtifactGetSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetUIArtifactGetSystem");

	Params::UIManager_GetUIArtifactGetSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetUIFieldStamp
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIFieldQueueStampSystem*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIFieldQueueStampSystem* UUIManager::GetUIFieldStamp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetUIFieldStamp");

	Params::UIManager_GetUIFieldStamp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.GetUIQuestQueueSystem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUIQuestQueueSystem*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIQuestQueueSystem* UUIManager::GetUIQuestQueueSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "GetUIQuestQueueSystem");

	Params::UIManager_GetUIQuestQueueSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.IsLoadedOneShot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   OneShotId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIManager::IsLoadedOneShot(int32 OneShotId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "IsLoadedOneShot");

	Params::UIManager_IsLoadedOneShot Parms{};

	Parms.OneShotId = OneShotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.IsQuestSystemPauseDirecting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIManager::IsQuestSystemPauseDirecting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "IsQuestSystemPauseDirecting");

	Params::UIManager_IsQuestSystemPauseDirecting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIManager.WidgetCanAction
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDarwinUserWidget*                Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetAction                           Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIManager::WidgetCanAction(class UDarwinUserWidget* Target, EWidgetAction Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIManager", "WidgetCanAction");

	Params::UIManager_WidgetCanAction Parms{};

	Parms.Target = Target;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIItemmenu_02_03_Root.SetFacilityType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacilityMenuType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIItemmenu_02_03_Root::SetFacilityType(EFacilityMenuType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_02_03_Root", "SetFacilityType");

	Params::UIItemmenu_02_03_Root_SetFacilityType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_WinMakeDirecting.PlayMakingSound
// (Final, Native, Private)

void UUIItemmenu_WinMakeDirecting::PlayMakingSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_WinMakeDirecting", "PlayMakingSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_WinMakeDirecting.ResultWindowCloseEndCallBack
// (Final, Native, Private)

void UUIItemmenu_WinMakeDirecting::ResultWindowCloseEndCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_WinMakeDirecting", "ResultWindowCloseEndCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_WinMakeDirecting.ResultWindowOpenEndCallBack
// (Final, Native, Private)

void UUIItemmenu_WinMakeDirecting::ResultWindowOpenEndCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_WinMakeDirecting", "ResultWindowOpenEndCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIItemmenu_WinMakeDirecting.SetMakeDirecting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacilityMenuType                       InMenuType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InItemId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InItemNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIItemmenu_WinMakeDirecting::SetMakeDirecting(EFacilityMenuType InMenuType, class FName InItemId, int32 InItemNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIItemmenu_WinMakeDirecting", "SetMakeDirecting");

	Params::UIItemmenu_WinMakeDirecting_SetMakeDirecting Parms{};

	Parms.InMenuType = InMenuType;
	Parms.InItemId = InItemId;
	Parms.InItemNum = InItemNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILineFade_00.EndFadeIn
// (Final, Native, Private)

void UUILineFade_00::EndFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILineFade_00", "EndFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILineFade_00.EndFadeOut
// (Final, Native, Private)

void UUILineFade_00::EndFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILineFade_00", "EndFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILinkGauge_Icon.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUILinkGauge_Icon::SetPercent(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILinkGauge_Icon", "SetPercent");

	Params::UILinkGauge_Icon_SetPercent Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILoading_Win_Tutorial.InAnimEnd
// (Final, Native, Private)

void UUILoading_Win_Tutorial::InAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILoading_Win_Tutorial", "InAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UILoading_Win_Tutorial.OutAnimEnd
// (Final, Native, Private)

void UUILoading_Win_Tutorial::OutAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UILoading_Win_Tutorial", "OutAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMapMenu.DrawDebug3DPos
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMapMenu::DrawDebug3DPos(const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMapMenu", "DrawDebug3DPos");

	Params::UIMapMenu_DrawDebug3DPos Parms{};

	Parms.Pos = std::move(Pos);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIMapMenu.DrawDebugPos
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMapMenu::DrawDebugPos(const struct FVector2D& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMapMenu", "DrawDebugPos");

	Params::UIMapMenu_DrawDebugPos Parms{};

	Parms.Pos = std::move(Pos);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIMapMenu.DrawDebugSignSymbolLog
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AreaID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMapMenu::DrawDebugSignSymbolLog(const struct FVector& Pos, class FName AreaID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMapMenu", "DrawDebugSignSymbolLog");

	Params::UIMapMenu_DrawDebugSignSymbolLog Parms{};

	Parms.Pos = std::move(Pos);
	Parms.AreaID = AreaID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UIMenuNumberBase.ChangeValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Add                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isLeftStick                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isRightStick                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIMenuNumberBase::ChangeValue(EAxisMappingType Key, int32 Add, bool isLeftStick, bool isRightStick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuNumberBase", "ChangeValue");

	Params::UIMenuNumberBase_ChangeValue Parms{};

	Parms.Key = Key;
	Parms.Add = Add;
	Parms.isLeftStick = isLeftStick;
	Parms.isRightStick = isRightStick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuNumberBase.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUIMenuNumberBase::GetValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuNumberBase", "GetValue");

	Params::UIMenuNumberBase_GetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuNumberBase.IsSelectable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIMenuNumberBase::IsSelectable(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuNumberBase", "IsSelectable");

	Params::UIMenuNumberBase_IsSelectable Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIMenuNumberBase.SetRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuNumberBase::SetRange(int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuNumberBase", "SetRange");

	Params::UIMenuNumberBase_SetRange Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuNumberBase.SetSkipValues
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuNumberBase::SetSkipValues(const TArray<int32>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuNumberBase", "SetSkipValues");

	Params::UIMenuNumberBase_SetSkipValues Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMenuNumberBase.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMenuNumberBase::SetValue(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMenuNumberBase", "SetValue");

	Params::UIMenuNumberBase_SetValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMonsterDict_SelectMenu.OnChangeFocusFunc
// (Final, Native, Protected)

void UUIMonsterDict_SelectMenu::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMonsterDict_SelectMenu", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMovieScreen.FadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMovieScreen::FadeIn(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMovieScreen", "FadeIn");

	Params::UIMovieScreen_FadeIn Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMovieScreen.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMovieScreen::FadeOut(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMovieScreen", "FadeOut");

	Params::UIMovieScreen_FadeOut Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIMovieScreen.SetMovieTexture
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UManaTexture*                     MovieTexture                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIMovieScreen::SetMovieTexture(class UManaTexture* MovieTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIMovieScreen", "SetMovieTexture");

	Params::UIMovieScreen_SetMovieTexture Parms{};

	Parms.MovieTexture = MovieTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UINameBoxBase.OffFocus
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             CommitMethod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUINameBoxBase::OffFocus(const class FText& InText, ETextCommit CommitMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UINameBoxBase", "OffFocus");

	Params::UINameBoxBase_OffFocus Parms{};

	Parms.InText = std::move(InText);
	Parms.CommitMethod = CommitMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UINameBoxBase.OnFloatingScreenKeyboardDismissed
// (Final, Native, Protected)

void UUINameBoxBase::OnFloatingScreenKeyboardDismissed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UINameBoxBase", "OnFloatingScreenKeyboardDismissed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UINameBoxBase.OnScreenKeyboardDismissed
// (Final, Native, Protected)
// Parameters:
// bool                                    IsTextCallbackSuccessful                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             CallbackText                                           (Parm, NativeAccessSpecifierPublic)

void UUINameBoxBase::OnScreenKeyboardDismissed(bool IsTextCallbackSuccessful, const class FText& CallbackText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UINameBoxBase", "OnScreenKeyboardDismissed");

	Params::UINameBoxBase_OnScreenKeyboardDismissed Parms{};

	Parms.IsTextCallbackSuccessful = IsTextCallbackSuccessful;
	Parms.CallbackText = std::move(CallbackText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UINameBoxBase.OnTextChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUINameBoxBase::OnTextChanged(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UINameBoxBase", "OnTextChanged");

	Params::UINameBoxBase_OnTextChanged Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UINetWorkTop.OnChangeFocusFunc
// (Final, Native, Protected)

void UUINetWorkTop::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UINetWorkTop", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIPlayerSp_Stock.PlayAnimEnd
// (Final, Native, Private)

void UUIPlayerSp_Stock::PlayAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPlayerSp_Stock", "PlayAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIPlayerSp_Stock.SetSpValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIPlayerSp_Stock::SetSpValue(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIPlayerSp_Stock", "SetSpValue");

	Params::UIPlayerSp_Stock_SetSpValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuestFunctionLibrary.DebugClearQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIQuestFunctionLibrary::DebugClearQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "DebugClearQuest");

	Params::UIQuestFunctionLibrary_DebugClearQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuestFunctionLibrary.DebugOpenQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIQuestFunctionLibrary::DebugOpenQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "DebugOpenQuest");

	Params::UIQuestFunctionLibrary_DebugOpenQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuestFunctionLibrary.DebugOrderQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIQuestFunctionLibrary::DebugOrderQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "DebugOrderQuest");

	Params::UIQuestFunctionLibrary_DebugOrderQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuestFunctionLibrary.HasClearedQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIQuestFunctionLibrary::HasClearedQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "HasClearedQuest");

	Params::UIQuestFunctionLibrary_HasClearedQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIQuestFunctionLibrary.HasOpenedQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIQuestFunctionLibrary::HasOpenedQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "HasOpenedQuest");

	Params::UIQuestFunctionLibrary_HasOpenedQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIQuestFunctionLibrary.HasOrderQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIQuestFunctionLibrary::HasOrderQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "HasOrderQuest");

	Params::UIQuestFunctionLibrary_HasOrderQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIQuestFunctionLibrary.IsOfficialNetworkQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIQuestFunctionLibrary::IsOfficialNetworkQuest(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UIQuestFunctionLibrary", "IsOfficialNetworkQuest");

	Params::UIQuestFunctionLibrary_IsOfficialNetworkQuest Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UIQuestMenu.ChildQuestChangeFocusCallback
// (Final, Native, Protected)

void UUIQuestMenu::ChildQuestChangeFocusCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQuestMenu", "ChildQuestChangeFocusCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIQuestMenu.MainQuestChangeFocusCallback
// (Final, Native, Protected)

void UUIQuestMenu::MainQuestChangeFocusCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIQuestMenu", "MainQuestChangeFocusCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIRewardWin_00.OpenItem
// (Final, Native, Protected, BlueprintCallable)

void UUIRewardWin_00::OpenItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIRewardWin_00", "OpenItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIRewardWin_00.OpenSentence
// (Final, Native, Protected, BlueprintCallable)

void UUIRewardWin_00::OpenSentence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIRewardWin_00", "OpenSentence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIRewardWin_00.OpenWindow
// (Final, Native, Protected, BlueprintCallable)

void UUIRewardWin_00::OpenWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIRewardWin_00", "OpenWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISaveContent.OpenSaveEndCallback
// (Final, Native, Protected)

void UUISaveContent::OpenSaveEndCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISaveContent", "OpenSaveEndCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISaveContent.SaveDialogCallback
// (Final, Native, Protected)
// Parameters:
// bool                                    IsYes                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISaveContent::SaveDialogCallback(bool IsYes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISaveContent", "SaveDialogCallback");

	Params::UISaveContent_SaveDialogCallback Parms{};

	Parms.IsYes = IsYes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISaveContent.SaveEndCallback
// (Final, Native, Protected)

void UUISaveContent::SaveEndCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISaveContent", "SaveEndCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISaveContent.SaveEndDialogCallback
// (Final, Native, Protected)
// Parameters:
// bool                                    IsYes                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISaveContent::SaveEndDialogCallback(bool IsYes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISaveContent", "SaveEndDialogCallback");

	Params::UISaveContent_SaveEndDialogCallback Parms{};

	Parms.IsYes = IsYes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconBullet.Clip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_IconBullet::Clip(float InX, float InY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconBullet", "Clip");

	Params::UIShot_IconBullet_Clip Parms{};

	Parms.InX = InX;
	Parms.InY = InY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconBullet.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InItemId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_IconBullet::SetData(const class FName& InItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconBullet", "SetData");

	Params::UIShot_IconBullet_SetData Parms{};

	Parms.InItemId = InItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconBullet.SetIsCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsCategory                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIShot_IconBullet::SetIsCategory(bool bInIsCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconBullet", "SetIsCategory");

	Params::UIShot_IconBullet_SetIsCategory Parms{};

	Parms.bInIsCategory = bInIsCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIShot_IconBullet.UpdateData
// (Final, Native, Public, BlueprintCallable)

void UUIShot_IconBullet::UpdateData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIShot_IconBullet", "UpdateData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_BoxCursor.EndCursorTargetAnim
// (Final, Native, Private)

void UUISign_BoxCursor::EndCursorTargetAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_BoxCursor", "EndCursorTargetAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_BoxCursor.EndCursorUnTargetAnim
// (Final, Native, Private)

void UUISign_BoxCursor::EndCursorUnTargetAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_BoxCursor", "EndCursorUnTargetAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageBase.EndAnimExec
// (Final, Native, Private)

void UUISign_IconDamageBase::EndAnimExec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageBase", "EndAnimExec");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageBase.SetBelongType
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Belong                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageBase::SetBelongType(const struct FGameplayTag& Belong)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageBase", "SetBelongType");

	Params::UISign_IconDamageBase_SetBelongType Parms{};

	Parms.Belong = std::move(Belong);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageBase.SetDamageValue
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageBase::SetDamageValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageBase", "SetDamageValue");

	Params::UISign_IconDamageBase_SetDamageValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageBase.SetData
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Belong                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageSizeType                         SizeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageBase::SetData(float Value, const struct FGameplayTag& Belong, EDamageSizeType SizeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageBase", "SetData");

	Params::UISign_IconDamageBase_SetData Parms{};

	Parms.Value = Value;
	Parms.Belong = std::move(Belong);
	Parms.SizeType = SizeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconDamageBase.SetSizeType
// (Native, Public, BlueprintCallable)
// Parameters:
// EDamageSizeType                         SizeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconDamageBase::SetSizeType(EDamageSizeType SizeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconDamageBase", "SetSizeType");

	Params::UISign_IconDamageBase_SetSizeType Parms{};

	Parms.SizeType = SizeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconExp.SetExpValue
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconExp::SetExpValue(int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconExp", "SetExpValue");

	Params::UISign_IconExp_SetExpValue Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UISign_IconHeal.SetData
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIHealPopType                          HealPopType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconHeal::SetData(float Value, const struct FVector& TargetLocation, EUIHealPopType HealPopType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconHeal", "SetData");

	Params::UISign_IconHeal_SetData Parms{};

	Parms.Value = Value;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.HealPopType = HealPopType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconHeal.SetHealPopType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIHealPopType                          HealPopType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconHeal::SetHealPopType(EUIHealPopType HealPopType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconHeal", "SetHealPopType");

	Params::UISign_IconHeal_SetHealPopType Parms{};

	Parms.HealPopType = HealPopType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconHeal.SetHealValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconHeal::SetHealValue(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconHeal", "SetHealValue");

	Params::UISign_IconHeal_SetHealValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconItemname.SetItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemDataType                           NewParam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconItemname::SetItem(class FName ID, EItemDataType NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconItemname", "SetItem");

	Params::UISign_IconItemname_SetItem Parms{};

	Parms.ID = ID;
	Parms.NewParam = NewParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconItemname.SetNameFromCoinParam
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FST_CoinParam                    CoinParam                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUISign_IconItemname::SetNameFromCoinParam(const struct FST_CoinParam& CoinParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconItemname", "SetNameFromCoinParam");

	Params::UISign_IconItemname_SetNameFromCoinParam Parms{};

	Parms.CoinParam = std::move(CoinParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconLvup.PlayLvupAnim
// (Final, Native, Protected, BlueprintCallable)

void UUISign_IconLvup::PlayLvupAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvup", "PlayLvupAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconLvup.PlayOneShotLvUp
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUISign_IconLvup::PlayOneShotLvUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvup", "PlayOneShotLvUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DarwinGame.UISign_IconLvup.SetData
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsComboUp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconLvup::SetData(bool IsComboUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvup", "SetData");

	Params::UISign_IconLvup_SetData Parms{};

	Parms.IsComboUp = IsComboUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DarwinGame.UISign_IconLvup.SetIsStatusIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconLvup::SetIsStatusIcon(bool IsIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconLvup", "SetIsStatusIcon");

	Params::UISign_IconLvup_SetIsStatusIcon Parms{};

	Parms.IsIcon = IsIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconQuest.SetBalloonData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconQuest::SetBalloonData(class FName QuestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconQuest", "SetBalloonData");

	Params::UISign_IconQuest_SetBalloonData Parms{};

	Parms.QuestID = QuestID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconQuest.SetBalloonType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EBalloonIconType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconQuest::SetBalloonType(EBalloonIconType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconQuest", "SetBalloonType");

	Params::UISign_IconQuest_SetBalloonType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISign_IconQuest.SetLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsAnother                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISign_IconQuest::SetLayer(bool IsAnother)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISign_IconQuest", "SetLayer");

	Params::UISign_IconQuest_SetLayer Parms{};

	Parms.IsAnother = IsAnother;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISkillName.SetSkillNameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             OverviewID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCloseTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFriend                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISkillName::SetSkillNameData(class FName OverviewID, float InCloseTime, bool IsFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISkillName", "SetSkillNameData");

	Params::UISkillName_SetSkillNameData Parms{};

	Parms.OverviewID = OverviewID;
	Parms.InCloseTime = InCloseTime;
	Parms.IsFriend = IsFriend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISpirit_Gauge.IsEndPercentAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUISpirit_Gauge::IsEndPercentAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISpirit_Gauge", "IsEndPercentAnim");

	Params::UISpirit_Gauge_IsEndPercentAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UISpirit_Gauge.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISpirit_Gauge::SetPercent(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISpirit_Gauge", "SetPercent");

	Params::UISpirit_Gauge_SetPercent Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStaff_Roll_00.PicOutEnd
// (Final, Native, Protected)

void UUIStaff_Roll_00::PicOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStaff_Roll_00", "PicOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStaff_Roll_00.PlayBackgroundMusic
// (Final, Native, Protected, BlueprintCallable)

void UUIStaff_Roll_00::PlayBackgroundMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStaff_Roll_00", "PlayBackgroundMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStaff_Roll_00.PlayPicOutAnim
// (Final, Native, Protected)

void UUIStaff_Roll_00::PlayPicOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStaff_Roll_00", "PlayPicOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStaff_Roll_00.PlayPicWaitAnim
// (Final, Native, Protected)

void UUIStaff_Roll_00::PlayPicWaitAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStaff_Roll_00", "PlayPicWaitAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStation_Map.PlayWaitAnim
// (Final, Native, Private)

void UUIStation_Map::PlayWaitAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStation_Map", "PlayWaitAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStation_Map.PlayWaitNameAnim
// (Final, Native, Private)

void UUIStation_Map::PlayWaitNameAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStation_Map", "PlayWaitNameAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIStationMenu.OnChangeFocusFunc
// (Final, Native, Public)

void UUIStationMenu::OnChangeFocusFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIStationMenu", "OnChangeFocusFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.MissAnimEnd
// (Final, Native, Private)

void UUISteal::MissAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "MissAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.PlayRotate
// (Final, Native, Protected, BlueprintCallable)

void UUISteal::PlayRotate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "PlayRotate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.PressAnimEnd
// (Final, Native, Private)

void UUISteal::PressAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "PressAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.Push
// (Final, Native, Public, BlueprintCallable)

void UUISteal::Push()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "Push");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitRangePercent                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUISteal::SetData(class AActor* Target, float HitRangePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "SetData");

	Params::UISteal_SetData Parms{};

	Parms.Target = Target;
	Parms.HitRangePercent = HitRangePercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.StopRotate
// (Final, Native, Protected, BlueprintCallable)

void UUISteal::StopRotate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "StopRotate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.SuccessAnimEnd
// (Final, Native, Private)

void UUISteal::SuccessAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "SuccessAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UISteal.GetRotationSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUISteal::GetRotationSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "GetRotationSeconds");

	Params::UISteal_GetRotationSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UISteal.IsSuccess
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUISteal::IsSuccess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISteal", "IsSuccess");

	Params::UISteal_IsSuccess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UISub_01.PlayContinuedWaitAnimation
// (Final, Native, Private)

void UUISub_01::PlayContinuedWaitAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UISub_01", "PlayContinuedWaitAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_BtnChoice.Decide
// (Final, Native, Public, BlueprintCallable)

void UUITalk_BtnChoice::Decide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "Decide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_BtnChoice.IsSlideIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUITalk_BtnChoice::IsSlideIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "IsSlideIn");

	Params::UITalk_BtnChoice_IsSlideIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UITalk_BtnChoice.OffNew
// (Final, Native, Public, BlueprintCallable)

void UUITalk_BtnChoice::OffNew()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "OffNew");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_BtnChoice.OnNew
// (Final, Native, Public, BlueprintCallable)

void UUITalk_BtnChoice::OnNew()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "OnNew");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_BtnChoice.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FChoiceItemData                  Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UUITalk_BtnChoice::SetData(const struct FChoiceItemData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "SetData");

	Params::UITalk_BtnChoice_SetData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_BtnChoice.SlideIn
// (Final, Native, Public, BlueprintCallable)

void UUITalk_BtnChoice::SlideIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "SlideIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_BtnChoice.SlideOut
// (Final, Native, Public, BlueprintCallable)

void UUITalk_BtnChoice::SlideOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_BtnChoice", "SlideOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.CallChoiceResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITalk_WinChoice::CallChoiceResult(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "CallChoiceResult");

	Params::UITalk_WinChoice_CallChoiceResult Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.CanShortCut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        ShortCutKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUITalk_WinChoice::CanShortCut(EAxisMappingType ShortCutKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "CanShortCut");

	Params::UITalk_WinChoice_CanShortCut Parms{};

	Parms.ShortCutKey = ShortCutKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UITalk_WinChoice.ChangeFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITalk_WinChoice::ChangeFocus(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "ChangeFocus");

	Params::UITalk_WinChoice_ChangeFocus Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.CheckSlideEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUITalk_WinChoice::CheckSlideEnd(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "CheckSlideEnd");

	Params::UITalk_WinChoice_CheckSlideEnd Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UITalk_WinChoice.GetEventType
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEventType                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEventType UUITalk_WinChoice::GetEventType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "GetEventType");

	Params::UITalk_WinChoice_GetEventType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DarwinGame.UITalk_WinChoice.GetShortCutItemIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        ShortCutKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUITalk_WinChoice::GetShortCutItemIndex(EAxisMappingType ShortCutKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "GetShortCutItemIndex");

	Params::UITalk_WinChoice_GetShortCutItemIndex Parms{};

	Parms.ShortCutKey = ShortCutKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.UITalk_WinChoice.Performance
// (Final, Native, Public, BlueprintCallable)

void UUITalk_WinChoice::Performance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "Performance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FChoiceWindowData                Data                                                   (Parm, NativeAccessSpecifierPublic)

void UUITalk_WinChoice::SetData(const struct FChoiceWindowData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "SetData");

	Params::UITalk_WinChoice_SetData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.SetItemsData
// (Final, Native, Public, BlueprintCallable)

void UUITalk_WinChoice::SetItemsData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "SetItemsData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.ShortCut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAxisMappingType                        InputKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITalk_WinChoice::ShortCut(EAxisMappingType InputKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "ShortCut");

	Params::UITalk_WinChoice_ShortCut Parms{};

	Parms.InputKey = InputKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.SlideIn
// (Final, Native, Public, BlueprintCallable)

void UUITalk_WinChoice::SlideIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "SlideIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITalk_WinChoice.WaitSlideIn
// (Final, Native, Public, BlueprintCallable)

void UUITalk_WinChoice::WaitSlideIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITalk_WinChoice", "WaitSlideIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITeam_Menu.FlagChangeFocusCallback
// (Final, Native, Protected)

void UUITeam_Menu::FlagChangeFocusCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITeam_Menu", "FlagChangeFocusCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITreasureHideBaseFrame.PlayLoopAnim
// (Final, Native, Protected, BlueprintCallable)

void UUITreasureHideBaseFrame::PlayLoopAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITreasureHideBaseFrame", "PlayLoopAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITutorialGuide.SetGuide
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             GuideId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShowTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITutorialGuide::SetGuide(const class FName& GuideId, float ShowTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITutorialGuide", "SetGuide");

	Params::UITutorialGuide_SetGuide Parms{};

	Parms.GuideId = GuideId;
	Parms.ShowTime = ShowTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UITutorialGuide_Content.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CommandText                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActionText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUITutorialGuide_Content::SetText(const class FString& CommandText, const class FString& ActionText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UITutorialGuide_Content", "SetText");

	Params::UITutorialGuide_Content_SetText Parms{};

	Parms.CommandText = std::move(CommandText);
	Parms.ActionText = std::move(ActionText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUnder_Button.SetButtonType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUnder_Button::SetButtonType(class FName ButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIUnder_Button", "SetButtonType");

	Params::UIUnder_Button_SetButtonType Parms{};

	Parms.ButtonType = ButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUnknownArtifact_Eff01.PlayEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EArtifactType                           ArtifactType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsReplica                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUnknownArtifact_Eff01::PlayEffect(EArtifactType ArtifactType, bool IsReplica)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIUnknownArtifact_Eff01", "PlayEffect");

	Params::UIUnknownArtifact_Eff01_PlayEffect Parms{};

	Parms.ArtifactType = ArtifactType;
	Parms.IsReplica = IsReplica;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUnknownArtifact_Pop.PlayOneShotPopAnimation
// (Final, Native, Public, BlueprintCallable)

void UUIUnknownArtifact_Pop::PlayOneShotPopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIUnknownArtifact_Pop", "PlayOneShotPopAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUnknownArtifact_Pop.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ArtifactID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EArtifactType                           ArtifactType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsReplica                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUnknownArtifact_Pop::SetData(class AActor* Target, int32 ArtifactID, EArtifactType ArtifactType, bool InIsReplica)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIUnknownArtifact_Pop", "SetData");

	Params::UIUnknownArtifact_Pop_SetData Parms{};

	Parms.Target = Target;
	Parms.ArtifactID = ArtifactID;
	Parms.ArtifactType = ArtifactType;
	Parms.InIsReplica = InIsReplica;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUpDownIcon.InitWidget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UImage*                           iconImg                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       upTex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       downTex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUpDownIcon::InitWidget(class UImage* iconImg, class UTexture2D* upTex, class UTexture2D* downTex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIUpDownIcon", "InitWidget");

	Params::UIUpDownIcon_InitWidget Parms{};

	Parms.iconImg = iconImg;
	Parms.upTex = upTex;
	Parms.downTex = downTex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIUpDownIcon.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InParam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIUpDownIcon::SetData(int32 InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIUpDownIcon", "SetData");

	Params::UIUpDownIcon_SetData Parms{};

	Parms.InParam = InParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision.SetCaptureImage
// (Final, Native, Protected, BlueprintCallable)

void UUIVision::SetCaptureImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision", "SetCaptureImage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision.Setup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InMatchMonsterList                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FirstFocusIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision::Setup(const TArray<int32>& InMatchMonsterList, int32 FirstFocusIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision", "Setup");

	Params::UIVision_Setup Parms{};

	Parms.InMatchMonsterList = std::move(InMatchMonsterList);
	Parms.FirstFocusIndex = FirstFocusIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_CutIn.InAnimEnd
// (Final, Native, Protected)

void UUIVision_CutIn::InAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_CutIn", "InAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.ActiveSense
// (Final, Native, Public, BlueprintCallable)

void UUIVision_Field::ActiveSense()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "ActiveSense");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.FrameIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVisionFrameOutFlag                     Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Field::FrameIn(EVisionFrameOutFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "FrameIn");

	Params::UIVision_Field_FrameIn Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.FrameOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVisionFrameOutFlag                     Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Field::FrameOut(EVisionFrameOutFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "FrameOut");

	Params::UIVision_Field_FrameOut Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.InactiveSense
// (Final, Native, Public, BlueprintCallable)

void UUIVision_Field::InactiveSense()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "InactiveSense");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.Maximize
// (Final, Native, Public, BlueprintCallable)

void UUIVision_Field::Maximize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "Maximize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.MinimizeCaptureImage
// (Final, Native, Private)

void UUIVision_Field::MinimizeCaptureImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "MinimizeCaptureImage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.SetMute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsMute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Field::SetMute(bool bInIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "SetMute");

	Params::UIVision_Field_SetMute Parms{};

	Parms.bInIsMute = bInIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.SetTutorial
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EVisionPattern                          Pattern                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Field::SetTutorial(const EVisionPattern& Pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "SetTutorial");

	Params::UIVision_Field_SetTutorial Parms{};

	Parms.Pattern = Pattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Field.SetupTutorial
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EVisionPattern                          Pattern                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Field::SetupTutorial(const EVisionPattern& Pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Field", "SetupTutorial");

	Params::UIVision_Field_SetupTutorial Parms{};

	Parms.Pattern = Pattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Menu.ChoiceInEnd
// (Final, Native, Protected)

void UUIVision_Menu::ChoiceInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Menu", "ChoiceInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Menu.ChoiceOutEnd
// (Final, Native, Protected)

void UUIVision_Menu::ChoiceOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Menu", "ChoiceOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Menu_Root.SetData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InMatchMonsterList                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVisionPattern                          InPattern                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Menu_Root::SetData(const TArray<int32>& InMatchMonsterList, const EVisionPattern& InPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Menu_Root", "SetData");

	Params::UIVision_Menu_Root_SetData Parms{};

	Parms.InMatchMonsterList = std::move(InMatchMonsterList);
	Parms.InPattern = InPattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Menu_Root.SetFadeType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EWhiteFadeState                         InFadeState                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Menu_Root::SetFadeType(const EWhiteFadeState& InFadeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Menu_Root", "SetFadeType");

	Params::UIVision_Menu_Root_SetFadeType Parms{};

	Parms.InFadeState = InFadeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Menu_Root.SetMute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsMute                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Menu_Root::SetMute(bool InIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Menu_Root", "SetMute");

	Params::UIVision_Menu_Root_SetMute Parms{};

	Parms.InIsMute = InIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Menu_Root.SetTutorial
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EVisionPattern                          InPattern                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIVision_Menu_Root::SetTutorial(const EVisionPattern& InPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Menu_Root", "SetTutorial");

	Params::UIVision_Menu_Root_SetTutorial Parms{};

	Parms.InPattern = InPattern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_MonsterIcon.PanelWait
// (Final, Native, Protected)

void UUIVision_MonsterIcon::PanelWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_MonsterIcon", "PanelWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UIVision_Select_Panel.OnFocusEnd
// (Final, Native, Protected)

void UUIVision_Select_Panel::OnFocusEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIVision_Select_Panel", "OnFocusEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UMGControlerInterface.ResumeUMGAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IUMGControlerInterface::ResumeUMGAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlerInterface", "ResumeUMGAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.UMGControlerInterface.StopUMGAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IUMGControlerInterface::StopUMGAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlerInterface", "StopUMGAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SizeFixProgressBar.SetFillColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeFixProgressBar::SetFillColorAndOpacity(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SizeFixProgressBar", "SetFillColorAndOpacity");

	Params::SizeFixProgressBar_SetFillColorAndOpacity Parms{};

	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SizeFixProgressBar.SetIsMarquee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsMarquee                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeFixProgressBar::SetIsMarquee(bool InbIsMarquee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SizeFixProgressBar", "SetIsMarquee");

	Params::SizeFixProgressBar_SetIsMarquee Parms{};

	Parms.InbIsMarquee = InbIsMarquee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.SizeFixProgressBar.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeFixProgressBar::SetPercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SizeFixProgressBar", "SetPercent");

	Params::SizeFixProgressBar_SetPercent Parms{};

	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.VisionCaptureCameraBase.Capture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Uid                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             KindId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisionCaptureCameraBase::Capture(const int32 Index_0, const int32 Uid, const class FName KindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisionCaptureCameraBase", "Capture");

	Params::VisionCaptureCameraBase_Capture Parms{};

	Parms.Index_0 = Index_0;
	Parms.Uid = Uid;
	Parms.KindId = KindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.VisionCaptureCameraBase.CaptureFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Uid                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVisionCaptureCameraBase::CaptureFailed(const int32 Index_0, const int32 Uid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisionCaptureCameraBase", "CaptureFailed");

	Params::VisionCaptureCameraBase_CaptureFailed Parms{};

	Parms.Index_0 = Index_0;
	Parms.Uid = Uid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WaterFallFlowBase.OnBeginOverlapCollision
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWaterFallFlowBase::OnBeginOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterFallFlowBase", "OnBeginOverlapCollision");

	Params::WaterFallFlowBase_OnBeginOverlapCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WaterFallFlowBase.OnEndOverlapCollision
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWaterFallFlowBase::OnEndOverlapCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterFallFlowBase", "OnEndOverlapCollision");

	Params::WaterFallFlowBase_OnEndOverlapCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WaterStateSwim.SetEffectVisiblity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterStateSwim::SetEffectVisiblity(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterStateSwim", "SetEffectVisiblity");

	Params::WaterStateSwim_SetEffectVisiblity Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WaterStateSwim.SpawnSplash
// (Final, Native, Public, BlueprintCallable)

void UWaterStateSwim::SpawnSplash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterStateSwim", "SpawnSplash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WindBase.OnBeginOverlapWind
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWindBase::OnBeginOverlapWind(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindBase", "OnBeginOverlapWind");

	Params::WindBase_OnBeginOverlapWind Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WindBase.OnEndOverlapWind
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindBase::OnEndOverlapWind(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WindBase", "OnEndOverlapWind");

	Params::WindBase_OnEndOverlapWind Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WordClassUtility.SglListOf
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UWordClassUtility::SglListOf(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WordClassUtility", "SglListOf");

	Params::WordClassUtility_SglListOf Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.AddTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SkipEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::AddTime(int32 Hour, int32 Minute, bool SkipEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "AddTime");

	Params::WorldTimeManager_AddTime Parms{};

	Parms.Hour = Hour;
	Parms.Minute = Minute;
	Parms.SkipEvent = SkipEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.ConvertTimespanToTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        Timespan                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UWorldTimeManager::ConvertTimespanToTime(const struct FTimespan& Timespan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "ConvertTimespanToTime");

	Params::WorldTimeManager_ConvertTimespanToTime Parms{};

	Parms.Timespan = std::move(Timespan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetTimeZoneType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ETimeZoneType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETimeZoneType UWorldTimeManager::GetTimeZoneType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetTimeZoneType");

	Params::WorldTimeManager_GetTimeZoneType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetTimeZoneTypeFromTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETimeZoneType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETimeZoneType UWorldTimeManager::GetTimeZoneTypeFromTime(int32 Hour, int32 Minute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetTimeZoneTypeFromTime");

	Params::WorldTimeManager_GetTimeZoneTypeFromTime Parms{};

	Parms.Hour = Hour;
	Parms.Minute = Minute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.Initialize
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UWorldTimeManager::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.OnPause
// (Final, Native, Public, BlueprintCallable)

void UWorldTimeManager::OnPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "OnPause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.OnResume
// (Final, Native, Public, BlueprintCallable)

void UWorldTimeManager::OnResume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "OnResume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.ResumeWeatherTime
// (Final, Native, Public, BlueprintCallable)

void UWorldTimeManager::ResumeWeatherTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "ResumeWeatherTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.SetGameTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::SetGameTime(int32 Hour, int32 Minute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "SetGameTime");

	Params::WorldTimeManager_SetGameTime Parms{};

	Parms.Hour = Hour;
	Parms.Minute = Minute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.SetOneDayMinute
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::SetOneDayMinute(int32 Minute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "SetOneDayMinute");

	Params::WorldTimeManager_SetOneDayMinute Parms{};

	Parms.Minute = Minute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.SetRealTimeRequiredToOneDay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::SetRealTimeRequiredToOneDay(int32 Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "SetRealTimeRequiredToOneDay");

	Params::WorldTimeManager_SetRealTimeRequiredToOneDay Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.SetTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SkipEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::SetTime(int32 Hour, int32 Minute, bool SkipEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "SetTime");

	Params::WorldTimeManager_SetTime Parms{};

	Parms.Hour = Hour;
	Parms.Minute = Minute;
	Parms.SkipEvent = SkipEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.SetTimeSpeedMagnification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Magnification                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::SetTimeSpeedMagnification(float Magnification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "SetTimeSpeedMagnification");

	Params::WorldTimeManager_SetTimeSpeedMagnification Parms{};

	Parms.Magnification = Magnification;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.SetWeatherTimePause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::SetWeatherTimePause(int32 Hour, int32 Minute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "SetWeatherTimePause");

	Params::WorldTimeManager_SetWeatherTimePause Parms{};

	Parms.Hour = Hour;
	Parms.Minute = Minute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.Update
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UWorldTimeManager::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.UpdateGameTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        AddTime                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldTimeManager::UpdateGameTime(const struct FTimespan& AddTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "UpdateGameTime");

	Params::WorldTimeManager_UpdateGameTime Parms{};

	Parms.AddTime = std::move(AddTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DarwinGame.WorldTimeManager.ConvertTimeToTimespan
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UWorldTimeManager::ConvertTimeToTimespan(int32 Hour, int32 Minute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "ConvertTimeToTimespan");

	Params::WorldTimeManager_ConvertTimeToTimespan Parms{};

	Parms.Hour = Hour;
	Parms.Minute = Minute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetCurrentTimeSpan
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UWorldTimeManager::GetCurrentTimeSpan() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetCurrentTimeSpan");

	Params::WorldTimeManager_GetCurrentTimeSpan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetElapsedRateToday
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWorldTimeManager::GetElapsedRateToday() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetElapsedRateToday");

	Params::WorldTimeManager_GetElapsedRateToday Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetRealTimeRequiredToOneDay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWorldTimeManager::GetRealTimeRequiredToOneDay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetRealTimeRequiredToOneDay");

	Params::WorldTimeManager_GetRealTimeRequiredToOneDay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UWorldTimeManager::GetTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetTime");

	Params::WorldTimeManager_GetTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DarwinGame.WorldTimeManager.GetTimeSpeedMagnification
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWorldTimeManager::GetTimeSpeedMagnification() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldTimeManager", "GetTimeSpeedMagnification");

	Params::WorldTimeManager_GetTimeSpeedMagnification Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

